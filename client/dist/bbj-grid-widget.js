(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 40);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getDocument = gw_getDocument;
exports.gw_getWindow = gw_getWindow;
exports.gw_escape = gw_escape;
exports.gw_uuid = gw_uuid;
exports.gw_getGrid = gw_getGrid;
exports.gw_addGrid = gw_addGrid;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Get document
 *
 * Get the document instance according to the current BBj env
 *
 * @return {Object} Document instance
 */
function gw_getDocument() {
  return typeof $doc !== 'undefined' ? $doc : document;
}
/**
 * Get window
 *
 * Get the window instance according to the current BBj env
 *
 * @return {Object} Window instance
 */


function gw_getWindow() {
  return typeof $wnd !== 'undefined' ? $wnd : window;
}
/**
 * Escape Value
 *
 * Change null and undefined to empty string
 *
 * @param {*} value
 *
 * @return {String} escaped value
 */


function gw_escape(value) {
  return value !== null && value !== undefined ? value : '';
}
/**
 * Generate a unique uuid
 * @see https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 */


function gw_uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
/**
 * Get Grid
 *
 * Retrieve the grid instance from `window.BBjGridExWidget` array
 *
 * @param {String} id The grid's id
 *
 * @return {Object|null} The grid's instance ofr null
 * @throws TypeError when the grid instance is not found
 */


function gw_getGrid(id) {
  window.BBjGridExWidget = window.BBjGridExWidget || {};
  var grid = window.BBjGridExWidget[id] || null;

  if (!grid) {
    var registeredGrids = JSON.stringify(Object.keys(window.BBjGridExWidget)); //getFuncArgs(func).forEach((key, i) => argsObj[key] = args[i]);

    throw new TypeError("\n\n[Grid Not Found] The method asked for non-existent grid instance.\n-------------------------------------------------------------------\nRequired Grid Id : ".concat(id, "   \nRegistered Grids : ").concat(registeredGrids, "\n"));
  }

  return grid;
}
/**
 * Add Grid
 *
 * Store a new grid instance by in the `window.BBjGridExWidget` array
 *
 * @param {String} id The grid's id
 * @param {Object} options  The grid's options
 *
 * @return {Object} Stored grid
 */


function gw_addGrid(id, options) {
  window.BBjGridExWidget = window.BBjGridExWidget || {};
  window.BBjGridExWidget[id] = options;
  return gw_getGrid(id);
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_debounce = gw_debounce;
exports.gw_sendEvent = gw_sendEvent;
exports.gw_parseNode = gw_parseNode;
exports.gw_parseNodeFromEvent = gw_parseNodeFromEvent;

var _utilities = __webpack_require__(0);

/* eslint-disable no-prototype-builtins */

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/** https://davidwalsh.name/javascript-debounce-function */
function gw_debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
}
/**
 * Send an event to BBj side
 *
 * @param {Array} context the grid's context
 * @param {*} payload the event payload
 * @param {String} eventId the event's id
 */


function gw_sendEvent(context) {
  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var registeredInterests = context.interests || [];

  if (registeredInterests.includes(eventId)) {
    var div = (0, _utilities.gw_getDocument)().getElementById("".concat(context.id)); // bui or webapp

    if ([5, 6].indexOf(context.platform) > -1) {
      var htmlviewId = "htmlview-".concat(context.id);
      var container = (0, _utilities.gw_getDocument)().getElementsByClassName(htmlviewId)[0];

      if (typeof container.basisDispatchCustomEvent === 'function') {
        container.basisDispatchCustomEvent(div, payload);
      } else {
        window.basisDispatchCustomEvent(div, payload);
      }
    } else {
      window.basisDispatchCustomEvent(div, payload);
    }
  }
}
/**
 * @typedef {Object} BBjGridExWidgetRow
 *
 * @property {number} id
 * @property {number} index
 * @property {number} parentKey
 * @property {number} childIndex
 * @property {boolean} selected
 */

/**
 * Parse a node as BBjGridExWidgetRow
 *
 * @param {Object} node ag grid node
 * @param {Object} context  ag grid context
 *
 * @returns {BBjGridExWidgetRow|Boolean} object formatted as BBjGridExWidgetRow.
 *                                       false if the node is for group node
 */


function gw_parseNode(node, context) {
  if (true === node.group) {
    return false;
  } // we do not manage groups


  var getRowNodeId = node.rowPinned ? '__ROW_INDEX' : context.getRowNodeId;
  return {
    i: context.hasOwnProperty('getRowNodeId') && node.data[getRowNodeId] ? node.data[getRowNodeId] : node.id,
    // id
    x: node.rowIndex,
    // index
    p: node.hasOwnProperty('parent') && node.parent.hasOwnProperty('key') ? node.parent.key : '',
    // parent key
    c: node.rowPinned ? -1 : node.childIndex,
    //childIndex
    s: Boolean(node.selected),
    // selected
    // client row
    cr: context.hasOwnProperty('includeClientRowData') && context['includeClientRowData'] === true ? node.data : null,
    pp: node.rowPinned // pin position

  };
}
/**
 * Parse node from event
 *
 * Parse node in the paSsed event as BBjGridExWidgetRow
 *
 * @param {Object} e
 *
 * @returns {BBjGridExWidgetRow}
 */


function gw_parseNodeFromEvent(e) {
  return gw_parseNode(e.node, e.context);
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GW_EVENT_READY = exports.GW_EVENT_FILTER_CHANGED = exports.GW_EVENT_KEYPRESS = exports.GW_EVENT_RANGE_SELECTION_CHANGED = exports.GW_EVENT_GRID_STATE_CHANGE = exports.GW_EVENT_ROW_VALUE_CHANGED = exports.GW_EVENT_ROW_EDITING_STOPPED = exports.GW_EVENT_ROW_EDITING_STARTED = exports.GW_EVENT_CELL_VALUE_CHANGED = exports.GW_EVENT_CELL_EDITING_STOPPED = exports.GW_EVENT_CELL_EDITING_STARTED = exports.GW_EVENT_CELL_DOUBLE_CLICK = exports.GW_EVENT_CELL_CLICK = exports.GW_EVENT_ROW_DOUBLE_CLICK = exports.GW_EVENT_ROW_CLICK = exports.GW_EVENT_ROW_SELECT = void 0;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
// selection constants
var GW_EVENT_ROW_SELECT = 69;
exports.GW_EVENT_ROW_SELECT = GW_EVENT_ROW_SELECT;
var GW_EVENT_ROW_CLICK = 5011;
exports.GW_EVENT_ROW_CLICK = GW_EVENT_ROW_CLICK;
var GW_EVENT_ROW_DOUBLE_CLICK = 52;
exports.GW_EVENT_ROW_DOUBLE_CLICK = GW_EVENT_ROW_DOUBLE_CLICK;
var GW_EVENT_CELL_CLICK = 5001;
exports.GW_EVENT_CELL_CLICK = GW_EVENT_CELL_CLICK;
var GW_EVENT_CELL_DOUBLE_CLICK = 5002; // editing constants

exports.GW_EVENT_CELL_DOUBLE_CLICK = GW_EVENT_CELL_DOUBLE_CLICK;
var GW_EVENT_CELL_EDITING_STARTED = 5003;
exports.GW_EVENT_CELL_EDITING_STARTED = GW_EVENT_CELL_EDITING_STARTED;
var GW_EVENT_CELL_EDITING_STOPPED = 5004;
exports.GW_EVENT_CELL_EDITING_STOPPED = GW_EVENT_CELL_EDITING_STOPPED;
var GW_EVENT_CELL_VALUE_CHANGED = 5005;
exports.GW_EVENT_CELL_VALUE_CHANGED = GW_EVENT_CELL_VALUE_CHANGED;
var GW_EVENT_ROW_EDITING_STARTED = 5006;
exports.GW_EVENT_ROW_EDITING_STARTED = GW_EVENT_ROW_EDITING_STARTED;
var GW_EVENT_ROW_EDITING_STOPPED = 5007;
exports.GW_EVENT_ROW_EDITING_STOPPED = GW_EVENT_ROW_EDITING_STOPPED;
var GW_EVENT_ROW_VALUE_CHANGED = 5012; // state constants

exports.GW_EVENT_ROW_VALUE_CHANGED = GW_EVENT_ROW_VALUE_CHANGED;
var GW_EVENT_GRID_STATE_CHANGE = 5008; // range selection

exports.GW_EVENT_GRID_STATE_CHANGE = GW_EVENT_GRID_STATE_CHANGE;
var GW_EVENT_RANGE_SELECTION_CHANGED = 5009; // keyboard events

exports.GW_EVENT_RANGE_SELECTION_CHANGED = GW_EVENT_RANGE_SELECTION_CHANGED;
var GW_EVENT_KEYPRESS = 5010; // filters

exports.GW_EVENT_KEYPRESS = GW_EVENT_KEYPRESS;
var GW_EVENT_FILTER_CHANGED = 5013; // ready

exports.GW_EVENT_FILTER_CHANGED = GW_EVENT_FILTER_CHANGED;
var GW_EVENT_READY = 5014;
exports.GW_EVENT_READY = GW_EVENT_READY;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(10));

var _getRawTag = _interopRequireDefault(__webpack_require__(68));

var _objectToString = _interopRequireDefault(__webpack_require__(69));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? (0, _getRawTag.default)(value) : (0, _objectToString.default)(value);
}

var _default = baseGetTag;
exports.default = _default;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

var _default = isObjectLike;
exports.default = _default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * [Recursively parses a stringified JSON]
 * @param  {[type]} jsonString [stringified json to parse]
 * @return {[type]}            [normalized Javascript object]
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function deepParseJson(jsonString) {
  // if not stringified json rather a simple string value then JSON.parse will throw error
  // otherwise continue recursion
  if (typeof jsonString === 'string') {
    try {
      return deepParseJson(JSON.parse(jsonString));
    } catch (err) {
      return jsonString;
    }
  } else if (Array.isArray(jsonString)) {
    // if an array is received, map over the array and deepParse each value
    return jsonString.map(function (val) {
      return deepParseJson(val);
    });
  } else if (_typeof(jsonString) === 'object' && jsonString !== null) {
    // if an object is received then deepParse each element in the object
    // typeof null returns 'object' too, so we have to eliminate that
    return Object.keys(jsonString).reduce(function (obj, key) {
      obj[key] = deepParseJson(jsonString[key]);
      return obj;
    }, {});
  } else {
    // otherwise return whatever was received
    return jsonString;
  }
}

module.exports = {
  deepParseJson: deepParseJson
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var _default = isObject;
exports.default = _default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setQuickFilter = gw_setQuickFilter;
exports.gw_expandAll = gw_expandAll;
exports.gw_collapseAll = gw_collapseAll;
exports.gw_ensureIndexVisible = gw_ensureIndexVisible;
exports.gw_navigateToNextRow = gw_navigateToNextRow;
exports.gw_getRowNodeId = gw_getRowNodeId;
exports.gw_setRowData = gw_setRowData;
exports.gw_updateRowData = gw_updateRowData;
exports.gw_setRowsHeight = gw_setRowsHeight;
exports.gw_setRowHeight = gw_setRowHeight;
exports.gw_resetRowHeights = gw_resetRowHeights;
exports.gw_setSelectedRows = gw_setSelectedRows;
exports.gw_selectAll = gw_selectAll;
exports.gw_deselectAll = gw_deselectAll;
exports.gw_getSelectedRows = gw_getSelectedRows;
exports.gw_getSelectedRow = gw_getSelectedRow;
exports.gw_getRow = gw_getRow;
exports.gw_getRows = gw_getRows;
exports.gw_redrawRows = gw_redrawRows;
exports.gw_setPinnedTopRowData = gw_setPinnedTopRowData;
exports.gw_setPinnedBottomRowData = gw_setPinnedBottomRowData;

var _utilities = __webpack_require__(0);

var _utilities2 = __webpack_require__(1);

var _expression = __webpack_require__(18);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setQuickFilter(id, filter) {
  (0, _utilities.gw_getGrid)(id).options.api.setQuickFilter(filter);
}

function gw_expandAll(id) {
  (0, _utilities.gw_getGrid)(id).options.api.expandAll();
}

function gw_collapseAll(id) {
  (0, _utilities.gw_getGrid)(id).options.api.collapseAll();
}
/**
 * Ensures the row index is visible by vertically scrolling the grid
 *
 * @param {String} id  the grid's id
 * @param {String|Number} index the row index or key
 * @param {String} position {'top', 'middle', 'bottom', undefined/null}
 */


function gw_ensureIndexVisible(id, index, position) {
  var api = (0, _utilities.gw_getGrid)(id).options.api;
  var node = api.getRowNode(index);

  if (node) {
    api.ensureNodeVisible(node, position);
  } else {
    api.ensureIndexVisible(Number(index), position);
  }
}

function gw_navigateToNextRow(id, params) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var previousCell = params.previousCellPosition;
  var suggestedNextCell = params.nextCellPosition;
  var KEY_UP = 'ArrowUp';
  var KEY_DOWN = 'ArrowDown';
  var KEY_LEFT = 'ArrowLeft';
  var KEY_RIGHT = 'ArrowRight';

  switch (params.key) {
    case KEY_DOWN:
      // set selected cell on current cell + 1
      if (suggestedNextCell && !suggestedNextCell.rowPinned) {
        if (previousCell.rowPinned) {
          var row = options.api.getDisplayedRowAtIndex(options.api.getFirstDisplayedRow());

          if (row) {
            row.setSelected(true);
          }
        } else {
          options.api.forEachNode(function (node) {
            if (previousCell.rowIndex + 1 === node.rowIndex) {
              node.setSelected(true);
            }
          });
        }
      }

      return suggestedNextCell;

    case KEY_UP:
      // set selected cell on current cell - 1
      if (suggestedNextCell && !suggestedNextCell.rowPinned) {
        if (previousCell.rowPinned) {
          var _row = options.api.getDisplayedRowAtIndex(options.api.getLastDisplayedRow());

          if (_row) {
            _row.setSelected(true);
          }
        } else {
          options.api.forEachNode(function (node) {
            if (previousCell.rowIndex - 1 === node.rowIndex) {
              node.setSelected(true);
            }
          });
        }
      }

      return suggestedNextCell;

    case KEY_LEFT:
    case KEY_RIGHT:
      return suggestedNextCell;

    default:
      throw new Error('You have super strange keyboard');
  }
}
/**
 * Returns a row based on `getRowNodeId` config defined in the grid context
 *
 * @param {String} id the grid's id
 * @param {Object} grid  the grid object
 */


function gw_getRowNodeId(_id, grid) {
  var rowNodeId = grid.api.gridOptionsWrapper.gridOptions.context.getRowNodeId;
  return grid.data[rowNodeId];
}
/**
 * Update the grid's data set
 *
 * @param {String} id the grid's id
 * @param {Object} json json object which contains the new dataset to update the grid
 */


function gw_setRowData(id, json) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  options.api.setRowData(json);
  options.rowData = json;
}
/**
 * Update the grid with a transaction object
 *
 * @param {String} id  the grid id
 * @param {Object} transaction
 */


function gw_updateRowData(id, transaction, batchUpdate) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (transaction.remove.length) {
    var items = [];
    transaction.remove.forEach(function (index) {
      items.push(options.api.getRowNode(index).data);
    });
    transaction.remove = items;
  }

  if (transaction.add.length) {
    transaction.add = transaction.add.reverse();
  }

  if (!batchUpdate) {
    options.api.applyTransaction(transaction);
  } else {
    options.api.applyTransactionAsync(transaction);
  }
}
/**
 * Set the height of all rows
 *
 * @param {String} id the grid id
 * @param {Number} height the row height
 */


function gw_setRowsHeight(id, height) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  api.forEachNode(function (row) {
    row.setRowHeight(height);
  });
  api.onRowHeightChanged();
}
/**
 * Set the given row height
 *
 * @param {String} id the grid id
 * @param {Number|String} index the row index or key
 * @param {Number} height the new height
 */


function gw_setRowHeight(id, index, height) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var row = api.getRowNode(index) || api.getDisplayedRowAtIndex(index);

  if (row) {
    row.setRowHeight(height);
    options.api.onRowHeightChanged();
  } else {
    console.warn("Failed to set height for row ".concat(index, ". Row cannot be found"));
  }
}
/**
 * Reset the row height
 *
 * @param {String} id  the grid id
 */


function gw_resetRowHeights(id) {
  (0, _utilities.gw_getGrid)(id).options.api.resetRowHeights();
}
/**
 * Select row or more based on the row id or index
 *
 * @param {String} id the grid's id
 * @param {Array} rows an array of row keys and indexes to select
 */


function gw_setSelectedRows(id, rows) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  api.forEachNodeAfterFilterAndSort(function (node) {
    if (rows.indexOf(String(node.rowIndex)) > -1 || rows.indexOf(String(node.id)) > -1) {
      node.setSelected(true);
      node.expanded = true;
    }
  });
  api.onGroupExpandedOrCollapsed();
}

function gw_selectAll(id, filtered) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (1 === filtered) {
    options.api.selectAllFiltered();
  } else {
    options.api.selectAll();
  }
}

function gw_deselectAll(id, filtered) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (1 === filtered) {
    options.api.deselectAllFiltered();
  } else {
    options.api.deselectAll();
  }
}
/**
 * Get the current selected rows
 *
 * @param {Number} id grid's id
 *
 * @returns {String}  selected rows as JSON
 */


function gw_getSelectedRows(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var nodes = options.api.getSelectedNodes();
  var parsed = [];
  nodes.forEach(function (node) {
    parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
  });
  return JSON.stringify(parsed);
}
/**
 * Get the last selected row
 *
 * @param {Number} id grid's id
 *
 * @returns {String} selected row as JSON
 */


function gw_getSelectedRow(id) {
  var rows = JSON.parse(gw_getSelectedRows(id));

  if (rows.length) {
    return JSON.stringify(rows[rows.length - 1]);
  }

  return '';
}
/**
 * Get the row by its id or index
 *
 * @param {String} id grid's id
 * @param {String|Number} index
 *
 * @return {String} row as JSON
 */


function gw_getRow(id, index) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  return JSON.stringify((0, _utilities2.gw_parseNode)(options.api.getRowNode(index), options.context));
}
/**
 * Get rows from the grid
 *
 * @param {String} id The grid's id
 * @param {String} phase The rows phase
 * @param {String} filterExpression A filter expression
 *
 * @return {String} Json stringified array of rows
 */


function gw_getRows(id, phase, filterExpression) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var parsed = [];
  options.api[phase](function (node) {
    if (!node.group) {
      if (filterExpression) {
        var canProcess = (0, _expression.gw_executeExpression)(filterExpression, {
          value: node.data,
          context: options.context,
          oldValue: null,
          newValue: null,
          node: node,
          data: node.data,
          colDef: null,
          rowIndex: node.rowIndex,
          api: node.gridApi,
          columnApi: node.columnApi,
          getValue: function getValue() {
            return node.data;
          },
          column: null,
          columnGroup: // eslint-disable-next-line no-prototype-builtins
          node.hasOwnProperty('parent') && node.parent.hasOwnProperty('key') ? node.parent.key : ''
        });

        if (canProcess) {
          parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
        }
      } else {
        parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
      }
    }
  });
  return JSON.stringify(parsed);
}
/**
 * Gets the grid to remove a row from the DOM and recreate it again from scratch.
 *
 * @param {String} id grid's id
 */


function gw_redrawRows(id) {
  (0, _utilities.gw_getGrid)(id).options.api.redrawRows();
}
/**
 * Pin an array of tow to the top of the grid
 *
 * @param {String} id the grid's id
 * @param {Array} data array of rows
 */


function gw_setPinnedTopRowData(id, data) {
  (0, _utilities.gw_getGrid)(id).options.api.setPinnedTopRowData(data);
}
/**
 * Pin an array of tow to the bottom of the grid
 *
 * @param {String} id the grid's id
 * @param {Array} data array of rows
 */


function gw_setPinnedBottomRowData(id, data) {
  (0, _utilities.gw_getGrid)(id).options.api.setPinnedBottomRowData(data);
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var _Symbol = _root.default.Symbol;
var _default = _Symbol;
exports.default = _default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _freeGlobal = _interopRequireDefault(__webpack_require__(25));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `self`. */
var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal.default || freeSelf || Function('return this')();
var _default = root;
exports.default = _default;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

var _default = eq;
exports.default = _default;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(24));

var _isLength = _interopRequireDefault(__webpack_require__(30));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && (0, _isLength.default)(value.length) && !(0, _isFunction.default)(value);
}

var _default = isArrayLike;
exports.default = _default;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(122);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _StringMask = _interopRequireDefault(__webpack_require__(46));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _default = _StringMask.default;
exports.default = _default;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NumberMask = _interopRequireDefault(__webpack_require__(47));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _default = _NumberMask.default;
exports.default = _default;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_extendColumnDefinitions = gw_extendColumnDefinitions;
exports.gw_setColumnDefinitions = gw_setColumnDefinitions;
exports.gw_sizeColumnsToFit = gw_sizeColumnsToFit;
exports.gw_autoSizeColumns = gw_autoSizeColumns;
exports.gw_ensureColumnVisible = gw_ensureColumnVisible;
exports.gw_setColumnWidth = gw_setColumnWidth;
exports.gw_pinColumn = gw_pinColumn;
exports.gw_moveColumn = gw_moveColumn;
exports.gw_isShowSelectionCheckbox = gw_isShowSelectionCheckbox;
exports.gw_isHeaderCheckboxSelection = gw_isHeaderCheckboxSelection;
exports.gw_addRowGroupColumn = gw_addRowGroupColumn;
exports.gw_removeRowGroupColumn = gw_removeRowGroupColumn;
exports.gw_getPivotMode = gw_getPivotMode;
exports.gw_setPivotMode = gw_setPivotMode;
exports.gw_addPivotColumns = gw_addPivotColumns;
exports.gw_removePivotColumns = gw_removePivotColumns;
exports.gw_addValueColumns = gw_addValueColumns;
exports.gw_removeValueColumns = gw_removeValueColumns;
exports.gw_setSortModel = gw_setSortModel;
exports.gw_refreshHeader = gw_refreshHeader;
exports.gw_setColumnVisible = gw_setColumnVisible;
exports.gw_addAlignedGrid = gw_addAlignedGrid;
exports.gw_removeAlignedGrid = gw_removeAlignedGrid;

var _utilities = __webpack_require__(0);

var _expression = __webpack_require__(18);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(7),
    deepParseJson = _require.deepParseJson;
/**
 * Extend the column definitions
 *
 * Extend the column definitions with options which can not be handled in BBj
 * (ex: attaching callbacks)
 *
 * @param {Array} definitions array of column definitions
 */


function gw_extendColumnDefinitions(definitions) {
  var _loop = function _loop(i) {
    var def = definitions[i];
    def.checkboxSelection = def.checkboxSelection || gw_isShowSelectionCheckbox;
    def.headerCheckboxSelection = def.headerCheckboxSelection || gw_isHeaderCheckboxSelection;
    var tooltipValueGetterExpression = def.tooltipValueGetter;

    if (tooltipValueGetterExpression) {
      def.tooltipValueGetter = function (params) {
        return (0, _expression.gw_executeExpression)(tooltipValueGetterExpression, params);
      };
    }

    def.tooltipComponent = 'HTMLTooltip'; // eslint-disable-next-line no-prototype-builtins

    if (def.hasOwnProperty('editable') && typeof def.editable === 'string') {
      var editable = def.editable;

      def.editable = function (params) {
        return (0, _expression.gw_executeExpression)(editable, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('rowSpan') && typeof def.rowSpan === 'string') {
      var rowSpan = def.rowSpan;

      def.rowSpan = function (params) {
        return (0, _expression.gw_executeExpression)(rowSpan, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('colSpan') && typeof def.colSpan === 'string') {
      var colSpan = def.colSpan;

      def.colSpan = function (params) {
        return (0, _expression.gw_executeExpression)(colSpan, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('children')) {
      gw_extendColumnDefinitions(def.children);
    }
  };

  for (var i in definitions) {
    _loop(i);
  }
}
/**
 * Update the column definitions
 *
 * @param {String} id The grid id
 * @param {Array} definitions array of column definitions
 */


function gw_setColumnDefinitions(id, definitions) {
  var grid = (0, _utilities.gw_getGrid)(id);
  var deepParsedDefinitions = deepParseJson(JSON.stringify(definitions));
  gw_extendColumnDefinitions(deepParsedDefinitions);
  grid.options.api.setColumnDefs(deepParsedDefinitions);
  grid.options.columnDefs = deepParsedDefinitions;
}
/**
 * Make the currently visible columns fit the screen
 *
 * @param {String} id The grid's id
 * @param {Number} the width to use to fit all columns in
 */


function gw_sizeColumnsToFit(id, width) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var columnsAPI = options.columnApi;

  if (width) {
    columnsAPI.sizeColumnsToFit(Number(width));
  } else {
    api.sizeColumnsToFit();
  }
}
/**
 * Work out the best width to fit the contents of the cells in the column.
 *
 * @param {String} id The grid's id
 * @param {Boolean} [skipHeader=false] when true indicate that the header content (headerName) should not be considered when
 *                             calculating the width of the column
 * @param {Array|null} [columns=null] an array of columns ids to auto size or null to auto size all columns
 */


function gw_autoSizeColumns(id) {
  var skipHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var options = (0, _utilities.gw_getGrid)(id).options;
  var columnsAPI = options.columnApi;

  if (!(columns && columns.length)) {
    var allColumnIds = [];
    columnsAPI.getAllColumns().forEach(function (column) {
      allColumnIds.push(column.colId);
    });
    columnsAPI.autoSizeColumns(allColumnIds, Boolean(skipHeader));
  } else {
    columnsAPI.autoSizeColumns(columns, Boolean(skipHeader));
  }
}
/**
 * Ensures the column is visible, scrolling the table if needed.
 *
 * @param {String} id  the grid's id
 * @param {String} columnId  the column id
 */


function gw_ensureColumnVisible(id, columnId) {
  (0, _utilities.gw_getGrid)(id).options.api.ensureColumnVisible(columnId);
}
/**
 * Set Column Width
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {Number|String} width The new column width
 */


function gw_setColumnWidth(id, columnId, width) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnWidth(columnId, Number(width));
}
/**
 * Pin Column
 *
 * Pin a column to a specific direction
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {String} pin The pin direction
 */


function gw_pinColumn(id, columnId, pin) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnPinned(columnId, pin);
}
/**
 * Move Column
 *
 * Move column to a specific index
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {Number|String} toIndex The new column index
 */


function gw_moveColumn(id, columnId, toIndex) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.moveColumn(columnId, toIndex);
}
/**
 * Show / Hide selection checkbox based on the first column
 *
 * The function make sure that the selection checkbox is always shown on the
 * first column
 *
 * @param {Object} param
 *
 * @return {Boolean} true when first column , false if not the first column or if the
 *                   grid's `Context.showSelectionCheckbox` is false
 */


function gw_isShowSelectionCheckbox(param) {
  if (!param.context.showSelectionCheckbox) {
    return false;
  }

  var columns = param.columnApi.getAllDisplayedColumns();
  return columns[0] === param.column;
}
/**
 * Show / Hide header selection checkbox based on the first column
 *
 * The function make sure that the header selection checkbox is always shown on the
 * first column
 *
 * @param {Object} param
 *
 * @return {Boolean} true when first column , false if not the first column or if the
 *                   grid's `Context.showHeaderSelectionCheckbox` is false
 */


function gw_isHeaderCheckboxSelection(param) {
  var context = param.api.gridOptionsWrapper.gridOptions.context;

  if (!context.showHeaderSelectionCheckbox) {
    return false;
  }

  var columns = param.columnApi.getAllDisplayedColumns();
  return columns[0] === param.column;
}
/**
 * Enable row grouping for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 * @param {Boolean} set  When true , `setRowGroupColumns` will be used , `addRowGroupColumns` otherwise
 */


function gw_addRowGroupColumn(id, columns, set) {
  (0, _utilities.gw_getGrid)(id).options.columnApi[set ? 'setRowGroupColumns' : 'addRowGroupColumns'](columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable row grouping for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removeRowGroupColumn(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removeRowGroupColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}

function gw_getPivotMode(id) {
  return (0, _utilities.gw_getGrid)(id).options.columnApi.isPivotMode();
}
/**
 * Enable / disbale pivot mode
 *
 * @param {String} id the grid id
 * @param {Boolean} mode when true
 */


function gw_setPivotMode(id, mode) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setPivotMode(!!Number(mode));
}
/**
 * Enable pivot for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 * @param {Boolean} set  When true , `addPivotColumns` will be used , `setPivotColumns` otherwise
 */


function gw_addPivotColumns(id, columns, set) {
  (0, _utilities.gw_getGrid)(id).options.columnApi[set ? 'setPivotColumns' : 'addPivotColumns'](columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable pivot for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removePivotColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removePivotColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Enable value for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_addValueColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.addValueColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable value for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removeValueColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removeValueColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Set the column sorting model
 *
 * @param {String} id the grid id
 * @param {String} model model as json array
 */


function gw_setSortModel(id, model) {
  var asArray = JSON.parse(model);
  var options = (0, _utilities.gw_getGrid)(id).options;
  var parsedModel = [];
  asArray.forEach(function (i) {
    for (var key in i) {
      parsedModel.push({
        colId: key,
        sort: i[key]
      });
    }
  });
  options.columnApi.applyColumnState({
    state: parsedModel,
    applyOrder: false,
    defaultState: options.columnApi.getColumnState()
  });
}
/**
 * Redraws the header. Useful if a column name changes,
 * or something else that changes how the column header is displayed.
 *
 * @param {String} id grid's id
 */


function gw_refreshHeader(id) {
  (0, _utilities.gw_getGrid)(id).options.api.redrawRows();
}
/**
 * Update column viability
 *
 * @param {String} id grid's id
 * @param {String} columns  a comma separated list of column ids
 * @param {Boolean} visible true to make the columns visible , false to hide
 */


function gw_setColumnVisible(id, columns, visible) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnsVisible(columns.split(','), Boolean(visible));
}
/**
 * Align two grid together
 *
 * @param {String} id The current grid's id
 * @param {String} gridId The target grid's id
 */


function gw_addAlignedGrid(id, gridId) {
  var currentGridOption = (0, _utilities.gw_getGrid)(id).options;

  var register = function register() {
    var targetGridOption = (0, _utilities.gw_getGrid)(gridId).options;
    currentGridOption.alignedGrids.push(targetGridOption);
  };

  try {
    register();
  } catch (err) {
    currentGridOption.alignedGrids.push(gridId);
    window.addEventListener("".concat(gridId, "-ready"), function () {
      var indexOf = currentGridOption.alignedGrids.indexOf(gridId);

      if (indexOf > -1) {
        currentGridOption.alignedGrids.splice(indexOf, 1);
        register();
      }
    });
  }
}
/**
 * Remove aligned grids
 *
 * @param {String} id The current grid's id
 * @param {String} gridId The target grid's id
 */


function gw_removeAlignedGrid(id, gridId) {
  var currentGridOption = (0, _utilities.gw_getGrid)(id).options;
  var alignedGrids = currentGridOption.alignedGrids;

  for (var x = 0; x < alignedGrids.length; x++) {
    var grid = alignedGrids[x];

    if (typeof grid === 'string' && grid === gridId || grid.context.id === gridId) {
      alignedGrids.splice(x, 1);
    }
  }
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_compileExpression = gw_compileExpression;
exports.gw_executeExpression = gw_executeExpression;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Build a js function from the given expression
 *
 * @param {String} expression
 *
 * @return {Function}
 */
function gw_compileExpression(expression) {
  // Check to see if the expression cache has been initialized
  if (typeof gw_compileExpression.expressionCache == 'undefined') {
    gw_compileExpression.expressionCache = [];
  } // check cache first


  if (gw_compileExpression.expressionCache[expression]) {
    return gw_compileExpression.expressionCache[expression];
  } // if not found in cache, return the function


  var functionBody = null; // if the expression has the 'return' word in it, then use as is,
  // if not, then wrap it with return and ';' to make a function

  if (expression.indexOf('return') >= 0) {
    functionBody = expression;
  } else {
    functionBody = 'return ' + expression + ';';
  }

  var theFunction = new Function('x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup', functionBody); // store in cache

  gw_compileExpression.expressionCache[expression] = theFunction;
  return theFunction;
}
/**
 * Build and executed an expression with the passed params
 *
 * @param {String} expression
 * @param {Object} params
 *
 * @return mixed
 */


function gw_executeExpression(expression, params) {
  try {
    var javaScriptFunction = gw_compileExpression(expression); // the params don't have all these values, rather we add every possible
    // value a params can have, which makes whatever is in the params available.

    var result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.columnApi, params.getValue, params.column, params.columnGroup);
    return result;
  } catch (e) {
    // the expression failed, which can happen, as it's the client that
    // provides the expression. so print a nice message
    console.log('Processing of the expression failed');
    console.log('Expression = ' + expression);
    console.log('Params =', params);
    console.log('Exception = ' + e);
    return null;
  }
}

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getChartToolbarItems = gw_getChartToolbarItems;
exports.gw_addChartRange = gw_addChartRange;
exports.gw_destroyChart = gw_destroyChart;

var _utilities = __webpack_require__(0);

var _cells = __webpack_require__(20);

/* eslint-disable no-prototype-builtins */

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(7),
    deepParseJson = _require.deepParseJson;
/**
 * The array contains references to created charts from BBj.
 * Every reference is a ChartRef object which provides the application with the
 * destroyChart() method that is required when the application wants to dispose the chart.
 */

/**
 * Return the chart toolbar items defined in the grid's context
 *
 * @param {Object} params
 * @returns {Array} array of supported chart items
 */


function gw_getChartToolbarItems(params) {
  return params.api.gridOptionsWrapper.gridOptions.context.chartToolbarItems || [];
}
/**
 * Add new chart range
 *
 * @param {String} id grid's id
 * @param {Object} range  bounded or unbounded range model
 *
 * @return {String} a unique id for the generate chart
 */


function gw_addChartRange(id, range) {
  var grid = (0, _utilities.gw_getGrid)(id);
  var options = grid.options;
  var pr = deepParseJson(JSON.stringify(range));
  pr.cellRange = (0, _cells.gw_parseAddCellRange)(options, pr.cellRange);
  var ref = options.api.createRangeChart(pr);
  var uuid = (0, _utilities.gw_uuid)();
  grid.created_charts = grid.created_charts || {};
  grid.created_charts[uuid] = ref;
  return uuid;
}
/**
 * Destroy created charts
 *
 * Destroy already created chart by id or all created charts
 * when the `uuid` is omitted.
 *
 * @param {String} id grid's id
 * @param {String} uuid The chart's id
 */


function gw_destroyChart(id, uuid) {
  var grid = (0, _utilities.gw_getGrid)(id);

  if (uuid) {
    if (grid.hasOwnProperty('created_charts') && grid.created_charts.hasOwnProperty(uuid)) {
      grid.created_charts[uuid].destroyChart();
    }
  } else {
    if (grid.hasOwnProperty('created_charts')) {
      for (var i in grid.created_charts) {
        if (grid.created_charts.hasOwnProperty(i)) {
          var chart = grid.created_charts[i];
          chart.destroyChart();
        }
      }
    }
  }
}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_startEditingCell = gw_startEditingCell;
exports.gw_stopEditing = gw_stopEditing;
exports.gw_tabToNextCell = gw_tabToNextCell;
exports.gw_tabToPreviousCell = gw_tabToPreviousCell;
exports.gw_setFocusedCell = gw_setFocusedCell;
exports.gw_getRangeSelections = gw_getRangeSelections;
exports.gw_parseAddCellRange = gw_parseAddCellRange;
exports.gw_addCellRange = gw_addCellRange;
exports.gw_clearRangeSelection = gw_clearRangeSelection;

var _utilities = __webpack_require__(0);

var _utilities2 = __webpack_require__(1);

var _rows = __webpack_require__(9);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(7),
    deepParseJson = _require.deepParseJson;
/**
 * Start cell editing
 *
 * @param {String} id The grid's id
 * @param {String|number} row The row index or key
 * @param {String} colKey The column's key
 * @param {String|Number} keyPress  Key press
 * @param {String} charPress
 * @param {String} rowPinned Set to 'top' or 'bottom' to started editing a pinned row
 */


function gw_startEditingCell(id, row, colKey, keyPress, charPress, rowPinned) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var node = api.getRowNode(row) || api.getDisplayedRowAtIndex(row);
  options.api.startEditingCell({
    rowIndex: node.rowIndex,
    keyPress: Number(keyPress),
    colKey: colKey,
    charPress: charPress,
    rowPinned: rowPinned
  });
}
/**
 * Stop cell editing
 *
 * @param {String} id The grid's id
 * @param {Boolean} cancel when true cancel edits , save edits otherwise
 */


function gw_stopEditing(id, cancel) {
  (0, _utilities.gw_getGrid)(id).options.api.stopEditing(cancel);
}
/**
 * Navigates the grid focus to the next cell, as if tabbing.
 *
 * @param {String} id  the grid id
 */


function gw_tabToNextCell(id) {
  (0, _utilities.gw_getGrid)(id).options.api.tabToNextCell();
}
/**
 * Navigates the grid focus to the previous cell, as if shift-tabbing.
 *
 * @param {String} id  the grid id
 */


function gw_tabToPreviousCell(id) {
  (0, _utilities.gw_getGrid)(id).options.api.tabToPreviousCell();
}
/**
 * Set Focus on the given row and column
 *
 * @param {String} id The grid's id
 * @param {String|Number} row The row's index/id
 * @param {String} column The column id
 * @param {String} floating null, 'top', or 'bottom'.
 */


function gw_setFocusedCell(id, row, column) {
  var floating = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var options = (0, _utilities.gw_getGrid)(id).options;
  var grid = (0, _utilities.gw_getGrid)(id); // ignore focus calls if editing

  if (options.api.getEditingCells().length > 0) {
    return;
  }

  if (!JSON.parse((0, _rows.gw_getRows)(id, 'forEachNodeAfterFilterAndSort', '')).length) {
    grid.container.focus();
    return;
  }

  var r, c, f;

  if (row == -1) {
    // try to retain the focus
    var lastFocusedCell = options.api.getFocusedCell();

    if (lastFocusedCell) {
      r = lastFocusedCell.rowIndex;
      c = lastFocusedCell.column.colId;
      f = lastFocusedCell.rowPinned;
    } else {
      r = 0;
      c = options.columnApi.getAllGridColumns()[0].colId;
      f = floating;
    }
  } else {
    r = !row ? 0 : Number.isInteger(+row) ? +row : options.api.getRowNode(row).rowIndex;
    c = column ? column : options.columnApi.getAllGridColumns()[0].colId;
    f = floating;
  }

  (0, _utilities.gw_getGrid)(id).options.api.setFocusedCell(r, c, f);
}
/**
 * Get Range Selections
 *
 * The method will create a range json model for each range which can be parsed in BBj side.
 *
 * @param {Number} id grid's id
 *
 * @returns {String} selected ranges as JSON
 */


function gw_getRangeSelections(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var context = options.context;
  var api = options.api;
  var ranges = api.getCellRanges();
  var model = api.getModel();
  var result = [];
  ranges.forEach(function (range) {
    // const start = gw_parseNode(model.getRow(range.startRow.rowIndex), options.context);
    // const end = gw_parseNode(model.getRow(range.endRow.rowIndex), options.context);
    //if (start !== false && end !== false) {
    var columns = range.columns.reduce(function (accumulator, current) {
      if ('ag-Grid-AutoColumn' !== current.colId) {
        accumulator.push(current.colId);
      }

      return accumulator;
    }, []).filter(Boolean);
    var starIndex = Math.min(range.startRow.rowIndex, range.endRow.rowIndex);
    var endIndex = Math.max(range.startRow.rowIndex, range.endRow.rowIndex);
    var rows = [];

    for (var rowIndex = starIndex; rowIndex <= endIndex; rowIndex++) {
      var node = model.getRow(rowIndex);

      if (node) {
        var parsedNode = (0, _utilities2.gw_parseNode)(node, context);

        if (parsedNode) {
          rows.push(parsedNode);
        }
      }
    }

    if (rows.length && columns.length) {
      result.push({
        r: rows,
        c: columns
      });
    } //}

  });
  return JSON.stringify(result);
}
/**
 * Parse the cells range in a format the grid can understand when it is passed
 * to `api.addCellRange`
 *
 * @param {Object} options The grid's options
 * @param {Object} range  bounded or unbounded range model
 */


function gw_parseAddCellRange(options, range) {
  var pr = deepParseJson(JSON.stringify(range));
  var start = !(pr.start || null) ? 0 : Number.isInteger(+pr.start) ? +pr.start : options.api.getRowNode(pr.start).rowIndex;
  var end = !(pr.end || null) ? options.rowData.length - 1 : Number.isInteger(+pr.end) ? +pr.end : options.api.getRowNode(pr.end).rowIndex;
  return {
    rowStartIndex: Math.abs(start),
    rowEndIndex: Math.abs(end),
    columns: pr.columns
  };
}
/**
 * Add new cell range
 *
 * @param {Number} id grid's id
 * @param {Object} range  bounded or unbounded range model
 */


function gw_addCellRange(id, range) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  options.api.addCellRange(gw_parseAddCellRange(options, range));
}
/**
 * Clears the selected range.
 *
 * @param {Number} id grid's id
 */


function gw_clearRangeSelection(id) {
  (0, _utilities.gw_getGrid)(id).options.api.clearRangeSelection();
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assignInWith = _interopRequireDefault(__webpack_require__(63));

var _attempt = _interopRequireDefault(__webpack_require__(92));

var _baseValues = _interopRequireDefault(__webpack_require__(95));

var _customDefaultsAssignIn = _interopRequireDefault(__webpack_require__(96));

var _escapeStringChar = _interopRequireDefault(__webpack_require__(97));

var _isError = _interopRequireDefault(__webpack_require__(35));

var _isIterateeCall = _interopRequireDefault(__webpack_require__(29));

var _keys = _interopRequireDefault(__webpack_require__(98));

var _reInterpolate = _interopRequireDefault(__webpack_require__(38));

var _templateSettings = _interopRequireDefault(__webpack_require__(101));

var _toString = _interopRequireDefault(__webpack_require__(39));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Error message constants. */
var INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';
/** Used to match empty string literals in compiled template source. */

var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to validate the `validate` option in `_.template` variable.
 *
 * Forbids characters which could potentially change the meaning of the function argument definition:
 * - "()," (modification of function parameters)
 * - "=" (default value)
 * - "[]{}" (destructuring of function parameters)
 * - "/" (beginning of a comment)
 * - whitespace
 */

var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = _templateSettings.default.imports._.templateSettings || _templateSettings.default;

  if (guard && (0, _isIterateeCall.default)(string, options, guard)) {
    options = undefined;
  }

  string = (0, _toString.default)(string);
  options = (0, _assignInWith.default)({}, options, settings, _customDefaultsAssignIn.default);
  var imports = (0, _assignInWith.default)({}, options.imports, settings.imports, _customDefaultsAssignIn.default),
      importsKeys = (0, _keys.default)(imports),
      importsValues = (0, _baseValues.default)(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate.default ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.

  var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/\s/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar.default); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.

  var variable = hasOwnProperty.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if (reForbiddenIdentifierChars.test(variable)) {
      throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
    } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = (0, _attempt.default)(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if ((0, _isError.default)(result)) {
    throw result;
  }

  return result;
}

var _default = template;
exports.default = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty = _interopRequireDefault(__webpack_require__(23));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty.default) {
    (0, _defineProperty.default)(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _default = baseAssignValue;
exports.default = _default;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNative = _interopRequireDefault(__webpack_require__(66));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defineProperty = function () {
  try {
    var func = (0, _getNative.default)(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var _default = defineProperty;
exports.default = _default;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _isObject = _interopRequireDefault(__webpack_require__(8));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!(0, _isObject.default)(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = (0, _baseGetTag.default)(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var _default = isFunction;
exports.default = _default;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
var _default = freeGlobal;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _identity = _interopRequireDefault(__webpack_require__(27));

var _overRest = _interopRequireDefault(__webpack_require__(75));

var _setToString = _interopRequireDefault(__webpack_require__(76));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return (0, _setToString.default)((0, _overRest.default)(func, start, _identity.default), func + '');
}

var _default = baseRest;
exports.default = _default;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var _default = identity;
exports.default = _default;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

var _default = apply;
exports.default = _default;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eq = _interopRequireDefault(__webpack_require__(12));

var _isArrayLike = _interopRequireDefault(__webpack_require__(13));

var _isIndex = _interopRequireDefault(__webpack_require__(31));

var _isObject = _interopRequireDefault(__webpack_require__(8));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!(0, _isObject.default)(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? (0, _isArrayLike.default)(object) && (0, _isIndex.default)(index, object.length) : type == 'string' && index in object) {
    return (0, _eq.default)(object[index], value);
  }

  return false;
}

var _default = isIterateeCall;
exports.default = _default;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var _default = isLength;
exports.default = _default;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var _default = isIndex;
exports.default = _default;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseTimes = _interopRequireDefault(__webpack_require__(81));

var _isArguments = _interopRequireDefault(__webpack_require__(82));

var _isArray = _interopRequireDefault(__webpack_require__(33));

var _isBuffer = _interopRequireDefault(__webpack_require__(84));

var _isIndex = _interopRequireDefault(__webpack_require__(31));

var _isTypedArray = _interopRequireDefault(__webpack_require__(86));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = (0, _isArray.default)(value),
      isArg = !isArr && (0, _isArguments.default)(value),
      isBuff = !isArr && !isArg && (0, _isBuffer.default)(value),
      isType = !isArr && !isArg && !isBuff && (0, _isTypedArray.default)(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? (0, _baseTimes.default)(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    (0, _isIndex.default)(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var _default = arrayLikeKeys;
exports.default = _default;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
var _default = isArray;
exports.default = _default;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

var _default = isPrototype;
exports.default = _default;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

var _isPlainObject = _interopRequireDefault(__webpack_require__(93));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!(0, _isObjectLike.default)(value)) {
    return false;
  }

  var tag = (0, _baseGetTag.default)(value);
  return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !(0, _isPlainObject.default)(value);
}

var _default = isError;
exports.default = _default;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _default = overArg;
exports.default = _default;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var _default = arrayMap;
exports.default = _default;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;
var _default = reInterpolate;
exports.default = _default;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseToString = _interopRequireDefault(__webpack_require__(105));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : (0, _baseToString.default)(value);
}

var _default = toString;
exports.default = _default;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(41);


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(42);

__webpack_require__(44);

__webpack_require__(48);

__webpack_require__(50);

var _polyfills = __webpack_require__(52);

Object.keys(_polyfills).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _polyfills[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _polyfills[key];
    }
  });
});

var _api = __webpack_require__(53);

Object.keys(_api).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _api[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _api[key];
    }
  });
});

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
__webpack_require__(120);

__webpack_require__(123);

__webpack_require__(125);

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["BBj"]) global["BBj"] = {};
module.exports = global["BBj"]["Masks"] = __webpack_require__(43);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 5);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toInteger;

      function toInteger(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }

        var number = Number(dirtyNumber);

        if (isNaN(number)) {
          return number;
        }

        return number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      /***/

    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(6);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"
      /* default */
      ];
      /***/
    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateMask__ = __webpack_require__(7);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["e"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "g", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["g"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "h", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["h"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["d"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "f", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["f"];
      });
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["c"] = __WEBPACK_IMPORTED_MODULE_0__DateMask__["c"
      /* default */
      ];
      /***/
    },
    /* 3 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzParseTimezone;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__ = __webpack_require__(9);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var patterns = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-])(\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
        timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      }; // Parse various time zone offset formats to an offset in milliseconds

      function tzParseTimezone(timezoneString, date) {
        var token;
        var absoluteOffset; // Z

        token = patterns.timezoneZ.exec(timezoneString);

        if (token) {
          return 0;
        }

        var hours; // hh

        token = patterns.timezoneHH.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);

          if (!validateTimezone(hours)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // hh:mm or hhmm


        token = patterns.timezoneHHMM.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);
          var minutes = parseInt(token[3], 10);

          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // IANA time zone


        token = patterns.timezoneIANA.exec(timezoneString);

        if (token) {
          // var [fYear, fMonth, fDay, fHour, fMinute, fSecond] = tzTokenizeDate(date, timezoneString)
          var tokens = Object(__WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__["a"
          /* default */
          ])(date, timezoneString);
          var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3], tokens[4], tokens[5]);
          var timestampWithMsZeroed = date.getTime() - date.getTime() % 1000;
          return -(asUTC - timestampWithMsZeroed);
        }

        return 0;
      }

      function validateTimezone(hours, minutes) {
        if (minutes != null && (minutes < 0 || minutes > 59)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 4 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__StringMask__ = __webpack_require__(19);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__StringMask__["a"
      /* default */
      ];
      /***/
    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "Utils", function () {
        return Utils;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__DateMask__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__StringMask__ = __webpack_require__(4);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__Types__ = __webpack_require__(20);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "Types", function () {
        return __WEBPACK_IMPORTED_MODULE_3__Types__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberMask", function () {
        return __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateMask", function () {
        return __WEBPACK_IMPORTED_MODULE_1__DateMask__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "StringMask", function () {
        return __WEBPACK_IMPORTED_MODULE_2__StringMask__["a"];
      });
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var Utils = {
        Dates: {
          getDayOfYear: __WEBPACK_IMPORTED_MODULE_1__DateMask__["e"
          /* getDayOfYear */
          ],
          getWeekNumber: __WEBPACK_IMPORTED_MODULE_1__DateMask__["g"
          /* getWeekNumber */
          ],
          getWeekStartByLocale: __WEBPACK_IMPORTED_MODULE_1__DateMask__["h"
          /* getWeekStartByLocale */
          ],
          IS_DATE_REGEX: __WEBPACK_IMPORTED_MODULE_1__DateMask__["a"
          /* IS_DATE_REGEX */
          ],
          IS_TIME_REGEX: __WEBPACK_IMPORTED_MODULE_1__DateMask__["b"
          /* IS_TIME_REGEX */
          ],
          fixShortISO: __WEBPACK_IMPORTED_MODULE_1__DateMask__["d"
          /* fixShortISO */
          ],
          getTimezoneOrOffset: __WEBPACK_IMPORTED_MODULE_1__DateMask__["f"
          /* getTimezoneOrOffset */
          ]
        }
      };
      /* harmony default export */

      __webpack_exports__["default"] = __WEBPACK_IMPORTED_MODULE_3__Types__["a"
      /* default */
      ];
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * NumberMask
       *
       * A javascript implementation for BBj numbers masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberMask = /*#__PURE__*/function () {
        function NumberMask() {
          _classCallCheck(this, NumberMask);
        }

        _createClass(NumberMask, null, [{
          key: "mask",

          /**
           * Mask the given number with the given mask according to BBj rules
           *
           * @param {Number} number the number to format
           * @param {String} mask the mask to use for formatting
           * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
           * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
           * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
           *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           * 
           * @throws {MaskError} only if loose is disabled
           * 
           * @returns {String} the masked number
           */
          value: function mask(number, _mask) {
            var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
            var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
            var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
            var maskLen = _mask.length;

            if (0 === maskLen) {
              if (loose) return str; // friendly silent fail
              else throw {
                  name: 'MaskError',
                  message: "MaskError: Mask is empty"
                };
            } // Get magnitude and precision of MASK


            var maskBeforeDecimal = 0;
            var maskAfterDecimal = 0;
            var foundDecimal = false;

            for (var i = 0; i < maskLen; ++i) {
              var m = _mask.charAt(i);

              if (m == '0' || m == '#') {
                if (foundDecimal) ++maskAfterDecimal;else ++maskBeforeDecimal;
              } else if (m == '.') foundDecimal = true;
            }

            var num = NumberMask._round(number, maskAfterDecimal);

            var bytes = NumberMask._toCharArray(num); // Get magnitude and precision of NUMBER


            var inLen = bytes.length;
            var numBeforeDecimal = 0;
            var numAfterDecimal = 0;
            foundDecimal = false;

            for (var _i = 0; _i < inLen; ++_i) {
              if (bytes[_i] == '.') foundDecimal = true;else {
                if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
              }
            } // always ignore mask overflow


            if (numBeforeDecimal > maskBeforeDecimal) {
              if (loose) return number.toString(); // friendly silent fail
              else throw {
                  name: 'MaskError',
                  message: "MaskError: Number is too large for mask"
                };
            } // round if mask is for a lower precision number


            if (numAfterDecimal > maskAfterDecimal) {
              num = NumberMask._round(num, maskAfterDecimal);
              bytes = NumberMask._toCharArray(num);
              inLen = bytes.length; // Get new magnitude and precision of NUMBER

              numBeforeDecimal = 0;
              numAfterDecimal = 0;
              foundDecimal = false;

              for (var _i2 = 0; _i2 < inLen; ++_i2) {
                if (bytes[_i2] == '.') foundDecimal = true;else {
                  if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
                }
              } // always ignore mask overflow


              if (numBeforeDecimal > maskBeforeDecimal) {
                if (loose) return number.toString(); // friendly silent fail
                else throw {
                    name: 'MaskError',
                    message: "MaskError: Number is too large for mask"
                  };
              }
            }

            var fillByte = ' ',
                floatByte = ' ';
            var inPos = 0,
                outPos = 0,
                floatPos = 0;
            if (_mask.charAt(0) == '*') fillByte = '*';
            var fillInit = fillByte;
            var isNegative = NumberMask._getSign(num) < 0;
            var emitDecimal = inLen > 0 || _mask.indexOf('0') >= 0;
            var foundZero = false;
            var foundDigit = false;
            var currency = false;
            foundDecimal = false;
            var ret = new Array(maskLen);

            for (var maskPos = 0; maskPos < maskLen; ++maskPos) {
              var _m = _mask.charAt(maskPos);

              switch (_m) {
                case '0':
                  --maskBeforeDecimal;

                  if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
                    ret[outPos] = bytes[inPos];
                    ++inPos;
                    foundDigit = true;
                  } else {
                    ret[outPos] = '0';
                    foundZero = true;
                  }

                  ++outPos;
                  break;

                case '#':
                  --maskBeforeDecimal;

                  if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
                    ret[outPos] = bytes[inPos];
                    ++inPos;
                    foundDigit = true;
                  } else {
                    ret[outPos] = foundDecimal && forceTrailingZeros && NumberMask._getSign(num) != 0 ? '0' : fillByte;
                    if (!foundDecimal) floatPos = maskPos;
                  }

                  ++outPos;
                  break;

                case ',':
                  if (foundZero || inPos > 0) ret[outPos] = groupingSeparator;else {
                    ret[outPos] = fillByte;
                    if (!foundDecimal) floatPos = maskPos;
                  }
                  ++outPos;
                  break;

                case '-':
                  if (!foundDigit && floatByte == ' ') {
                    if (isNegative) floatByte = '-';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else ret[outPos] = isNegative ? '-' : fillByte;

                  ++outPos;
                  break;

                case '+':
                  if (!foundDigit && floatByte == ' ') {
                    floatByte = isNegative ? '-' : '+';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else ret[outPos] = isNegative ? '-' : '+';

                  ++outPos;
                  break;

                case '$':
                  if (!foundDigit && floatByte == ' ') {
                    floatByte = '$';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else {
                    ret[outPos] = '$';
                  }

                  ++outPos;
                  break;
                // case '&':
                //   currency = true
                //   if (!foundDigit && floatByte == ' ') {
                //     floatByte = '&'
                //     ret[outPos] = fillByte
                //     floatPos = foundDecimal ? -1 : maskPos
                //   } else {
                //     ret[outPos] = '&'
                //   }
                //   ++outPos
                //   break
                // case '@':
                //   currency = true
                //   if (!foundDigit && floatByte == ' ') {
                //     floatByte = '@'
                //     ret[outPos] = fillByte
                //     floatPos = foundDecimal ? -1 : maskPos
                //   } else {
                //     ret[outPos] = '@'
                //   }
                //   ++outPos
                //   break

                case '(':
                  if (!foundDigit && floatByte == ' ') {
                    if (isNegative) floatByte = '(';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else {
                    if (isNegative) {
                      ret[outPos] = '(';
                    } else {
                      ret[outPos] = foundDecimal ? ' ' : fillByte;
                    }
                  }

                  ++outPos;
                  break;

                case ')':
                  if (isNegative) {
                    ret[outPos] = ')';
                  } else {
                    ret[outPos] = foundDecimal ? ' ' : fillByte;
                  }

                  ++outPos;
                  break;

                case 'C':
                  if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
                    if (isNegative) {
                      ret[outPos] = 'C';
                      ret[outPos + 1] = 'R';
                    } else {
                      ret[outPos] = ' ';
                      ret[outPos + 1] = ' ';
                    }

                    outPos += 2;
                    ++maskPos;
                  } else {
                    ret[outPos] = 'C';
                    ++outPos;
                  }

                  break;

                case 'D':
                  if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
                    if (isNegative) {
                      ret[outPos] = 'C';
                      ret[outPos + 1] = 'R';
                    } else {
                      ret[outPos] = 'D';
                      ret[outPos + 1] = 'R';
                    }

                    outPos += 2;
                    ++maskPos;
                  } else {
                    ret[outPos] = 'D';
                    ++outPos;
                  }

                  break;

                case '*':
                  ret[outPos] = '*';
                  ++outPos;
                  break;

                case '.':
                  ret[outPos] = emitDecimal ? decimalSeparator : fillByte;
                  fillByte = ' ';
                  foundDecimal = true;
                  ++inPos;
                  ++outPos;
                  break;

                case 'B':
                  ret[outPos] = ' ';
                  ++outPos;
                  break;

                default:
                  ret[outPos] = _m;
                  ++outPos;
                  break;
              }
            }

            if (floatByte != ' ') {
              if (floatPos < 0) floatPos = outPos;

              while (floatPos >= maskLen) {
                --floatPos;
              }

              if (ret[floatPos] == fillInit) ret[floatPos] = floatByte;
            }

            return ret.join('');
          }
        }, {
          key: "_shift",
          value: function _shift(number, precision, reverseShift) {
            if (reverseShift) precision = -precision;
            var numArray = ('' + number).split('e');
            return +(numArray[0] + 'e' + (numArray[1] ? +numArray[1] + precision : precision));
          }
        }, {
          key: "_round",
          value: function _round(number, precision) {
            return NumberMask._shift(Math.round(NumberMask._shift(number, precision, false)), precision, true);
          }
        }, {
          key: "_toCharArray",
          value: function _toCharArray(number) {
            var signum = NumberMask._getSign(number);

            var chars = [];

            if (signum !== 0) {
              var string = signum < 0 ? "".concat(-1 * number.toString()) : number.toString();
              if (string.length > 1 && string.charAt(0) == '0') string = string.substring(1); // The string contains only [0-9] and '.'

              chars = string.split('');
            }

            return chars;
          }
          /**
           * Returns the sign of a number
           *
           * @param {Number} x number
           * @returns {Number} A number representing the sign of the given argument.
           *                   If the argument is a positive number, negative number, positive zero
           *                   or negative zero, the function will return 1, -1, 0 or -0 respectively.
           *                   Otherwise, NaN is returned.
           */

        }, {
          key: "_getSign",
          value: function _getSign(x) {
            return (x > 0) - (x < 0) || +x;
          }
        }]);

        return NumberMask;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = NumberMask;
      /***/
    },
    /* 7 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return IS_TIME_REGEX;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return IS_DATE_REGEX;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "h", function () {
        return getWeekStartByLocale;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return getDayOfYear;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return fixShortISO;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "f", function () {
        return getTimezoneOrOffset;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "g", function () {
        return getWeekNumber;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_date_fns_tz_utcToZonedTime__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_weekstart__ = __webpack_require__(15);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var IS_TIME_REGEX = /^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/;
      var IS_DATE_REGEX = /^(([12]\d{3})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?))$/;
      /**
       * Find out when the first day of the week based on the passed locale
       *
       * @param {locale} locale
       *
       * @return {Number} a number 0 = sunday , 1 = monday , ....
       */

      var getWeekStartByLocale = function getWeekStartByLocale(locale) {
        return Object(__WEBPACK_IMPORTED_MODULE_1_weekstart__["a"
        /* getWeekStartByLocale */
        ])(locale);
      };
      /**
       *  Get day number in the year of the passed date
       *
       * @param {Date} date
       *
       * @return {Number} day number
       */


      var getDayOfYear = function getDayOfYear(date) {
        var start = new Date(date.getFullYear(), 0, 0);
        var diff = date - start + (start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000;
        var oneDay = 1000 * 60 * 60 * 24;
        var day = Math.floor(diff / oneDay);
        return day;
      };
      /**
       * Takes incomplete iso string and return a complete one
       *
       * @param {String} date incomplete iso string
       *
       * @return {String} complete iso string
       */


      var fixShortISO = function fixShortISO(date) {
        var value = date;
        var offset = (value.match(/z$|[+\-]\d\d:\d\d$/i) || [])[0];

        if (!offset) {
          offset = 'Z';
          value += offset;
        }

        if (IS_TIME_REGEX.test(value)) {
          value = "1970-01-01T".concat(value);
        } else if (IS_DATE_REGEX.test(value)) {
          value = "".concat(value.split(offset)[0], "T00:00:00").concat(offset);
        }

        return value;
      };
      /**
       * Get the browser timezone name , if not supported then the browser
       * timezone offset formatted
       *
       * @return {String} timezone of offset
       */


      var getTimezoneOrOffset = function getTimezoneOrOffset() {
        var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        if (!timezone) {
          var pad = function pad(number, length) {
            var str = '' + number;

            while (str.length < length) {
              str = '0' + str;
            }

            return str;
          };

          var offset = new Date().getTimezoneOffset();
          offset = (offset < 0 ? '+' : '-') + // Note the reversed sign!
          pad(parseInt(Math.abs(offset / 60)), 2) + pad(Math.abs(offset % 60), 2);
          return offset;
        }

        return timezone;
      };
      /**
       * Get the Week Number in the passed date
       *
       * @param {Date} date - Date object
       * @param {Number} weekStart A number which defines the first day of the week (0  = sunday , 1 = monday , ...)
       *
       * @returns {Number} the week number
       */


      var getWeekNumber = function getWeekNumber(date, weekStart) {
        var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        var dayNum = d.getUTCDay() - (weekStart - 1) || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
      };
      /**
       * DateMask
       *
       * A javascript implementation for BBj dates masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateMask = /*#__PURE__*/function () {
        function DateMask() {
          _classCallCheck(this, DateMask);
        }

        _createClass(DateMask, null, [{
          key: "mask",

          /**
           * Mask date
           *
           * Mask the passed date with the passed mask
           *
           * @param {String} date date as a string
           * @param {String} mask mask as a string
           * @param {String} [locale=Browser's locale] the language to use ex(en-US). default is to the system language
           * @param {String} [timezone=System timezone] the time zone descriptor (e.g. America/Los_Angeles). default to the system
           *                          timezone
           *
           * @return {String} a date masked with the given mask
           */
          value: function mask(date, _mask, locale, timezone) {
            if (!date) return '';
            if (!_mask) return date;
            timezone = timezone || getTimezoneOrOffset();
            locale = locale || Intl.DateTimeFormat().resolvedOptions().locale || 'en-US'; // make sure we have a complete iso string

            date = date instanceof Date ? date : fixShortISO(date);
            var dateObject = Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_tz_utcToZonedTime__["a"
            /* default */
            ])(date, timezone);

            var translation = DateMask._buildTranslation({
              year: dateObject.getFullYear(),
              month: dateObject.getMonth() + 1,
              monthShort: new Intl.DateTimeFormat([locale], {
                month: 'short'
              }).format(dateObject),
              monthLong: new Intl.DateTimeFormat([locale], {
                month: 'long'
              }).format(dateObject),
              day: dateObject.getDate(),
              dayShort: new Intl.DateTimeFormat([locale], {
                weekday: 'short'
              }).format(dateObject),
              dayLong: new Intl.DateTimeFormat([locale], {
                weekday: 'long'
              }).format(dateObject),
              minutes: dateObject.getMinutes(),
              seconds: dateObject.getSeconds(),

              get hours24() {
                return dateObject.getHours();
              },

              get hours12() {
                return this.hours24 % 12 || 12;
              },

              dayOfYear: getDayOfYear(dateObject),
              dayOfWeek: dateObject.getDay() + 1,
              // Sunday = 1 in BBj but Sunday = 0 in JS
              weekNumber: getWeekNumber(dateObject, getWeekStartByLocale(locale)),
              locale: locale,
              timezone: timezone
            });

            var result = _mask;

            for (var k in translation) {
              result = result.replace(new RegExp('(%' + k + ')', 'g'), translation[k]);
            }

            return result;
          }
          /**
           * Get a map object which contains all possible forms of masks
           *
           * @param {Object} dateDetails date
           *
           * @return {Object} forms masks
           */

        }, {
          key: "_buildTranslation",
          value: function _buildTranslation(dateDetails) {
            return {
              // year
              Yz: dateDetails.year.toString().substr(-2),
              Ys: dateDetails.year,
              Yl: dateDetails.year,
              Yp: String.fromCharCode(dateDetails.year),
              Yd: dateDetails.year,
              Y: dateDetails.year,
              // month
              Mz: String(dateDetails.month).length == 1 ? '0' + dateDetails.month : dateDetails.month,
              Ms: dateDetails.monthShort,
              Ml: dateDetails.monthLong,
              Mp: String.fromCharCode(dateDetails.month),
              Md: dateDetails.month,
              M: dateDetails.month,
              // day
              Dz: String(dateDetails.day).length == 1 ? '0' + dateDetails.day : dateDetails.day,
              Ds: dateDetails.dayShort,
              Dl: dateDetails.dayLong,
              Dp: String.fromCharCode(dateDetails.day),
              Dd: dateDetails.day,
              D: dateDetails.day,
              // hour 24
              Hz: String(dateDetails.hours24).length == 1 ? '0' + dateDetails.hours24 : dateDetails.hours24,
              Hs: dateDetails.hours24,
              Hl: dateDetails.hours24,
              Hp: String.fromCharCode(dateDetails.hours24),
              Hd: dateDetails.hours24,
              H: dateDetails.hours24,
              // hour 12
              hz: String(dateDetails.hours12).length == 1 ? '0' + dateDetails.hours12 : dateDetails.hours12,
              hs: dateDetails.hours12,
              hl: dateDetails.hours12,
              hp: String.fromCharCode(dateDetails.hours12),
              hd: dateDetails.hours12,
              h: dateDetails.hours12,
              // minutes
              mz: String(dateDetails.minutes).length == 1 ? '0' + dateDetails.minutes : dateDetails.minutes,
              ms: dateDetails.minutes,
              ml: dateDetails.minutes,
              mp: String.fromCharCode(dateDetails.minutes),
              md: dateDetails.minutes,
              m: dateDetails.minutes,
              // seconds
              sz: String(dateDetails.seconds).length == 1 ? '0' + dateDetails.seconds : dateDetails.seconds,
              ss: dateDetails.seconds,
              sl: dateDetails.seconds,
              sp: String.fromCharCode(dateDetails.seconds),
              sd: dateDetails.seconds,
              s: dateDetails.seconds,
              // AM , PM
              PP: dateDetails.hours24 > 12 ? 'PM' : 'PM',
              P: dateDetails.hours24 > 12 ? 'PM' : 'AM',
              pp: dateDetails.hours24 > 12 ? 'pm' : 'am',
              p: dateDetails.hours24 > 12 ? 'pm' : 'am',
              // Day of Year
              Jz: String(dateDetails.dayOfYear).length == 1 ? '0' + dateDetails.dayOfYear : dateDetails.dayOfYear,
              Js: dateDetails.dayOfYear,
              Jl: dateDetails.dayOfYear,
              Jd: dateDetails.dayOfYear,
              J: dateDetails.dayOfYear,
              // Day Of Week
              Wz: String(dateDetails.dayOfWeek).length == 1 ? '0' + dateDetails.dayOfWeek : dateDetails.dayOfWeek,
              Ws: dateDetails.dayOfWeek,
              Wl: dateDetails.dayOfWeek,
              Wp: String.fromCharCode(dateDetails.dayOfWeek),
              Wd: dateDetails.dayOfWeek,
              W: dateDetails.dayOfWeek,
              // week number
              wz: String(dateDetails.weekNumber).length == 1 ? '0' + dateDetails.weekNumber : dateDetails.weekNumber,
              ws: dateDetails.weekNumber,
              wl: dateDetails.weekNumber,
              wp: String.fromCharCode(dateDetails.weekNumber),
              wd: dateDetails.weekNumber,
              w: dateDetails.weekNumber
            };
          }
        }]);

        return DateMask;
      }();
      /* harmony default export */


      __webpack_exports__["c"] = DateMask;
      /***/
    },
    /* 8 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = utcToZonedTime;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__ = __webpack_require__(3);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__ = __webpack_require__(10);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__toDate__ = __webpack_require__(13);
      /**
       * @name utcToZonedTime
       * @category Time Zone Helpers
       * @summary Get a date/time representing local time in a given time zone from the UTC date
       *
       * @description
       * Returns a date instance with values representing the local time in the time zone
       * specified of the UTC time from the date provided. In other words, when the new date
       * is formatted it will show the equivalent hours in the target time zone regardless
       * of the current system time zone.
       *
       * @param {Date|String|Number} date - the date with the relevant UTC time
       * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
       * @returns {Date} the new date with the equivalent time in the time zone
       * @throws {TypeError} 2 arguments required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // In June 10am UTC is 6am in New York (-04:00)
       * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
       * //=> Jun 25 2014 06:00:00
       */


      function utcToZonedTime(dirtyDate, timeZone, options) {
        var date = Object(__WEBPACK_IMPORTED_MODULE_2__toDate__["a"
        /* default */
        ])(dirtyDate, options); // This date has the UTC time values of the input date at the system time zone

        var utcDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()); // We just need to apply the offset indicated by the time zone to this localized date

        var offsetMilliseconds = Object(__WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__["a"
        /* default */
        ])(timeZone, date);
        return offsetMilliseconds ? Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__["a"
        /* default */
        ])(utcDate, offsetMilliseconds) : utcDate;
      }
      /***/

    },
    /* 9 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzTokenizeDate;
      /**
       * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
       * `date` as it will be rendered in the `timeZone`.
       */

      function tzTokenizeDate(date, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      }

      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };

      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date);
        var filled = [];

        for (var i = 0; i < formatted.length; i++) {
          var pos = typeToPos[formatted[i].type];

          if (pos >= 0) {
            filled[pos] = parseInt(formatted[i].value, 10);
          }
        }

        return filled;
      }

      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, '');
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted); // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
        // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]

        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      } // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
      // to get deterministic local date/time output according to the `en-US` locale which
      // can be used to extract local time parts as necessary.


      var dtfCache = {};

      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
          var testDateFormatted = new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: 'America/New_York',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }).format(new Date('2014-06-25T04:00:00.123Z'));
          var hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '06/25/2014 00:00:00';
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }) : new Intl.DateTimeFormat('en-US', {
            hourCycle: 'h23',
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        }

        return dtfCache[timeZone];
      }
      /***/

    },
    /* 10 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = subMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__ = __webpack_require__(11);
      /**
       * @name subMilliseconds
       * @category Millisecond Helpers
       * @summary Subtract the specified number of milliseconds from the given date.
       *
       * @description
       * Subtract the specified number of milliseconds from the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be subtracted
       * @returns {Date} the new date with the milliseconds subtracted
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
       * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:29.250
       */


      function subMilliseconds(dirtyDate, dirtyAmount) {
        if (arguments.length < 2) {
          throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
        }

        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return Object(__WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__["a"
        /* default */
        ])(dirtyDate, -amount);
      }
      /***/

    },
    /* 11 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = addMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toDate_index_js__ = __webpack_require__(12);
      /**
       * @name addMilliseconds
       * @category Millisecond Helpers
       * @summary Add the specified number of milliseconds to the given date.
       *
       * @description
       * Add the specified number of milliseconds to the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be added
       * @returns {Date} the new date with the milliseconds added
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
       * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:30.750
       */


      function addMilliseconds(dirtyDate, dirtyAmount) {
        if (arguments.length < 2) {
          throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
        }

        var timestamp = Object(__WEBPACK_IMPORTED_MODULE_1__toDate_index_js__["a"
        /* default */
        ])(dirtyDate).getTime();
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return new Date(timestamp + amount);
      }
      /***/

    },
    /* 12 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       *
       * @param {Date|Number} argument - the value to convert
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       *
       * @example
       * // Clone the date:
       * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert the timestamp to date:
       * const result = toDate(1392098430000)
       * //=> Tue Feb 11 2014 11:30:30
       */

      function toDate(argument) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        var argStr = Object.prototype.toString.call(argument); // Clone the date

        if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || argStr === '[object Number]') {
          return new Date(argument);
        } else {
          if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
            // eslint-disable-next-line no-console
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

            console.warn(new Error().stack);
          }

          return new Date(NaN);
        }
      }
      /***/

    },
    /* 13 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__ = __webpack_require__(14);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__ = __webpack_require__(3);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns = {
        dateTimeDelimeter: /[T ]/,
        plainTime: /:/,
        timeZoneDelimeter: /[Z ]/i,
        // year tokens
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, // 0 additional digits
        /^([+-]\d{3})$/, // 1 additional digit
        /^([+-]\d{4})$/ // 2 additional digits
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, // 0 additional digits
        /^([+-]\d{5})/, // 1 additional digit
        /^([+-]\d{6})/ // 2 additional digits
        ],
        // date tokens
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        // timezone tokens (to identify the presence of a tz)
        timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If an argument is a string, the function tries to parse it.
       * Function accepts complete ISO 8601 formats as well as partial implementations.
       * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
       * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
       *
       * @param {Date|String|Number} argument - the value to convert
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
       * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // Convert string '2014-02-11T11:30:30' to date:
       * var result = toDate('2014-02-11T11:30:30')
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert string '+02014101' to date,
       * // if the additional number of digits in the extended year format is 1:
       * var result = toDate('+02014101', {additionalDigits: 1})
       * //=> Fri Apr 11 2014 00:00:00
       */

      function toDate(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        if (argument === null) {
          return new Date(NaN);
        }

        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__["a"
        /* default */
        ])(options.additionalDigits);

        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError('additionalDigits must be 0, 1 or 2');
        } // Clone the date


        if (argument instanceof Date || _typeof(argument) === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
          return new Date(argument);
        } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
          return new Date(NaN);
        }

        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date = parseDate(restDateString, year);

        if (isNaN(date)) {
          return new Date(NaN);
        }

        if (date) {
          var timestamp = date.getTime();
          var time = 0;
          var offset;

          if (dateStrings.time) {
            time = parseTime(dateStrings.time);

            if (isNaN(time)) {
              return new Date(NaN);
            }
          }

          if (dateStrings.timezone || options.timeZone) {
            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time));

            if (isNaN(offset)) {
              return new Date(NaN);
            }
          } else {
            // get offset accurate to hour in timezones that change offset
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time));
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time + offset));
          }

          return new Date(timestamp + time + offset);
        } else {
          return new Date(NaN);
        }
      }

      function splitDateString(dateString) {
        var dateStrings = {};
        var array = dateString.split(patterns.dateTimeDelimeter);
        var timeString;

        if (patterns.plainTime.test(array[0])) {
          dateStrings.date = null;
          timeString = array[0];
        } else {
          dateStrings.date = array[0];
          timeString = array[1];
          dateStrings.timezone = array[2];

          if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
          }
        }

        if (timeString) {
          var token = patterns.timezone.exec(timeString);

          if (token) {
            dateStrings.time = timeString.replace(token[1], '');
            dateStrings.timezone = token[1];
          } else {
            dateStrings.time = timeString;
          }
        }

        return dateStrings;
      }

      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns.YYY[additionalDigits];
        var patternYYYYY = patterns.YYYYY[additionalDigits];
        var token; // YYYY or YYYYY

        token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

        if (token) {
          var yearString = token[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        } // YY or YYY


        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

        if (token) {
          var centuryString = token[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        } // Invalid ISO-formatted year


        return {
          year: null
        };
      }

      function parseDate(dateString, year) {
        // Invalid ISO-formatted year
        if (year === null) {
          return null;
        }

        var token;
        var date;
        var month;
        var week; // YYYY

        if (dateString.length === 0) {
          date = new Date(0);
          date.setUTCFullYear(year);
          return date;
        } // YYYY-MM


        token = patterns.MM.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;

          if (!validateDate(year, month)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month);
          return date;
        } // YYYY-DDD or YYYYDDD


        token = patterns.DDD.exec(dateString);

        if (token) {
          date = new Date(0);
          var dayOfYear = parseInt(token[1], 10);

          if (!validateDayOfYearDate(year, dayOfYear)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, 0, dayOfYear);
          return date;
        } // yyyy-MM-dd or YYYYMMDD


        token = patterns.MMDD.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;
          var day = parseInt(token[2], 10);

          if (!validateDate(year, month, day)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month, day);
          return date;
        } // YYYY-Www or YYYYWww


        token = patterns.Www.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;

          if (!validateWeekDate(year, week)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week);
        } // YYYY-Www-D or YYYYWwwD


        token = patterns.WwwD.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;
          var dayOfWeek = parseInt(token[2], 10) - 1;

          if (!validateWeekDate(year, week, dayOfWeek)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week, dayOfWeek);
        } // Invalid ISO-formatted date


        return null;
      }

      function parseTime(timeString) {
        var token;
        var hours;
        var minutes; // hh

        token = patterns.HH.exec(timeString);

        if (token) {
          hours = parseFloat(token[1].replace(',', '.'));

          if (!validateTime(hours)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR;
        } // hh:mm or hhmm


        token = patterns.HHMM.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseFloat(token[2].replace(',', '.'));

          if (!validateTime(hours, minutes)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
        } // hh:mm:ss or hhmmss


        token = patterns.HHMMSS.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseInt(token[2], 10);
          var seconds = parseFloat(token[3].replace(',', '.'));

          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
        } // Invalid ISO-formatted time


        return null;
      }

      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date = new Date(0);
        date.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date.setUTCDate(date.getUTCDate() + diff);
        return date;
      } // Validation functions


      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }

      function validateDate(year, month, date) {
        if (month < 0 || month > 11) {
          return false;
        }

        if (date != null) {
          if (date < 1) {
            return false;
          }

          var isLeapYear = isLeapYearIndex(year);

          if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }

          if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
            return false;
          }
        }

        return true;
      }

      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }

        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear && dayOfYear > 366) {
          return false;
        }

        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }

        return true;
      }

      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }

        if (day != null && (day < 0 || day > 6)) {
          return false;
        }

        return true;
      }

      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }

        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }

        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 14 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = getTimezoneOffsetInMilliseconds;
      var MILLISECONDS_IN_MINUTE = 60000;
      /**
       * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
       * They usually appear for dates that denote time before the timezones were introduced
       * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
       * and GMT+01:00:00 after that date)
       *
       * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
       * which would lead to incorrect calculations.
       *
       * This function returns the timezone offset in milliseconds that takes seconds in account.
       */

      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime());
        var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        date.setSeconds(0, 0);
        var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
        return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export getWeekStartByRegion */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return getWeekStartByLocale$1;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__api_js__ = __webpack_require__(16);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__langRegionMap_js__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__ = __webpack_require__(18);

      function getWeekStartByRegion$1(regionCode) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__api_js__["b"
        /* getWeekStartByRegion */
        ])(regionCode, __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__["a"
        /* default */
        ]);
      }

      function getWeekStartByLocale$1(locale) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__api_js__["a"
        /* getWeekStartByLocale */
        ])(locale, __WEBPACK_IMPORTED_MODULE_1__langRegionMap_js__["a"
        /* default */
        ], __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__["a"
        /* default */
        ]);
      }
      /***/

    },
    /* 16 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return getWeekStartByRegion;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return getWeekStartByLocale;
      });

      function getWeekStartByRegion(regionCode, regionDayMap) {
        var code = regionDayMap[typeof regionCode === 'string' ? regionCode.toUpperCase() : regionCode];
        return typeof code === 'number' ? code : 1;
      }

      function getWeekStartByLocale(locale, langRegionMap, regionDayMap) {
        if (locale) {
          var data = locale.toLowerCase().split(/[-_]/);
          var language = data[0];
          var country;

          if (data[1] && data[1].length === 4) {
            language += "_" + data[1];
            country = data[2];
          } else {
            country = data[1];
          }

          if (!country) {
            country = langRegionMap[language];
          }

          if (country) {
            return getWeekStartByRegion(country.match(/^\d+$/) ? Number(country) : country, regionDayMap);
          }
        }

        return 1;
      }
      /***/

    },
    /* 17 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var langRegionMap = {
        en: 'US',
        zh: 'CN',
        zh_hans: 'CN',
        hans: 'CN',
        wuu: 'CN',
        hsn: 'CN',
        hak: 'CN',
        nan: 'CN',
        gan: 'CN',
        hi: 'IN',
        te: 'IN',
        mr: 'IN',
        ta: 'IN',
        gu: 'IN',
        kn: 'IN',
        or: 'IN',
        ml: 'IN',
        pa_guru: 'IN',
        bho: 'IN',
        awa: 'IN',
        as: 'IN',
        mwr: 'IN',
        mai: 'IN',
        mag: 'IN',
        bgc: 'IN',
        hne: 'IN',
        dcc: 'IN',
        dz: 'BT',
        tn: 'BW',
        am: 'ET',
        om: 'ET',
        quc: 'GT',
        id: 'ID',
        jv: 'ID',
        su: 'ID',
        mad: 'ID',
        ms_arab: 'ID',
        ga: 'IE',
        he: 'IL',
        jam: 'JM',
        ja: 'JP',
        km: 'KH',
        ko: 'KR',
        lo: 'LA',
        mh: 'MH',
        my: 'MM',
        mt: 'MT',
        ne: 'NP',
        fil: 'PH',
        ceb: 'PH',
        ilo: 'PH',
        ur: 'PK',
        pa: 'PK',
        pa_arab: 'PK',
        arab: 'PK',
        lah: 'PK',
        ps: 'PK',
        sd: 'PK',
        sd_arab: 'PK',
        skr: 'PK',
        gn: 'PY',
        th: 'TH',
        tts: 'TH',
        aeb: 'TN',
        zh_hant: 'TW',
        hant: 'TW',
        sm: 'WS',
        zu: 'ZA',
        sn: 'ZW',
        arq: 'DZ',
        ar: 'EG',
        arz: 'EG',
        fa: 'IR',
        az_arab: 'IR',
        ary: 'MA',
        bn: 'BD',
        rkt: 'BD',
        dv: 'MV'
      };
      /* harmony default export */

      __webpack_exports__["a"] = langRegionMap;
      /***/
    },
    /* 18 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var regionDayMap = {
        AG: 0,
        ATG: 0,
        28: 0,
        AR: 0,
        ARG: 0,
        32: 0,
        AS: 0,
        ASM: 0,
        16: 0,
        AU: 0,
        AUS: 0,
        36: 0,
        BR: 0,
        BRA: 0,
        76: 0,
        BS: 0,
        BHS: 0,
        44: 0,
        BT: 0,
        BTN: 0,
        64: 0,
        BW: 0,
        BWA: 0,
        72: 0,
        BZ: 0,
        BLZ: 0,
        84: 0,
        CA: 0,
        CAN: 0,
        124: 0,
        CN: 0,
        CHN: 0,
        156: 0,
        CO: 0,
        COL: 0,
        170: 0,
        DM: 0,
        DMA: 0,
        212: 0,
        DO: 0,
        DOM: 0,
        214: 0,
        ET: 0,
        ETH: 0,
        231: 0,
        GT: 0,
        GTM: 0,
        320: 0,
        GU: 0,
        GUM: 0,
        316: 0,
        HK: 0,
        HKG: 0,
        344: 0,
        HN: 0,
        HND: 0,
        340: 0,
        ID: 0,
        IDN: 0,
        360: 0,
        IE: 0,
        IRL: 0,
        372: 0,
        IL: 0,
        ISR: 0,
        376: 0,
        IN: 0,
        IND: 0,
        356: 0,
        JM: 0,
        JAM: 0,
        388: 0,
        JP: 0,
        JPN: 0,
        392: 0,
        KE: 0,
        KEN: 0,
        404: 0,
        KH: 0,
        KHM: 0,
        116: 0,
        KR: 0,
        KOR: 0,
        410: 0,
        LA: 0,
        LA0: 0,
        418: 0,
        MH: 0,
        MHL: 0,
        584: 0,
        MM: 0,
        MMR: 0,
        104: 0,
        MO: 0,
        MAC: 0,
        446: 0,
        MT: 0,
        MLT: 0,
        470: 0,
        MX: 0,
        MEX: 0,
        484: 0,
        MZ: 0,
        MOZ: 0,
        508: 0,
        NI: 0,
        NIC: 0,
        558: 0,
        NP: 0,
        NPL: 0,
        524: 0,
        NZ: 0,
        NZL: 0,
        554: 0,
        PA: 0,
        PAN: 0,
        591: 0,
        PE: 0,
        PER: 0,
        604: 0,
        PH: 0,
        PHL: 0,
        608: 0,
        PK: 0,
        PAK: 0,
        586: 0,
        PR: 0,
        PRI: 0,
        630: 0,
        PY: 0,
        PRY: 0,
        600: 0,
        SA: 0,
        SAU: 0,
        682: 0,
        SG: 0,
        SGP: 0,
        702: 0,
        SV: 0,
        SLV: 0,
        222: 0,
        TH: 0,
        THA: 0,
        764: 0,
        TN: 0,
        TUN: 0,
        788: 0,
        TT: 0,
        TTO: 0,
        780: 0,
        TW: 0,
        TWN: 0,
        158: 0,
        UM: 0,
        UMI: 0,
        581: 0,
        US: 0,
        USA: 0,
        840: 0,
        VE: 0,
        VEN: 0,
        862: 0,
        VI: 0,
        VIR: 0,
        850: 0,
        WS: 0,
        WSM: 0,
        882: 0,
        YE: 0,
        YEM: 0,
        887: 0,
        ZA: 0,
        ZAF: 0,
        710: 0,
        ZW: 0,
        ZWE: 0,
        716: 0,
        AE: 6,
        ARE: 6,
        784: 6,
        AF: 6,
        AFG: 6,
        4: 6,
        BH: 6,
        BHR: 6,
        48: 6,
        DJ: 6,
        DJI: 6,
        262: 6,
        DZ: 6,
        DZA: 6,
        12: 6,
        EG: 6,
        EGY: 6,
        818: 6,
        IQ: 6,
        IRQ: 6,
        368: 6,
        IR: 6,
        IRN: 6,
        364: 6,
        JO: 6,
        JOR: 6,
        400: 6,
        KW: 6,
        KWT: 6,
        414: 6,
        LY: 6,
        LBY: 6,
        434: 6,
        MA: 6,
        MAR: 6,
        504: 6,
        OM: 6,
        OMN: 6,
        512: 6,
        QA: 6,
        QAT: 6,
        634: 6,
        SD: 6,
        SDN: 6,
        729: 6,
        SY: 6,
        SYR: 6,
        760: 6,
        BD: 5,
        BGD: 5,
        50: 5,
        MV: 5,
        MDV: 5,
        462: 5
      };
      /* harmony default export */

      __webpack_exports__["a"] = regionDayMap;
      /***/
    },
    /* 19 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var isNumberRegex = /^\d+$/;
      var isWhitespaceRegex = /\s/;
      var punctuationList = '!"#$%&\'()*+,-./:;<=>?@[]^_`{|}~';
      /**
       * Check if the given string is in lower case
       *
       * @param {String} str
       */

      var isLowerCase = function isLowerCase(str) {
        return str == str.toLowerCase() && str != str.toUpperCase();
      };
      /**
       * Check if the given string is in upper case
       *
       * @param {String} str
       */


      var isUpperCase = function isUpperCase(str) {
        return str == str.toUpperCase() && str != str.toLowerCase();
      };

      var passOrThrowError = function passOrThrowError(loose, ret, i, str) {
        if (!loose) {
          var _char = str.charAt(i);

          var pos = i + 1;
          throw {
            name: 'StringMaskError',
            message: "StringMaskError: error applying mask at position \"".concat(pos, "\" , char \"").concat(_char, "\""),
            pos: pos,
            "char": _char
          };
        } else ret[i] = ' ';
      };
      /**
       * NumberMask
       *
       * A javascript implementation for BBj numbers masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var StringMask = /*#__PURE__*/function () {
        function StringMask() {
          _classCallCheck(this, StringMask);
        }

        _createClass(StringMask, null, [{
          key: "mask",

          /**
           * Mask the given string with the given mask according to BBj rules
           *
           * @param {String} str the string to mask
           * @param {String} mask the mask to use for formatting
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           * 
           * @throws {MaskIsTooShortError}
           * @throws {StringMaskError}
           * @throws {MaskError}
           * 
           * @returns {String} the masked string
           */
          value: function mask(str, _mask) {
            var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            str = String(str);
            _mask = String(_mask);
            var maskLen = _mask.length;
            var strLen = str.length;

            if (strLen > maskLen) {
              if (loose) return str; // friendly silent fail
              else throw {
                  name: 'MaskIsTooShortError',
                  message: "MaskIsTooShortError: Mask is shorter than the passed string"
                };
            }

            var ret = new Array(maskLen);
            var pos = 0; // to keep track of the current position in the str

            var maskByte = '';

            for (var i = 0; i < maskLen; i++) {
              maskByte = _mask.charAt(i);

              switch (maskByte) {
                case 'X':
                  // match any character
                  ret[i] = pos < strLen ? str.charAt(pos) : ' ';
                  ++pos;
                  break;

                case 'A':
                  // match letter; force upper case
                  if (pos < strLen) {
                    var _byte = str.charAt(pos);

                    if (isUpperCase(_byte)) ret[i] = _byte;else if (isLowerCase(_byte)) ret[i] = _byte.toUpperCase();else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'a':
                  // match letter
                  if (pos < strLen) {
                    var _byte2 = str.charAt(pos);

                    if (isUpperCase(_byte2) || isLowerCase(_byte2)) ret[i] = _byte2;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case '0':
                  // match digit
                  if (pos < strLen) {
                    var _byte3 = str.charAt(pos);

                    if (isNumberRegex.test(_byte3)) ret[i] = _byte3;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'Z':
                  // match letter or digit; force upper case
                  if (pos < strLen) {
                    var _byte4 = str.charAt(pos);

                    if (isUpperCase(_byte4) || isNumberRegex.test(_byte4)) ret[i] = _byte4;else if (isLowerCase(_byte4)) ret[i] = _byte4.toUpperCase();else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'z':
                  // match letter or digit
                  if (pos < strLen) {
                    var _byte5 = str.charAt(pos);

                    if (isUpperCase(_byte5) || isLowerCase(_byte5) || isNumberRegex.test(_byte5)) ret[i] = _byte5;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;
                  break;

                case 'U':
                  // match letter (force upper case), digit, whitespace or punctuation.
                  if (pos < strLen) {
                    var _byte6 = str.charAt(pos);

                    if (isLowerCase(_byte6)) ret[i] = _byte6.toUpperCase();else if (isUpperCase(_byte6) || isNumberRegex.test(_byte6) || isWhitespaceRegex.test(_byte6) || punctuationList.indexOf(_byte6) > -1) ret[i] = _byte6;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                default:
                  ret[i] = maskByte;
                  break;
              }
            }

            if (pos < strLen) {
              if (!loose) {
                throw {
                  name: 'MaskError',
                  message: 'Mask cannot be applied'
                };
              }
            }

            return ret.join('');
          }
        }]);

        return StringMask;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = StringMask;
      /***/
    },
    /* 20 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Types__ = __webpack_require__(21);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__Types__["a"
      /* default */
      ];
      /***/
    },
    /* 21 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__DateMask__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__StringMask__ = __webpack_require__(4);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Types
       *
       * BBj masks factory
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var Types = /*#__PURE__*/function () {
        function Types() {
          _classCallCheck(this, Types);
        }

        _createClass(Types, null, [{
          key: "number",

          /**
           * Mask the given number with the given mask according to BBj rules
           *
           * @param {Number} number the number to format
           * @param {String} mask the mask to use for formatting
           * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
           * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
           * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
           *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           *
           * @returns {String} the masked number
           */
          value: function number(_number, mask) {
            var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
            var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
            var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
            return __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"
            /* default */
            ].mask(_number, mask, groupingSeparator, decimalSeparator, forceTrailingZeros, loose);
          }
          /**
           * Mask a date according to bbj masking rules
           *
           * @param {String} date date as a string
           * @param {String} mask mask as a string
           * @param {String} [locale=Browser's locale] the language to use ex(en-US). default is to the system language
           * @param {String} [timezone=System timezone] the time zone descriptor (e.g. America/Los_Angeles). default to the system
           *                          timezone
           *
           * @return {String} number masked with the given mask
           */

        }, {
          key: "date",
          value: function date(_date, mask, locale, timezone) {
            return __WEBPACK_IMPORTED_MODULE_1__DateMask__["c"
            /* default */
            ].mask(_date, mask, locale, timezone);
          }
          /**
           * Mask the given string with the given mask according to BBj rules
           *
           * @param {String} str the string to mask
           * @param {String} mask the mask to use for formatting
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           *
           * @throws {MaskIsTooShortError}
           * @throws {StringMaskError}
           * @throws {MaskError}
           *
           * @returns {String} the masked string
           */

        }, {
          key: "string",
          value: function string(str, mask) {
            var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            return __WEBPACK_IMPORTED_MODULE_2__StringMask__["a"
            /* default */
            ].mask(str, mask, loose);
          }
        }]);

        return Types;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = Types;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)(module)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["Basis"]) global["Basis"] = {};
module.exports = global["Basis"]["InputMasking"] = __webpack_require__(45);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(15), __webpack_require__(16));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(15), __webpack_require__(16)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_7__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 1);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;
      /***/
    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextInput__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__NumberInput__ = __webpack_require__(5);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TextInput", function () {
        return __WEBPACK_IMPORTED_MODULE_0__TextInput__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberInput", function () {
        return __WEBPACK_IMPORTED_MODULE_1__NumberInput__["a"];
      });
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /***/

    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextInput__ = __webpack_require__(3);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TextInput__["a"
      /* default */
      ];
      /***/
    },
    /* 3 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__tools_js__ = __webpack_require__(4);

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * The `TextInput` will wrap text inputs and apply the given [bbj string mask](https://github.com/BasisHub/bbj-masks#string-masks)
       *
       * **Options**
       *
       * _Options can be passed via data attributes . For data attributes, append the option name to data-, as in data-mask_
       *
       * | Option    | Default | Description                                                                                             |
       * |-----------|---------|---------------------------------------------------------------------------------------------------------|
       * | mask |         | The bbj string mask @see [BBj String Masks](https://github.com/BasisHub/bbj-masks#string-masks) |
       *
       *  <br>
       *
       * **Example :**
       * ```html
       *  <input class="bbj-text-masked" name="test" id="test" value="ed23" data-mask="AA-00">
       *
       *  <script>
       *    document.addEventListener('DOMContentLoaded', function (e) {
       *      new Basis.InputMasking.TextInput({
       *         onUpdate: (maskedValue , rawValue , input) => {
       *            // do something
       *         },
       *         onInvalid: (err , input) => {
       *            // do something
       *         }
       *      })
       *    })
       *  </script>
       * ```
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TextInput = /*#__PURE__*/function () {
        /**
         * Construct new TextInput
         *
         * @param {?Object} options - The input options.
         * @param {HTMLElement|String} [options.elements=".bbj-text-masked"] - The class name or the node to use
         * @param {HTMLDocument} [options.document=document] - Document instance to use
         * @param {String} [options.cssClassError="bbj-mask-error"] - A css class to attach to the input when it is invalid
         * @param {String} [options.cssClassSuccess="bbj-mask-success"] - A css class to attach to the input when it is valid after the user interaction
         * @param {Function} [options.onUpdate=null] - A callback to be called on the new masked value is set
         * @param {Function} [options.onInvalid=null] - A callback to be called on the input or the mask is invalid
         */
        function TextInput() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, TextInput);

          this.options = _objectSpread({}, {
            elements: '.bbj-text-masked',
            doc: document,
            cssClassError: 'bbj-mask-error',
            cssClassSuccess: 'bbj-mask-success',
            onUpdate: null,
            onInvalid: null
          }, {}, options);
          this._onKeystroke = this._onKeystroke.bind(this);
          this._onFocus = this._onFocus.bind(this);
          this.refresh();
        }
        /**
         * Initialize the component and wrap the input elements for masking in case
         * they are not wrapped yet
         */


        _createClass(TextInput, [{
          key: "refresh",
          value: function refresh() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];

              if (input instanceof HTMLInputElement) {
                parentClass = input.parentNode.getAttribute('class');

                if (!input.getAttribute('id')) {
                  console.warn("BBjMasking: Input has no ID. Without an ID the input cannot be masked", input);
                  continue;
                } // we don't initialize the input's wrap twice


                var isWrapped = parentClass && parentClass.indexOf('textInputMask__wrap') > -1;

                this._wrap(input, isWrapped);
              } else {
                console.warn("BBjMasking: Invalid input element. The element will be ignored", input);
              }
            }
          }
          /**
           * Unwrap the input elements and remove attached listeners
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parent, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];
              parent = input.parentNode;
              parentClass = parent.getAttribute('class');

              if (parentClass && parentClass.indexOf('textInputMask__wrap') > -1) {
                this._unwrap(parent);
              }
            }
          }
          /**
           * Create the text masking input wrapper
           *
           * @param {HTMLInputElement} input the input element
           * @param {Boolean} isWrapped when true the input is already wrapped and we need to add what is
           *                            missing only
           *
           * @returns {HTMLSpanElement} the wrap element
           *
           * @protected
           */

        }, {
          key: "_wrap",
          value: function _wrap(input, isWrapped) {
            var inputId = input.getAttribute('id'),
                inputName = input.getAttribute('name'),
                mask = input.dataset.mask || '',
                originalPattern = input.pattern,
                defaultPattern = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["b"
            /* generatePatternFromMask */
            ])(mask),
                pattern = originalPattern || defaultPattern;
            var wrap = null,
                unmaskInput = null;

            if (!isWrapped) {
              wrap = this.options.doc.createElement('span');
              unmaskInput = this.options.doc.createElement('input'); // hidden input with the unmasked values for forms
            } else {
              wrap = input.parentNode;
              unmaskInput = wrap.querySelector('.textInputMask__unmaskedInput');
            } // configure the actual input
            // -----------------------------------------------------


            input.value = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["c"
            /* maskIfNotMasked */
            ])(input.value, mask);
            input.pattern = pattern;
            input.classList.add('textInputMask__textInput');
            input.dataset.mask = mask;
            input.dataset.valueUnmasked = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["d"
            /* unmask */
            ])(input.value, mask);

            if (originalPattern && originalPattern !== defaultPattern) {
              input.dataset.isCustomPattern = true;
            }

            if (!isWrapped) {
              if (!(input.hasAttribute('readonly') || input.hasAttribute('disable'))) {
                input.addEventListener('keyup', this._onKeystroke);
                input.addEventListener('keypress', this._onKeystroke);
                input.addEventListener('paste', this._onKeystroke);
                input.addEventListener('focusin', this._onFocus);
                input.addEventListener('click', this._onFocus);
              }

              input.parentNode.insertBefore(wrap, input); // move the input outside the wrapper
            }

            if (this._validateInput(input)) {
              this.__fireOnUpdate(input.value, input.dataset.valueUnmasked, input);
            } // configure the unmasked input
            // ----------------------------------------------------


            unmaskInput.setAttribute('aria-hidden', 'true');
            unmaskInput.setAttribute('type', 'hidden');
            unmaskInput.classList.add('textInputMask__unmaskedInput');
            unmaskInput.value = input.dataset.valueUnmasked;
            if (inputId) unmaskInput.setAttribute('id', "".concat(inputId, "-unmasked"));
            if (inputName) unmaskInput.setAttribute('name', "".concat(inputName, "-unmasked"));

            if (!isWrapped) {
              // configure the wrapper
              wrap.setAttribute('class', 'textInputMask__wrap');
              wrap.appendChild(unmaskInput);
              wrap.appendChild(input);
            }

            return wrap;
          }
          /**
           * Unwrap the masked input and remove the value changed listener
           *
           * @param {HTMLSpanElement} textInput the wrapper span instance
           *
           * @protected
           */

        }, {
          key: "_unwrap",
          value: function _unwrap(textInput) {
            textInput.removeChild(textInput.querySelector('.textInputMask__unmaskedInput'));
            var input = textInput.querySelector('.textInputMask__textInput');
            input.removeEventListener('keyup', this._onKeystroke);
            input.removeEventListener('keypress', this._onKeystroke);
            input.removeEventListener('paste', this._onKeystroke);
            input.removeEventListener('focusin', this._onFocus);
            input.removeEventListener('click', this._onFocus);
            delete input.dataset.valueUnmasked;

            if (!input.dataset.isCustomPattern) {
              input.removeAttribute('pattern');
              delete input.dataset.isCustomPattern;
            }

            input.classList.remove(this.options.cssClassError);
            textInput.parentNode.insertBefore(input, textInput);
            textInput.parentNode.removeChild(textInput);
          }
          /**
           * Listen to every keystroke on the input and update the masked and the unmasked value
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_onKeystroke",
          value: function _onKeystroke(e) {
            if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return;
            if (e.keyCode !== 13) e.preventDefault();
            var input = e.target,
                mask = input.dataset.mask || this.options.mask,
                eventType = e.type;
            input.classList.remove(this.options.cssClassError);
            input.classList.remove(this.options.cssClassSuccess);
            input.setCustomValidity('');
            var value = input.value,
                keyCode = e.keyCode,
                keyContent = e.key || e.code.replace(/[^0-9]/g, ''),
                key = keyContent ? keyContent.length > 1 ? '' : keyContent : '',
                insertPosition = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["a"
            /* findCaretPosition */
            ])(value, mask),
                newValue,
                unmaskedValue,
                maskError = false;

            switch (eventType) {
              case 'paste':
                newValue = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["c"
                /* maskIfNotMasked */
                ])((e.clipboardData || window.clipboardData).getData('Text'), mask);
                break;

              case 'keyup':
                newValue = value;
                break;

              case 'keypress':
                var selectionStart = input.selectionStart;
                if (selectionStart !== insertPosition) insertPosition = selectionStart;
                newValue = value.substr(0, insertPosition) + key + value.substr(insertPosition);
                break;

              default:
                break;
            }

            unmaskedValue = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["d"
            /* unmask */
            ])(newValue, mask);

            if ([35, 36, 37, 38, 39, 40].indexOf(keyCode) === -1) {
              try {
                input.value = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(unmaskedValue, mask, false);

                if (this._validateInput(input)) {
                  input.dataset.valueUnmasked = unmaskedValue;
                  this.options.doc.querySelector("#".concat(input.getAttribute('id'), "-unmasked")).value = unmaskedValue;

                  this.__applyCssClassState(input, 'success');

                  this.__fireOnUpdate(input.value, input.dataset.valueUnmasked, input);
                }

                maskError = false;
              } catch (error) {
                this.__applyCssClassState(input, 'error');

                this.__fireOnInvalid(error, input);

                maskError = true;
              }

              this._updateCaretPosition(input, mask);
            }

            if (!maskError) this._validateInput(input);
          }
          /**
           * Listen to focus events on the input and update the caret position
           * where the next char should be inserted according to the mask
           *
           * @param {FocusEvent} e
           *
           * @protected
           */

        }, {
          key: "_onFocus",
          value: function _onFocus(e) {
            var input = e.target;
            var mask = input.dataset.mask || this.options.mask;

            this._updateCaretPosition(input, mask);
          }
          /**
           * Update the caret position on the input based on the given mask
           *
           * @param {HTMLInputElement} input instance
           * @param {String} mask  bbj string
           *
           * @protected
           */

        }, {
          key: "_updateCaretPosition",
          value: function _updateCaretPosition(input, mask) {
            setTimeout(function () {
              var position = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["a"
              /* findCaretPosition */
              ])(input.value, mask);
              input.setSelectionRange(position, position);
            }, 0);
          }
          /**
           * Trigger `checkValidity` on the input
           *
           * @param {HTMLInputElement} input
           *
           * @returns {Boolean} true when valid , false otherwise
           *
           * @protected
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (isValid) {
              this.__applyCssClassState(input, 'success');

              input.setCustomValidity('');
            } else {
              this.__applyCssClassState(input, 'error');

              this.__fireOnInvalid(input.validationMessage, input);
            }

            return isValid;
          }
          /**
           * @private
           */

        }, {
          key: "__fireOnUpdate",
          value: function __fireOnUpdate(valueMasked, valueUnmasked, input) {
            if (this.options.onUpdate) {
              this.options.onUpdate(valueMasked, valueUnmasked, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__fireOnInvalid",
          value: function __fireOnInvalid(error, input) {
            if (this.options.onInvalid) {
              this.options.onInvalid(error, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__applyCssClassState",
          value: function __applyCssClassState(input, state) {
            if (input.hasAttribute('readonly') || input.hasAttribute('disabled')) {
              input.classList.remove(this.options.cssClassError);
              input.classList.remove(this.options.cssClassSuccess);
            } else {
              if (state === 'success') {
                input.classList.remove(this.options.cssClassError);
                input.classList.add(this.options.cssClassSuccess);
              }

              if (state === 'error') {
                input.classList.add(this.options.cssClassError);
                input.classList.remove(this.options.cssClassSuccess);
              }
            }
          }
        }]);

        return TextInput;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = TextInput;
      /***/
    },
    /* 4 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export isMaskedValue */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "c", function () {
        return maskIfNotMasked;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return unmask;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return findCaretPosition;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return generatePatternFromMask;
      });
      /* unused harmony export IS_UNICODE_PROPERTY_SUPPORTED */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var SUPPORTED_MASKS = ['X', 'a', 'A', '0', 'z', 'Z', 'U'];
      /**
       * When true , then the browser supports Unicode Property Escapes
       * otherwise it is false 
       * 
       * {@link https://github.com/tc39/proposal-regexp-unicode-property-escapes}
       */

      var IS_UNICODE_PROPERTY_SUPPORTED = false;

      try {
        eval('/\\p{L}/u');
        IS_UNICODE_PROPERTY_SUPPORTED = true;
      } catch (err) {
        IS_UNICODE_PROPERTY_SUPPORTED = false;
      }
      /**
       * Check if the given value is masked with the given mask or not
       *
       * @param {String} value masked or unmasked value
       * @param {String} mask  a bbj mask
       *
       * @return {Boolean} true when the value is masked with given mask , false otherwise
       */


      var isMaskedValue = function isMaskedValue(value, mask) {
        if (typeof isMaskedValue.__CACHE__ === 'undefined') {
          isMaskedValue.__CACHE__ = {};
        }

        var cacheKey = "".concat(value, "-").concat(mask);

        if (!isMaskedValue.__CACHE__[cacheKey]) {
          var unmaskedValue = unmask(value, mask);
          isMaskedValue.__CACHE__[cacheKey] = value === __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(unmaskedValue, mask);
        }

        return isMaskedValue.__CACHE__[cacheKey];
      };
      /**
       * Mask the given value with the given mask in case the value is not already masked with the
       * given mask
       *
       * @param {String} value masked or unmasked value
       * @param {String} mask  a bbj mask
       *
       * @return {String} a masked value
       */


      var maskIfNotMasked = function maskIfNotMasked(value, mask) {
        if (typeof maskIfNotMasked.__CACHE__ === 'undefined') {
          maskIfNotMasked.__CACHE__ = {};
        }

        var cacheKey = "".concat(value, "-").concat(mask);

        if (!maskIfNotMasked.__CACHE__[cacheKey]) {
          if (isMaskedValue(value, mask)) {
            maskIfNotMasked.__CACHE__[cacheKey] = value;
          } else {
            try {
              maskIfNotMasked.__CACHE__[cacheKey] = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(value, mask, false);
            } catch (e) {
              maskIfNotMasked.__CACHE__[cacheKey] = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask('', mask);
            }
          }
        }

        return maskIfNotMasked.__CACHE__[cacheKey];
      };
      /**
       * Generate a regex patter based on the give task
       *
       * @param {String} mask  bbj string mask
       *
       * @return {String} regex for the give mask
       */


      var generatePatternFromMask = function generatePatternFromMask(mask) {
        if (typeof generatePatternFromMask.__CACHE__ === 'undefined') {
          generatePatternFromMask.__CACHE__ = {};
        }

        var cacheKey = mask;

        if (!generatePatternFromMask.__CACHE__[cacheKey]) {
          var maskAsArry = mask.split('');
          var regex = '';
          maskAsArry.forEach(function (c) {
            switch (c) {
              case 'X':
                regex += '([^ -~])';
                break;

              case 'a':
              case 'A':
                // https://mothereff.in/regexpu#input=var+regex+%3D+/%5Cp%7BL%7D/u%3B&unicodePropertyEscape=1
                // https://stackoverflow.com/questions/150033/regular-expression-to-match-non-ascii-characters#answer-48902765
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '\\p{L}' : "((?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              case '0':
                regex += '([0-9])';
                break;

              case 'z':
              case 'Z':
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '([0-9]|\\p{L})' : "([0-9]|(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              case 'U':
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '(([0-9])|(\\s)|([.,/#!$%^&*;:{}=-_`~()])|(\\p{L}))' : "(([0-9])|(\\s)|([.,/#!$%^&*;:{}=-_`~()])|(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              default:
                regex += c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                break;
            }
          });
          generatePatternFromMask.__CACHE__[cacheKey] = regex;
        }

        return generatePatternFromMask.__CACHE__[cacheKey];
      };
      /**
       * Unmask the given value
       *
       * @param {String} maskedValue masked string
       * @param {String} mask  the used mask to produce the masked string
       */


      var unmask = function unmask(maskedValue, mask) {
        if (typeof unmask.__CACHE__ === 'undefined') {
          unmask.__CACHE__ = {};
        }

        var cacheKey = "".concat(maskedValue, "-").concat(mask);

        if (!unmask.__CACHE__[cacheKey]) {
          var maskAsArray = mask.split('');
          var maskedValueAsArray = maskedValue.split('');
          var unmasked = '';

          for (var index = 0; index < maskedValueAsArray.length; index++) {
            var el = maskedValueAsArray[index];
            var _mask = maskAsArray[index];
            var elHasMask = SUPPORTED_MASKS.indexOf(_mask) > -1;

            if (elHasMask) {
              var pattern = new RegExp(generatePatternFromMask(_mask), IS_UNICODE_PROPERTY_SUPPORTED ? 'u' : '');
              if (pattern.test(el)) unmasked += el;else break;
            }
          }

          unmask.__CACHE__[cacheKey] = unmasked.toLocaleLowerCase();
        }

        return unmask.__CACHE__[cacheKey];
      };
      /**
       * Given the masked string , find the next caret position depending on
       * what is missing to complete the mask
       *
       * @param {String} maskedValue masked string
       * @param {String} mask  the used mask to produce the masked string
       */


      var findCaretPosition = function findCaretPosition(maskedValue, mask) {
        if (typeof findCaretPosition.__CACHE__ === 'undefined') {
          findCaretPosition.__CACHE__ = {};
        }

        var cacheKey = "".concat(maskedValue, "-").concat(mask);

        if (!findCaretPosition.__CACHE__[cacheKey]) {
          var maskAsArray = mask.split('');
          var maskedValueAsArray = maskedValue.split('');

          if (maskedValueAsArray.length < maskAsArray.length) {
            maskedValueAsArray = maskedValueAsArray.concat(new Array(maskAsArray.length - maskedValueAsArray.length).join(' ').split(''));
          }

          var position = -1;

          for (var index = 0; index < maskAsArray.length; index++) {
            var el = maskAsArray[index];

            if (el !== maskedValueAsArray[index]) {
              // if (maskedValueAsArray[index] === ' ') return index
              if (SUPPORTED_MASKS.indexOf(el) > -1) {
                var pattern = new RegExp(generatePatternFromMask(el), IS_UNICODE_PROPERTY_SUPPORTED ? 'u' : '');

                if (!pattern.test(maskedValueAsArray[index])) {
                  position = index;
                  break;
                }
              }
            }
          }

          findCaretPosition.__CACHE__[cacheKey] = position < 0 ? maskedValueAsArray.length : position;
        }

        return findCaretPosition.__CACHE__[cacheKey];
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberInput__ = __webpack_require__(6);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberInput__["a"
      /* default */
      ];
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask__ = __webpack_require__(7);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask__);

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var countDecimals = function countDecimals(value) {
        if (value % 1 != 0) {
          var split = value.toString().split('.');
          if (split.length === 2) return split[1].length;
        }

        return 0;
      };
      /**
       * The `NumberInput` will wrap text inputs and apply the given [bbj Number mask](https://github.com/BasisHub/bbj-masks#number-masks)
       *
       * **Options**
       *
       * _Options can be passed via data attributes . For data attributes, append the option name to data-, as in data-mask_
       *
       * | Option    | Default | Description                                                                                             |
       * |-----------|---------|---------------------------------------------------------------------------------------------------------|
       * | mask |         | The bbj number mask @see [BBj Number Masks](https://github.com/BasisHub/bbj-masks#number-masks) |
       * | min |         | The maximum value to accept for this input|
       * | max |         | The minimum value to accept for this input|
       * | step |         | A stepping interval to use when using up and down arrows to adjust the value, as well as for validation|
       * |grouping-separator | , | a char which will be used as a grouping separator |
       * |decimal-separator | . | a char which will be used as a decimal separator |
       * |force-trailing-zeros | false | Affects the output by switching the way a mask with "#" characters in the trailing positions is filled. for example, the function NumberMask.mask(.10:"#.##") returns .10 instead of .1|
       *
       *  <br>
       *
       * **Example :**
       * ```html
       *  <input class="bbj-number-masked" name="test" id="test" value="1234" data-mask="##,##0">
       *
       *  <script>
       *    document.addEventListener('DOMContentLoaded', function (e) {
       *      new Basis.InputMasking.NumberInput({
       *
       *         // @param {String} valueMasked  masked value
       *         // @param {Number} valueUnmasked  original value
       *         // @param {HTMLInputElement} input the actual input instance
       *         onUpdate: (valueMasked, valueUnmasked, input, isApplied, isInitial) => {
       *            // do something
       *         },
       *
       *         // @param {String|Object} error last occurred error. could be mask error or validation error
       *         // @param {HTMLInputElement} input the actual input instance
       *         onInvalid: (err , input) => {
       *            // do something
       *         }
       *      })
       *    })
       *  </script>
       * ```
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberInput = /*#__PURE__*/function () {
        /**
         * Construct new NumberInput
         *
         * @param {?Object} options - The input options.
         * @param {HTMLElement|String} [options.elements=".bbj-number-masked"] - The class name or the node to use
         * @param {HTMLDocument} [options.document=document] - Document instance to use
         * @param {String} [options.cssClassError="bbj-mask-error"] - A css class to attach to the input when it is invalid
         * @param {String} [options.cssClassSuccess="bbj-mask-success"] - A css class to attach to the input when it is valid after the user interaction
         * @param {Function} [options.onUpdate=null] - A callback to be called on the new masked value is set
         * @param {Function} [options.onInvalid=null] - A callback to be called on the input or the mask is invalid
         */
        function NumberInput() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, NumberInput);

          this.options = _objectSpread({}, {
            elements: '.bbj-number-masked',
            doc: document,
            cssClassError: 'bbj-mask-error',
            cssClassSuccess: 'bbj-mask-success',
            onUpdate: null,
            onInvalid: null
          }, {}, options);
          this._actualInputHandler = this._actualInputHandler.bind(this);
          this._unmaskedInputHandler = this._unmaskedInputHandler.bind(this);
          this.refresh();
        }
        /**
         * Initialize the component and wrap the input elements for masking in case
         * they are not wrapped yet
         */


        _createClass(NumberInput, [{
          key: "refresh",
          value: function refresh() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];

              if (input instanceof HTMLInputElement) {
                parentClass = input.parentNode.getAttribute('class');

                if (!input.getAttribute('id')) {
                  console.warn("BBjMasking: Input has no ID. Without an ID the input cannot be masked", input);
                  continue;
                } // we don't initialize the input's wrap twice


                var isWrapped = parentClass && parentClass.indexOf('numberInputMask__wrap') > -1;

                this._wrap(input, isWrapped);
              } else {
                console.warn("BBjMasking: Invalid input element. The element will be ignored", input);
              }
            }
          }
          /**
           * Unwrap the input elements and remove attached listeners
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parent, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];
              parent = input.parentNode;
              parentClass = parent.getAttribute('class');

              if (parentClass && parentClass.indexOf('numberInputMask__wrap') > -1) {
                this._unwrap(parent);
              }
            }
          }
          /**
           * Create the number masking input wrapper
           *
           * @param {HTMLInputElement} actualInput the input element
           * @param {Boolean} isWrapped when true the input is already wrapped and we need to add what is
           *                            missing only
           *
           * @returns {HTMLSpanElement} wrapper instance
           *
           * @protected
           */

        }, {
          key: "_wrap",
          value: function _wrap(actualInput, isWrapped) {
            var actualInputId = actualInput.getAttribute('id'),
                actualInputName = actualInput.getAttribute('name'),
                actualInputStep = actualInput.dataset.step || null,
                actualInputMax = actualInput.dataset.max || null,
                actualInputMin = actualInput.dataset.min || null,
                actualInputGroupingSeparator = actualInput.dataset.groupingSeparator || ',',
                actualInputDecimalSeparator = actualInput.dataset.decimalSeparator || '.',
                actualInputForceTrailingZeros = actualInput.dataset.forceTrailingZeros || null,
                actualInputMask = actualInput.dataset.mask || '',
                actualInputClasses = actualInput.getAttribute('class'),
                actualInputRequired = actualInput.getAttribute('required') || null;
            var wrap = null,
                unmaskedInput = null;

            if (!isWrapped) {
              wrap = this.options.doc.createElement('span');
              unmaskedInput = this.options.doc.createElement('input'); // hidden input with the unmasked values for forms
            } else {
              wrap = actualInput.parentNode;
              unmaskedInput = wrap.querySelector('.numberInputMask__unmaskedInput');
            } // configure the actual input
            // -----------------------------------------------------


            if (!isWrapped) {
              actualInput.parentNode.insertBefore(wrap, actualInput); // move the input outside the wrapper

              if (!(actualInput.hasAttribute('readonly') || actualInput.hasAttribute('disabled'))) {
                actualInput.addEventListener('click', this._actualInputHandler);
                actualInput.addEventListener('focusin', this._actualInputHandler);
              }
            }

            actualInput.dataset.valueUnmasked = actualInput.value || 0;
            actualInput.dataset.groupingSeparator = actualInputGroupingSeparator;
            actualInput.dataset.decimalSeparator = actualInputDecimalSeparator;
            actualInput.dataset.forceTrailingZeros = actualInputForceTrailingZeros;
            actualInput.value = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default.a.mask(actualInput.dataset.valueUnmasked, actualInputMask, actualInputGroupingSeparator, actualInputDecimalSeparator, actualInputForceTrailingZeros).trim();
            actualInput.classList.add('numberInputMask__textInput', this.options.cssClassSuccess); // configure the unmasked input
            // ----------------------------------------------------

            unmaskedInput.value = actualInput.dataset.valueUnmasked;
            unmaskedInput.setAttribute('aria-hidden', 'true');
            unmaskedInput.setAttribute('type', 'hidden');
            unmaskedInput.setAttribute('class', actualInputClasses);
            if (actualInputId) unmaskedInput.setAttribute('id', "".concat(actualInputId, "-unmasked"));
            if (actualInputName) unmaskedInput.setAttribute('name', "".concat(actualInputName, "-unmasked"));
            if (actualInputRequired) unmaskedInput.setAttribute('required', 'required');
            if (actualInputStep) unmaskedInput.setAttribute('step', actualInputStep);else {
              var decimals = countDecimals(unmaskedInput.value);
              var step = '1';

              if (decimals > 0) {
                step = ".".concat(Array(decimals).join('0'), "1");
              }

              unmaskedInput.setAttribute('step', step);
            }
            if (actualInputMin) unmaskedInput.setAttribute('min', actualInputMin);
            if (actualInputMax) unmaskedInput.setAttribute('max', actualInputMax);
            unmaskedInput.dataset.inputId = actualInputId;
            unmaskedInput.dataset.mask = actualInputMask;
            unmaskedInput.dataset.groupingSeparator = actualInputGroupingSeparator;
            unmaskedInput.dataset.decimalSeparator = actualInputDecimalSeparator;
            if (actualInputForceTrailingZeros) unmaskedInput.dataset.forceTrailingZeros = actualInputForceTrailingZeros;

            if (!isWrapped) {
              unmaskedInput.classList.add('numberInputMask__unmaskedInput');
              unmaskedInput.addEventListener('keydown', this._unmaskedInputHandler);
              unmaskedInput.addEventListener('keyup', this._unmaskedInputHandler);
              unmaskedInput.addEventListener('focusout', this._unmaskedInputHandler); // configure the wrapper

              wrap.setAttribute('class', 'numberInputMask__wrap');
              wrap.appendChild(unmaskedInput);
              wrap.appendChild(actualInput);
            }

            if (!isNaN(Number(actualInput.dataset.valueUnmasked))) {
              if (this._validateInput(unmaskedInput, actualInput)) {
                this.__fireOnUpdate(actualInput.value, actualInput.dataset.valueUnmasked, actualInput);
              }
            } else {
              actualInput.classList.add(this.options.cssClassError);
            }

            return wrap;
          }
          /**
           * Unwrap the masked input and remove the value changed listener
           *
           * @param {HTMLSpanElement} wrapper the wrapper span instance
           *
           * @protected
           */

        }, {
          key: "_unwrap",
          value: function _unwrap(wrapper) {
            var actualInput = wrapper.querySelector('.numberInputMask__textInput'),
                actualInputId = actualInput.id,
                unmaskedInput = wrapper.querySelector("#".concat(actualInputId, "-unmasked"));
            unmaskedInput.removeEventListener('keyup', this._unmaskedInputHandler);
            unmaskedInput.removeEventListener('keypress', this._unmaskedInputHandler);
            unmaskedInput.removeEventListener('focusout', this._unmaskedInputHandler);
            wrapper.removeChild(unmaskedInput);
            actualInput.removeEventListener('click', this._actualInputHandler);
            actualInput.removeEventListener('focusin', this._actualInputHandler);
            actualInput.classList.remove('numberInputMask__textInput');
            actualInput.classList.remove(this.options.cssClassError);
            actualInput.classList.remove(this.options.cssClassSuccess);
            delete actualInput.dataset.valueUnmasked;
            wrapper.parentNode.insertBefore(actualInput, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
          /**
           * Listen to click and focusin event on the actual input and toggle the number input
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_actualInputHandler",
          value: function _actualInputHandler(e) {
            var actualInput = e.target,
                actualInputId = actualInput.id,
                unmaskedInput = this.options.doc.querySelector("#".concat(actualInputId, "-unmasked"));
            actualInput.setAttribute('aria-hidden', 'true');
            actualInput.setAttribute('type', 'hidden');
            unmaskedInput.removeAttribute('aria-hidden');
            unmaskedInput.setAttribute('type', 'number');

            this._validateInput(unmaskedInput, actualInput);

            setTimeout(function () {
              unmaskedInput.focus();
              var length = String(unmaskedInput.value).length;
              unmaskedInput.type = 'text';
              unmaskedInput.setSelectionRange(length, length);
              unmaskedInput.type = 'number';
            }, 0);
          }
          /**
           * Listen to the unmasked input keydown and focusout events and check
           * if the input value can be masked or not
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_unmaskedInputHandler",
          value: function _unmaskedInputHandler(e) {
            var unmaskedInput = e.target,
                keyCode = e.keyCode,
                mask = unmaskedInput.dataset.mask,
                groupingSeparator = unmaskedInput.dataset.groupingSeparator,
                decimalSeparator = unmaskedInput.dataset.decimalSeparator,
                forceTrailingZeros = unmaskedInput.dataset.forceTrailingZeros,
                actualInputId = unmaskedInput.dataset.inputId,
                actualInput = this.options.doc.querySelector("#".concat(actualInputId));

            var restore = false,
                apply = false,
                maskedValue = false,
                isValid = this._validateInput(unmaskedInput, actualInput);

            try {
              maskedValue = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default.a.mask(unmaskedInput.value || 0, mask, groupingSeparator, decimalSeparator, forceTrailingZeros, false).trim();
            } catch (e) {
              maskedValue = false;

              this.__applyCssClassState(unmaskedInput, actualInput, 'error');

              this.__fireOnInvalid(e, actualInput);
            }

            restore = [13, 27].indexOf(keyCode) > -1 || e.type === 'focusout';
            apply = maskedValue && isValid;

            if (restore) {
              unmaskedInput.classList.remove(this.options.cssClassError);
              unmaskedInput.classList.remove(this.options.cssClassSuccess);
              unmaskedInput.setAttribute('aria-hidden', 'true');
              unmaskedInput.setAttribute('type', 'hidden');
              actualInput.removeAttribute('aria-hidden');
              actualInput.setAttribute('type', 'text');
              actualInput.classList.add(this.options.cssClassSuccess);

              if (apply) {
                actualInput.value = maskedValue;
                actualInput.dataset.valueUnmasked = unmaskedInput.value;

                this.__fireOnUpdate(maskedValue, unmaskedInput.value, actualInput);
              } else {
                unmaskedInput.value = actualInput.dataset.valueUnmasked;

                this.__applyCssClassState(unmaskedInput, actualInput, 'success');
              }
            }
          }
          /**
           * Trigger `checkValidity` on the input
           *
           * @param {HTMLInputElement} unmaskedInput
           * @param {HTMLInputElement} actualInput
           *
           * @returns {Boolean} true when valid , false otherwise
           *
           * @protected
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(unmaskedInput, actualInput) {
            var isValid = true;
            var value = Number(unmaskedInput.value);

            if (unmaskedInput.getAttribute('type') === 'hidden' && !isNaN(value)) {
              var max = unmaskedInput.getAttribute('max');
              var min = unmaskedInput.getAttribute('min');
              var step = unmaskedInput.getAttribute('step');
              if (min) isValid = isValid && value >= Number(min);
              if (max) isValid = isValid && value <= Number(max);
              if (step) isValid = isValid && countDecimals(step) === countDecimals(unmaskedInput.value);
            } else isValid = unmaskedInput.checkValidity();

            if (isValid) {
              this.__applyCssClassState(unmaskedInput, actualInput, 'success');
            } else {
              this.__applyCssClassState(unmaskedInput, actualInput, 'error');

              this.__fireOnInvalid(unmaskedInput.validationMessage || 'Validity check fails', actualInput);
            }

            return isValid;
          }
          /**
           * @param {String} valueMasked  masked value
           * @param {Number} valueUnmasked  original value
           * @param {HTMLInputElement} input the actual input instance
           *
           * @private
           */

        }, {
          key: "__fireOnUpdate",
          value: function __fireOnUpdate(valueMasked, valueUnmasked, input) {
            if (this.options.onUpdate) {
              this.options.onUpdate(valueMasked, valueUnmasked, input);
            }
          }
          /**
           * @param {String|Object} error last occurred error. could be mask error or validation error
           * @param {HTMLInputElement} input the actual input instance
           *
           * @private
           */

        }, {
          key: "__fireOnInvalid",
          value: function __fireOnInvalid(error, input) {
            if (this.options.onInvalid) {
              this.options.onInvalid(error, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__applyCssClassState",
          value: function __applyCssClassState(unmaskedInput, actualInput, state) {
            if (actualInput.hasAttribute('readonly') || actualInput.hasAttribute('disabled')) {
              actualInput.classList.remove(this.options.cssClassError);
              actualInput.classList.remove(this.options.cssClassSuccess);
              unmaskedInput.classList.remove(this.options.cssClassError);
              unmaskedInput.classList.remove(this.options.cssClassSuccess);
            } else {
              if (state === 'success') {
                actualInput.classList.remove(this.options.cssClassError);
                actualInput.classList.add(this.options.cssClassSuccess);
                unmaskedInput.classList.remove(this.options.cssClassError);
                unmaskedInput.classList.add(this.options.cssClassSuccess);
              }

              if (state === 'error') {
                actualInput.classList.add(this.options.cssClassError);
                actualInput.classList.remove(this.options.cssClassSuccess);
                unmaskedInput.classList.add(this.options.cssClassError);
                unmaskedInput.classList.remove(this.options.cssClassSuccess);
              }
            }
          }
        }]);

        return NumberInput;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = NumberInput;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)(module)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var isNumberRegex = /^\d+$/;
var isWhitespaceRegex = /\s/;
var punctuationList = '!"#$%&\'()*+,-./:;<=>?@[]^_`{|}~';
/**
 * Check if the given string is in lower case
 *
 * @param {String} str
 */

var isLowerCase = function isLowerCase(str) {
  return str == str.toLowerCase() && str != str.toUpperCase();
};
/**
 * Check if the given string is in upper case
 *
 * @param {String} str
 */


var isUpperCase = function isUpperCase(str) {
  return str == str.toUpperCase() && str != str.toLowerCase();
};

var passOrThrowError = function passOrThrowError(loose, ret, i, str) {
  if (!loose) {
    var char = str.charAt(i);
    var pos = i + 1;
    throw {
      name: 'StringMaskError',
      message: "StringMaskError: error applying mask at position \"".concat(pos, "\" , char \"").concat(char, "\""),
      pos: pos,
      char: char
    };
  } else ret[i] = ' ';
};
/**
 * NumberMask
 *
 * A javascript implementation for BBj numbers masking
 *
 * @author Hyyan Abo Fakher <habofakher@basis.com>
 */


var StringMask = /*#__PURE__*/function () {
  function StringMask() {
    _classCallCheck(this, StringMask);
  }

  _createClass(StringMask, null, [{
    key: "mask",

    /**
     * Mask the given string with the given mask according to BBj rules
     *
     * @param {String} str the string to mask
     * @param {String} mask the mask to use for formatting
     * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
     *                anyway , otherwise it will stop at first error and throw it.
     * 
     * @throws {MaskIsTooShortError}
     * @throws {StringMaskError}
     * @throws {MaskError}
     * 
     * @returns {String} the masked string
     */
    value: function mask(str, _mask) {
      var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      str = String(str);
      _mask = String(_mask);
      var maskLen = _mask.length;
      var strLen = str.length;

      if (strLen > maskLen) {
        if (loose) return str; // friendly silent fail
        else throw {
            name: 'MaskIsTooShortError',
            message: "MaskIsTooShortError: Mask is shorter than the passed string"
          };
      }

      var ret = new Array(maskLen);
      var pos = 0; // to keep track of the current position in the str

      var maskByte = '';

      for (var i = 0; i < maskLen; i++) {
        maskByte = _mask.charAt(i);

        switch (maskByte) {
          case 'X':
            // match any character
            ret[i] = pos < strLen ? str.charAt(pos) : ' ';
            ++pos;
            break;

          case 'A':
            // match letter; force upper case
            if (pos < strLen) {
              var byte = str.charAt(pos);
              if (isUpperCase(byte)) ret[i] = byte;else if (isLowerCase(byte)) ret[i] = byte.toUpperCase();else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'a':
            // match letter
            if (pos < strLen) {
              var _byte = str.charAt(pos);

              if (isUpperCase(_byte) || isLowerCase(_byte)) ret[i] = _byte;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case '0':
            // match digit
            if (pos < strLen) {
              var _byte2 = str.charAt(pos);

              if (isNumberRegex.test(_byte2)) ret[i] = _byte2;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'Z':
            // match letter or digit; force upper case
            if (pos < strLen) {
              var _byte3 = str.charAt(pos);

              if (isUpperCase(_byte3) || isNumberRegex.test(_byte3)) ret[i] = _byte3;else if (isLowerCase(_byte3)) ret[i] = _byte3.toUpperCase();else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'z':
            // match letter or digit
            if (pos < strLen) {
              var _byte4 = str.charAt(pos);

              if (isUpperCase(_byte4) || isLowerCase(_byte4) || isNumberRegex.test(_byte4)) ret[i] = _byte4;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;
            break;

          case 'U':
            // match letter (force upper case), digit, whitespace or punctuation.
            if (pos < strLen) {
              var _byte5 = str.charAt(pos);

              if (isLowerCase(_byte5)) ret[i] = _byte5.toUpperCase();else if (isUpperCase(_byte5) || isNumberRegex.test(_byte5) || isWhitespaceRegex.test(_byte5) || punctuationList.indexOf(_byte5) > -1) ret[i] = _byte5;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          default:
            ret[i] = maskByte;
            break;
        }
      }

      if (pos < strLen) {
        if (!loose) {
          throw {
            name: 'MaskError',
            message: 'Mask cannot be applied'
          };
        }
      }

      return ret.join('');
    }
  }]);

  return StringMask;
}();

var _default = StringMask;
exports.default = _default;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * NumberMask
 *
 * A javascript implementation for BBj numbers masking
 *
 * @author Hyyan Abo Fakher <habofakher@basis.com>
 */
var NumberMask = /*#__PURE__*/function () {
  function NumberMask() {
    _classCallCheck(this, NumberMask);
  }

  _createClass(NumberMask, null, [{
    key: "mask",

    /**
     * Mask the given number with the given mask according to BBj rules
     *
     * @param {Number} number the number to format
     * @param {String} mask the mask to use for formatting
     * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
     * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
     * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
     *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
     * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
     *                anyway , otherwise it will stop at first error and throw it.
     * 
     * @throws {MaskError} only if loose is disabled
     * 
     * @returns {String} the masked number
     */
    value: function mask(number, _mask) {
      var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
      var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
      var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var maskLen = _mask.length;

      if (0 === maskLen) {
        if (loose) return str; // friendly silent fail
        else throw {
            name: 'MaskError',
            message: "MaskError: Mask is empty"
          };
      } // Get magnitude and precision of MASK


      var maskBeforeDecimal = 0;
      var maskAfterDecimal = 0;
      var foundDecimal = false;

      for (var i = 0; i < maskLen; ++i) {
        var m = _mask.charAt(i);

        if (m == '0' || m == '#') {
          if (foundDecimal) ++maskAfterDecimal;else ++maskBeforeDecimal;
        } else if (m == '.') foundDecimal = true;
      }

      var num = NumberMask._round(number, maskAfterDecimal);

      var bytes = NumberMask._toCharArray(num); // Get magnitude and precision of NUMBER


      var inLen = bytes.length;
      var numBeforeDecimal = 0;
      var numAfterDecimal = 0;
      foundDecimal = false;

      for (var _i = 0; _i < inLen; ++_i) {
        if (bytes[_i] == '.') foundDecimal = true;else {
          if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
        }
      } // always ignore mask overflow


      if (numBeforeDecimal > maskBeforeDecimal) {
        if (loose) return number.toString(); // friendly silent fail
        else throw {
            name: 'MaskError',
            message: "MaskError: Number is too large for mask"
          };
      } // round if mask is for a lower precision number


      if (numAfterDecimal > maskAfterDecimal) {
        num = NumberMask._round(num, maskAfterDecimal);
        bytes = NumberMask._toCharArray(num);
        inLen = bytes.length; // Get new magnitude and precision of NUMBER

        numBeforeDecimal = 0;
        numAfterDecimal = 0;
        foundDecimal = false;

        for (var _i2 = 0; _i2 < inLen; ++_i2) {
          if (bytes[_i2] == '.') foundDecimal = true;else {
            if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
          }
        } // always ignore mask overflow


        if (numBeforeDecimal > maskBeforeDecimal) {
          if (loose) return number.toString(); // friendly silent fail
          else throw {
              name: 'MaskError',
              message: "MaskError: Number is too large for mask"
            };
        }
      }

      var fillByte = ' ',
          floatByte = ' ';
      var inPos = 0,
          outPos = 0,
          floatPos = 0;
      if (_mask.charAt(0) == '*') fillByte = '*';
      var fillInit = fillByte;
      var isNegative = NumberMask._getSign(num) < 0;
      var emitDecimal = inLen > 0 || _mask.indexOf('0') >= 0;
      var foundZero = false;
      var foundDigit = false;
      var currency = false;
      foundDecimal = false;
      var ret = new Array(maskLen);

      for (var maskPos = 0; maskPos < maskLen; ++maskPos) {
        var _m = _mask.charAt(maskPos);

        switch (_m) {
          case '0':
            --maskBeforeDecimal;

            if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
              ret[outPos] = bytes[inPos];
              ++inPos;
              foundDigit = true;
            } else {
              ret[outPos] = '0';
              foundZero = true;
            }

            ++outPos;
            break;

          case '#':
            --maskBeforeDecimal;

            if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
              ret[outPos] = bytes[inPos];
              ++inPos;
              foundDigit = true;
            } else {
              ret[outPos] = foundDecimal && forceTrailingZeros && NumberMask._getSign(num) != 0 ? '0' : fillByte;
              if (!foundDecimal) floatPos = maskPos;
            }

            ++outPos;
            break;

          case ',':
            if (foundZero || inPos > 0) ret[outPos] = groupingSeparator;else {
              ret[outPos] = fillByte;
              if (!foundDecimal) floatPos = maskPos;
            }
            ++outPos;
            break;

          case '-':
            if (!foundDigit && floatByte == ' ') {
              if (isNegative) floatByte = '-';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else ret[outPos] = isNegative ? '-' : fillByte;

            ++outPos;
            break;

          case '+':
            if (!foundDigit && floatByte == ' ') {
              floatByte = isNegative ? '-' : '+';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else ret[outPos] = isNegative ? '-' : '+';

            ++outPos;
            break;

          case '$':
            if (!foundDigit && floatByte == ' ') {
              floatByte = '$';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else {
              ret[outPos] = '$';
            }

            ++outPos;
            break;
          // case '&':
          //   currency = true
          //   if (!foundDigit && floatByte == ' ') {
          //     floatByte = '&'
          //     ret[outPos] = fillByte
          //     floatPos = foundDecimal ? -1 : maskPos
          //   } else {
          //     ret[outPos] = '&'
          //   }
          //   ++outPos
          //   break
          // case '@':
          //   currency = true
          //   if (!foundDigit && floatByte == ' ') {
          //     floatByte = '@'
          //     ret[outPos] = fillByte
          //     floatPos = foundDecimal ? -1 : maskPos
          //   } else {
          //     ret[outPos] = '@'
          //   }
          //   ++outPos
          //   break

          case '(':
            if (!foundDigit && floatByte == ' ') {
              if (isNegative) floatByte = '(';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else {
              if (isNegative) {
                ret[outPos] = '(';
              } else {
                ret[outPos] = foundDecimal ? ' ' : fillByte;
              }
            }

            ++outPos;
            break;

          case ')':
            if (isNegative) {
              ret[outPos] = ')';
            } else {
              ret[outPos] = foundDecimal ? ' ' : fillByte;
            }

            ++outPos;
            break;

          case 'C':
            if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
              if (isNegative) {
                ret[outPos] = 'C';
                ret[outPos + 1] = 'R';
              } else {
                ret[outPos] = ' ';
                ret[outPos + 1] = ' ';
              }

              outPos += 2;
              ++maskPos;
            } else {
              ret[outPos] = 'C';
              ++outPos;
            }

            break;

          case 'D':
            if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
              if (isNegative) {
                ret[outPos] = 'C';
                ret[outPos + 1] = 'R';
              } else {
                ret[outPos] = 'D';
                ret[outPos + 1] = 'R';
              }

              outPos += 2;
              ++maskPos;
            } else {
              ret[outPos] = 'D';
              ++outPos;
            }

            break;

          case '*':
            ret[outPos] = '*';
            ++outPos;
            break;

          case '.':
            ret[outPos] = emitDecimal ? decimalSeparator : fillByte;
            fillByte = ' ';
            foundDecimal = true;
            ++inPos;
            ++outPos;
            break;

          case 'B':
            ret[outPos] = ' ';
            ++outPos;
            break;

          default:
            ret[outPos] = _m;
            ++outPos;
            break;
        }
      }

      if (floatByte != ' ') {
        if (floatPos < 0) floatPos = outPos;

        while (floatPos >= maskLen) {
          --floatPos;
        }

        if (ret[floatPos] == fillInit) ret[floatPos] = floatByte;
      }

      return ret.join('');
    }
  }, {
    key: "_shift",
    value: function _shift(number, precision, reverseShift) {
      if (reverseShift) precision = -precision;
      var numArray = ('' + number).split('e');
      return +(numArray[0] + 'e' + (numArray[1] ? +numArray[1] + precision : precision));
    }
  }, {
    key: "_round",
    value: function _round(number, precision) {
      return NumberMask._shift(Math.round(NumberMask._shift(number, precision, false)), precision, true);
    }
  }, {
    key: "_toCharArray",
    value: function _toCharArray(number) {
      var signum = NumberMask._getSign(number);

      var chars = [];

      if (signum !== 0) {
        var string = signum < 0 ? "".concat(-1 * number.toString()) : number.toString();
        if (string.length > 1 && string.charAt(0) == '0') string = string.substring(1); // The string contains only [0-9] and '.'

        chars = string.split('');
      }

      return chars;
    }
    /**
     * Returns the sign of a number
     *
     * @param {Number} x number
     * @returns {Number} A number representing the sign of the given argument.
     *                   If the argument is a positive number, negative number, positive zero
     *                   or negative zero, the function will return 1, -1, 0 or -0 respectively.
     *                   Otherwise, NaN is returned.
     */

  }, {
    key: "_getSign",
    value: function _getSign(x) {
      return (x > 0) - (x < 0) || +x;
    }
  }]);

  return NumberMask;
}();

var _default = NumberMask;
exports.default = _default;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["flatpickr"] = __webpack_require__(49);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* flatpickr v4.6.6, @license MIT */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function () {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }

  var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
  var defaults = {
    _disable: [],
    _enable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enable: [],
    enableSeconds: false,
    enableTime: false,
    errorHandler: function errorHandler(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function getWeek(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.

      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.

      var week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.

      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: undefined,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    months: {
      shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function ordinal(nth) {
      var s = nth % 100;
      if (s > 3 && s < 21) return "th";

      switch (s % 10) {
        case 1:
          return "st";

        case 2:
          return "nd";

        case 3:
          return "rd";

        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };

  var pad = function pad(number, length) {
    if (length === void 0) {
      length = 2;
    }

    return ("000" + number).slice(length * -1);
  };

  var int = function int(bool) {
    return bool === true ? 1 : 0;
  };
  /* istanbul ignore next */


  function debounce(func, wait, immediate) {
    if (immediate === void 0) {
      immediate = false;
    }

    var timeout;
    return function () {
      var context = this,
          args = arguments;
      timeout !== null && clearTimeout(timeout);
      timeout = window.setTimeout(function () {
        timeout = null;
        if (!immediate) func.apply(context, args);
      }, wait);
      if (immediate && !timeout) func.apply(context, args);
    };
  }

  var arrayify = function arrayify(obj) {
    return obj instanceof Array ? obj : [obj];
  };

  function toggleClass(elem, className, bool) {
    if (bool === true) return elem.classList.add(className);
    elem.classList.remove(className);
  }

  function createElement(tag, className, content) {
    var e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== undefined) e.textContent = content;
    return e;
  }

  function clearNode(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function findParent(node, condition) {
    if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
    return undefined; // nothing found
  }

  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"),
        numInput = createElement("input", "numInput " + inputClassName),
        arrowUp = createElement("span", "arrowUp"),
        arrowDown = createElement("span", "arrowDown");

    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }

    if (opts !== undefined) for (var key in opts) {
      numInput.setAttribute(key, opts[key]);
    }
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }

  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }

      return event.target;
    } catch (error) {
      return event.target;
    }
  }

  var doNothing = function doNothing() {
    return undefined;
  };

  var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  };

  var revFormat = {
    D: doNothing,
    F: function F(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function G(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    H: function H(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function J(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function K(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function M(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function S(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function U(_, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1000);
    },
    W: function W(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function Y(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function Z(_, ISODate) {
      return new Date(ISODate);
    },
    d: function d(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function h(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    i: function i(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function j(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function m(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function n(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function s(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function u(_, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function y(dateObj, year) {
      dateObj.setFullYear(2000 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "(\\w+)",
    F: "(\\w+)",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "(\\w+)",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "(\\w+)",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    // get the date in UTC
    Z: function Z(date) {
      return date.toISOString();
    },
    // weekday name, short, e.g. Thu
    D: function D(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    // full month name e.g. January
    F: function F(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    // padded hour 1-12
    G: function G(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    // hours with leading zero e.g. 03
    H: function H(date) {
      return pad(date.getHours());
    },
    // day (1-30) with ordinal suffix e.g. 1st, 2nd
    J: function J(date, locale) {
      return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    // AM/PM
    K: function K(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    // shorthand month e.g. Jan, Sep, Oct, etc
    M: function M(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    // seconds 00-59
    S: function S(date) {
      return pad(date.getSeconds());
    },
    // unix timestamp
    U: function U(date) {
      return date.getTime() / 1000;
    },
    W: function W(date, _, options) {
      return options.getWeek(date);
    },
    // full year e.g. 2016, padded (0001-9999)
    Y: function Y(date) {
      return pad(date.getFullYear(), 4);
    },
    // day in month, padded (01-30)
    d: function d(date) {
      return pad(date.getDate());
    },
    // hour from 1-12 (am/pm)
    h: function h(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    // minutes, padded with leading zero e.g. 09
    i: function i(date) {
      return pad(date.getMinutes());
    },
    // day in month (1-30)
    j: function j(date) {
      return date.getDate();
    },
    // weekday name, full, e.g. Thursday
    l: function l(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    // padded month number (01-12)
    m: function m(date) {
      return pad(date.getMonth() + 1);
    },
    // the month number (1-12)
    n: function n(date) {
      return date.getMonth() + 1;
    },
    // seconds 0-59
    s: function s(date) {
      return date.getSeconds();
    },
    // Unix Milliseconds
    u: function u(date) {
      return date.getTime();
    },
    // number of the day of the week
    w: function w(date) {
      return date.getDay();
    },
    // last two digits of year e.g. 16 for 2016
    y: function y(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  var createDateFormatter = function createDateFormatter(_a) {
    var _b = _a.config,
        config = _b === void 0 ? defaults : _b,
        _c = _a.l10n,
        l10n = _c === void 0 ? english : _c,
        _d = _a.isMobile,
        isMobile = _d === void 0 ? false : _d;
    return function (dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;

      if (config.formatDate !== undefined && !isMobile) {
        return config.formatDate(dateObj, frmt, locale);
      }

      return frmt.split("").map(function (c, i, arr) {
        return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
      }).join("");
    };
  };

  var createDateParser = function createDateParser(_a) {
    var _b = _a.config,
        config = _b === void 0 ? defaults : _b,
        _c = _a.l10n,
        l10n = _c === void 0 ? english : _c;
    return function (date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date) return undefined;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined // timestamp
      ) // create a copy
        parsedDate = new Date(date);else if (typeof date === "string") {
        // date string
        var format = givenFormat || (config || defaults).dateFormat;
        var datestr = String(date).trim();

        if (datestr === "today") {
          parsedDate = new Date();
          timeless = true;
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr) // datestrings w/ timezone
        ) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {
          parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
          var matched = void 0,
              ops = [];

          for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
            var token_1 = format[i];
            var isBackSlash = token_1 === "\\";
            var escaped = format[i - 1] === "\\" || isBackSlash;

            if (tokenRegex[token_1] && !escaped) {
              regexStr += tokenRegex[token_1];
              var match = new RegExp(regexStr).exec(date);

              if (match && (matched = true)) {
                ops[token_1 !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token_1],
                  val: match[++matchIndex]
                });
              }
            } else if (!isBackSlash) regexStr += "."; // don't really care


            ops.forEach(function (_a) {
              var fn = _a.fn,
                  val = _a.val;
              return parsedDate = fn(parsedDate, val, locale) || parsedDate;
            });
          }

          parsedDate = matched ? parsedDate : undefined;
        }
      }
      /* istanbul ignore next */

      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return undefined;
      }

      if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  };
  /**
   * Compute the difference in dates, measured in ms
   */


  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }

    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }

    return date1.getTime() - date2.getTime();
  }

  var isBetween = function isBetween(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };

  var duration = {
    DAY: 86400000
  };

  if (typeof Object.assign !== "function") {
    Object.assign = function (target) {
      var args = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }

      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }

      var _loop_1 = function _loop_1(source) {
        if (source) {
          Object.keys(source).forEach(function (key) {
            return target[key] = source[key];
          });
        }
      };

      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];

        _loop_1(source);
      }

      return target;
    };
  }

  var DEBOUNCED_CHANGE_MS = 300;

  function FlatpickrInstance(element, instanceConfig) {
    var self = {
      config: _assign(_assign({}, defaults), flatpickr.defaultConfig),
      l10n: english
    };
    self.parseDate = createDateParser({
      config: self.config,
      l10n: self.l10n
    });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear;
    self.close = close;
    self._createElement = createElement;
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.open = open;
    self.redraw = redraw;
    self.set = set;
    self.setDate = setDate;
    self.toggle = toggle;

    function setupHelperFunctions() {
      self.utils = {
        getDaysInMonth: function getDaysInMonth(month, yr) {
          if (month === void 0) {
            month = self.currentMonth;
          }

          if (yr === void 0) {
            yr = self.currentYear;
          }

          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
          return self.l10n.daysInMonth[month];
        }
      };
    }

    function init() {
      self.element = self.input = element;
      self.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self.isMobile) build();
      bindEvents();

      if (self.selectedDates.length || self.config.noCalendar) {
        if (self.config.enableTime) {
          setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);
        }

        updateValue(false);
      }

      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      /* TODO: investigate this further
                 Currently, there is weird positioning behavior in safari causing pages
        to scroll up. https://github.com/chmln/flatpickr/issues/563
                 However, most browsers are not Safari and positioning is expensive when used
        in scale. https://github.com/chmln/flatpickr/issues/1096
      */

      if (!self.isMobile && isSafari) {
        positionCalendar();
      }

      triggerEvent("onReady");
    }

    function bindToInstance(fn) {
      return fn.bind(self);
    }

    function setCalendarWidth() {
      var config = self.config;

      if (config.weekNumbers === false && config.showMonths === 1) {
        return;
      } else if (config.noCalendar !== true) {
        window.requestAnimationFrame(function () {
          if (self.calendarContainer !== undefined) {
            self.calendarContainer.style.visibility = "hidden";
            self.calendarContainer.style.display = "block";
          }

          if (self.daysContainer !== undefined) {
            var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
            self.daysContainer.style.width = daysWidth + "px";
            self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
            self.calendarContainer.style.removeProperty("visibility");
            self.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    /**
     * The handler for all events targeting the time inputs
     */


    function updateTime(e) {
      if (self.selectedDates.length === 0) {
        var defaultDate = self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date();

        var _a = getDefaultHours(),
            hours = _a.hours,
            minutes = _a.minutes,
            seconds = _a.seconds;

        defaultDate.setHours(hours, minutes, seconds, 0);
        self.setDate(defaultDate, false);
      }

      if (e !== undefined && e.type !== "blur") {
        timeWrapper(e);
      }

      var prevValue = self._input.value;
      setHoursFromInputs();
      updateValue();

      if (self._input.value !== prevValue) {
        self._debouncedChange();
      }
    }

    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
    }

    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;

        default:
          return hour % 12;
      }
    }
    /**
     * Syncs the selected date object time with user's time input
     */


    function setHoursFromInputs() {
      if (self.hourElement === undefined || self.minuteElement === undefined) return;
      var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
          minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
          seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

      if (self.amPM !== undefined) {
        hours = ampm2military(hours, self.amPM.textContent);
      }

      var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
      var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;

      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }

      if (limitMinHours) {
        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }

      setHours(hours, minutes, seconds);
    }
    /**
     * Syncs time input values with a date
     */


    function setHoursFromDate(dateObj) {
      var date = dateObj || self.latestSelectedDateObj;

      if (date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }

    function getDefaultHours() {
      var hours = self.config.defaultHour;
      var minutes = self.config.defaultMinute;
      var seconds = self.config.defaultSeconds;

      if (self.config.minDate !== undefined) {
        var minHr = self.config.minDate.getHours();
        var minMinutes = self.config.minDate.getMinutes();
        hours = Math.max(hours, minHr);
        if (hours === minHr) minutes = Math.max(minMinutes, minutes);
        if (hours === minHr && minutes === minMinutes) seconds = self.config.minDate.getSeconds();
      }

      if (self.config.maxDate !== undefined) {
        var maxHr = self.config.maxDate.getHours();
        var maxMinutes = self.config.maxDate.getMinutes();
        hours = Math.min(hours, maxHr);
        if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
        if (hours === maxHr && minutes === maxMinutes) seconds = self.config.maxDate.getSeconds();
      }

      return {
        hours: hours,
        minutes: minutes,
        seconds: seconds
      };
    }
    /**
     * Sets the hours, minutes, and optionally seconds
     * of the latest selected date object and the
     * corresponding time inputs
     * @param {Number} hours the hour. whether its military
     *                 or am-pm gets inferred from config
     * @param {Number} minutes the minutes
     * @param {Number} seconds the seconds (optional)
     */


    function setHours(hours, minutes, seconds) {
      if (self.latestSelectedDateObj !== undefined) {
        self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }

      if (!self.hourElement || !self.minuteElement || self.isMobile) return;
      self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self.minuteElement.value = pad(minutes);
      if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
      if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
    }
    /**
     * Handles the year input and incrementing events
     * @param {Event} event the keyup or increment event
     */


    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);

      if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    /**
     * Essentially addEventListener + tracking
     * @param {Element} element the element to addEventListener to
     * @param {String} event the event name
     * @param {Function} handler the event handler
     */


    function bind(element, event, handler, options) {
      if (event instanceof Array) return event.forEach(function (ev) {
        return bind(element, ev, handler, options);
      });
      if (element instanceof Array) return element.forEach(function (el) {
        return bind(el, event, handler, options);
      });
      element.addEventListener(event, handler, options);

      self._handlers.push({
        element: element,
        event: event,
        handler: handler,
        options: options
      });
    }

    function triggerChange() {
      triggerEvent("onChange");
    }
    /**
     * Adds all the necessary event listeners
     */


    function bindEvents() {
      if (self.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function (evt) {
          Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
            return bind(el, "click", self[evt]);
          });
        });
      }

      if (self.isMobile) {
        setupMobile();
        return;
      }

      var debouncedResize = debounce(onResize, 50);
      self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
        if (self.config.mode === "range") onMouseOver(getEventTarget(e));
      });
      bind(window.document.body, "keydown", onKeyDown);
      if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "click", documentClick);
      bind(window.document, "focus", documentClick, {
        capture: true
      });

      if (self.config.clickOpens === true) {
        bind(self._input, "focus", self.open);
        bind(self._input, "click", self.open);
      }

      if (self.daysContainer !== undefined) {
        bind(self.monthNav, "click", onMonthNavClick);
        bind(self.monthNav, ["keyup", "increment"], onYearInput);
        bind(self.daysContainer, "click", selectDate);
      }

      if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
        var selText = function selText(e) {
          return getEventTarget(e).select();
        };

        bind(self.timeContainer, ["increment"], updateTime);
        bind(self.timeContainer, "blur", updateTime, {
          capture: true
        });
        bind(self.timeContainer, "click", timeIncrement);
        bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
        if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
          return self.secondElement && self.secondElement.select();
        });

        if (self.amPM !== undefined) {
          bind(self.amPM, "click", function (e) {
            updateTime(e);
            triggerChange();
          });
        }
      }

      if (self.config.allowInput) bind(self._input, "blur", onBlur);
    }
    /**
     * Set the calendar view to a particular date.
     * @param {Date} jumpDate the date to set the view to
     * @param {boolean} triggerChange if change events should be triggered
     */


    function jumpToDate(jumpDate, triggerChange) {
      var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
      var oldYear = self.currentYear;
      var oldMonth = self.currentMonth;

      try {
        if (jumpTo !== undefined) {
          self.currentYear = jumpTo.getFullYear();
          self.currentMonth = jumpTo.getMonth();
        }
      } catch (e) {
        /* istanbul ignore next */
        e.message = "Invalid date supplied: " + jumpTo;
        self.config.errorHandler(e);
      }

      if (triggerChange && self.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }

      if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }

      self.redraw();
    }
    /**
     * The up/down arrow handler for time inputs
     * @param {Event} e the click event
     */


    function timeIncrement(e) {
      var eventTarget = getEventTarget(e);
      if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    /**
     * Increments/decrements the value of input associ-
     * ated with the up/down arrow by dispatching an
     * "increment" event on the input.
     *
     * @param {Event} e the click event
     * @param {Number} delta the diff (usually 1 or -1)
     * @param {Element} inputElem the input element
     */


    function incrementNumInput(e, delta, inputElem) {
      var target = e && getEventTarget(e);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }

    function build() {
      var fragment = window.document.createDocumentFragment();
      self.calendarContainer = createElement("div", "flatpickr-calendar");
      self.calendarContainer.tabIndex = -1;

      if (!self.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self.innerContainer = createElement("div", "flatpickr-innerContainer");

        if (self.config.weekNumbers) {
          var _a = buildWeeks(),
              weekWrapper = _a.weekWrapper,
              weekNumbers = _a.weekNumbers;

          self.innerContainer.appendChild(weekWrapper);
          self.weekNumbers = weekNumbers;
          self.weekWrapper = weekWrapper;
        }

        self.rContainer = createElement("div", "flatpickr-rContainer");
        self.rContainer.appendChild(buildWeekdays());

        if (!self.daysContainer) {
          self.daysContainer = createElement("div", "flatpickr-days");
          self.daysContainer.tabIndex = -1;
        }

        buildDays();
        self.rContainer.appendChild(self.daysContainer);
        self.innerContainer.appendChild(self.rContainer);
        fragment.appendChild(self.innerContainer);
      }

      if (self.config.enableTime) {
        fragment.appendChild(buildTime());
      }

      toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
      toggleClass(self.calendarContainer, "animate", self.config.animate === true);
      toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
      self.calendarContainer.appendChild(fragment);
      var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;

      if (self.config.inline || self.config.static) {
        self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

        if (self.config.inline) {
          if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
        }

        if (self.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
          wrapper.appendChild(self.element);
          if (self.altInput) wrapper.appendChild(self.altInput);
          wrapper.appendChild(self.calendarContainer);
        }
      }

      if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
    }

    function createDay(className, date, dayNumber, i) {
      var dateIsEnabled = isEnabled(date, true),
          dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i;
      dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

      if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
        self.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }

      if (dateIsEnabled) {
        dayElement.tabIndex = -1;

        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self.selectedDateElem = dayElement;

          if (self.config.mode === "range") {
            toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
            if (className === "nextMonthDay") dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }

      if (self.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
      }

      if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
        self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
      }

      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }

    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self.config.mode === "range") onMouseOver(targetNode);
    }

    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
      var endMonth = delta > 0 ? self.config.showMonths : -1;

      for (var m = startMonth; m != endMonth; m += delta) {
        var month = self.daysContainer.children[m];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;

        for (var i = startIndex; i != endIndex; i += delta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
        }
      }

      return undefined;
    }

    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
      var endMonth = delta > 0 ? self.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;

      for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
        var month = self.daysContainer.children[m];
        var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;

        for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
        }
      }

      self.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return undefined;
    }

    function focusOnDay(current, offset) {
      var dayFocused = isInView(document.activeElement || document.body);
      var startElem = current !== undefined ? current : dayFocused ? document.activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);

      if (startElem === undefined) {
        self._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }

    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self.utils.getDaysInMonth(month, year),
          days = window.document.createDocumentFragment(),
          isMultiMonth = self.config.showMonths > 1,
          prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
          nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth,
          dayIndex = 0; // prepend days from the ending of previous month

      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      } // Start at 1 since there is no 0th day


      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
      } // append days from the next month


      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      } //updateNavigationCurrentMonth();


      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }

    function buildDays() {
      if (self.daysContainer === undefined) {
        return;
      }

      clearNode(self.daysContainer); // TODO: week numbers for each month

      if (self.weekNumbers) clearNode(self.weekNumbers);
      var frag = document.createDocumentFragment();

      for (var i = 0; i < self.config.showMonths; i++) {
        var d = new Date(self.currentYear, self.currentMonth, 1);
        d.setMonth(self.currentMonth + i);
        frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
      }

      self.daysContainer.appendChild(frag);
      self.days = self.daysContainer.firstChild;

      if (self.config.mode === "range" && self.selectedDates.length === 1) {
        onMouseOver();
      }
    }

    function buildMonthSwitch() {
      if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;

      var shouldBuildMonth = function shouldBuildMonth(month) {
        if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
          return false;
        }

        return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
      };

      self.monthsDropdownContainer.tabIndex = -1;
      self.monthsDropdownContainer.innerHTML = "";

      for (var i = 0; i < 12; i++) {
        if (!shouldBuildMonth(i)) continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self.currentYear, i).getMonth().toString();
        month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
        month.tabIndex = -1;

        if (self.currentMonth === i) {
          month.selected = true;
        }

        self.monthsDropdownContainer.appendChild(month);
      }
    }

    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;

      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
        bind(self.monthsDropdownContainer, "change", function (e) {
          var target = getEventTarget(e);
          var selectedMonth = parseInt(target.value, 10);
          self.changeMonth(selectedMonth - self.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self.monthsDropdownContainer;
      }

      var yearInput = createNumberInput("cur-year", {
        tabindex: "-1"
      });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);

      if (self.config.minDate) {
        yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
      }

      if (self.config.maxDate) {
        yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
      }

      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container: container,
        yearElement: yearElement,
        monthElement: monthElement
      };
    }

    function buildMonths() {
      clearNode(self.monthNav);
      self.monthNav.appendChild(self.prevMonthNav);

      if (self.config.showMonths) {
        self.yearElements = [];
        self.monthElements = [];
      }

      for (var m = self.config.showMonths; m--;) {
        var month = buildMonth();
        self.yearElements.push(month.yearElement);
        self.monthElements.push(month.monthElement);
        self.monthNav.appendChild(month.container);
      }

      self.monthNav.appendChild(self.nextMonthNav);
    }

    function buildMonthNav() {
      self.monthNav = createElement("div", "flatpickr-months");
      self.yearElements = [];
      self.monthElements = [];
      self.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self.prevMonthNav.innerHTML = self.config.prevArrow;
      self.nextMonthNav = createElement("span", "flatpickr-next-month");
      self.nextMonthNav.innerHTML = self.config.nextArrow;
      buildMonths();
      Object.defineProperty(self, "_hidePrevMonthArrow", {
        get: function get() {
          return self.__hidePrevMonthArrow;
        },
        set: function set(bool) {
          if (self.__hidePrevMonthArrow !== bool) {
            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
            self.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self, "_hideNextMonthArrow", {
        get: function get() {
          return self.__hideNextMonthArrow;
        },
        set: function set(bool) {
          if (self.__hideNextMonthArrow !== bool) {
            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
            self.__hideNextMonthArrow = bool;
          }
        }
      });
      self.currentYearElement = self.yearElements[0];
      updateNavigationCurrentMonth();
      return self.monthNav;
    }

    function buildTime() {
      self.calendarContainer.classList.add("hasTime");
      if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
      self.timeContainer = createElement("div", "flatpickr-time");
      self.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self.l10n.hourAriaLabel
      });
      self.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self.l10n.minuteAriaLabel
      });
      self.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
      self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));
      self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);
      self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
      self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
      self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
      self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
      self.minuteElement.setAttribute("min", "0");
      self.minuteElement.setAttribute("max", "59");
      self.timeContainer.appendChild(hourInput);
      self.timeContainer.appendChild(separator);
      self.timeContainer.appendChild(minuteInput);
      if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

      if (self.config.enableSeconds) {
        self.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self.secondElement = secondInput.getElementsByTagName("input")[0];
        self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);
        self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
        self.secondElement.setAttribute("min", "0");
        self.secondElement.setAttribute("max", "59");
        self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self.timeContainer.appendChild(secondInput);
      }

      if (!self.config.time_24hr) {
        // add self.amPM if appropriate
        self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
        self.amPM.title = self.l10n.toggleTitle;
        self.amPM.tabIndex = -1;
        self.timeContainer.appendChild(self.amPM);
      }

      return self.timeContainer;
    }

    function buildWeekdays() {
      if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);

      for (var i = self.config.showMonths; i--;) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self.weekdayContainer.appendChild(container);
      }

      updateWeekdays();
      return self.weekdayContainer;
    }

    function updateWeekdays() {
      if (!self.weekdayContainer) {
        return;
      }

      var firstDayOfWeek = self.l10n.firstDayOfWeek;

      var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);

      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }

      for (var i = self.config.showMonths; i--;) {
        self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    /* istanbul ignore next */


    function buildWeeks() {
      self.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper: weekWrapper,
        weekNumbers: weekNumbers
      };
    }

    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }

      var delta = isOffset ? value : value - self.currentMonth;
      if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
      self.currentMonth += delta;

      if (self.currentMonth < 0 || self.currentMonth > 11) {
        self.currentYear += self.currentMonth > 11 ? 1 : -1;
        self.currentMonth = (self.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }

      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }

    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }

      if (toInitial === void 0) {
        toInitial = true;
      }

      self.input.value = "";
      if (self.altInput !== undefined) self.altInput.value = "";
      if (self.mobileInput !== undefined) self.mobileInput.value = "";
      self.selectedDates = [];
      self.latestSelectedDateObj = undefined;

      if (toInitial === true) {
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
      }

      if (self.config.enableTime === true) {
        var _a = getDefaultHours(),
            hours = _a.hours,
            minutes = _a.minutes,
            seconds = _a.seconds;

        setHours(hours, minutes, seconds);
      }

      self.redraw();
      if (triggerChangeEvent) // triggerChangeEvent is true (default) or an Event
        triggerEvent("onChange");
    }

    function close() {
      self.isOpen = false;

      if (!self.isMobile) {
        if (self.calendarContainer !== undefined) {
          self.calendarContainer.classList.remove("open");
        }

        if (self._input !== undefined) {
          self._input.classList.remove("active");
        }
      }

      triggerEvent("onClose");
    }

    function destroy() {
      if (self.config !== undefined) triggerEvent("onDestroy");

      for (var i = self._handlers.length; i--;) {
        var h = self._handlers[i];
        h.element.removeEventListener(h.event, h.handler, h.options);
      }

      self._handlers = [];

      if (self.mobileInput) {
        if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
        self.mobileInput = undefined;
      } else if (self.calendarContainer && self.calendarContainer.parentNode) {
        if (self.config.static && self.calendarContainer.parentNode) {
          var wrapper = self.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);

          if (wrapper.parentNode) {
            while (wrapper.firstChild) {
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            }

            wrapper.parentNode.removeChild(wrapper);
          }
        } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
      }

      if (self.altInput) {
        self.input.type = "text";
        if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
        delete self.altInput;
      }

      if (self.input) {
        self.input.type = self.input._type;
        self.input.classList.remove("flatpickr-input");
        self.input.removeAttribute("readonly");
      }

      ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
        try {
          delete self[k];
        } catch (_) {}
      });
    }

    function isCalendarElem(elem) {
      if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;
      return self.calendarContainer.contains(elem);
    }

    function documentClick(e) {
      if (self.isOpen && !self.config.inline) {
        var eventTarget_1 = getEventTarget(e);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || // web components
        // e.path is not present in all browsers. circumventing typechecks
        e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
        var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
        var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
          return elem.contains(eventTarget_1);
        });

        if (lostFocus && isIgnored) {
          if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) {
            updateTime();
          }

          self.close();

          if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) {
            self.clear(false);
            self.redraw();
          }
        }
      }
    }

    function changeYear(newYear) {
      if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
      var newYearNum = newYear,
          isNewYear = self.currentYear !== newYearNum;
      self.currentYear = newYearNum || self.currentYear;

      if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
        self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
      } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
        self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
      }

      if (isNewYear) {
        self.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }

    function isEnabled(date, timeless) {
      if (timeless === void 0) {
        timeless = true;
      }

      var dateToCheck = self.parseDate(date, undefined, timeless); // timeless

      if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
      if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;
      if (dateToCheck === undefined) return false;
      var bool = self.config.enable.length > 0,
          array = bool ? self.config.enable : self.config.disable;

      for (var i = 0, d = void 0; i < array.length; i++) {
        d = array[i];
        if (typeof d === "function" && d(dateToCheck) // disabled by function
        ) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) // disabled by date
          return bool;else if (typeof d === "string" && dateToCheck !== undefined) {
          // disabled by date string
          var parsed = self.parseDate(d, undefined, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if ( // disabled by range
        _typeof(d) === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
      }

      return !bool;
    }

    function isInView(elem) {
      if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
      return false;
    }

    function onBlur(e) {
      var isInput = e.target === self._input;

      if (isInput && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
        self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
      }
    }

    function onKeyDown(e) {
      // e.key                      e.keyCode
      // "Backspace"                        8
      // "Tab"                              9
      // "Enter"                           13
      // "Escape"     (IE "Esc")           27
      // "ArrowLeft"  (IE "Left")          37
      // "ArrowUp"    (IE "Up")            38
      // "ArrowRight" (IE "Right")         39
      // "ArrowDown"  (IE "Down")          40
      // "Delete"     (IE "Del")           46
      var eventTarget = getEventTarget(e);
      var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
      var allowInput = self.config.allowInput;
      var allowKeydown = self.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self.config.inline && isInput && !allowInput;

      if (e.keyCode === 13 && isInput) {
        if (allowInput) {
          self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
          return eventTarget.blur();
        } else {
          self.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);

        switch (e.keyCode) {
          case 13:
            if (isTimeObj) {
              e.preventDefault();
              updateTime();
              focusAndClose();
            } else selectDate(e);

            break;

          case 27:
            // escape
            e.preventDefault();
            focusAndClose();
            break;

          case 8:
          case 46:
            if (isInput && !self.config.allowInput) {
              e.preventDefault();
              self.clear();
            }

            break;

          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e.preventDefault();

              if (self.daysContainer !== undefined && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                var delta_1 = e.keyCode === 39 ? 1 : -1;
                if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                  e.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self.hourElement) self.hourElement.focus();

            break;

          case 38:
          case 40:
            e.preventDefault();
            var delta = e.keyCode === 40 ? 1 : -1;

            if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
              if (e.ctrlKey) {
                e.stopPropagation();
                changeYear(self.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
            } else if (eventTarget === self.currentYearElement) {
              changeYear(self.currentYear - delta);
            } else if (self.config.enableTime) {
              if (!isTimeObj && self.hourElement) self.hourElement.focus();
              updateTime(e);

              self._debouncedChange();
            }

            break;

          case 9:
            if (isTimeObj) {
              var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
                return x;
              });
              var i = elems.indexOf(eventTarget);

              if (i !== -1) {
                var target = elems[i + (e.shiftKey ? -1 : 1)];
                e.preventDefault();

                (target || self._input).focus();
              }
            } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
              e.preventDefault();

              self._input.focus();
            }

            break;
        }
      }

      if (self.amPM !== undefined && eventTarget === self.amPM) {
        switch (e.key) {
          case self.l10n.amPM[0].charAt(0):
          case self.l10n.amPM[0].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;

          case self.l10n.amPM[1].charAt(0):
          case self.l10n.amPM[1].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }

      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e);
      }
    }

    function onMouseOver(elem) {
      if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled"))) return;
      var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
          initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
          rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
          rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0,
          maxRange = 0;

      for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
        if (!isEnabled(new Date(t), true)) {
          containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
          if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
        }
      }

      for (var m = 0; m < self.config.showMonths; m++) {
        var month = self.daysContainer.children[m];

        var _loop_1 = function _loop_1(i, l) {
          var dayElem = month.children[i],
              date = dayElem.dateObj;
          var timestamp = date.getTime();
          var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;

          if (outOfRange) {
            dayElem.classList.add("notAllowed");
            ["inRange", "startRange", "endRange"].forEach(function (c) {
              dayElem.classList.remove(c);
            });
            return "continue";
          } else if (containsDisabled && !outOfRange) return "continue";

          ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
            dayElem.classList.remove(c);
          });

          if (elem !== undefined) {
            elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
            if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
          }
        };

        for (var i = 0, l = month.children.length; i < l; i++) {
          _loop_1(i, l);
        }
      }
    }

    function onResize() {
      if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
    }

    function open(e, positionElement) {
      if (positionElement === void 0) {
        positionElement = self._positionElement;
      }

      if (self.isMobile === true) {
        if (e) {
          e.preventDefault();
          var eventTarget = getEventTarget(e);
          eventTarget && eventTarget.blur();
        }

        if (self.mobileInput !== undefined) {
          self.mobileInput.focus();
          self.mobileInput.click();
        }

        triggerEvent("onOpen");
        return;
      }

      if (self._input.disabled || self.config.inline) return;
      var wasOpen = self.isOpen;
      self.isOpen = true;

      if (!wasOpen) {
        self.calendarContainer.classList.add("open");

        self._input.classList.add("active");

        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }

      if (self.config.enableTime === true && self.config.noCalendar === true) {
        if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
          setTimeout(function () {
            return self.hourElement.select();
          }, 50);
        }
      }
    }

    function minMaxDateSetter(type) {
      return function (date) {
        var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
        var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

        if (dateObj !== undefined) {
          self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }

        if (self.selectedDates) {
          self.selectedDates = self.selectedDates.filter(function (d) {
            return isEnabled(d);
          });
          if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
          updateValue();
        }

        if (self.daysContainer) {
          redraw();
          if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
          self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }

    function parseConfig() {
      var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

      var userConfig = _assign(_assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);

      var formats = {};
      self.config.parseDate = userConfig.parseDate;
      self.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self.config, "enable", {
        get: function get() {
          return self.config._enable;
        },
        set: function set(dates) {
          self.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self.config, "disable", {
        get: function get() {
          return self.config._disable;
        },
        set: function set(dates) {
          self.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";

      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }

      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }

      Object.defineProperty(self.config, "minDate", {
        get: function get() {
          return self.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self.config, "maxDate", {
        get: function get() {
          return self.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });

      var minMaxTimeSetter = function minMaxTimeSetter(type) {
        return function (val) {
          self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
        };
      };

      Object.defineProperty(self.config, "minTime", {
        get: function get() {
          return self.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self.config, "maxTime", {
        get: function get() {
          return self.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });

      if (userConfig.mode === "time") {
        self.config.noCalendar = true;
        self.config.enableTime = true;
      }

      Object.assign(self.config, formats, userConfig);

      for (var i = 0; i < boolOpts.length; i++) {
        // https://github.com/microsoft/TypeScript/issues/31663
        self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
      }

      HOOKS.filter(function (hook) {
        return self.config[hook] !== undefined;
      }).forEach(function (hook) {
        self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
      });
      self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      for (var i = 0; i < self.config.plugins.length; i++) {
        var pluginConf = self.config.plugins[i](self) || {};

        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
          } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
        }
      }

      if (!userConfig.altInputClass) {
        self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
      }

      triggerEvent("onParseConfig");
    }

    function getInputElem() {
      return self.config.wrap ? element.querySelector("[data-input]") : element;
    }

    function setupLocale() {
      if (_typeof(self.config.locale) !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
      self.l10n = _assign(_assign({}, flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
      tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";

      var userConfig = _assign(_assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));

      if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
        self.config.time_24hr = self.l10n.time_24hr;
      }

      self.formatDate = createDateFormatter(self);
      self.parseDate = createDateParser({
        config: self.config,
        l10n: self.l10n
      });
    }

    function positionCalendar(customPositionElement) {
      if (self.calendarContainer === undefined) return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
        return acc + child.offsetHeight;
      }, 0),
          calendarWidth = self.calendarContainer.offsetWidth,
          configPos = self.config.position.split(" "),
          configPosVertical = configPos[0],
          configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
          inputBounds = positionElement.getBoundingClientRect(),
          distanceFromBottom = window.innerHeight - inputBounds.bottom,
          showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
      if (self.config.inline) return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;

      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }

      toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self.calendarContainer, "rightMost", rightMost);
      if (self.config.static) return;
      self.calendarContainer.style.top = top + "px";

      if (!rightMost) {
        self.calendarContainer.style.left = left + "px";
        self.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self.calendarContainer.style.left = "auto";
        self.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet(); // some testing environments don't have css support

        if (doc === undefined) return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self.calendarContainer, "rightMost", false);
        toggleClass(self.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self.calendarContainer.style.left = centerLeft + "px";
        self.calendarContainer.style.right = "auto";
      }
    }

    function getDocumentStyleSheet() {
      var editableSheet = null;

      for (var i = 0; i < document.styleSheets.length; i++) {
        var sheet = document.styleSheets[i];

        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }

        editableSheet = sheet;
        break;
      }

      return editableSheet != null ? editableSheet : createStyleSheet();
    }

    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }

    function redraw() {
      if (self.config.noCalendar || self.isMobile) return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }

    function focusAndClose() {
      self._input.focus();

      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
        // hack - bugs in the way IE handles focus keeps the calendar open
        setTimeout(self.close, 0);
      } else {
        self.close();
      }
    }

    function selectDate(e) {
      e.preventDefault();
      e.stopPropagation();

      var isSelectable = function isSelectable(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      };

      var t = findParent(getEventTarget(e), isSelectable);
      if (t === undefined) return;
      var target = t;
      var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
      self.selectedDateElem = target;
      if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
      } else if (self.config.mode === "range") {
        if (self.selectedDates.length === 2) {
          self.clear(false, false);
        }

        self.latestSelectedDateObj = selectedDate;
        self.selectedDates.push(selectedDate); // unless selecting same date twice, sort ascendingly

        if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
          return a.getTime() - b.getTime();
        });
      }
      setHoursFromInputs();

      if (shouldChangeMonth) {
        var isNewYear = self.currentYear !== selectedDate.getFullYear();
        self.currentYear = selectedDate.getFullYear();
        self.currentMonth = selectedDate.getMonth();

        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }

        triggerEvent("onMonthChange");
      }

      updateNavigationCurrentMonth();
      buildDays();
      updateValue(); // maintain focus

      if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
        self.selectedDateElem && self.selectedDateElem.focus();
      }
      if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();

      if (self.config.closeOnSelect) {
        var single = self.config.mode === "single" && !self.config.enableTime;
        var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

        if (single || range) {
          focusAndClose();
        }
      }

      triggerChange();
    }

    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate]
    };

    function set(option, value) {
      if (option !== null && _typeof(option) === "object") {
        Object.assign(self.config, option);

        for (var key in option) {
          if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
            return x();
          });
        }
      } else {
        self.config[option] = value;
        if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
          return x();
        });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
      }

      self.redraw();
      updateValue(true);
    }

    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array) dates = inputDate.map(function (d) {
        return self.parseDate(d, format);
      });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
        switch (self.config.mode) {
          case "single":
          case "time":
            dates = [self.parseDate(inputDate, format)];
            break;

          case "multiple":
            dates = inputDate.split(self.config.conjunction).map(function (date) {
              return self.parseDate(date, format);
            });
            break;

          case "range":
            dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
              return self.parseDate(date, format);
            });
            break;
        }
      } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function (d) {
        return d instanceof Date && isEnabled(d, false);
      });
      if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
        return a.getTime() - b.getTime();
      });
    }

    function setDate(date, triggerChange, format) {
      if (triggerChange === void 0) {
        triggerChange = false;
      }

      if (format === void 0) {
        format = self.config.dateFormat;
      }

      if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
      setSelectedDate(date, format);
      self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
      self.redraw();
      jumpToDate(undefined, triggerChange);
      setHoursFromDate();

      if (self.selectedDates.length === 0) {
        self.clear(false);
      }

      updateValue(triggerChange);
      if (triggerChange) triggerEvent("onChange");
    }

    function parseDateRules(arr) {
      return arr.slice().map(function (rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self.parseDate(rule, undefined, true);
        } else if (rule && _typeof(rule) === "object" && rule.from && rule.to) return {
          from: self.parseDate(rule.from, undefined),
          to: self.parseDate(rule.to, undefined)
        };

        return rule;
      }).filter(function (x) {
        return x;
      }); // remove falsy values
    }

    function setupDates() {
      self.selectedDates = [];
      self.now = self.parseDate(self.config.now) || new Date(); // Workaround IE11 setting placeholder as the input's value

      var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
      if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
      self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
      if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
      if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
      if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
      self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
      self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
    }

    function setupInputs() {
      self.input = getInputElem();
      /* istanbul ignore next */

      if (!self.input) {
        self.config.errorHandler(new Error("Invalid input element specified"));
        return;
      } // hack: store previous type to restore it after destroy()


      self.input._type = self.input.type;
      self.input.type = "text";
      self.input.classList.add("flatpickr-input");
      self._input = self.input;

      if (self.config.altInput) {
        // replicate self.element
        self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
        self._input = self.altInput;
        self.altInput.placeholder = self.input.placeholder;
        self.altInput.disabled = self.input.disabled;
        self.altInput.required = self.input.required;
        self.altInput.tabIndex = self.input.tabIndex;
        self.altInput.type = "text";
        self.input.setAttribute("type", "hidden");
        if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
      }

      if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
      self._positionElement = self.config.positionElement || self._input;
    }

    function setupMobile() {
      var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
      self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
      self.mobileInput.tabIndex = 1;
      self.mobileInput.type = inputType;
      self.mobileInput.disabled = self.input.disabled;
      self.mobileInput.required = self.input.required;
      self.mobileInput.placeholder = self.input.placeholder;
      self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

      if (self.selectedDates.length > 0) {
        self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
      }

      if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
      if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
      if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
      self.input.type = "hidden";
      if (self.altInput !== undefined) self.altInput.type = "hidden";

      try {
        if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
      } catch (_a) {}

      bind(self.mobileInput, "change", function (e) {
        self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }

    function toggle(e) {
      if (self.isOpen === true) return self.close();
      self.open(e);
    }

    function triggerEvent(event, data) {
      // If the instance has been destroyed already, all hooks have been removed
      if (self.config === undefined) return;
      var hooks = self.config[event];

      if (hooks !== undefined && hooks.length > 0) {
        for (var i = 0; hooks[i] && i < hooks.length; i++) {
          hooks[i](self.selectedDates, self.input.value, self, data);
        }
      }

      if (event === "onChange") {
        self.input.dispatchEvent(createEvent("change")); // many front-end frameworks bind to the input event

        self.input.dispatchEvent(createEvent("input"));
      }
    }

    function createEvent(name) {
      var e = document.createEvent("Event");
      e.initEvent(name, true, true);
      return e;
    }

    function isDateSelected(date) {
      for (var i = 0; i < self.selectedDates.length; i++) {
        if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
      }

      return false;
    }

    function isDateInRange(date) {
      if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
      return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
    }

    function updateNavigationCurrentMonth() {
      if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
      self.yearElements.forEach(function (yearElement, i) {
        var d = new Date(self.currentYear, self.currentMonth, 1);
        d.setMonth(self.currentMonth + i);

        if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
          self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
        } else {
          self.monthsDropdownContainer.value = d.getMonth().toString();
        }

        yearElement.value = d.getFullYear().toString();
      });
      self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
      self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
    }

    function getDateStr(format) {
      return self.selectedDates.map(function (dObj) {
        return self.formatDate(dObj, format);
      }).filter(function (d, i, arr) {
        return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
      }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
    }
    /**
     * Updates the values of inputs associated with the calendar
     */


    function updateValue(triggerChange) {
      if (triggerChange === void 0) {
        triggerChange = true;
      }

      if (self.mobileInput !== undefined && self.mobileFormatStr) {
        self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
      }

      self.input.value = getDateStr(self.config.dateFormat);

      if (self.altInput !== undefined) {
        self.altInput.value = getDateStr(self.config.altFormat);
      }

      if (triggerChange !== false) triggerEvent("onValueUpdate");
    }

    function onMonthNavClick(e) {
      var eventTarget = getEventTarget(e);
      var isPrevMonth = self.prevMonthNav.contains(eventTarget);
      var isNextMonth = self.nextMonthNav.contains(eventTarget);

      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self.changeYear(self.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self.changeYear(self.currentYear - 1);
      }
    }

    function timeWrapper(e) {
      e.preventDefault();
      var isKeyDown = e.type === "keydown",
          eventTarget = getEventTarget(e),
          input = eventTarget;

      if (self.amPM !== undefined && eventTarget === self.amPM) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }

      var min = parseFloat(input.getAttribute("min")),
          max = parseFloat(input.getAttribute("max")),
          step = parseFloat(input.getAttribute("step")),
          curValue = parseInt(input.value, 10),
          delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;

      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self.hourElement,
            isMinuteElem = input === self.minuteElement;

        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
          if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
        } else if (newValue > max) {
          newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
          if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
        }

        if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
        }

        input.value = pad(newValue);
      }
    }

    init();
    return self;
  }
  /* istanbul ignore next */


  function _flatpickr(nodeList, config) {
    // static list
    var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
      return x instanceof HTMLElement;
    });
    var instances = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      try {
        if (node.getAttribute("data-fp-omit") !== null) continue;

        if (node._flatpickr !== undefined) {
          node._flatpickr.destroy();

          node._flatpickr = undefined;
        }

        node._flatpickr = FlatpickrInstance(node, config || {});
        instances.push(node._flatpickr);
      } catch (e) {
        console.error(e);
      }
    }

    return instances.length === 1 ? instances[0] : instances;
  }
  /* istanbul ignore next */


  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    // browser env
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
      return _flatpickr(this, config);
    };

    HTMLElement.prototype.flatpickr = function (config) {
      return _flatpickr([this], config);
    };
  }
  /* istanbul ignore next */


  var flatpickr = function flatpickr(selector, config) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config);
    } else {
      return _flatpickr(selector, config);
    }
  };
  /* istanbul ignore next */


  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: _assign({}, english),
    default: _assign({}, english)
  };

  flatpickr.localize = function (l10n) {
    flatpickr.l10ns.default = _assign(_assign({}, flatpickr.l10ns.default), l10n);
  };

  flatpickr.setDefaults = function (config) {
    flatpickr.defaultConfig = _assign(_assign({}, flatpickr.defaultConfig), config);
  };

  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  /* istanbul ignore next */

  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function (config) {
      return _flatpickr(this, config);
    };
  } // eslint-disable-next-line @typescript-eslint/camelcase


  Date.prototype.fp_incr = function (days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };

  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }

  return flatpickr;
});

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["Basis"]) global["Basis"] = {};
module.exports = global["Basis"]["AgGridComponents"] = __webpack_require__(51);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 42);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(45);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ];
      /***/
    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = autobind;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var defineProperty = Object.defineProperty,
          getPrototypeOf = Object.getPrototypeOf;
      var mapStore;

      function getBoundSuper(obj, fn) {
        if (typeof WeakMap === 'undefined') {
          throw new Error("Using @autobind on ".concat(fn.name, "() requires WeakMap support due to its use of super.").concat(fn.name, "()\n      See https://github.com/jayphelps/core-decorators.js/issues/20"));
        }

        if (!mapStore) {
          mapStore = new WeakMap();
        }

        if (mapStore.has(obj) === false) {
          mapStore.set(obj, new WeakMap());
        }

        var superStore = mapStore.get(obj);

        if (superStore.has(fn) === false) {
          superStore.set(fn, Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["a"
          /* bind */
          ])(fn, obj));
        }

        return superStore.get(fn);
      }

      function autobindClass(klass) {
        var descs = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["e"
        /* getOwnPropertyDescriptors */
        ])(klass.prototype);
        var keys = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["d"
        /* getOwnKeys */
        ])(descs);

        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          var desc = descs[key];

          if (typeof desc.value !== 'function' || key === 'constructor') {
            continue;
          }

          defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));
        }
      }

      function autobindMethod(target, key, _ref) {
        var fn = _ref.value,
            configurable = _ref.configurable,
            enumerable = _ref.enumerable;

        if (typeof fn !== 'function') {
          throw new SyntaxError("@autobind can only be used on functions, not: ".concat(fn));
        }

        var constructor = target.constructor;
        return {
          configurable: configurable,
          enumerable: enumerable,
          get: function get() {
            // Class.prototype.key lookup
            // Someone accesses the property directly on the prototype on which it is
            // actually defined on, i.e. Class.prototype.hasOwnProperty(key)
            if (this === target) {
              return fn;
            } // Class.prototype.key lookup
            // Someone accesses the property directly on a prototype but it was found
            // up the chain, not defined directly on it
            // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype


            if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {
              return fn;
            } // Autobound method calling super.sameMethod() which is also autobound and so on.


            if (this.constructor !== constructor && key in this.constructor.prototype) {
              return getBoundSuper(this, fn);
            }

            var boundFn = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["a"
            /* bind */
            ])(fn, this);
            defineProperty(this, key, {
              configurable: true,
              writable: true,
              // NOT enumerable when it's a bound method
              enumerable: false,
              value: boundFn
            });
            return boundFn;
          },
          set: Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["b"
          /* createDefaultSetter */
          ])(key)
        };
      }

      function handle(args) {
        if (args.length === 1) {
          return autobindClass.apply(void 0, _toConsumableArray(args));
        } else {
          return autobindMethod.apply(void 0, _toConsumableArray(args));
        }
      }

      function autobind() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 0) {
          return function () {
            return handle(arguments);
          };
        } else {
          return handle(args);
        }
      }
      /***/

    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = override;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';
      var FUNCTION_REGEXP = /^function ([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?(\([^\)]*\))[\s\S]+$/;

      var SyntaxErrorReporter = /*#__PURE__*/function () {
        _createClass(SyntaxErrorReporter, [{
          key: "_getTopic",
          value: function _getTopic(descriptor) {
            if (descriptor === undefined) {
              return null;
            }

            if ('value' in descriptor) {
              return descriptor.value;
            }

            if ('get' in descriptor) {
              return descriptor.get;
            }

            if ('set' in descriptor) {
              return descriptor.set;
            }
          }
        }, {
          key: "_extractTopicSignature",
          value: function _extractTopicSignature(topic) {
            switch (_typeof(topic)) {
              case 'function':
                return this._extractFunctionSignature(topic);

              default:
                return this.key;
            }
          }
        }, {
          key: "_extractFunctionSignature",
          value: function _extractFunctionSignature(fn) {
            var _this = this;

            return fn.toString().replace(FUNCTION_REGEXP, function (match) {
              var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;
              var params = arguments.length > 2 ? arguments[2] : undefined;
              return name + params;
            });
          }
        }, {
          key: "key",
          get: function get() {
            return this.childDescriptor.key;
          }
        }, {
          key: "parentNotation",
          get: function get() {
            return "".concat(this.parentKlass.constructor.name, "#").concat(this.parentPropertySignature);
          }
        }, {
          key: "childNotation",
          get: function get() {
            return "".concat(this.childKlass.constructor.name, "#").concat(this.childPropertySignature);
          }
        }, {
          key: "parentTopic",
          get: function get() {
            return this._getTopic(this.parentDescriptor);
          }
        }, {
          key: "childTopic",
          get: function get() {
            return this._getTopic(this.childDescriptor);
          }
        }, {
          key: "parentPropertySignature",
          get: function get() {
            return this._extractTopicSignature(this.parentTopic);
          }
        }, {
          key: "childPropertySignature",
          get: function get() {
            return this._extractTopicSignature(this.childTopic);
          }
        }]);

        function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {
          _classCallCheck(this, SyntaxErrorReporter);

          this.parentKlass = void 0;
          this.childKlass = void 0;
          this.parentDescriptor = void 0;
          this.childDescriptor = void 0;
          this.parentKlass = parentKlass;
          this.childKlass = childKlass;
          this.parentDescriptor = parentDescriptor;
          this.childDescriptor = childDescriptor;
        }

        _createClass(SyntaxErrorReporter, [{
          key: "assert",
          value: function assert(condition) {
            var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            if (condition !== true) {
              this.error(GENERIC_FUNCTION_ERROR + msg);
            }
          }
        }, {
          key: "error",
          value: function error(msg) {
            var _this2 = this;

            msg = msg // Replace lazily, because they actually might not
            // be available in all cases
            .replace('{parent}', function (m) {
              return _this2.parentNotation;
            }).replace('{child}', function (m) {
              return _this2.childNotation;
            });
            throw new SyntaxError(msg);
          }
        }]);

        return SyntaxErrorReporter;
      }();

      function getDescriptorType(descriptor) {
        if (descriptor.hasOwnProperty('value')) {
          return 'data';
        }

        if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {
          return 'accessor';
        } // If none of them exist, browsers treat it as
        // a data descriptor with a value of `undefined`


        return 'data';
      }

      function checkFunctionSignatures(parent, child, reporter) {
        reporter.assert(parent.length === child.length);
      }

      function checkDataDescriptors(parent, child, reporter) {
        var parentValueType = _typeof(parent.value);

        var childValueType = _typeof(child.value);

        if (parentValueType === 'undefined' && childValueType === 'undefined') {
          // class properties can be any expression, which isn't ran until the
          // the instance is created, so we can't reliably get type information
          // for them yet (per spec). Perhaps when Babel includes flow-type info
          // in runtime? Tried regex solutions, but super hacky and only feasible
          // on primitives, which is confusing for usage...
          reporter.error("descriptor values are both undefined. (class properties are are not currently supported)'");
        }

        if (parentValueType !== childValueType) {
          var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined; // Even though we don't support class properties, this
          // will still handle more than just functions, just in case.
          // Shadowing an undefined value is an error if the inherited
          // value was undefined (usually a class property, not a method)

          if (isFunctionOverUndefined || parentValueType !== undefined) {
            reporter.error("value types do not match. {parent} is \"".concat(parentValueType, "\", {child} is \"").concat(childValueType, "\""));
          }
        } // Switch, in preparation for supporting more types


        switch (childValueType) {
          case 'function':
            checkFunctionSignatures(parent.value, child.value, reporter);
            break;

          default:
            reporter.error("Unexpected error. Please file a bug with: {parent} is \"".concat(parentValueType, "\", {child} is \"").concat(childValueType, "\""));
            break;
        }
      }

      function checkAccessorDescriptors(parent, child, reporter) {
        var parentHasGetter = typeof parent.get === 'function';
        var childHasGetter = typeof child.get === 'function';
        var parentHasSetter = typeof parent.set === 'function';
        var childHasSetter = typeof child.set === 'function';

        if (parentHasGetter || childHasGetter) {
          if (!parentHasGetter && parentHasSetter) {
            reporter.error("{parent} is setter but {child} is getter");
          }

          if (!childHasGetter && childHasSetter) {
            reporter.error("{parent} is getter but {child} is setter");
          }

          checkFunctionSignatures(parent.get, child.get, reporter);
        }

        if (parentHasSetter || childHasSetter) {
          if (!parentHasSetter && parentHasGetter) {
            reporter.error("{parent} is getter but {child} is setter");
          }

          if (!childHasSetter && childHasGetter) {
            reporter.error("{parent} is setter but {child} is getter");
          }

          checkFunctionSignatures(parent.set, child.set, reporter);
        }
      }

      function checkDescriptors(parent, child, reporter) {
        var parentType = getDescriptorType(parent);
        var childType = getDescriptorType(child);

        if (parentType !== childType) {
          reporter.error("descriptor types do not match. {parent} is \"".concat(parentType, "\", {child} is \"").concat(childType, "\""));
        }

        switch (childType) {
          case 'data':
            checkDataDescriptors(parent, child, reporter);
            break;

          case 'accessor':
            checkAccessorDescriptors(parent, child, reporter);
            break;
        }
      }

      var suggestionTransforms = [function (key) {
        return key.toLowerCase();
      }, function (key) {
        return key.toUpperCase();
      }, function (key) {
        return key + 's';
      }, function (key) {
        return key.slice(0, -1);
      }, function (key) {
        return key.slice(1, key.length);
      }];

      function findPossibleAlternatives(superKlass, key) {
        for (var i = 0, l = suggestionTransforms.length; i < l; i++) {
          var fn = suggestionTransforms[i];
          var suggestion = fn(key);

          if (suggestion in superKlass) {
            return suggestion;
          }
        }

        return null;
      }

      function handleDescriptor(target, key, descriptor) {
        descriptor.key = key;
        var superKlass = Object.getPrototypeOf(target);
        var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);
        var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);

        if (superDescriptor === undefined) {
          var suggestedKey = findPossibleAlternatives(superKlass, key);
          var suggestion = suggestedKey ? "\n\n  Did you mean \"".concat(suggestedKey, "\"?") : '';
          reporter.error("No descriptor matching {child} was found on the prototype chain.".concat(suggestion));
        }

        checkDescriptors(superDescriptor, descriptor, reporter);
        return descriptor;
      }

      function override() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 3 */

    /***/
    function (module, exports) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      // css base code, injected by the css-loader
      module.exports = function (useSourceMap) {
        var list = []; // return the list of modules as css string

        list.toString = function toString() {
          return this.map(function (item) {
            var content = cssWithMappingToString(item, useSourceMap);

            if (item[2]) {
              return "@media " + item[2] + "{" + content + "}";
            } else {
              return content;
            }
          }).join("");
        }; // import a list of modules into the list


        list.i = function (modules, mediaQuery) {
          if (typeof modules === "string") modules = [[null, modules, ""]];
          var alreadyImportedModules = {};

          for (var i = 0; i < this.length; i++) {
            var id = this[i][0];
            if (typeof id === "number") alreadyImportedModules[id] = true;
          }

          for (i = 0; i < modules.length; i++) {
            var item = modules[i]; // skip already imported module
            // this implementation is not 100% perfect for weird media query combinations
            //  when a module is imported multiple times with different media queries.
            //  I hope this will never occur (Hey this way we have smaller bundles)

            if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
              if (mediaQuery && !item[2]) {
                item[2] = mediaQuery;
              } else if (mediaQuery) {
                item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
              }

              list.push(item);
            }
          }
        };

        return list;
      };

      function cssWithMappingToString(item, useSourceMap) {
        var content = item[1] || '';
        var cssMapping = item[3];

        if (!cssMapping) {
          return content;
        }

        if (useSourceMap && typeof btoa === 'function') {
          var sourceMapping = toComment(cssMapping);
          var sourceURLs = cssMapping.sources.map(function (source) {
            return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
          });
          return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
        }

        return [content].join('\n');
      } // Adapted from convert-source-map (MIT)


      function toComment(sourceMap) {
        // eslint-disable-next-line no-undef
        var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
        var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
        return '/*# ' + data + ' */';
      }
      /***/

    },
    /* 4 */

    /***/
    function (module, exports, __webpack_require__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      var stylesInDom = {};

      var memoize = function memoize(fn) {
        var memo;
        return function () {
          if (typeof memo === "undefined") memo = fn.apply(this, arguments);
          return memo;
        };
      };

      var isOldIE = memoize(function () {
        // Test for IE <= 9 as proposed by Browserhacks
        // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
        // Tests for existence of standard globals is to allow style-loader
        // to operate correctly into non-standard environments
        // @see https://github.com/webpack-contrib/style-loader/issues/177
        return window && document && document.all && !window.atob;
      });

      var getTarget = function getTarget(target) {
        return document.querySelector(target);
      };

      var getElement = function (fn) {
        var memo = {};
        return function (target) {
          // If passing function in options, then use it for resolve "head" element.
          // Useful for Shadow Root style i.e
          // {
          //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
          // }
          if (typeof target === 'function') {
            return target();
          }

          if (typeof memo[target] === "undefined") {
            var styleTarget = getTarget.call(this, target); // Special case to return head of iframe instead of iframe itself

            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
              try {
                // This will throw an exception if access to iframe is blocked
                // due to cross-origin restrictions
                styleTarget = styleTarget.contentDocument.head;
              } catch (e) {
                styleTarget = null;
              }
            }

            memo[target] = styleTarget;
          }

          return memo[target];
        };
      }();

      var singleton = null;
      var singletonCounter = 0;
      var stylesInsertedAtTop = [];

      var fixUrls = __webpack_require__(50);

      module.exports = function (list, options) {
        if (typeof DEBUG !== "undefined" && DEBUG) {
          if ((typeof document === "undefined" ? "undefined" : _typeof2(document)) !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
        }

        options = options || {};
        options.attrs = _typeof2(options.attrs) === "object" ? options.attrs : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
        // tags it will allow on a page

        if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE(); // By default, add <style> tags to the <head> element

        if (!options.insertInto) options.insertInto = "head"; // By default, add <style> tags to the bottom of the target

        if (!options.insertAt) options.insertAt = "bottom";
        var styles = listToStyles(list, options);
        addStylesToDom(styles, options);
        return function update(newList) {
          var mayRemove = [];

          for (var i = 0; i < styles.length; i++) {
            var item = styles[i];
            var domStyle = stylesInDom[item.id];
            domStyle.refs--;
            mayRemove.push(domStyle);
          }

          if (newList) {
            var newStyles = listToStyles(newList, options);
            addStylesToDom(newStyles, options);
          }

          for (var i = 0; i < mayRemove.length; i++) {
            var domStyle = mayRemove[i];

            if (domStyle.refs === 0) {
              for (var j = 0; j < domStyle.parts.length; j++) {
                domStyle.parts[j]();
              }

              delete stylesInDom[domStyle.id];
            }
          }
        };
      };

      function addStylesToDom(styles, options) {
        for (var i = 0; i < styles.length; i++) {
          var item = styles[i];
          var domStyle = stylesInDom[item.id];

          if (domStyle) {
            domStyle.refs++;

            for (var j = 0; j < domStyle.parts.length; j++) {
              domStyle.parts[j](item.parts[j]);
            }

            for (; j < item.parts.length; j++) {
              domStyle.parts.push(addStyle(item.parts[j], options));
            }
          } else {
            var parts = [];

            for (var j = 0; j < item.parts.length; j++) {
              parts.push(addStyle(item.parts[j], options));
            }

            stylesInDom[item.id] = {
              id: item.id,
              refs: 1,
              parts: parts
            };
          }
        }
      }

      function listToStyles(list, options) {
        var styles = [];
        var newStyles = {};

        for (var i = 0; i < list.length; i++) {
          var item = list[i];
          var id = options.base ? item[0] + options.base : item[0];
          var css = item[1];
          var media = item[2];
          var sourceMap = item[3];
          var part = {
            css: css,
            media: media,
            sourceMap: sourceMap
          };
          if (!newStyles[id]) styles.push(newStyles[id] = {
            id: id,
            parts: [part]
          });else newStyles[id].parts.push(part);
        }

        return styles;
      }

      function insertStyleElement(options, style) {
        var target = getElement(options.insertInto);

        if (!target) {
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        }

        var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

        if (options.insertAt === "top") {
          if (!lastStyleElementInsertedAtTop) {
            target.insertBefore(style, target.firstChild);
          } else if (lastStyleElementInsertedAtTop.nextSibling) {
            target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
          } else {
            target.appendChild(style);
          }

          stylesInsertedAtTop.push(style);
        } else if (options.insertAt === "bottom") {
          target.appendChild(style);
        } else if (_typeof2(options.insertAt) === "object" && options.insertAt.before) {
          var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
          target.insertBefore(style, nextSibling);
        } else {
          throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
        }
      }

      function removeStyleElement(style) {
        if (style.parentNode === null) return false;
        style.parentNode.removeChild(style);
        var idx = stylesInsertedAtTop.indexOf(style);

        if (idx >= 0) {
          stylesInsertedAtTop.splice(idx, 1);
        }
      }

      function createStyleElement(options) {
        var style = document.createElement("style");
        options.attrs.type = "text/css";
        addAttrs(style, options.attrs);
        insertStyleElement(options, style);
        return style;
      }

      function createLinkElement(options) {
        var link = document.createElement("link");
        options.attrs.type = "text/css";
        options.attrs.rel = "stylesheet";
        addAttrs(link, options.attrs);
        insertStyleElement(options, link);
        return link;
      }

      function addAttrs(el, attrs) {
        Object.keys(attrs).forEach(function (key) {
          el.setAttribute(key, attrs[key]);
        });
      }

      function addStyle(obj, options) {
        var style, update, remove, result; // If a transform function was defined, run it on the css

        if (options.transform && obj.css) {
          result = options.transform(obj.css);

          if (result) {
            // If transform returns a value, use that instead of the original css.
            // This allows running runtime transformations on the css.
            obj.css = result;
          } else {
            // If the transform function returns a falsy value, don't add this css.
            // This allows conditional loading of css
            return function () {// noop
            };
          }
        }

        if (options.singleton) {
          var styleIndex = singletonCounter++;
          style = singleton || (singleton = createStyleElement(options));
          update = applyToSingletonTag.bind(null, style, styleIndex, false);
          remove = applyToSingletonTag.bind(null, style, styleIndex, true);
        } else if (obj.sourceMap && typeof URL === "function" && typeof URL.createObjectURL === "function" && typeof URL.revokeObjectURL === "function" && typeof Blob === "function" && typeof btoa === "function") {
          style = createLinkElement(options);
          update = updateLink.bind(null, style, options);

          remove = function remove() {
            removeStyleElement(style);
            if (style.href) URL.revokeObjectURL(style.href);
          };
        } else {
          style = createStyleElement(options);
          update = applyToTag.bind(null, style);

          remove = function remove() {
            removeStyleElement(style);
          };
        }

        update(obj);
        return function updateStyle(newObj) {
          if (newObj) {
            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
              return;
            }

            update(obj = newObj);
          } else {
            remove();
          }
        };
      }

      var replaceText = function () {
        var textStore = [];
        return function (index, replacement) {
          textStore[index] = replacement;
          return textStore.filter(Boolean).join('\n');
        };
      }();

      function applyToSingletonTag(style, index, remove, obj) {
        var css = remove ? "" : obj.css;

        if (style.styleSheet) {
          style.styleSheet.cssText = replaceText(index, css);
        } else {
          var cssNode = document.createTextNode(css);
          var childNodes = style.childNodes;
          if (childNodes[index]) style.removeChild(childNodes[index]);

          if (childNodes.length) {
            style.insertBefore(cssNode, childNodes[index]);
          } else {
            style.appendChild(cssNode);
          }
        }
      }

      function applyToTag(style, obj) {
        var css = obj.css;
        var media = obj.media;

        if (media) {
          style.setAttribute("media", media);
        }

        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          while (style.firstChild) {
            style.removeChild(style.firstChild);
          }

          style.appendChild(document.createTextNode(css));
        }
      }

      function updateLink(link, options, obj) {
        var css = obj.css;
        var sourceMap = obj.sourceMap;
        /*
        	If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
        	and there is no publicPath defined then lets turn convertToAbsoluteUrls
        	on by default.  Otherwise default to the convertToAbsoluteUrls option
        	directly
        */

        var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

        if (options.convertToAbsoluteUrls || autoFixUrls) {
          css = fixUrls(css);
        }

        if (sourceMap) {
          // http://stackoverflow.com/a/26603875
          css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
        }

        var blob = new Blob([css], {
          type: "text/css"
        });
        var oldSrc = link.href;
        link.href = URL.createObjectURL(blob);
        if (oldSrc) URL.revokeObjectURL(oldSrc);
      }
      /***/

    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(73);
      /** `Object#toString` result references. */


      var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';
      /** Built-in value references. */

      var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].toStringTag : undefined;
      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */

      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }

        return symToStringTag && symToStringTag in Object(value) ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a"
        /* default */
        ])(value) : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseGetTag;
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */


      function isObjectLike(value) {
        return value != null && _typeof(value) == 'object';
      }
      /* harmony default export */


      __webpack_exports__["a"] = isObjectLike;
      /***/
    },
    /* 7 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export isDescriptor */

      /* harmony export (immutable) */

      __webpack_exports__["c"] = decorate;
      /* unused harmony export metaFor */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "d", function () {
        return getOwnKeys;
      });
      /* harmony export (immutable) */


      __webpack_exports__["e"] = getOwnPropertyDescriptors;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = createDefaultSetter;
      /* harmony export (immutable) */

      __webpack_exports__["a"] = bind;
      /* unused harmony export warn */

      /* unused harmony export internalDeprecation */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lazy_initialize__ = __webpack_require__(47);

      var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }

      function _initializerWarningHelper(descriptor, context) {
        throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var defineProperty = Object.defineProperty,
          getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
          getOwnPropertyNames = Object.getOwnPropertyNames,
          getOwnPropertySymbols = Object.getOwnPropertySymbols;

      function isDescriptor(desc) {
        if (!desc || !desc.hasOwnProperty) {
          return false;
        }

        var keys = ['value', 'initializer', 'get', 'set'];

        for (var i = 0, l = keys.length; i < l; i++) {
          if (desc.hasOwnProperty(keys[i])) {
            return true;
          }
        }

        return false;
      }

      function decorate(handleDescriptor, entryArgs) {
        if (isDescriptor(entryArgs[entryArgs.length - 1])) {
          return handleDescriptor.apply(void 0, _toConsumableArray(entryArgs).concat([[]]));
        } else {
          return function () {
            return handleDescriptor.apply(void 0, _toConsumableArray(Array.prototype.slice.call(arguments)).concat([entryArgs]));
          };
        }
      }

      var Meta = (_class = (_temp = function Meta() {
        _classCallCheck(this, Meta);

        _initializerDefineProperty(this, "debounceTimeoutIds", _descriptor, this);

        _initializerDefineProperty(this, "throttleTimeoutIds", _descriptor2, this);

        _initializerDefineProperty(this, "throttlePreviousTimestamps", _descriptor3, this);

        _initializerDefineProperty(this, "throttleTrailingArgs", _descriptor4, this);

        _initializerDefineProperty(this, "profileLastRan", _descriptor5, this);
      }, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "debounceTimeoutIds", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "throttleTimeoutIds", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "throttlePreviousTimestamps", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "throttleTrailingArgs", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "profileLastRan", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class);
      var META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';

      function metaFor(obj) {
        if (obj.hasOwnProperty(META_KEY) === false) {
          defineProperty(obj, META_KEY, {
            // Defaults: NOT enumerable, configurable, or writable
            value: new Meta()
          });
        }

        return obj[META_KEY];
      }

      var getOwnKeys = getOwnPropertySymbols ? function (object) {
        return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
      } : getOwnPropertyNames;

      function getOwnPropertyDescriptors(obj) {
        var descs = {};
        getOwnKeys(obj).forEach(function (key) {
          return descs[key] = getOwnPropertyDescriptor(obj, key);
        });
        return descs;
      }

      function createDefaultSetter(key) {
        return function set(newValue) {
          Object.defineProperty(this, key, {
            configurable: true,
            writable: true,
            // IS enumerable when reassigned by the outside word
            enumerable: true,
            value: newValue
          });
          return newValue;
        };
      }

      function bind(fn, context) {
        if (fn.bind) {
          return fn.bind(context);
        } else {
          return function __autobind__() {
            return fn.apply(context, arguments);
          };
        }
      }

      var warn = function () {
        if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== 'object' || !console || typeof console.warn !== 'function') {
          return function () {};
        } else {
          return bind(console.warn, console);
        }
      }();

      var seenDeprecations = {};

      function internalDeprecation(msg) {
        if (seenDeprecations[msg] !== true) {
          seenDeprecations[msg] = true;
          warn('DEPRECATION: ' + msg);
        }
      }
      /***/

    },
    /* 8 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */


      function isObject(value) {
        var type = _typeof(value);

        return value != null && (type == 'object' || type == 'function');
      }
      /* harmony default export */


      __webpack_exports__["a"] = isObject;
      /***/
    },
    /* 9 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
      /** Built-in value references. */


      var _Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
      /* default */
      ].Symbol;
      /* harmony default export */

      __webpack_exports__["a"] = _Symbol;
      /***/
    },
    /* 10 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(20);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** Detect free variable `self`. */


      var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
      /** Used as a reference to the global object. */

      var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a"
      /* default */
      ] || freeSelf || Function('return this')();
      /* harmony default export */

      __webpack_exports__["a"] = root;
      /***/
    },
    /* 11 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */

      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      /* harmony default export */


      __webpack_exports__["a"] = eq;
      /***/
    },
    /* 12 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(19);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(26);
      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */


      function isArrayLike(value) {
        return value != null && Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a"
        /* default */
        ])(value.length) && !Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = isArrayLike;
      /***/
    },
    /* 13 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toInteger;

      function toInteger(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }

        var number = Number(dirtyNumber);

        if (isNaN(number)) {
          return number;
        }

        return number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      /***/

    },
    /* 14 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = requiredArgs;

      function requiredArgs(required, args) {
        if (args.length < required) {
          throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
        }
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanSwitch__ = __webpack_require__(46);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanSwitch__["a"
      /* default */
      ];
      /***/
    },
    /* 16 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__ = __webpack_require__(65);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 17 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__ = __webpack_require__(18);
      /**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */


      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a"
        /* default */
        ]) {
          Object(__WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a"
          /* default */
          ])(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          });
        } else {
          object[key] = value;
        }
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseAssignValue;
      /***/
    },
    /* 18 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(70);

      var defineProperty = function () {
        try {
          var func = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a"
          /* default */
          ])(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) {}
      }();
      /* harmony default export */


      __webpack_exports__["a"] = defineProperty;
      /***/
    },
    /* 19 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObject_js__ = __webpack_require__(8);
      /** `Object#toString` result references. */


      var asyncTag = '[object AsyncFunction]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          proxyTag = '[object Proxy]';
      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */

      function isFunction(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__isObject_js__["a"
        /* default */
        ])(value)) {
          return false;
        } // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.


        var tag = Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isFunction;
      /***/
    },
    /* 20 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (global) {
        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `global` from Node.js. */


        var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
        /* harmony default export */

        __webpack_exports__["a"] = freeGlobal;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(21));
      /***/
    },
    /* 21 */

    /***/
    function (module, exports) {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        // This works if the window reference is available
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;
      /***/
    },
    /* 22 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__identity_js__ = __webpack_require__(23);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__overRest_js__ = __webpack_require__(79);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__setToString_js__ = __webpack_require__(80);
      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */


      function baseRest(func, start) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__setToString_js__["a"
        /* default */
        ])(Object(__WEBPACK_IMPORTED_MODULE_1__overRest_js__["a"
        /* default */
        ])(func, start, __WEBPACK_IMPORTED_MODULE_0__identity_js__["a"
        /* default */
        ]), func + '');
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseRest;
      /***/
    },
    /* 23 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */

      function identity(value) {
        return value;
      }
      /* harmony default export */


      __webpack_exports__["a"] = identity;
      /***/
    },
    /* 24 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */

      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }

        return func.apply(thisArg, args);
      }
      /* harmony default export */


      __webpack_exports__["a"] = apply;
      /***/
    },
    /* 25 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(11);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__ = __webpack_require__(12);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isIndex_js__ = __webpack_require__(27);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isObject_js__ = __webpack_require__(8);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */


      function isIterateeCall(value, index, object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_3__isObject_js__["a"
        /* default */
        ])(object)) {
          return false;
        }

        var type = _typeof(index);

        if (type == 'number' ? Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__["a"
        /* default */
        ])(object) && Object(__WEBPACK_IMPORTED_MODULE_2__isIndex_js__["a"
        /* default */
        ])(index, object.length) : type == 'string' && index in object) {
          return Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a"
          /* default */
          ])(object[index], value);
        }

        return false;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isIterateeCall;
      /***/
    },
    /* 26 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used as references for various `Number` constants. */

      var MAX_SAFE_INTEGER = 9007199254740991;
      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */

      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isLength;
      /***/
    },
    /* 27 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** Used as references for various `Number` constants. */


      var MAX_SAFE_INTEGER = 9007199254740991;
      /** Used to detect unsigned integer values. */

      var reIsUint = /^(?:0|[1-9]\d*)$/;
      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */

      function isIndex(value, length) {
        var type = _typeof(value);

        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isIndex;
      /***/
    },
    /* 28 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseTimes_js__ = __webpack_require__(85);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isArguments_js__ = __webpack_require__(86);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(29);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isBuffer_js__ = __webpack_require__(88);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__isIndex_js__ = __webpack_require__(27);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__ = __webpack_require__(90);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */

      function arrayLikeKeys(value, inherited) {
        var isArr = Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["a"
        /* default */
        ])(value),
            isArg = !isArr && Object(__WEBPACK_IMPORTED_MODULE_1__isArguments_js__["a"
        /* default */
        ])(value),
            isBuff = !isArr && !isArg && Object(__WEBPACK_IMPORTED_MODULE_3__isBuffer_js__["a"
        /* default */
        ])(value),
            isType = !isArr && !isArg && !isBuff && Object(__WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__["a"
        /* default */
        ])(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? Object(__WEBPACK_IMPORTED_MODULE_0__baseTimes_js__["a"
        /* default */
        ])(value.length, String) : [],
            length = result.length;

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
          key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
          Object(__WEBPACK_IMPORTED_MODULE_4__isIndex_js__["a"
          /* default */
          ])(key, length)))) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = arrayLikeKeys;
      /***/
    },
    /* 29 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */

      var isArray = Array.isArray;
      /* harmony default export */

      __webpack_exports__["a"] = isArray;
      /***/
    },
    /* 30 */

    /***/
    function (module, exports) {
      module.exports = function (originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule); // module.parent = undefined by default

          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function get() {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function get() {
              return module.i;
            }
          });
          Object.defineProperty(module, "exports", {
            enumerable: true
          });
          module.webpackPolyfill = 1;
        }

        return module;
      };
      /***/

    },
    /* 31 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */

      function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
        return value === proto;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isPrototype;
      /***/
    },
    /* 32 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isPlainObject_js__ = __webpack_require__(97);
      /** `Object#toString` result references. */


      var domExcTag = '[object DOMException]',
          errorTag = '[object Error]';
      /**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */

      function isError(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value)) {
          return false;
        }

        var tag = Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !Object(__WEBPACK_IMPORTED_MODULE_2__isPlainObject_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = isError;
      /***/
    },
    /* 33 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */

      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = overArg;
      /***/
    },
    /* 34 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */

      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = arrayMap;
      /***/
    },
    /* 35 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reInterpolate = /<%=([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reInterpolate;
      /***/
    },
    /* 36 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseToString_js__ = __webpack_require__(109);
      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */


      function toString(value) {
        return value == null ? '' : Object(__WEBPACK_IMPORTED_MODULE_0__baseToString_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = toString;
      /***/
    },
    /* 37 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = readonly;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function handleDescriptor(target, key, descriptor) {
        descriptor.writable = false;
        return descriptor;
      }

      function readonly() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 38 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = utcToZonedTime;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__ = __webpack_require__(39);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__ = __webpack_require__(118);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__toDate__ = __webpack_require__(121);
      /**
       * @name utcToZonedTime
       * @category Time Zone Helpers
       * @summary Get a date/time representing local time in a given time zone from the UTC date
       *
       * @description
       * Returns a date instance with values representing the local time in the time zone
       * specified of the UTC time from the date provided. In other words, when the new date
       * is formatted it will show the equivalent hours in the target time zone regardless
       * of the current system time zone.
       *
       * @param {Date|String|Number} date - the date with the relevant UTC time
       * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
       * @returns {Date} the new date with the equivalent time in the time zone
       * @throws {TypeError} 2 arguments required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // In June 10am UTC is 6am in New York (-04:00)
       * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
       * //=> Jun 25 2014 06:00:00
       */


      function utcToZonedTime(dirtyDate, timeZone, options) {
        var date = Object(__WEBPACK_IMPORTED_MODULE_2__toDate__["a"
        /* default */
        ])(dirtyDate, options); // This date has the UTC time values of the input date at the system time zone

        var utcDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()); // We just need to apply the offset indicated by the time zone to this localized date

        var offsetMilliseconds = Object(__WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__["a"
        /* default */
        ])(timeZone, utcDate);
        return offsetMilliseconds ? Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__["a"
        /* default */
        ])(utcDate, offsetMilliseconds) : utcDate;
      }
      /***/

    },
    /* 39 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzParseTimezone;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__ = __webpack_require__(117);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var patterns = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-])(\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
        timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      }; // Parse various time zone offset formats to an offset in milliseconds

      function tzParseTimezone(timezoneString, date) {
        var token;
        var absoluteOffset; // Z

        token = patterns.timezoneZ.exec(timezoneString);

        if (token) {
          return 0;
        }

        var hours; // hh

        token = patterns.timezoneHH.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);

          if (!validateTimezone(hours)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // hh:mm or hhmm


        token = patterns.timezoneHHMM.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);
          var minutes = parseInt(token[3], 10);

          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // IANA time zone


        token = patterns.timezoneIANA.exec(timezoneString);

        if (token) {
          // var [fYear, fMonth, fDay, fHour, fMinute, fSecond] = tzTokenizeDate(date, timezoneString)
          var tokens = Object(__WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__["a"
          /* default */
          ])(date, timezoneString);
          var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3], tokens[4], tokens[5]);
          var timestampWithMsZeroed = date.getTime() - date.getTime() % 1000;
          return -(asUTC - timestampWithMsZeroed);
        }

        return 0;
      }

      function validateTimezone(hours, minutes) {
        if (minutes != null && (minutes < 0 || minutes > 59)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 40 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__EventsMixin__ = __webpack_require__(123);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__EventsMixin__["b"];
      });
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* unused harmony default export */


      var _unused_webpack_default_export = __WEBPACK_IMPORTED_MODULE_0__EventsMixin__["a"
      /* EventsMixin */
      ];
      /***/
    },
    /* 41 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeInput__ = __webpack_require__(124);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeInput__["a"
      /* default */
      ];
      /***/
    },
    /* 42 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__ = __webpack_require__(43);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanRenderer__ = __webpack_require__(51);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__BooleanFilter__ = __webpack_require__(53);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__NumberEditor__ = __webpack_require__(57);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__TextEditor__ = __webpack_require__(61);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__TemplateRenderer__ = __webpack_require__(16);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__ImageRenderer__ = __webpack_require__(113);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__DateTimeFilter__ = __webpack_require__(115);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__DateTimeEditor__ = __webpack_require__(129);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_1__BooleanRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanFilter", function () {
        return __WEBPACK_IMPORTED_MODULE_2__BooleanFilter__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_3__NumberEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TextEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_4__TextEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TemplateRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_5__TemplateRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "ImageRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_6__ImageRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateTimeFilter", function () {
        return __WEBPACK_IMPORTED_MODULE_7__DateTimeFilter__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateTimeEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_8__DateTimeEditor__["a"];
      });
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /***/

    },
    /* 43 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__ = __webpack_require__(44);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 44 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__ = __webpack_require__(15);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Booleans Editor
       *
       * Handle boolean values Editing
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanUsedTrueValue**   | undefined    | the value to return when the editor changes the current cell value to true. in case it is undefined then we use the first item in **booleanTrueValue[]**
       * | **booleanUsedFalseValue**   | undefined    | the value to return when the editor changes the current cell value to false. in case it is undefined then we use the first item in **booleanFalseValue[]**
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanEditor = /*#__PURE__*/function (_Component) {
        _inherits(BooleanEditor, _Component);

        var _super = _createSuper(BooleanEditor);

        function BooleanEditor() {
          _classCallCheck(this, BooleanEditor);

          return _super.apply(this, arguments);
        }

        _createClass(BooleanEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var _this = this;

            if (params.keyPress !== null) {
              this._value = Boolean(params.keyPress);
            } else if (params.charPress !== null) {
              this._value = Boolean(params.charPress);
            }

            this._trueValue = [].concat(this.getOption('booleanTrueValue', params, [true]));
            this._falseValue = [].concat(this.getOption('booleanFalseValue', params, [false]));
            this._returnTrueValue = this.getOption('booleanUsedTrueValue', params, this._trueValue[0]);
            this._returnFalseValue = this.getOption('booleanUsedFalseValue', params, this._falseValue[0]);
            this._trueValue = this._trueValue.map(function (x) {
              return String(x);
            });
            this._falseValue = this._falseValue.map(function (x) {
              return String(x);
            });
            this.focusAfterAttached = params.cellStartedEdit;

            if (this.focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                this._value = false;
              } else if (params.charPress !== null) {
                this._value = params.charPress;
              } else {
                this._value = params.value;
              }
            } else {
              this._value = params.value;
            }

            this._value = this._convertValue(this._value, this._trueValue, this._falseValue);
            this._switcher = new __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__["a"
            /* default */
            ](this._value, function (switcher) {
              _this._value = _this._convertValue(switcher.isChecked(), _this._trueValue, _this._falseValue);
            });

            this._switcher.init(params);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._switcher.getGui();
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._switcher.destroy();
          }
          /**
           * Gets called once after GUI is attached to DOM.
           * Make sure the container is always focused and listening to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (this.focusAfterAttached) {
              this.focusIn();
            }
          }
          /**
           * Get the final value to the grid, the result of the editing
           *
           * @return {Boolean}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._value ? this._returnTrueValue : this._returnFalseValue;
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           *
           * @return {Boolean}
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._switcher.setDisabled(false);

            this._switcher.focus();

            return true;
          }
          /**
           * If doing full row edit, then gets called when tabbing out of the cell.
           *
           * @return {Boolean}
           */

        }, {
          key: "focusOut",
          value: function focusOut() {
            this._switcher.setDisabled(true);

            return true;
          }
          /**
           * @param {Boolean} value the current cell value
           * @param {String|Number} trueValue true value alias
           * @param {String|Number} falseValue false value alias
           */

        }, {
          key: "_convertValue",
          value: function _convertValue(value, trueValue, falseValue) {
            var valueAsString = String(value);
            return trueValue.indexOf(valueAsString) > -1 ? true : falseValue.indexOf(valueAsString) > -1 ? false : value;
          }
        }]);

        return BooleanEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = BooleanEditor;
      /***/
    },
    /* 45 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * The base component class
       *
       * This class is the abstract class which all components should use
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var Component = /*#__PURE__*/function () {
        function Component() {
          _classCallCheck(this, Component);

          this._gui = null;
        }

        _createClass(Component, [{
          key: "init",

          /**
           * Initialize the component
           *
           * @param {Object} params
           *
           * @return void
           */
          // eslint-disable-next-line no-unused-vars
          value: function init(params) {
            console.warn("".concat(this.constructor.name, " does not implement the [init] method"));
          }
          /**
           * Return the DOM element of the component, this is what the grid puts into the cell
           *
           * @return {HTMLElement}
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           * Gets called when the component is destroyed. If your custom component needs to do
           * any resource cleaning up, do it here.
           */

        }, {
          key: "destroy",
          value: function destroy() {// pass
          }
          /**
           * Find the required option value
           *
           * This function will try to find the passed option's value in the following order
           *
           *  1. params
           *  2. Search `params.colDef`
           *  3. Search `params.context.AGridComponentsMetaConfig[COLUMN_ID]` or `params.context.meta[COLUMN_ID]`
           *  4. Search `params.context.AGridComponentsMetaConfig` or `params.context.meta`
           *  5. Search `params.context`
           *  6. If none found return the fallback
           *
           * @param {String} name the name of the option
           * @param {params} params an object used to search for the option
           * @param {String} fallback a value to return in case the option can not be found
           */

        }, {
          key: "getOption",
          value: function getOption(name, params) {
            var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var option;

            if (params && params.hasOwnProperty(name) && params[name] !== null) {
              option = params[name];
            } else {
              // try to fetch from the column def first
              if (params.hasOwnProperty('colDef') && params.colDef.hasOwnProperty(name) && params.colDef[name] !== null) {
                option = params.colDef[name];
              } else {
                // try to fetch from AGridComponentsMetaConfig|meta in the context
                var AGridComponentsMetaConfig = null;

                if (params.hasOwnProperty('context')) {
                  AGridComponentsMetaConfig = params.context.AGridComponentsMetaConfig || params.context.meta;
                }

                if (AGridComponentsMetaConfig && AGridComponentsMetaConfig.hasOwnProperty(params.column.colId) && AGridComponentsMetaConfig[params.column.colId].hasOwnProperty(name) && AGridComponentsMetaConfig[params.column.colId][name] !== null) {
                  option = AGridComponentsMetaConfig[params.column.colId][name];
                } else if (AGridComponentsMetaConfig && AGridComponentsMetaConfig.hasOwnProperty(name) && AGridComponentsMetaConfig[name] !== null) {
                  option = AGridComponentsMetaConfig[name];
                } else {
                  // try to fetch from the context object itself
                  var context = params.context;

                  if (context && context.hasOwnProperty(name) && context[name] !== null) {
                    option = context[name];
                  } else {
                    // try to check params itself or fallback to default
                    option = fallback;
                  }
                }
              }
            }

            return typeof option !== 'undefined' ? option : fallback;
          }
          /**
           * Get Window Instance
           *
           * @param {params} params an object used to search for the window instance
           *
           * @return {Window}
           */

        }, {
          key: "getWin",
          value: function getWin(params) {
            var win = this.getOption('window', params) || window || null;

            if (!win) {
              throw new Error('Current environment does not support window');
            }

            return win;
          }
          /**
           * Get document Instance
           *
           * @param {params} params an object used to search for the document instance
           *
           * @return {HTMLDocument}
           */

        }, {
          key: "getDoc",
          value: function getDoc(params) {
            var doc = this.getOption('document', params) || document || null;

            if (!doc) {
              throw new Error('Current environment does not support document');
            }

            return doc;
          }
        }]);

        return Component;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = Component;
      /***/
    },
    /* 46 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(48);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Boolean Renderer
       *
       * Simple toggle switch to handle boolean values
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanSwitch = (_class = /*#__PURE__*/function (_Component) {
        _inherits(BooleanSwitch, _Component);

        var _super = _createSuper(BooleanSwitch);
        /**
         * Construct new BooleanSwitch Component
         *
         * @param {Boolean} [initialValue = false] the default state , checked or unchecked
         * @param {Function} [listener = null] a listener to be called when the state is changed
         */


        function BooleanSwitch() {
          var _this;

          var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var listener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          _classCallCheck(this, BooleanSwitch);

          _this = _super.call(this);

          _this.setChecked(initialValue);

          _this.setListener(listener);

          _this.setDisabled(false);

          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(BooleanSwitch, [{
          key: "init",
          value: function init(params) {
            this._params = params;
            this._onClick = this._onClick.bind(this);
            this._onKeydown = this._onKeydown.bind(this);
            this._gui = this.getDoc(params).createElement('div');
            this._gui.className = 'boolSwitch__wrapper';
            this._gui.tabIndex = -1;
            this.render();
          }
          /**
           * Render the switch slider and hidden input.
           */

        }, {
          key: "render",
          value: function render() {
            var doc = this.getDoc(this._params);
            var boolSwitch = document.createElement('div');
            boolSwitch.className = 'boolSwitch'; // input

            this._input = doc.createElement('input');
            this._input.id = "el-".concat(Math.random());
            this._input.name = 'checkbox';
            this._input.className = 'boolSwitch__checkbox';
            this._input.type = 'checkbox';
            this._input.checked = this.isChecked();
            this._input.disabled = this.isDisabled();
            this._input.tabIndex = '0'; // label

            var label = document.createElement('label');
            label.className = 'boolSwitch__label';
            label["for"] = this._input.id;
            label.innerHTML =
            /* html */
            "\n      <span class=\"boolSwitch__inner\"></span>\n      <span class=\"boolSwitch__switch\"></span>\n    "; // attache input and slider to component

            boolSwitch.appendChild(this._input);
            boolSwitch.appendChild(label);
            boolSwitch.addEventListener('click', this._onClick);

            this._gui.addEventListener('keydown', this._onKeydown);

            this._gui.appendChild(boolSwitch);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var boolSwitch = this._gui.querySelector('.boolSwitch');

            boolSwitch.removeEventListener('click', this._onClick);

            this._gui.removeEventListener('keydown', this._onKeydown);
          }
          /**
           * Focus the component
           */

        }, {
          key: "focus",
          value: function focus() {
            this._gui.focus();

            this._input.focus();
          }
          /**
           * Set a listener to be called when the switch state is changed
           *
           * @param {Function} listener
           */

        }, {
          key: "setListener",
          value: function setListener(listener) {
            this._listener = listener;
          }
          /**
           * Get the listener instance , if
           *
           * @return {Function|null}
           */

        }, {
          key: "getListener",
          value: function getListener() {
            return this._listener;
          }
          /**
           * Set checked
           *
           * @param {Boolean} value true to check , false to uncheck
           */

        }, {
          key: "setChecked",
          value: function setChecked(value) {
            this._checked = value;

            if (this._input) {
              this._input.checked = value;
            }
          }
          /**
           * Check the if switch is checked
           *
           * @return {Boolean}  true when checked , false otherwise
           */

        }, {
          key: "isChecked",
          value: function isChecked() {
            return this._checked;
          }
          /**
           * Toggle the component state
           */

        }, {
          key: "toggle",
          value: function toggle() {
            this.setChecked(!this.isChecked());
          }
          /**
           * Set disabled
           *
           * @param {Boolean} value true to disabled , false to enable
           */

        }, {
          key: "setDisabled",
          value: function setDisabled(value) {
            this._disabled = value;

            if (this._input) {
              this._input.disabled = value;
            }
          }
          /**
           * Check if the switch is disabled
           *
           * @return {Boolean} true when disabled , false otherwise
           */

        }, {
          key: "isDisabled",
          value: function isDisabled() {
            return this._disabled;
          }
          /**
           * The default click listener of the switch. It will toggle the state and fire any registered listener
           *
           * @param {Event} e the event object
           *
           * @protected
           */

        }, {
          key: "_onClick",
          value: function _onClick(e) {
            if (this._disabled) {
              return false;
            }

            this.toggle();

            if (this._listener) {
              this._listener(this);
            }
          }
          /**
           * The default key listener of the switch. It will toggle the state using keyboard keys (left , right , space)
           * and fire any registered listener
           *
           * @param {Event} e  the event object
           *
           * @protected
           */

        }, {
          key: "_onKeydown",
          value: function _onKeydown(e) {
            if (this._disabled) {
              return false;
            }

            var key = e.which || e.keyCode; // space

            if (key == 32) {
              this.toggle();

              if (this._listener) {
                this._listener(this);
              }

              e.stopPropagation();
            } // right
            else if (key == 39) {
                this.setChecked(true);

                if (this._listener) {
                  this._listener(this);
                }

                e.stopPropagation();
              } // left
              else if (key == 37) {
                  this.setChecked(false);

                  if (this._listener) {
                    this._listener(this);
                  }

                  e.stopPropagation();
                }
          }
        }]);

        return BooleanSwitch;
      }(__WEBPACK_IMPORTED_MODULE_2__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onKeydown", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onKeydown"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = BooleanSwitch;
      /***/
    },
    /* 47 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = lazyInitialize;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      var defineProperty = Object.defineProperty;

      function handleDescriptor(target, key, descriptor) {
        var configurable = descriptor.configurable,
            enumerable = descriptor.enumerable,
            initializer = descriptor.initializer,
            value = descriptor.value;
        return {
          configurable: configurable,
          enumerable: enumerable,
          get: function get() {
            // This happens if someone accesses the
            // property directly on the prototype
            if (this === target) {
              return;
            }

            var ret = initializer ? initializer.call(this) : value;
            defineProperty(this, key, {
              configurable: configurable,
              enumerable: enumerable,
              writable: true,
              value: ret
            });
            return ret;
          },
          set: Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["b"
          /* createDefaultSetter */
          ])(key)
        };
      }

      function lazyInitialize() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 48 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(49);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 49 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".ag-cell-inline-editing .boolSwitch__wrapper{margin:auto 11px}.boolSwitch__wrapper{display:flex;width:100%;height:100%;align-items:center;outline:none;padding-left:6px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.boolSwitch{position:relative;width:55px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.boolSwitch__checkbox{display:none}.boolSwitch__label{display:block;overflow:hidden;cursor:pointer;border:2px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:20px}.boolSwitch__inner{display:block;width:200%;margin-left:-100%;transition:margin 0.3s ease-in 0s}.boolSwitch__inner:before,.boolSwitch__inner:after{display:block;float:left;width:50%;height:15px;padding:0;line-height:15px;font-size:14px;color:white;font-family:'Segoe UI Symbol', Trebuchet, Arial, sans-serif;font-weight:bold;box-sizing:border-box}.boolSwitch__inner:before{content:'\\2714';padding-left:10px;background-color:var(--ag-checkbox-checked-color, var(--ag-alpine-active-color, #2196f3));color:#ffffff}.boolSwitch__inner:after{content:'\\2718';padding-right:10px;background-color:var(--ag-background-color);color:var(--ag-input-border-color, var(--ag-border-color, #babfc7));text-align:right}.boolSwitch__switch{display:block;width:18px;margin:1px;background:#ffffff;position:absolute;top:0;bottom:0;right:35px;border:2px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:20px;transition:all 0.3s ease-in 0s}.boolSwitch__checkbox:checked+.boolSwitch__label .boolSwitch__inner{margin-left:0}.boolSwitch__checkbox:checked+.boolSwitch__label .boolSwitch__switch{right:0px}\n", ""]); // exports

      /***/
    },
    /* 50 */

    /***/
    function (module, exports) {
      /**
       * When source maps are enabled, `style-loader` uses a link element with a data-uri to
       * embed the css on the page. This breaks all relative urls because now they are relative to a
       * bundle instead of the current page.
       *
       * One solution is to only use full urls, but that may be impossible.
       *
       * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
       *
       * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
       *
       */
      module.exports = function (css) {
        // get current location
        var location = typeof window !== "undefined" && window.location;

        if (!location) {
          throw new Error("fixUrls requires window.location");
        } // blank or null?


        if (!css || typeof css !== "string") {
          return css;
        }

        var baseUrl = location.protocol + "//" + location.host;
        var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

        /*
        This regular expression is just a way to recursively match brackets within
        a string.
        	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
           (  = Start a capturing group
             (?:  = Start a non-capturing group
                 [^)(]  = Match anything that isn't a parentheses
                 |  = OR
                 \(  = Match a start parentheses
                     (?:  = Start another non-capturing groups
                         [^)(]+  = Match anything that isn't a parentheses
                         |  = OR
                         \(  = Match a start parentheses
                             [^)(]*  = Match anything that isn't a parentheses
                         \)  = Match a end parentheses
                     )  = End Group
                     *\) = Match anything and then a close parens
                 )  = Close non-capturing group
                 *  = Match anything
              )  = Close capturing group
         \)  = Match a close parens
        	 /gi  = Get all matches, not the first.  Be case insensitive.
         */

        var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
          // strip quotes (if they exist)
          var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
            return $1;
          }).replace(/^'(.*)'$/, function (o, $1) {
            return $1;
          }); // already a full url? no change

          if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
            return fullMatch;
          } // convert the url to a full url


          var newUrl;

          if (unquotedOrigUrl.indexOf("//") === 0) {
            //TODO: should we add protocol?
            newUrl = unquotedOrigUrl;
          } else if (unquotedOrigUrl.indexOf("/") === 0) {
            // path should be relative to the base url
            newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
          } else {
            // path should be relative to current directory
            newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
          } // send back the fixed url(...)


          return "url(" + JSON.stringify(newUrl) + ")";
        }); // send back the fixed css

        return fixedCss;
      };
      /***/

    },
    /* 51 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanRenderer__ = __webpack_require__(52);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 52 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__ = __webpack_require__(15);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * Booleans Renderer
       *
       * Handle boolean values Rendering
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanTrueRenderValue**  	| switch      	| The option controls how to render `true` values. <br> **switch** is a special value used to render true values as a switch component  	|
       * | **booleanFalseRenderValue** 	| switch      	| The option controls how to render `false` values. <br> **switch** is a special value used to render true values as a switch component 	|
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`                                                                               	|
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanRenderer = /*#__PURE__*/function (_Component) {
        _inherits(BooleanRenderer, _Component);

        var _super = _createSuper(BooleanRenderer);
        /**
         * Construct new BooleanRenderer
         */


        function BooleanRenderer() {
          var _this;

          _classCallCheck(this, BooleanRenderer);

          _this = _super.call(this); // will this affect BBj bui ?

          _this._gui = document.createElement('span');
          _this._gui.className = 'boolRenderer';
          _this._gui.style.fontFamily = '"Segoe UI Symbol",Trebuchet, Arial, sans-serif';
          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(BooleanRenderer, [{
          key: "init",
          value: function init(params) {
            this.refresh(params, true);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this._switcher) {
              this._switcher.destroy();
            }
          }
          /**
           * Refresh the cell
           *
           * @param {Object} params cell renderer params
           * @param {Boolean} isInit true when this method is being called in `init` phase , false otherwise
           *
           * @return {Boolean} true if the refresh succeeded, otherwise return false.
           */
          // eslint-disable-next-line no-unused-vars

        }, {
          key: "refresh",
          value: function refresh(params, isInit) {
            var value = params.valueFormatted ? params.valueFormatted : params.value;

            if (value === null || typeof value === 'undefined') {
              this._gui.innerHTML = '';
            } else {
              value = String(value);
              var booleanTrueRenderValue = String(this.getOption('booleanTrueRenderValue', params, 'switch'));
              var booleanFalseRenderValue = String(this.getOption('booleanFalseRenderValue', params, 'switch'));
              var booleanTrueValue = [].concat(this.getOption('booleanTrueValue', params, [true])).map(function (x) {
                return String(x);
              });
              var booleanFalseValue = [].concat(this.getOption('booleanFalseValue', params, [false])).map(function (x) {
                return String(x);
              }); // handle true values

              if (booleanTrueValue.indexOf(value) > -1) {
                if (!booleanTrueRenderValue.length || booleanTrueRenderValue === 'switch') {
                  var switcher = this._getSwitcher(params);

                  switcher.setChecked(true);
                  this._gui.innerHTML = '';

                  this._gui.appendChild(switcher.getGui());
                } else {
                  this._gui.innerHTML = booleanTrueRenderValue;
                }
              } // handle false values
              else if (booleanFalseValue.indexOf(value) > -1) {
                  if (!booleanFalseRenderValue.length || booleanFalseRenderValue === 'switch') {
                    var _switcher = this._getSwitcher(params);

                    _switcher.setChecked(false);

                    this._gui.innerHTML = '';

                    this._gui.appendChild(_switcher.getGui());
                  } else {
                    this._gui.innerHTML = booleanFalseRenderValue;
                  }
                } else {
                  this._gui.innerHTML = value;
                }
            }

            return true;
          }
          /**
           * Get switch instance if available , or create it otherwise
           *
           * @param {Object} params
           *
           * @return {BooleanSwitch} switch instance
           */

        }, {
          key: "_getSwitcher",
          value: function _getSwitcher(params) {
            if (!this._switcher) {
              this._switcher = new __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__["a"
              /* default */
              ]();

              this._switcher.setDisabled(true);

              this._switcher.init(params);
            }

            return this._switcher;
          }
        }]);

        return BooleanRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = BooleanRenderer;
      /***/
    },
    /* 53 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanFilter__ = __webpack_require__(54);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanFilter__["a"
      /* default */
      ];
      /***/
    },
    /* 54 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(55);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var toTitleCase = function toTitleCase(phrase) {
        return phrase.toLowerCase().split(' ').map(function (word) {
          return word.charAt(0).toUpperCase() + word.slice(1);
        }).join(' ');
      };

      var stripHTML = function stripHTML(html) {
        var tmp = document.createElement('DIV');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
      };
      /**
       * Booleans Filter
       *
       * Handle boolean values Filtering
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanUsedTrueValue**   | undefined    | the value to use when the filter displays the true state . in case it is undefined then we use the first item in **booleanTrueValue[]**
       * | **booleanUsedFalseValue**   | undefined    | the value to use when the filter displays the false state. in case it is undefined then we use the first item in **booleanFalseValue[]**
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`
       * | **clearButton**   | false    |  Set to true to have the filter use a Clear button. The Clear button will clear the (form) details of the filter without removing any active filters on the column.
       * | **applyButton**   | false    |  Set to true to have the filter use an Apply button. If the Apply button is present, then the filter is only applied after the user hits the Apply button.
       * | **resetButton**   | false    |  Set to true to have the filter use a Reset button. The Reset button will clear the details of the filter and any active filters on that column.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanFilter = (_class = (_temp = /*#__PURE__*/function (_Component) {
        _inherits(BooleanFilter, _Component);

        var _super = _createSuper(BooleanFilter);
        /**
         * True , false translation
         *
         * @type {Object}
         */

        /**
         * Construct new BooleanFilter
         */


        function BooleanFilter() {
          var _this;

          _classCallCheck(this, BooleanFilter);

          _this = _super.call(this);
          _this._booleanFilterTranslation = {};
          _this._gui = document.createElement('div');
          _this._gui.className = 'booleanFilter ag-filter-body-wrapper';
          _this._gui.tabIndex = '0';
          return _this;
        }
        /**
         * @inheritDoc
         */


        _createClass(BooleanFilter, [{
          key: "init",
          value: function init(params) {
            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            var isClearFilter = this.getOption('clearButton', params, false);
            var isResetButton = this.getOption('resetButton', params, false);
            var isApplyButton = this.getOption('applyButton', params, false);
            this._trueValue = [].concat(this.getOption('booleanTrueValue', params, [true])).map(function (x) {
              return String(x);
            });
            this._falseValue = [].concat(this.getOption('booleanFalseValue', params, [false])).map(function (x) {
              return String(x);
            });
            this._usedTrueValue = String(this.getOption('booleanUsedTrueValue', params, this._trueValue[0]));
            this._usedFalseValue = String(this.getOption('booleanUsedFalseValue', params, this._falseValue[0]));
            this._booleanFilterTranslation = this.getOption('booleanFilterTranslation', params, {
              "true": translate('booleanTrue', toTitleCase(String(this._usedTrueValue))),
              "false": translate('booleanFalse', toTitleCase(String(this._usedFalseValue))),
              reset: translate('booleanReset', translate('resetFilter', 'Reset Filter'))
            });
            this._params = params;
            this._filterText = null;
            this._onRadioChange = this._onRadioChange.bind(this, isApplyButton); // create body

            var body = document.createElement('div');
            body.className = 'booleanFilter__body ag-filter-body';
            body.style.padding = '5px 15px';
            body.innerHTML =
            /* html */
            "\n      <div class=\"booleanFilter__body__labels\">\n\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n            <div class=\"ag-wrapper-true ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n              <input class=\"true-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"true\"/>              \n          </div> \n          <span>".concat(this._booleanFilterTranslation["true"], "</span>\n        </label>\n\n\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n            <div class=\"ag-wrapper-false ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n              <input class=\"false-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"false\"/>              \n          </div> \n          <span>").concat(this._booleanFilterTranslation["false"], "</span>\n        </label>\n          \n          ").concat(!isResetButton ?
            /* html */
            "\n              <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n                  <div class=\"ag-wrapper-reset ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper ag-checked\">\n                    <input class=\"reset-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"\" checked/>              \n                </div> \n                <span>".concat(this._booleanFilterTranslation.reset, "</span>\n              </label>                \n              ") : '', "       \n        </div>\n    ");
            body.addEventListener('change', this._onRadioChange);

            this._gui.appendChild(body); // create apply filter panel


            var applyFilterPanel = document.createElement('div');
            applyFilterPanel.className = "booleanFilter__body__applyPanel ag-filter-apply-panel ag-hidden";
            applyFilterPanel.innerHTML =
            /* html */
            "\n      <button class=\"ag-standard-button ag-filter-apply-panel-button clear ".concat(!isClearFilter && 'ag-hidden', "\" type=\"button\">").concat(translate('clearFilter', 'Clear Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button reset ").concat(!isResetButton && 'ag-hidden', "\" type=\"button\">").concat(translate('resetFilter', 'Reset Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button apply ").concat(!isApplyButton && 'ag-hidden', "\" type=\"button\">").concat(translate('applyFilter', 'Apply Filter'), "</button>\n    ");

            if (isClearFilter || isResetButton || isApplyButton) {
              applyFilterPanel.classList.remove('ag-hidden');
            }

            applyFilterPanel.addEventListener('click', this._ApplyFilterPanelButtonClick);

            this._gui.appendChild(applyFilterPanel);
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._gui.querySelector('.booleanFilter__body__labels').removeEventListener('change', this._onRadioChange);

            this._gui.querySelector('.booleanFilter__body__applyPanel').removeEventListener('click', this._ApplyFilterPanelButtonClick);
          }
          /**
           * Check whether selected filter matches the passed cell data
           *
           * @param {Object} params
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "doesFilterPass",
          value: function doesFilterPass(params) {
            // eslint-disable-next-line no-prototype-builtins
            var value = String( // eslint-disable-next-line no-prototype-builtins
            this._params.hasOwnProperty('filterValueGetter') ? this._params.filterValueGetter(params) : this._params.valueGetter(params));
            return this._filterText === 'true' ? this._trueValue.indexOf(value) > -1 : this._falseValue.indexOf(value) > -1;
          }
          /**
           * Check whether the component is applying any filter on the column
           *
           * @return {Boolean}
           **/

        }, {
          key: "isFilterActive",
          value: function isFilterActive() {
            return this._filterText !== null && this._filterText !== undefined && this._filterText !== '';
          }
          /**
           * Gets the filter state. If filter is not active, then should return null/undefined.
           * The grid calls getModel() on all active filters when gridApi.getFilterModel() is called.
           *
           * @return Object | null the filter state
           */

        }, {
          key: "getModel",
          value: function getModel() {
            if (!this.isFilterActive()) {
              return null;
            }

            var model = {
              value: this._filterText,
              filterType: 'boolean'
            };
            return model;
          }
          /**
           * Restores the filter state. Called by the grid after gridApi.setFilterModel(model) is called.
           * The grid will pass undefined/null to clear the filter.
           *
           * @param {Object | null} model
           */

        }, {
          key: "setModel",
          value: function setModel(model) {
            /* eslint-disable no-prototype-builtins */
            this._filterText = model && model.hasOwnProperty('value') ? model.value : '';
            var filterTextAsString = String(this._filterText);

            var body = this._gui.querySelector('.booleanFilter__body');

            body.querySelectorAll('input[type="radio"]').forEach(function (i) {
              if (i.value == filterTextAsString) {
                i.checked = true;
              } else {
                i.checked = false;
              }
            });
          }
          /**
           * Get the filter model as plain string to display in the floating filter input
           *
           * @param {Object | null} model
           */

        }, {
          key: "getModelAsString",
          value: function getModelAsString(model) {
            if (!model) {
              return '';
            }

            return stripHTML(model.value === 'true' ? this._booleanFilterTranslation["true"] : this._booleanFilterTranslation["false"]);
          }
          /**
           * Reset the filter state
           */

        }, {
          key: "reset",
          value: function reset() {
            var body = this._gui.querySelector('.booleanFilter__body');

            body.querySelectorAll('input[type="radio"]').forEach(function (i) {
              i.checked = false;
            });
            body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
            body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

            try {
              body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
            } catch (e) {
              /* pass */
            }

            this._filterText = null;
          }
          /**
           * Listen to selection changes in the filter radio buttons and update the current filter text
           *
           * @param {Event} e
           */

        }, {
          key: "_onRadioChange",
          value: function _onRadioChange(isApplyButton, e) {
            var target = e.target;
            this._filterText = target.value;

            var body = this._gui.querySelector('.booleanFilter__body');

            if (body) {
              if (target.classList.contains('true-input')) {
                body.querySelector('.ag-wrapper-true').classList.add('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
                } catch (e) {
                  /* pass */
                }
              } else if (target.classList.contains('false-input')) {
                body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.add('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
                } catch (e) {
                  /* pass */
                }
              } else {
                body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.add('ag-checked');
                } catch (e) {
                  /* pass */
                }
              }
            }

            if (false === isApplyButton) {
              this._params.filterChangedCallback();
            }
          }
          /**
           * Listen to the button clicks in the buttons panel and apply the chosen action
           *
           * @param {Event} e
           */

        }, {
          key: "_ApplyFilterPanelButtonClick",
          value: function _ApplyFilterPanelButtonClick(e) {
            var target = e.target;

            if (target.nodeName === 'BUTTON') {
              if (target.classList.contains('reset')) {
                this.reset();

                this._params.filterChangedCallback();
              } else if (target.classList.contains('clear')) {
                this.reset();
              } else if (target.classList.contains('apply')) {
                this._params.filterChangedCallback();
              }
            }
          }
        }]);

        return BooleanFilter;
      }(__WEBPACK_IMPORTED_MODULE_2__Component__["a"
      /* default */
      ]), _temp), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_ApplyFilterPanelButtonClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_ApplyFilterPanelButtonClick"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = BooleanFilter;
      /***/
    },
    /* 55 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(56);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 56 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".booleanFilter__body__labels label{display:block;padding:6px}.booleanFilter__body__labels label{display:block;padding:6px 0}.booleanFilter__body__labels label span{padding-left:6px}\n", ""]); // exports

      /***/
    },
    /* 57 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberEditor__ = __webpack_require__(58);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 58 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(59);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **numberMinValue**   | undefined    | min allowed value
       * | **numberMaxValue**   | undefined    | max allowed value
       * | **numberStepValue**       | undefined  	| number of step by increment or decrement
       * | **numberMask**       | undefined  	| a bbj number mask to validate the number against
       * |**numberGroupingSeparator** | , | a char which will be used as a grouping separator. The options is used only when **numberMask** is defined |
       * |**numberDecimalSeparator** | . | a char which will be used as a decimal separator. The options is used only when **numberMask** is defined  |
       * |**numberForceTrailingZeros** | false | Affects the output by switching the way a mask with "#" characters in the trailing positions is filled. for example, the function NumberMask.mask(.10:"#.##") returns .10 instead of .1 . The options is used only when **numberMask** is defined|
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberEditor = (_class = /*#__PURE__*/function (_Component) {
        _inherits(NumberEditor, _Component);

        var _super = _createSuper(NumberEditor);

        function NumberEditor() {
          _classCallCheck(this, NumberEditor);

          return _super.apply(this, arguments);
        }

        _createClass(NumberEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var min = this.getOption('numberMinValue', params);
            var max = this.getOption('numberMaxValue', params);
            var step = this.getOption('numberStepValue', params);
            var mask = this.getOption('numberMask', params);
            var startValue;
            this._focusAfterAttached = params.cellStartedEdit;

            if (this._focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                startValue = '';
              } else if (params.charPress) {
                startValue = params.charPress;
              } else {
                startValue = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this._highlightAllOnFocus = true;
                }
              }
            } else {
              startValue = params.value;
            } // make params it accessible from tall methods


            this._params = params; // create the input wrapper

            this._gui = document.createElement('label');
            this._gui.className = 'numberEditor ag-cell-edit-wrapper';
            this._gui.tabIndex = '0';
            this._gui.innerHTML =
            /* html */
            "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // create the input

            this._inputGeneratedId = Math.random().toString(16).slice(2, 10); // generate random id

            this._input = document.createElement('input');
            this._input.className = 'numberEditor__input ag-cell-edit-input';
            this._input.id = "el-".concat(this._inputGeneratedId);
            this._input.type = mask ? 'text' : 'number';
            this._input.value = startValue;
            this._input.tabIndex = 0; // place the input inside the wrapper

            this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

            if (min !== null) {
              mask ? this._input.dataset.min = min : this._input.min = min;
            }

            if (max !== null) {
              mask ? this._input.dataset.max = max : this._input.max = max;
            }

            if (step !== null) {
              mask ? this._input.dataset.step = step : this._input.step = step;
            } // If there is a mask then we use the `Basis.InputMasking.NumberInput`


            if (mask) {
              var groupingSeparator = this.getOption('numberGroupingSeparator', params, this.getOption('numberGroupSep', params));
              var decimalSeparator = this.getOption('numberDecimalSeparator', params, this.getOption('numberDecimalSep', params));
              var forceTrailingZeros = this.getOption('numberForceTrailingZeros', params);

              if (groupingSeparator !== null) {
                this._input.dataset.groupingSeparator = groupingSeparator;
              }

              if (decimalSeparator !== null) {
                this._input.dataset.decimalSeparator = decimalSeparator;
              }

              if (forceTrailingZeros !== null) {
                this._input.dataset.forceTrailingZeros = forceTrailingZeros;
              }

              this._input.dataset.mask = mask;
              this._numberInput = new Basis.InputMasking.NumberInput({
                elements: [this._input],
                // doc: this.getDoc(params),
                onUpdate: this._onNumberInputUpdate,
                onInvalid: this._onNumberInputInvalid
              });
            } else {
              this._input.addEventListener('keydown', this._onInputKeyDownUp);

              this._input.addEventListener('keyup', this._onInputKeyDownUp);

              this._input.addEventListener('change', this._onChange);
            }

            this._gui.addEventListener('keydown', this._onComponentKeyDown); // update `currentValue` the value which this component is managing


            this._currentValue = startValue;
            this.__isMasked__ = mask && mask.length;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (!this.__isMasked__) {
              this._input.removeEventListener('keydown', this._onInputKeyDownUp);

              this._input.removeEventListener('keyup', this._onInputKeyDownUp);

              this._input.removeEventListener('change', this._onChange);
            } else {
              this._numberInput.destroy();
            }

            this._gui.removeEventListener('keydown', this._onComponentKeyDown);
          }
          /**
           * Gets called once after GUI is attached to DOM.
           *
           * Make sure container is always focused to listen to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (!this.__isMasked__) {
              this._validateInput(this._input);
            }

            if (this._highlightAllOnFocus) {
              this._input.select();
            } else {
              if (this._focusAfterAttached) {
                this.focusIn();
              }
            }
          }
          /**
           * Get The component value
           *
           * @return {Number}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            var casted = Number(this._currentValue);
            var retValue = isNaN(casted) ? this._currentValue : casted;
            return this.__isMasked__ ? retValue : this._params.parseValue(retValue);
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            if (!this.__isMasked__) {
              this._input.focus();
            } else {
              this._input.click();
            }
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * Update `currentValue` when the checkbox value is changed
           */

        }, {
          key: "_onChange",
          value: function _onChange(event) {
            var isValid = this._validateInput(event.target);

            if (isValid) {
              this._currentValue = this._input.value;
            }
          }
          /**
           * Update the current value when the NumberInput components fire the update
           * event.
           *
           * @param {String} _masked  the masked value
           * @param {Number} unmasked  the unmasked value
           */

        }, {
          key: "_onNumberInputUpdate",
          value: function _onNumberInputUpdate(_masked, unmasked) {
            this._currentValue = unmasked;
            this.focusIn(); // we pass the last captured event back to the grid to handle it internally

            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * On invalid inputs , update the input with a custom validity message
           *
           * @param {String|Object} error the error message reported by NumberInput
           * @param {HTMLElement} input The input element used instance
           */

        }, {
          key: "_onNumberInputInvalid",
          value: function _onNumberInputInvalid(error, input) {
            this.focusIn(); // restore the original value of the cell

            this._currentValue = this._params.value;

            if (typeof error === 'string') {
              input.setCustomValidity(error);
            } else {
              input.setCustomValidity(error.message);
            }
          }
          /**
           * Capture all keyboard events to allow value processing by the NumberInput component
           *
           * @param {KeyboardEvent} e
           */

        }, {
          key: "_onComponentKeyDown",
          value: function _onComponentKeyDown(e) {
            var key = event.which || event.keyCode;
            var isNavigationKey = key === 37 || // left
            key === 38 || // up
            key === 39 || // right
            key === 40 || // down
            key === 33 || // page up
            key === 34 || // page down
            key === 35 || // page home
            key === 36 || // page end
            key === 13; // enter

            if (isNavigationKey) {
              event.stopPropagation(); // save the last capture key so NumberInput can pass it again to the grid.

              this.__lastComponentKeyboardPress__ = e;
            }
          }
          /**
           * Listen to key changes and validate the input
           *
           * @param {Event} event
           */

        }, {
          key: "_onInputKeyDownUp",
          value: function _onInputKeyDownUp(event) {
            var isValid = this._validateInput(event.target);

            if (!isValid) {
              return;
            }

            var key = event.which || event.keyCode;

            if (key == 38 || key == 40) {
              // top | down
              this._currentValue = this._input.value;
              event.stopPropagation();
            } else if (key == 13 || key === 9) {
              // enter
              this._currentValue = this._input.value;
            } // we pass the last captured event back to the grid to handle it internally


            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * Validate the given input element
           *
           * @param {HTMLInputElement} input input element
           *
           * @return {Boolean} true when valid , false otherwise
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (!isValid) {
              input.classList.add('bbj-mask-error');
              input.classList.remove('bbj-mask-success'); // restore the original value

              this._currentValue = this._params.value;
            } else {
              input.classList.remove('bbj-mask-error');
              input.classList.add('bbj-mask-success');
            }

            return isValid;
          }
        }]);

        return NumberEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onChange", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onNumberInputUpdate", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onNumberInputUpdate"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onNumberInputInvalid", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onNumberInputInvalid"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onComponentKeyDown", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onComponentKeyDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onInputKeyDownUp", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onInputKeyDownUp"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = NumberEditor;
      /***/
    },
    /* 59 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(60);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 60 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".numberEditor{overflow:hidden}.numberEditor .numberInputMask__wrap{width:100%;height:100%;box-sizing:border-box;outline:none;display:block;padding:0;margin:0;display:flex;flex:1 1 auto;align-items:center;line-height:normal;position:relative;overflow:hidden}.numberEditor .bbj-mask-error{box-shadow:0 -2px 0 #e91e63 inset}.numberEditor .bbj-mask-success{box-shadow:0 -2px 0 #4caf50 inset}.numberEditor__input{padding-left:6px;border:thin solid var(--ag-input-focus-border-color, rgba(33,150,243,0.4));border-radius:3px;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .numberEditor__input,.ag-theme-balham .numberEditor__input,.ag-theme-material .numberEditor__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .numberEditor__input,.ag-theme-balham-dark .numberEditor__input{background-color:var(--ag-background-color, #2d3436)}\n", ""]); // exports

      /***/
    },
    /* 61 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextEditor__ = __webpack_require__(62);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TextEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 62 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(63);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Text Editor
       *
       * Handle text values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **textPattern**   | undefined    | A regular expression that the input's value must match in order for the value to pass constraint validation
       * | **textRequired**   | undefined    | Boolean. A value is required to consider the input valid
       * | **textMask**   | undefined    | A bbj string mask to validate the value
       * | **textTitle**   | null    | The input title , when null and the **textMask** options is defined , then we use the mask as title , when set to `default` we the browser's default title , otherwise the value defined in this option
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TextEditor = (_class = /*#__PURE__*/function (_Component) {
        _inherits(TextEditor, _Component);

        var _super = _createSuper(TextEditor);

        function TextEditor() {
          _classCallCheck(this, TextEditor);

          return _super.apply(this, arguments);
        }

        _createClass(TextEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var pattern = this.getOption('textPattern', params);
            var required = this.getOption('textRequired', params);
            var mask = this.getOption('textMask', params);
            var title = this.getOption('textTitle', params);
            var startValue;
            this._focusAfterAttached = params.cellStartedEdit;

            if (this._focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                startValue = '';
              } else if (params.charPress) {
                startValue = params.charPress;
              } else {
                startValue = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this._highlightAllOnFocus = true;
                }
              }
            } else {
              startValue = params.value;
            }

            this._params = params;
            this._gui = document.createElement('div');
            this._gui.className = 'textEditor ag-cell-edit-wrapper';
            this._gui.tabIndex = '0';
            this._gui.innerHTML =
            /* html */
            "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // input

            this._input = document.createElement('input');
            this._input.className = 'textEditor__input ag-cell-edit-input ag-input-field-input ag-text-field-input';
            this._input.id = "el-".concat(Math.random().toString(16).slice(2, 10)); // generate random id

            this._input.type = 'text';
            this._input.value = startValue;
            this._input.tabIndex = 0;

            this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

            if (pattern !== null) {
              this._input.setAttribute('pattern', pattern);
            }

            if (required === true) {
              this._input.setAttribute('required', 'required');
            }

            if (title !== null) {
              if (title !== 'default') {
                this._input.title = title;
              }
            } else if (mask) {
              this._input.title = mask;
            } // If there is a mask then we use the `Basis.InputMasking.TextInput`


            if (mask) {
              this._input.dataset.mask = mask;
              this._textInput = new Basis.InputMasking.TextInput({
                elements: [this._input],
                doc: this.getDoc(params),
                onUpdate: this._onTextInputUpdate,
                onInvalid: this._onTextInputInvalid
              });
            } else {
              this._input.addEventListener('keydown', this._onInputKeyDownUp);

              this._input.addEventListener('keyup', this._onInputKeyDownUp);

              this._input.addEventListener('input', this._onChange);

              this._input.addEventListener('change', this._onChange);
            }

            this._gui.addEventListener('keydown', this._onComponentKeyDown); // update `currentValue` the value which this component is managing


            this._currentValue = startValue;
            this.__isMasked__ = mask && mask.length;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (!this.__isMasked__) {
              this._input.removeEventListener('keydown', this._onInputKeyDownUp);

              this._input.removeEventListener('keyup', this._onInputKeyDownUp);

              this._input.removeEventListener('input', this._onChange);

              this._input.removeEventListener('change', this._onChange);
            } else {
              this._textInput.destroy();
            }

            this._gui.removeEventListener('keydown', this._onComponentKeyDown);
          }
          /**
           * Gets called once after GUI is attached to DOM.
           *
           * Make sure container is always focused to listen to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (!this.__isMasked__) {
              this._validateInput(this._input);
            }

            if (this._highlightAllOnFocus) {
              this._input.select();
            } else {
              if (this._focusAfterAttached) {
                this.focusIn();
              }
            }
          }
          /**
           * Get The component value
           *
           * @return {Number}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._params.parseValue(this._currentValue);
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._input.focus();
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * Update the current value when the TextInput component fires the update
           * event.
           *
           * @param {String} _masked  the masked value
           * @param {String} unmasked  the unmasked value
           */

        }, {
          key: "_onTextInputUpdate",
          value: function _onTextInputUpdate(_masked, unmasked, input) {
            this._currentValue = unmasked;
            input.setCustomValidity('');
            this.focusIn(); // we pass the last captured event back to the grid to handle it internally

            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * On invalid inputs , update the input with a custom validity message
           *
           * @param {String|Object} error the error message reported by TextInput
           * @param {HTMLElement} input The input element used instance
           */

        }, {
          key: "_onTextInputInvalid",
          value: function _onTextInputInvalid(error, input) {
            this.focusIn(); // restore the original value of the cell

            this._currentValue = this._params.value;

            if (typeof error === 'string') {
              input.setCustomValidity(error);
            }
          }
          /**
           * Capture all keyboard events to allow value processing by the NumberInput component
           *
           * @param {KeyboardEvent} e
           */

        }, {
          key: "_onComponentKeyDown",
          value: function _onComponentKeyDown(e) {
            var key = event.which || event.keyCode;
            var isNavigationKey = key === 37 || // left
            key === 38 || // up
            key === 39 || // right
            key === 40 || // down
            key === 33 || // page up
            key === 34 || // page down
            key === 35 || // page home
            key === 36 || // page end
            key === 13; // enter

            if (isNavigationKey) {
              event.stopPropagation(); // save the last capture key so NumberInput can pass it again to the grid.

              this.__lastComponentKeyboardPress__ = e;
            }
          }
          /**
           * Listen to key changes and validate the input
           *
           * @param {Event} event
           */

        }, {
          key: "_onInputKeyDownUp",
          value: function _onInputKeyDownUp(event) {
            var isValid = this._validateInput(event.target);

            if (!isValid) {
              return;
            }

            var key = event.which || event.keyCode;

            if (key == 13 || key === 9) {
              // enter
              this._currentValue = this._input.value;
            } // we pass the last captured event back to the grid to handle it internally


            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * Update `currentValue` on the input value is changed and it is valid
           */

        }, {
          key: "_onChange",
          value: function _onChange(event) {
            var isValid = this._validateInput(event.target);

            if (isValid) {
              this._currentValue = this._input.value;
            }
          }
          /**
           * Validate the given input element
           *
           * @param {HTMLInputElement} input input element
           *
           * @return {Boolean} true when valid , false otherwise
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (!isValid) {
              input.classList.add('bbj-mask-error');
              input.classList.remove('bbj-mask-success'); // restore the original value

              this._currentValue = this._params.value;
            } else {
              input.classList.remove('bbj-mask-error');
              input.classList.add('bbj-mask-success');
            }

            return isValid;
          }
        }]);

        return TextEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onTextInputUpdate", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onTextInputUpdate"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onTextInputInvalid", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onTextInputInvalid"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onComponentKeyDown", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onComponentKeyDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onInputKeyDownUp", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onInputKeyDownUp"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onChange", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onChange"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = TextEditor;
      /***/
    },
    /* 63 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(64);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 64 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".textEditor{overflow:hidden}.textEditor .textInputMask__wrap{width:100%;height:100%;box-sizing:border-box;outline:none;display:block;padding:0;margin:0;display:flex;flex:1 1 auto;align-items:center;line-height:normal;position:relative;overflow:hidden}.textEditor .bbj-mask-error{box-shadow:0 -2px 0 #e91e63 inset}.textEditor .bbj-mask-success{box-shadow:0 -2px 0 #4caf50 inset}.textEditor__input{padding-left:6px;border:thin solid var(--ag-input-focus-border-color, rgba(33,150,243,0.4));border-radius:3px;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .textEditor__input,.ag-theme-balham .textEditor__input,.ag-theme-material .textEditor__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .textEditor__input,.ag-theme-balham-dark .textEditor__input{background-color:var(--ag-background-color, #2d3436)}\n", ""]); // exports

      /***/
    },
    /* 65 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_lodash_es_template__ = __webpack_require__(66);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **renderTemplate**   | undefined    | lodash template
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TemplateRenderer = /*#__PURE__*/function (_Component) {
        _inherits(TemplateRenderer, _Component);

        var _super = _createSuper(TemplateRenderer);
        /**
         * Construct new TemplateRenderer
         */


        function TemplateRenderer() {
          var _this;

          _classCallCheck(this, TemplateRenderer);

          _this = _super.call(this); // will this affect BBj bui ?

          _this._gui = document.createElement('div');
          _this._gui.className = 'templateRenderer ag-cell-wrapper';
          _this._gui.style.width = '100%';
          _this._gui.style.height = '100%';
          _this._gui.style.lineHeight = 'normal';
          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(TemplateRenderer, [{
          key: "init",
          value: function init(params) {
            this.refresh(params, true);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           * Refresh the cell l
           *
           * @param {Object} params cell renderer params
           * @param {Boolean} isInit true when this method is being called in `init` phase , false otherwise
           *
           * @return {Boolean} true if the refresh succeeded, otherwise return false.
           */

        }, {
          key: "refresh",
          value: function refresh(params, isInit) {
            if (isInit) {
              this._compiledTemplate = Object(__WEBPACK_IMPORTED_MODULE_1_lodash_es_template__["a"
              /* default */
              ])(this.getOption('renderTemplate', params, ''));
            }

            var content;

            if (typeof this._compiledTemplate === 'function') {
              content = this._compiledTemplate({
                params: params
              });
            } else {
              content = params.valueFormatted ? params.valueFormatted : params.value;
            }

            this._gui.innerHTML = content;
            return true;
          }
        }]);

        return TemplateRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = TemplateRenderer;
      /***/
    },
    /* 66 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__assignInWith_js__ = __webpack_require__(67);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__attempt_js__ = __webpack_require__(96);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__baseValues_js__ = __webpack_require__(99);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__ = __webpack_require__(100);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__escapeStringChar_js__ = __webpack_require__(101);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__isError_js__ = __webpack_require__(32);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__isIterateeCall_js__ = __webpack_require__(25);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__keys_js__ = __webpack_require__(102);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__reInterpolate_js__ = __webpack_require__(35);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__ = __webpack_require__(105);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__toString_js__ = __webpack_require__(36);
      /** Used to match empty string literals in compiled template source. */


      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */

      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      /** Used to ensure capturing order of template delimiters. */

      var reNoMatch = /($^)/;
      /** Used to match unescaped characters in compiled string literals. */

      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */

      function template(string, options, guard) {
        // Based on John Resig's `tmpl` implementation
        // (http://ejohn.org/blog/javascript-micro-templating/)
        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
        var settings = __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__["a"
        /* default */
        ].imports._.templateSettings || __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__["a"
        /* default */
        ];

        if (guard && Object(__WEBPACK_IMPORTED_MODULE_6__isIterateeCall_js__["a"
        /* default */
        ])(string, options, guard)) {
          options = undefined;
        }

        string = Object(__WEBPACK_IMPORTED_MODULE_10__toString_js__["a"
        /* default */
        ])(string);
        options = Object(__WEBPACK_IMPORTED_MODULE_0__assignInWith_js__["a"
        /* default */
        ])({}, options, settings, __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__["a"
        /* default */
        ]);
        var imports = Object(__WEBPACK_IMPORTED_MODULE_0__assignInWith_js__["a"
        /* default */
        ])({}, options.imports, settings.imports, __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__["a"
        /* default */
        ]),
            importsKeys = Object(__WEBPACK_IMPORTED_MODULE_7__keys_js__["a"
        /* default */
        ])(imports),
            importsValues = Object(__WEBPACK_IMPORTED_MODULE_2__baseValues_js__["a"
        /* default */
        ])(imports, importsKeys);
        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '"; // Compile the regexp to match each delimiter.

        var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === __WEBPACK_IMPORTED_MODULE_8__reInterpolate_js__["a"
        /* default */
        ] ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
        // The sourceURL gets injected into the source that's eval-ed, so be careful
        // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
        // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

        var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

          source += string.slice(index, offset).replace(reUnescapedString, __WEBPACK_IMPORTED_MODULE_4__escapeStringChar_js__["a"
          /* default */
          ]); // Replace delimiters with snippets.

          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }

          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }

          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }

          index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
          // order to produce the correct `offset` value.

          return match;
        });
        source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
        // code to add the data object to the top of the scope chain.
        // Like with sourceURL, we take care to not check the option's prototype,
        // as this configuration is a code injection vector.

        var variable = hasOwnProperty.call(options, 'variable') && options.variable;

        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        } // Cleanup code by stripping empty strings.


        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

        source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
        var result = Object(__WEBPACK_IMPORTED_MODULE_1__attempt_js__["a"
        /* default */
        ])(function () {
          return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        }); // Provide the compiled function's source by its `toString` method or
        // the `source` property as a convenience for inlining compiled templates.

        result.source = source;

        if (Object(__WEBPACK_IMPORTED_MODULE_5__isError_js__["a"
        /* default */
        ])(result)) {
          throw result;
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = template;
      /***/
    },
    /* 67 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(68);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__createAssigner_js__ = __webpack_require__(78);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__keysIn_js__ = __webpack_require__(84);
      /**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */


      var assignInWith = Object(__WEBPACK_IMPORTED_MODULE_1__createAssigner_js__["a"
      /* default */
      ])(function (object, source, srcIndex, customizer) {
        Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a"
        /* default */
        ])(source, Object(__WEBPACK_IMPORTED_MODULE_2__keysIn_js__["a"
        /* default */
        ])(source), object, customizer);
      });
      /* harmony default export */

      __webpack_exports__["a"] = assignInWith;
      /***/
    },
    /* 68 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__assignValue_js__ = __webpack_require__(69);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__ = __webpack_require__(17);
      /**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */


      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

          if (newValue === undefined) {
            newValue = source[key];
          }

          if (isNew) {
            Object(__WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__["a"
            /* default */
            ])(object, key, newValue);
          } else {
            Object(__WEBPACK_IMPORTED_MODULE_0__assignValue_js__["a"
            /* default */
            ])(object, key, newValue);
          }
        }

        return object;
      }
      /* harmony default export */


      __webpack_exports__["a"] = copyObject;
      /***/
    },
    /* 69 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__eq_js__ = __webpack_require__(11);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */

      function assignValue(object, key, value) {
        var objValue = object[key];

        if (!(hasOwnProperty.call(object, key) && Object(__WEBPACK_IMPORTED_MODULE_1__eq_js__["a"
        /* default */
        ])(objValue, value)) || value === undefined && !(key in object)) {
          Object(__WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__["a"
          /* default */
          ])(object, key, value);
        }
      }
      /* harmony default export */


      __webpack_exports__["a"] = assignValue;
      /***/
    },
    /* 70 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__ = __webpack_require__(71);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getValue_js__ = __webpack_require__(77);
      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */


      function getNative(object, key) {
        var value = Object(__WEBPACK_IMPORTED_MODULE_1__getValue_js__["a"
        /* default */
        ])(object, key);
        return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__["a"
        /* default */
        ])(value) ? value : undefined;
      }
      /* harmony default export */


      __webpack_exports__["a"] = getNative;
      /***/
    },
    /* 71 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(19);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isMasked_js__ = __webpack_require__(74);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObject_js__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__toSource_js__ = __webpack_require__(76);
      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */


      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      /** Used to detect host constructors (Safari). */

      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
          objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to detect if a method is native. */

      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */

      function baseIsNative(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObject_js__["a"
        /* default */
        ])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__isMasked_js__["a"
        /* default */
        ])(value)) {
          return false;
        }

        var pattern = Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["a"
        /* default */
        ])(value) ? reIsNative : reIsHostCtor;
        return pattern.test(Object(__WEBPACK_IMPORTED_MODULE_3__toSource_js__["a"
        /* default */
        ])(value));
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsNative;
      /***/
    },
    /* 72 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /** Built-in value references. */

      var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].toStringTag : undefined;
      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */

      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);

        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = getRawTag;
      /***/
    },
    /* 73 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */

      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = objectToString;
      /***/
    },
    /* 74 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__ = __webpack_require__(75);
      /** Used to detect methods masquerading as native. */


      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(__WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ] && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ].keys && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ].keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();
      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */


      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isMasked;
      /***/
    },
    /* 75 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
      /** Used to detect overreaching core-js shims. */


      var coreJsData = __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
      /* default */
      ]['__core-js_shared__'];
      /* harmony default export */

      __webpack_exports__["a"] = coreJsData;
      /***/
    },
    /* 76 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var funcProto = Function.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */

      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}

          try {
            return func + '';
          } catch (e) {}
        }

        return '';
      }
      /* harmony default export */


      __webpack_exports__["a"] = toSource;
      /***/
    },
    /* 77 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */

      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }
      /* harmony default export */


      __webpack_exports__["a"] = getValue;
      /***/
    },
    /* 78 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(22);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__ = __webpack_require__(25);
      /**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */


      function createAssigner(assigner) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a"
        /* default */
        ])(function (object, sources) {
          var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
          customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

          if (guard && Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__["a"
          /* default */
          ])(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
          }

          object = Object(object);

          while (++index < length) {
            var source = sources[index];

            if (source) {
              assigner(object, source, index, customizer);
            }
          }

          return object;
        });
      }
      /* harmony default export */


      __webpack_exports__["a"] = createAssigner;
      /***/
    },
    /* 79 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(24);
      /* Built-in method references for those with the same name as other `lodash` methods. */


      var nativeMax = Math.max;
      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */

      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
        return function () {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }

          index = -1;
          var otherArgs = Array(start + 1);

          while (++index < start) {
            otherArgs[index] = args[index];
          }

          otherArgs[start] = transform(array);
          return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a"
          /* default */
          ])(func, this, otherArgs);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = overRest;
      /***/
    },
    /* 80 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__ = __webpack_require__(81);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__shortOut_js__ = __webpack_require__(83);
      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var setToString = Object(__WEBPACK_IMPORTED_MODULE_1__shortOut_js__["a"
      /* default */
      ])(__WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__["a"
      /* default */
      ]);
      /* harmony default export */

      __webpack_exports__["a"] = setToString;
      /***/
    },
    /* 81 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__constant_js__ = __webpack_require__(82);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__defineProperty_js__ = __webpack_require__(18);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__identity_js__ = __webpack_require__(23);
      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var baseSetToString = !__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_2__identity_js__["a"
      /* default */
      ] : function (func, string) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a"
        /* default */
        ])(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a"
          /* default */
          ])(string),
          'writable': true
        });
      };
      /* harmony default export */

      __webpack_exports__["a"] = baseSetToString;
      /***/
    },
    /* 82 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */

      function constant(value) {
        return function () {
          return value;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = constant;
      /***/
    },
    /* 83 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to detect hot functions by number of calls within a span of milliseconds. */

      var HOT_COUNT = 800,
          HOT_SPAN = 16;
      /* Built-in method references for those with the same name as other `lodash` methods. */

      var nativeNow = Date.now;
      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */

      function shortOut(func) {
        var count = 0,
            lastCalled = 0;
        return function () {
          var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;

          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }

          return func.apply(undefined, arguments);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = shortOut;
      /***/
    },
    /* 84 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(28);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__ = __webpack_require__(94);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(12);
      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */


      function keysIn(object) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a"
        /* default */
        ])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a"
        /* default */
        ])(object, true) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__["a"
        /* default */
        ])(object);
      }
      /* harmony default export */


      __webpack_exports__["a"] = keysIn;
      /***/
    },
    /* 85 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */

      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseTimes;
      /***/
    },
    /* 86 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__ = __webpack_require__(87);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Built-in value references. */

      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */

      var isArguments = Object(__WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a"
      /* default */
      ])(function () {
        return arguments;
      }()) ? __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a"
      /* default */
      ] : function (value) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
      };
      /* harmony default export */

      __webpack_exports__["a"] = isArguments;
      /***/
    },
    /* 87 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]';
      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */

      function baseIsArguments(value) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) == argsTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsArguments;
      /***/
    },
    /* 88 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (module) {
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
        /* harmony import */


        var __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__ = __webpack_require__(89);

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `exports`. */


        var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && (false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Built-in value references. */

        var Buffer = moduleExports ? __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
        /* default */
        ].Buffer : undefined;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */

        var isBuffer = nativeIsBuffer || __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__["a"
        /* default */
        ];
        /* harmony default export */

        __webpack_exports__["a"] = isBuffer;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(30)(module));
      /***/
    },
    /* 89 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */

      function stubFalse() {
        return false;
      }
      /* harmony default export */


      __webpack_exports__["a"] = stubFalse;
      /***/
    },
    /* 90 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__ = __webpack_require__(91);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseUnary_js__ = __webpack_require__(92);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__ = __webpack_require__(93);
      /* Node.js helper references. */


      var nodeIsTypedArray = __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a"
      /* default */
      ] && __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a"
      /* default */
      ].isTypedArray;
      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */

      var isTypedArray = nodeIsTypedArray ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUnary_js__["a"
      /* default */
      ])(nodeIsTypedArray) : __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__["a"
      /* default */
      ];
      /* harmony default export */

      __webpack_exports__["a"] = isTypedArray;
      /***/
    },
    /* 91 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(26);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      /** Used to identify `toStringTag` values of typed arrays. */

      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      /**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */

      function baseIsTypedArray(value) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a"
        /* default */
        ])(value.length) && !!typedArrayTags[Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value)];
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsTypedArray;
      /***/
    },
    /* 92 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */

      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseUnary;
      /***/
    },
    /* 93 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (module) {
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(20);

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `exports`. */


        var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && (false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */

        var freeProcess = moduleExports && __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a"
        /* default */
        ].process;
        /** Used to access faster Node.js helpers. */

        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;

            if (types) {
              return types;
            } // Legacy `process.binding('util')` for Node.js < 10.


            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();
        /* harmony default export */


        __webpack_exports__["a"] = nodeUtil;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(30)(module));
      /***/
    },
    /* 94 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isPrototype_js__ = __webpack_require__(31);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__ = __webpack_require__(95);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function baseKeysIn(object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a"
        /* default */
        ])(object)) {
          return Object(__WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__["a"
          /* default */
          ])(object);
        }

        var isProto = Object(__WEBPACK_IMPORTED_MODULE_1__isPrototype_js__["a"
        /* default */
        ])(object),
            result = [];

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseKeysIn;
      /***/
    },
    /* 95 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function nativeKeysIn(object) {
        var result = [];

        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = nativeKeysIn;
      /***/
    },
    /* 96 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(24);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseRest_js__ = __webpack_require__(22);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isError_js__ = __webpack_require__(32);
      /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */


      var attempt = Object(__WEBPACK_IMPORTED_MODULE_1__baseRest_js__["a"
      /* default */
      ])(function (func, args) {
        try {
          return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a"
          /* default */
          ])(func, undefined, args);
        } catch (e) {
          return Object(__WEBPACK_IMPORTED_MODULE_2__isError_js__["a"
          /* default */
          ])(e) ? e : new Error(e);
        }
      });
      /* harmony default export */

      __webpack_exports__["a"] = attempt;
      /***/
    },
    /* 97 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(98);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var objectTag = '[object Object]';
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
          objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to infer the `Object` constructor. */

      var objectCtorString = funcToString.call(Object);
      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */

      function isPlainObject(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a"
        /* default */
        ])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) != objectTag) {
          return false;
        }

        var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a"
        /* default */
        ])(value);

        if (proto === null) {
          return true;
        }

        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isPlainObject;
      /***/
    },
    /* 98 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(33);
      /** Built-in value references. */


      var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a"
      /* default */
      ])(Object.getPrototypeOf, Object);
      /* harmony default export */

      __webpack_exports__["a"] = getPrototype;
      /***/
    },
    /* 99 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(34);
      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */


      function baseValues(object, props) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a"
        /* default */
        ])(props, function (key) {
          return object[key];
        });
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseValues;
      /***/
    },
    /* 100 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(11);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */

      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined || Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a"
        /* default */
        ])(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }

        return objValue;
      }
      /* harmony default export */


      __webpack_exports__["a"] = customDefaultsAssignIn;
      /***/
    },
    /* 101 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to escape characters for inclusion in compiled string literals. */

      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        "\u2028": 'u2028',
        "\u2029": 'u2029'
      };
      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */

      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      /* harmony default export */


      __webpack_exports__["a"] = escapeStringChar;
      /***/
    },
    /* 102 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(28);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseKeys_js__ = __webpack_require__(103);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(12);
      /**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */


      function keys(object) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a"
        /* default */
        ])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a"
        /* default */
        ])(object) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeys_js__["a"
        /* default */
        ])(object);
      }
      /* harmony default export */


      __webpack_exports__["a"] = keys;
      /***/
    },
    /* 103 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isPrototype_js__ = __webpack_require__(31);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__ = __webpack_require__(104);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function baseKeys(object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__isPrototype_js__["a"
        /* default */
        ])(object)) {
          return Object(__WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__["a"
          /* default */
          ])(object);
        }

        var result = [];

        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseKeys;
      /***/
    },
    /* 104 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(33);
      /* Built-in method references for those with the same name as other `lodash` methods. */


      var nativeKeys = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a"
      /* default */
      ])(Object.keys, Object);
      /* harmony default export */

      __webpack_exports__["a"] = nativeKeys;
      /***/
    },
    /* 105 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__escape_js__ = __webpack_require__(106);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__reEscape_js__ = __webpack_require__(111);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__reEvaluate_js__ = __webpack_require__(112);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__reInterpolate_js__ = __webpack_require__(35);
      /**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */


      var templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'escape': __WEBPACK_IMPORTED_MODULE_1__reEscape_js__["a"
        /* default */
        ],

        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'evaluate': __WEBPACK_IMPORTED_MODULE_2__reEvaluate_js__["a"
        /* default */
        ],

        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'interpolate': __WEBPACK_IMPORTED_MODULE_3__reInterpolate_js__["a"
        /* default */
        ],

        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        'variable': '',

        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        'imports': {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          '_': {
            'escape': __WEBPACK_IMPORTED_MODULE_0__escape_js__["a"
            /* default */
            ]
          }
        }
      };
      /* harmony default export */

      __webpack_exports__["a"] = templateSettings;
      /***/
    },
    /* 106 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__escapeHtmlChar_js__ = __webpack_require__(107);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toString_js__ = __webpack_require__(36);
      /** Used to match HTML entities and HTML characters. */


      var reUnescapedHtml = /[&<>"']/g,
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      /**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */

      function escape(string) {
        string = Object(__WEBPACK_IMPORTED_MODULE_1__toString_js__["a"
        /* default */
        ])(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, __WEBPACK_IMPORTED_MODULE_0__escapeHtmlChar_js__["a"
        /* default */
        ]) : string;
      }
      /* harmony default export */


      __webpack_exports__["a"] = escape;
      /***/
    },
    /* 107 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__basePropertyOf_js__ = __webpack_require__(108);
      /** Used to map characters to HTML entities. */


      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */

      var escapeHtmlChar = Object(__WEBPACK_IMPORTED_MODULE_0__basePropertyOf_js__["a"
      /* default */
      ])(htmlEscapes);
      /* harmony default export */

      __webpack_exports__["a"] = escapeHtmlChar;
      /***/
    },
    /* 108 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */

      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined : object[key];
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = basePropertyOf;
      /***/
    },
    /* 109 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__arrayMap_js__ = __webpack_require__(34);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(29);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isSymbol_js__ = __webpack_require__(110);
      /** Used as references for various `Number` constants. */


      var INFINITY = 1 / 0;
      /** Used to convert symbols to primitives and strings. */

      var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */

      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value;
        }

        if (Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["a"
        /* default */
        ])(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap_js__["a"
          /* default */
          ])(value, baseToString) + '';
        }

        if (Object(__WEBPACK_IMPORTED_MODULE_3__isSymbol_js__["a"
        /* default */
        ])(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseToString;
      /***/
    },
    /* 110 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** `Object#toString` result references. */


      var symbolTag = '[object Symbol]';
      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */

      function isSymbol(value) {
        return _typeof(value) == 'symbol' || Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) == symbolTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isSymbol;
      /***/
    },
    /* 111 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reEscape = /<%-([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reEscape;
      /***/
    },
    /* 112 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reEvaluate = /<%([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reEvaluate;
      /***/
    },
    /* 113 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__ImageRenderer__ = __webpack_require__(114);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__ImageRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 114 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__ = __webpack_require__(16);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **imageRendererWidth**   | 28px    | image width
       * | **imageRendererHeight**   | 28px    | image height
       * | **imageRendererList**       | {}  	| a list of which maps images with cell values as JSON or plain JS object
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       *
       * @see https://lodash.com/docs/4.17.15#template
       */


      var ImageRenderer = /*#__PURE__*/function (_TemplateRenderer) {
        _inherits(ImageRenderer, _TemplateRenderer);

        var _super = _createSuper(ImageRenderer);

        function ImageRenderer() {
          _classCallCheck(this, ImageRenderer);

          return _super.apply(this, arguments);
        }

        _createClass(ImageRenderer, [{
          key: "refresh",

          /**
           * @inheritDoc
           */
          value: function refresh(params, isInit) {
            var value = params.value;
            var imageWidth = this.getOption('imageRendererWidth', params, '28px');
            var imageHeight = this.getOption('imageRendererHeight', params, '28px');
            var imageList = this.getOption('imageRendererList', params);

            try {
              imageList = JSON.parse(imageList);
            } catch (e) {
              imageList = imageList || {};
            }
            /* eslint-disable no-prototype-builtins */


            if (imageList && imageList.hasOwnProperty(value)) {
              params.renderTemplate =
              /*html*/
              "\n        <img \n          src=\"".concat(imageList[params.value], "\" \n          width=\"").concat(imageWidth, "\"\n          height=\"").concat(imageHeight, "\"  \n        />\n      ");
            } else {
              params.renderTemplate = value;
            }

            return _get(_getPrototypeOf(ImageRenderer.prototype), "refresh", this).call(this, params, isInit);
          }
        }]);

        return ImageRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = ImageRenderer;
      /***/
    },
    /* 115 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeFilter__ = __webpack_require__(116);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeFilter__["a"
      /* default */
      ];
      /***/
    },
    /* 116 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__ = __webpack_require__(37);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3_date_fns_tz_utcToZonedTime__ = __webpack_require__(38);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__EventsMixin__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__ = __webpack_require__(41);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__style_scss__ = __webpack_require__(127);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__style_scss__);

      var _class, _class2, _init, _descriptor, _class3, _temp, _class4, _class5, _init2, _descriptor2, _class6, _temp2, _class7, _temp3;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _initializerWarningHelper(descriptor, context) {
        throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var TOKENS = {
        TOKEN_EQUAL: 'equals',
        TOKEN_NOT_EQUAL: 'notEqual',
        TOKEN_LESS: 'lessThan',
        TOKEN_GREATER: 'greaterThan',
        TOKEN_RANGE: 'inRange',
        TOKEN_AND: 'AND',
        TOKEN_OR: 'OR'
      };

      var ConditionPanel = Object(__WEBPACK_IMPORTED_MODULE_4__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inherits(ConditionPanel, _Component);

        var _super = _createSuper(ConditionPanel);

        function ConditionPanel() {
          var _this;

          _classCallCheck(this, ConditionPanel);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          _initializerDefineProperty(_this, "state", _descriptor, _assertThisInitialized(_this));

          _this._filterTimeInput = new __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
          /* default */
          ]();
          _this._filterToDateTimeInput = new __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
          /* default */
          ]();
          _this._filterOptions = [];
          _this._defaultOption = -1;
          return _this;
        }

        _createClass(ConditionPanel, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var _optionsTranslations,
                _this2 = this;

            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            this._filterOptions = this.getOption('filterOptions', params, [TOKENS.TOKEN_EQUAL, TOKENS.TOKEN_NOT_EQUAL, TOKENS.TOKEN_LESS, TOKENS.TOKEN_GREATER, TOKENS.TOKEN_RANGE]);
            this._defaultOption = this.getOption('defaultOption', params, this._filterOptions.indexOf(TOKENS.TOKEN_EQUAL) > -1 ? TOKENS.TOKEN_EQUAL : this._filterOptions[0]);
            this.state.type = this._defaultOption;
            var optionsTranslations = (_optionsTranslations = {}, _defineProperty(_optionsTranslations, TOKENS.TOKEN_EQUAL, translate(TOKENS.TOKEN_EQUAL, 'Equals')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_NOT_EQUAL, translate(TOKENS.TOKEN_EQUAL, 'Not equal')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_LESS, translate(TOKENS.TOKEN_LESS, 'Less than')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_GREATER, translate(TOKENS.TOKEN_GREATER, 'Greater than')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_RANGE, translate(TOKENS.TOKEN_RANGE, 'In range')), _optionsTranslations);
            this._gui = document.createElement('div');
            this._gui.className = 'dateTimeFilter ag-filter-body-wrapper';
            this._gui.innerHTML =
            /* html */
            "\n      <select class=\"ag-filter-select dateTimeFilter__select\"  ".concat(this._filterOptions.length === 1 ? 'disabled' : '', ">\n        ").concat(this._filterOptions.map(function (option) {
              return (
                /* html */
                "\n          <option \n            value=\"".concat(option, "\" \n            ").concat(option === _this2._defaultOption ? 'selected' : '', "\n          >\n              ").concat(optionsTranslations[option], "\n          </option>")
              );
            }), "\n      </select>\n      <div class=\"ag-filter-body\">\n        <div class=\"ag-filter-date-from\">\n        </div>\n        <div class=\"ag-filter-date-to ag-hidden\">\n        </div>\n      </div>\n    ");

            this._filterTimeInput.init(params);

            this._filterTimeInput.on(__WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, function (selectedDate) {
              _this2.state.filter = selectedDate;

              _this2.notify(ConditionPanel.ON_CONDITION_CHANGED, _this2.state);
            });

            this._filterToDateTimeInput.init(params);

            this._filterToDateTimeInput.on(__WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, function (selectedDate) {
              _this2.state.filterTo = selectedDate;

              _this2.notify(ConditionPanel.ON_CONDITION_CHANGED, _this2.state);
            });

            this._gui.querySelector('.ag-filter-date-from').appendChild(this._filterTimeInput.getGui());

            this._gui.querySelector('.ag-filter-date-to').appendChild(this._filterToDateTimeInput.getGui());

            var select = this._gui.querySelector('.ag-filter-select');

            select.addEventListener('change', this._onTypeChange);
            this.setState(this._state);
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this.off(ConditionPanel.ON_CONDITION_CHANGED);

            this._filterTimeInput.destroy();

            this._filterToDateTimeInput.destroy();

            this._gui.querySelector('.ag-filter-select').removeEventListener('change', this._onTypeChange);

            this.reset();
          }
          /**
           * Reset the state
           */

        }, {
          key: "reset",
          value: function reset() {
            this.state.filter = null;
            this.state.filterTo = null;

            this._filterTimeInput.reset();

            this._filterToDateTimeInput.reset();

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Set the condition state
           *
           * @param {Object} state
           */

        }, {
          key: "setState",
          value: function setState(state) {
            state = state || {};
            this.state.filter = state.filter || null;
            this.state.filterTo = state.filterTo || null;
            this.state.type = state.type || this._defaultOption;
            var gui = this._gui;
            var filterOptions = this._filterOptions;
            var selectEl = gui.querySelector('.ag-filter-select');
            var filterInput = this._filterTimeInput;
            var filterToInput = this._filterToDateTimeInput;
            selectEl.selectedIndex = filterOptions.indexOf(this.state.type);
            filterInput.setDate(this.state.filter);
            filterToInput.setDate(this.state.filterTo); // we fire on change event in case the filter options contain
            // one option which is in Range "inRange"

            if ('createEvent' in document) {
              var evt = document.createEvent('HTMLEvents');
              evt.initEvent('change', false, true);
              selectEl.dispatchEvent(evt);
            } else {
              selectEl.fireEvent('onchange');
            }

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Update the state with the selected type
           *
           * @param {Event} e
           */

        }, {
          key: "_onTypeChange",
          value: function _onTypeChange(e) {
            var el = e.target;

            var filterDateTo = this._gui.querySelector('.ag-filter-date-to');

            this.state.type = el.options[el.selectedIndex].value;

            if (this.state.type === TOKENS.TOKEN_RANGE) {
              filterDateTo.classList.remove('ag-hidden');
            } else {
              filterDateTo.classList.add('ag-hidden');
            }

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
        }]);

        return ConditionPanel;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _class3.ON_CONDITION_CHANGED = 'ConditionPanel.ON_CONDITION_CHANGED', _temp), (_applyDecoratedDescriptor(_class2, "ON_CONDITION_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init = Object.getOwnPropertyDescriptor(_class2, "ON_CONDITION_CHANGED"), _init = _init ? _init.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init;
        }
      }), _class2), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "state", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {
            type: TOKENS.TOKEN_EQUAL,
            filter: null,
            filterTo: null
          };
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "init"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "destroy"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "_onTypeChange", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "_onTypeChange"), _class2.prototype)), _class2)) || _class;

      var JoinConditionPanel = Object(__WEBPACK_IMPORTED_MODULE_4__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class4 = (_class5 = (_temp2 = _class6 = /*#__PURE__*/function (_Component2) {
        _inherits(JoinConditionPanel, _Component2);

        var _super2 = _createSuper(JoinConditionPanel);

        function JoinConditionPanel() {
          var _this3;

          _classCallCheck(this, JoinConditionPanel);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this3 = _super2.call.apply(_super2, [this].concat(args));

          _initializerDefineProperty(_this3, "state", _descriptor2, _assertThisInitialized(_this3));

          _this3._firstConditionPanel = new ConditionPanel();
          _this3._secondConditionPanel = new ConditionPanel();
          _this3._operatorPanel = null;
          _this3._params = null;
          return _this3;
        }

        _createClass(JoinConditionPanel, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            this._params = params;

            this._firstConditionPanel.init(params);

            this._firstConditionPanel.on(ConditionPanel.ON_CONDITION_CHANGED, this._onFirstConditionChanged);

            this._secondConditionPanel.init(params);

            this._secondConditionPanel.on(ConditionPanel.ON_CONDITION_CHANGED, this._onSecondConditionChanged);

            this._secondConditionPanel.getGui().classList.add('ag-hidden');

            this._gui = document.createElement('div');
            this._gui.className = 'ag-filter-body-wrapper ag-simple-filter-body-wrapper';

            this._gui.appendChild(this._firstConditionPanel.getGui()); //prettier-ignore


            var idOne = '_' + Math.random().toString(36).substr(2, 9),
                idTwo = '_' + Math.random().toString(36).substr(2, 9);
            this._operatorPanel = document.createElement('div');
            this._operatorPanel.className = 'ag-filter-condition ag-hidden';
            this._operatorPanel.innerHTML =
            /* html */
            "\n    <div class=\"ag-filter-condition-operator ag-filter-condition-operator-and ag-labeled ag-label-align-right ag-radio-button ag-input-field\">\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\" for=\"".concat(idOne, "\">       \n          ").concat(translate('andCondition', 'AND'), "\n        </label>\n        <div class=\"ag-wrapper-and ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper ag-checked\">\n          <input id=\"").concat(idOne, "\" class=\"AND ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"orAndRadio\" value=\"").concat(TOKENS.TOKEN_AND, "\"/>              \n        </div> \n    </div>   \n    \n    <div class=\"ag-filter-condition-operator ag-filter-condition-operator-and ag-labeled ag-label-align-right ag-radio-button ag-input-field\">\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\" for=\"").concat(idTwo, "\">       \n          ").concat(translate('orCondition', 'OR'), "\n        </label>\n        <div class=\"ag-wrapper-or ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n          <input id=\"").concat(idTwo, "\" class=\"OR ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"orAndRadio\" value=\"").concat(TOKENS.TOKEN_OR, "\"/>              \n        </div>         \n    </div>   \n    ");

            this._gui.appendChild(this._operatorPanel);

            this._operatorPanel.addEventListener('change', this._onOperatorChanged);

            this._gui.appendChild(this._secondConditionPanel.getGui());
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._firstConditionPanel.destroy();

            this._secondConditionPanel.destroy();

            this._operatorPanel.removeEventListener('change', this._onOperatorChanged);

            this.off(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED);
            this.reset();
          }
          /**
           * Reset the state
           */

        }, {
          key: "reset",
          value: function reset() {
            this._firstConditionPanel.reset();

            this._secondConditionPanel.reset();

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Set the condition join state
           *
           * @param {Object} state
           */

        }, {
          key: "setState",
          value: function setState(state) {
            var _this4 = this;

            state = state || {};
            this.state.operator = state.operator || TOKENS.TOKEN_OR;
            this.state.condition1 = state.condition1 || null;
            this.state.condition2 = state.condition2 || null;

            this._firstConditionPanel.setState(this.state.condition1);

            this._secondConditionPanel.setState(this.state.condition2);

            this._operatorPanel.querySelectorAll('input').forEach(function (input) {
              if (input.classList.contains(_this4.state.operator)) {
                input.checked = true;
              } else {
                input.checked = false;
              }
            });

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * Add the selected condition to the component stater
           *
           * @param {Event} e
           */

        }, {
          key: "_onOperatorChanged",
          value: function _onOperatorChanged(e) {
            var target = e.target;
            this.state.operator = target.value;

            if (target.classList.contains('OR')) {
              this._operatorPanel.querySelector('.ag-wrapper-or').classList.add('ag-checked');

              this._operatorPanel.querySelector('.ag-wrapper-and').classList.remove('ag-checked');
            } else {
              this._operatorPanel.querySelector('.ag-wrapper-or').classList.remove('ag-checked');

              this._operatorPanel.querySelector('.ag-wrapper-and').classList.add('ag-checked');
            }

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * @param {Object} state  the option state
           */

        }, {
          key: "_onFirstConditionChanged",
          value: function _onFirstConditionChanged(state) {
            this.state.condition1 = state;
            var suppressAndOrCondition = this.getOption('suppressAndOrCondition', this._params, false);

            if (!suppressAndOrCondition) {
              var _this$state$condition = this.state.condition1,
                  filter = _this$state$condition.filter,
                  filterTo = _this$state$condition.filterTo,
                  type = _this$state$condition.type;

              var secondConditionGui = this._secondConditionPanel.getGui();

              var operatorPanelGui = this._operatorPanel;
              var condition = type === TOKENS.TOKEN_RANGE ? !filter || !filterTo : !filter;

              if (condition) {
                secondConditionGui.classList.add('ag-hidden');
                operatorPanelGui.classList.add('ag-hidden');
              } else {
                secondConditionGui.classList.remove('ag-hidden');
                operatorPanelGui.classList.remove('ag-hidden');
              }
            }

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * @param {Object} state  the option state
           */

        }, {
          key: "_onSecondConditionChanged",
          value: function _onSecondConditionChanged(state) {
            this.state.condition2 = state;
            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
        }]);

        return JoinConditionPanel;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _class6.ON_JOIN_CONDITION_CHANGED = 'JoinConditionPanel.ON_JOIN_CONDITION_CHANGED', _temp2), (_applyDecoratedDescriptor(_class5, "ON_JOIN_CONDITION_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init2 = Object.getOwnPropertyDescriptor(_class5, "ON_JOIN_CONDITION_CHANGED"), _init2 = _init2 ? _init2.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init2;
        }
      }), _class5), _descriptor2 = _applyDecoratedDescriptor(_class5.prototype, "state", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {
            condition1: {},
            condition2: {},
            operator: TOKENS.TOKEN_OR
          };
        }
      }), _applyDecoratedDescriptor(_class5.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "init"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "destroy"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onOperatorChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onOperatorChanged"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onFirstConditionChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onFirstConditionChanged"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onSecondConditionChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onSecondConditionChanged"), _class5.prototype)), _class5)) || _class4;
      /**
       * DateTime Filter
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **dateTimeEnableTime**   | false    | enable / disable time
       * | **dateTimeEnable24HR**   | false    | enable / disable time 24 format
       * | **dateTimeEnableSeconds**   | false    | enable / disable seconds management
       * | **dateTimeEnableCalendar**   | false    | enable / disable Calendar.
       * | **dateTimeMask**   | false    | The mask used to format the selected date
       * | **dateTimeMax**   | undefined    |  Max allowed date
       * | **dateTimeMin**   | undefined    |  Min allowed date
       * | **dateTimeFormatter**   | undefined    |  A function or expression to format the date (@see supported param)
       * | **dateTimeLocale**   | System default    |  A locale to use for date formatting
       * | **dateTimeDefaultHour**   | 12    |  Initial value of the hour element.
       * | **dateTimeDefaultMinute**   | 0    |  Initial value of the minute element.
       * | **dateTimeDisableMobile**   | false    |  Set disableMobile to true to always use the non-native picker.
       * | **dateTimeEnableWeekNumber**   | true    |  Enables display of week numbers in calendar.
       * | **filterOptions**   | Equals, Greater Than, Less Than, Not Equals, In Range.    |  What Filter Options to present to the user.
       * | **defaultOption**   | Equals    |  The default Filter Options to be selected.
       * | **suppressAndOrCondition**   | false    |  If true, the filter will only offer Condition 1.
       * | **inRangeInclusive**   | false    |  If true then doing 'inRange' filter option will include values equal to the start and end of the range.
       * | **clearButton**   | false    |  Set to true to have the filter use a Clear button. The Clear button will clear the (form) details of the filter without removing any active filters on the column.
       * | **applyButton**   | false    |  Set to true to have the filter use an Apply button. If the Apply button is present, then the filter is only applied after the user hits the Apply button.
       * | **resetButton**   | false    |  Set to true to have the filter use a Reset button. The Reset button will clear the details of the filter and any active filters on that column.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeFilter = (_class7 = (_temp3 = /*#__PURE__*/function (_Component3) {
        _inherits(DateTimeFilter, _Component3);

        var _super3 = _createSuper(DateTimeFilter);

        function DateTimeFilter() {
          var _this5;

          _classCallCheck(this, DateTimeFilter);

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this5 = _super3.call.apply(_super3, [this].concat(args));
          _this5._JoinConditionPanel = new JoinConditionPanel();
          _this5._state = {};
          _this5._params = {};
          _this5._doesFilterPassOptions = null;
          return _this5;
        }

        _createClass(DateTimeFilter, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var _this6 = this;

            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            var isClearFilter = this.getOption('clearButton', params, false);
            var isResetButton = this.getOption('resetButton', params, false);
            var isApplyButton = this.getOption('applyButton', params, false);
            this._gui = document.createElement('div');

            this._JoinConditionPanel.init(params);

            this._JoinConditionPanel.on(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, function (state) {
              if (!_this6.__disableStateChangeListener) {
                _this6._onJoinConditionPanelStateChanged(state, isApplyButton);
              }
            });

            this._gui.appendChild(this._JoinConditionPanel.getGui());

            var applyFilterPanel = document.createElement('div');
            applyFilterPanel.className = "ag-filter-apply-panel ag-hidden";
            applyFilterPanel.innerHTML =
            /* html */
            "\n      <button class=\"ag-standard-button ag-filter-apply-panel-button clear ".concat(!isClearFilter && 'ag-hidden', "\" type=\"button\">").concat(translate('clearFilter', 'Clear Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button reset ").concat(!isResetButton && 'ag-hidden', "\" type=\"button\">").concat(translate('resetFilter', 'Reset Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button apply ").concat(!isApplyButton && 'ag-hidden', "\" type=\"button\">").concat(translate('applyFilter', 'Apply Filter'), "</button>\n    ");

            if (isClearFilter || isResetButton || isApplyButton) {
              applyFilterPanel.classList.remove('ag-hidden');
            }

            applyFilterPanel.addEventListener('click', this._ApplyFilterPanelButtonClick);

            this._gui.appendChild(applyFilterPanel);

            this._state = this._JoinConditionPanel.state;
            this._params = params;
            this._doesFilterPassOptions = {
              enableTime: this.getOption('dateTimeEnableTime', this._params, true),
              inRangeInclusive: this.getOption('inRangeInclusive', this._params, false),
              // eslint-disable-next-line no-prototype-builtins
              valueGetter: this._params.hasOwnProperty('filterValueGetter') ? this._params.filterValueGetter : this._params.valueGetter
            };
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._JoinConditionPanel.destroy();
          }
          /**
           * Check whether selected filter matches the passed cell data
           *
           * @param {Object} params
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "doesFilterPass",
          value: function doesFilterPass(params) {
            var value = this._doesFilterPassOptions.valueGetter(params);

            var _this$_state = this._state,
                condition1 = _this$_state.condition1,
                condition2 = _this$_state.condition2,
                operator = _this$_state.operator;

            var doesPassFirstCondition = this._doesPassCondition(condition1, value);

            var doesPassSecondCondition = this._doesPassCondition(condition2, value);

            return operator === TOKENS.TOKEN_OR ? doesPassFirstCondition || doesPassSecondCondition : doesPassFirstCondition && doesPassSecondCondition;
          }
          /**
           * Check whether the component is applying any filter on the column
           *
           * @return {Boolean}
           **/

        }, {
          key: "isFilterActive",
          value: function isFilterActive() {
            var condition1 = this._state.condition1;

            if (condition1 && condition1.filter) {
              if (condition1.filterTo && condition1.type === TOKENS.TOKEN_RANGE) {
                return condition1.filter !== null && condition1.filterTo !== null;
              }

              return condition1.filter !== null;
            }

            return false;
          }
          /**
           * Gets the filter state. If filter is not active, then should return null/undefined.
           * The grid calls getModel() on all active filters when gridApi.getFilterModel() is called.
           *
           * @return Object | null the filter state
           */

        }, {
          key: "getModel",
          value: function getModel() {
            var _this7 = this;

            var clone = JSON.parse(JSON.stringify(this._state));
            [clone.condition1, clone.condition2].forEach(function (condition, i) {
              if (condition.filter) {
                condition.filter = _this7._state["condition".concat(i + 1)].filter.toISOString();
              }

              if (condition.filterTo) {
                condition.filterTo = _this7._state["condition".concat(i + 1)].filterTo.toISOString();
              }
            });
            clone.filterType = 'datetime';
            clone.condition1.filterType = 'datetime';
            clone.condition2.filterType = 'datetime'; // eslint-disable-next-line no-prototype-builtins

            return clone.hasOwnProperty('condition2') && // eslint-disable-next-line no-prototype-builtins
            clone.condition2.hasOwnProperty('filter') && clone.condition2.filter ? clone : clone.condition1;
          }
          /**
           * Restores the filter state. Called by the grid after gridApi.setFilterModel(model) is called.
           * The grid will pass undefined/null to clear the filter.
           *
           * @param {Object | null} model
           */

        }, {
          key: "setModel",
          value: function setModel(model) {
            if (model && // eslint-disable-next-line no-prototype-builtins
            !model.hasOwnProperty('condition1') && // eslint-disable-next-line no-prototype-builtins
            !model.hasOwnProperty('condition2')) {
              model = {
                condition1: model
              };
            }

            this.__disableStateChangeListener = true;

            this._JoinConditionPanel.setState(model);

            this.__disableStateChangeListener = false;
            this._state = this._JoinConditionPanel.state;
            [this._state.condition1, this._state.condition2].forEach(function (condition) {
              if (condition.filter) {
                condition.filter = new Date(condition.filter);
              }

              if (condition.filterTo) {
                condition.filterTo = new Date(condition.filterTo);
              }
            });
          }
          /**
           * Get the filter model as plain string to display in the floating filter input
           *
           * @param {Object | null} model
           */

        }, {
          key: "getModelAsString",
          value: function getModelAsString(model) {
            if (!model) {
              return '';
            }

            var dateTimeMask = this.getOption('dateTimeMask', this._params, // @todo Find a better way for this
            this._JoinConditionPanel._firstConditionPanel._filterTimeInput.picker.config['dateFormat']);
            var locale = this.getOption('dateTimeLocale', this._params, Intl.DateTimeFormat().resolvedOptions().locale || 'en-US');

            var _JSON$parse = JSON.parse(JSON.stringify(model)),
                condition1 = _JSON$parse.condition1,
                condition2 = _JSON$parse.condition2,
                operator = _JSON$parse.operator;

            [condition1, condition2].forEach(function (condition) {
              if (condition.filter) {
                condition.filter = BBj.Masks.DateMask.mask(condition.filter, dateTimeMask, locale);
              }

              if (condition.filterTo) {
                condition.filterTo = BBj.Masks.DateMask.mask(condition.filterTo, dateTimeMask, locale);
              }
            });
            var firstConditionAsString = "".concat(condition1.filter || '', " ").concat(condition1.filterTo ? ' ' + condition1.filterTo : '');
            var secondConditionAsString = "".concat(condition2.filter || '', " ").concat(condition2.filterTo ? ' ' + condition2.filterTo : '');
            var operatorAsString = "".concat(condition2.filter && operator ? operator : '');
            return "".concat(firstConditionAsString, " ").concat(operatorAsString, " ").concat(secondConditionAsString).trim();
          }
          /**
           * Check if the given value passes the filter defined in the passed ConditionPanel's state
           *
           * @param {Object} condition condition panel state
           * @param {String} value cell value
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "_doesPassCondition",
          value: function _doesPassCondition(condition, value) {
            if (!condition.filter || !value) {
              return false;
            }

            var filter = condition.filter,
                filterTo = condition.filterTo,
                type = condition.type;
            var timezone = BBj.Masks.Utils.Dates.getTimezoneOrOffset();
            var inRangeInclusive = this._doesFilterPassOptions.inRangeInclusive;
            var enableTime = this._doesFilterPassOptions.enableTime;
            var passed = false;

            if (BBj.Masks.Utils.Dates.IS_TIME_REGEX.test(value)) {
              value = value = BBj.Masks.Utils.Dates.fixShortISO(value);
              [filter, filterTo].forEach(function (date) {
                if (date instanceof Date) {
                  date.setFullYear(1970);
                  date.setMonth(0);
                  date.setDate(1);
                }
              });
            } else if (BBj.Masks.Utils.Dates.IS_DATE_REGEX.test(value)) {
              value = BBj.Masks.Utils.Dates.fixShortISO(value);
            } // convert the datetime from utc to locale


            value = Object(__WEBPACK_IMPORTED_MODULE_3_date_fns_tz_utcToZonedTime__["a"
            /* default */
            ])(value, timezone); // firstDate = firstDate ? zonedTimeToUtc(firstDate , timezone) : firstDate
            // secondDate = secondDate ? zonedTimeToUtc(secondDate , timezone) : secondDate

            if (!enableTime) {
              // remove the time portion from the date
              // eslint-disable-next-line no-extra-semi
              ;
              [value, filter, filterTo].forEach(function (date) {
                if (date instanceof Date) {
                  date.setHours(0);
                  date.setMinutes(0);
                  date.setSeconds(0);
                  date.setMilliseconds(0);
                }
              });
            }

            if (type === TOKENS.TOKEN_EQUAL) {
              passed = filter > value === false && filter < value == false;
            } else if (type === TOKENS.TOKEN_NOT_EQUAL) {
              passed = !(filter > value === false && filter < value == false);
            } else if (type === TOKENS.TOKEN_GREATER) {
              passed = filter < value;
            } else if (type === TOKENS.TOKEN_LESS) {
              passed = filter > value;
            } else if (type === TOKENS.TOKEN_RANGE && filterTo) {
              if (inRangeInclusive) {
                passed = (filter < value || filter > value === false && filter < value == false) && filterTo > value || filterTo > value === false && filterTo < value == false;
              } else {
                passed = filter < value && filterTo > value;
              }
            }

            return passed;
          }
          /**
           * List to click button event on the filter panel and execute the
           * right action
           *
           * @param {Event} e
           */

        }, {
          key: "_ApplyFilterPanelButtonClick",
          value: function _ApplyFilterPanelButtonClick(e) {
            var target = e.target;

            if (target.nodeName === 'BUTTON') {
              if (target.classList.contains('reset')) {
                this._JoinConditionPanel.reset();

                this._params.filterChangedCallback();
              } else if (target.classList.contains('clear')) {
                this._JoinConditionPanel.reset();
              } else if (target.classList.contains('apply')) {
                this._params.filterChangedCallback();
              }
            }
          }
          /**
           * Update the filter state and Apply the filter depending on
           * whether the `isApplyButtonActive` is true or false
           *
           * @param {Object} state
           * @param {Boolean} isApplyButtonActive
           */

        }, {
          key: "_onJoinConditionPanelStateChanged",
          value: function _onJoinConditionPanelStateChanged(state, isApplyButtonActive) {
            this._state = state;

            if (false === isApplyButtonActive) {
              this._params.filterChangedCallback();
            }
          }
        }]);

        return DateTimeFilter;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _temp3), (_applyDecoratedDescriptor(_class7.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "init"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "destroy"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "_ApplyFilterPanelButtonClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "_ApplyFilterPanelButtonClick"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "_onJoinConditionPanelStateChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "_onJoinConditionPanelStateChanged"), _class7.prototype)), _class7);
      /* harmony default export */

      __webpack_exports__["a"] = DateTimeFilter;
      /***/
    },
    /* 117 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzTokenizeDate;
      /**
       * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
       * `date` as it will be rendered in the `timeZone`.
       */

      function tzTokenizeDate(date, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      }

      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };

      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date);
        var filled = [];

        for (var i = 0; i < formatted.length; i++) {
          var pos = typeToPos[formatted[i].type];

          if (pos >= 0) {
            filled[pos] = parseInt(formatted[i].value, 10);
          }
        }

        return filled;
      }

      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, '');
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted); // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
        // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]

        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      } // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
      // to get deterministic local date/time output according to the `en-US` locale which
      // can be used to extract local time parts as necessary.


      var dtfCache = {};

      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
          var testDateFormatted = new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: 'America/New_York',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }).format(new Date('2014-06-25T04:00:00.123Z'));
          var hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '06/25/2014 00:00:00';
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }) : new Intl.DateTimeFormat('en-US', {
            hourCycle: 'h23',
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        }

        return dtfCache[timeZone];
      }
      /***/

    },
    /* 118 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = subMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__ = __webpack_require__(119);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__ = __webpack_require__(14);
      /**
       * @name subMilliseconds
       * @category Millisecond Helpers
       * @summary Subtract the specified number of milliseconds from the given date.
       *
       * @description
       * Subtract the specified number of milliseconds from the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
       * @returns {Date} the new date with the milliseconds subtracted
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
       * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:29.250
       */


      function subMilliseconds(dirtyDate, dirtyAmount) {
        Object(__WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__["a"
        /* default */
        ])(2, arguments);
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return Object(__WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__["a"
        /* default */
        ])(dirtyDate, -amount);
      }
      /***/

    },
    /* 119 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = addMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toDate_index_js__ = __webpack_require__(120);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__ = __webpack_require__(14);
      /**
       * @name addMilliseconds
       * @category Millisecond Helpers
       * @summary Add the specified number of milliseconds to the given date.
       *
       * @description
       * Add the specified number of milliseconds to the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
       * @returns {Date} the new date with the milliseconds added
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
       * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:30.750
       */


      function addMilliseconds(dirtyDate, dirtyAmount) {
        Object(__WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__["a"
        /* default */
        ])(2, arguments);
        var timestamp = Object(__WEBPACK_IMPORTED_MODULE_1__toDate_index_js__["a"
        /* default */
        ])(dirtyDate).getTime();
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return new Date(timestamp + amount);
      }
      /***/

    },
    /* 120 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_requiredArgs_index_js__ = __webpack_require__(14);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       *
       * @param {Date|Number} argument - the value to convert
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       *
       * @example
       * // Clone the date:
       * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert the timestamp to date:
       * const result = toDate(1392098430000)
       * //=> Tue Feb 11 2014 11:30:30
       */


      function toDate(argument) {
        Object(__WEBPACK_IMPORTED_MODULE_0__lib_requiredArgs_index_js__["a"
        /* default */
        ])(1, arguments);
        var argStr = Object.prototype.toString.call(argument); // Clone the date

        if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || argStr === '[object Number]') {
          return new Date(argument);
        } else {
          if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
            // eslint-disable-next-line no-console
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

            console.warn(new Error().stack);
          }

          return new Date(NaN);
        }
      }
      /***/

    },
    /* 121 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__ = __webpack_require__(122);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__ = __webpack_require__(39);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns = {
        dateTimeDelimeter: /[T ]/,
        plainTime: /:/,
        timeZoneDelimeter: /[Z ]/i,
        // year tokens
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, // 0 additional digits
        /^([+-]\d{3})$/, // 1 additional digit
        /^([+-]\d{4})$/ // 2 additional digits
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, // 0 additional digits
        /^([+-]\d{5})/, // 1 additional digit
        /^([+-]\d{6})/ // 2 additional digits
        ],
        // date tokens
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        // timezone tokens (to identify the presence of a tz)
        timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If an argument is a string, the function tries to parse it.
       * Function accepts complete ISO 8601 formats as well as partial implementations.
       * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
       * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
       *
       * @param {Date|String|Number} argument - the value to convert
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
       * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // Convert string '2014-02-11T11:30:30' to date:
       * var result = toDate('2014-02-11T11:30:30')
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert string '+02014101' to date,
       * // if the additional number of digits in the extended year format is 1:
       * var result = toDate('+02014101', {additionalDigits: 1})
       * //=> Fri Apr 11 2014 00:00:00
       */

      function toDate(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        if (argument === null) {
          return new Date(NaN);
        }

        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__["a"
        /* default */
        ])(options.additionalDigits);

        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError('additionalDigits must be 0, 1 or 2');
        } // Clone the date


        if (argument instanceof Date || _typeof(argument) === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
          return new Date(argument);
        } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
          return new Date(NaN);
        }

        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date = parseDate(restDateString, year);

        if (isNaN(date)) {
          return new Date(NaN);
        }

        if (date) {
          var timestamp = date.getTime();
          var time = 0;
          var offset;

          if (dateStrings.time) {
            time = parseTime(dateStrings.time);

            if (isNaN(time)) {
              return new Date(NaN);
            }
          }

          if (dateStrings.timezone || options.timeZone) {
            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time));

            if (isNaN(offset)) {
              return new Date(NaN);
            }

            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time + offset));

            if (isNaN(offset)) {
              return new Date(NaN);
            }
          } else {
            // get offset accurate to hour in timezones that change offset
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time));
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time + offset));
          }

          return new Date(timestamp + time + offset);
        } else {
          return new Date(NaN);
        }
      }

      function splitDateString(dateString) {
        var dateStrings = {};
        var array = dateString.split(patterns.dateTimeDelimeter);
        var timeString;

        if (patterns.plainTime.test(array[0])) {
          dateStrings.date = null;
          timeString = array[0];
        } else {
          dateStrings.date = array[0];
          timeString = array[1];
          dateStrings.timezone = array[2];

          if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
          }
        }

        if (timeString) {
          var token = patterns.timezone.exec(timeString);

          if (token) {
            dateStrings.time = timeString.replace(token[1], '');
            dateStrings.timezone = token[1];
          } else {
            dateStrings.time = timeString;
          }
        }

        return dateStrings;
      }

      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns.YYY[additionalDigits];
        var patternYYYYY = patterns.YYYYY[additionalDigits];
        var token; // YYYY or YYYYY

        token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

        if (token) {
          var yearString = token[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        } // YY or YYY


        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

        if (token) {
          var centuryString = token[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        } // Invalid ISO-formatted year


        return {
          year: null
        };
      }

      function parseDate(dateString, year) {
        // Invalid ISO-formatted year
        if (year === null) {
          return null;
        }

        var token;
        var date;
        var month;
        var week; // YYYY

        if (dateString.length === 0) {
          date = new Date(0);
          date.setUTCFullYear(year);
          return date;
        } // YYYY-MM


        token = patterns.MM.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;

          if (!validateDate(year, month)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month);
          return date;
        } // YYYY-DDD or YYYYDDD


        token = patterns.DDD.exec(dateString);

        if (token) {
          date = new Date(0);
          var dayOfYear = parseInt(token[1], 10);

          if (!validateDayOfYearDate(year, dayOfYear)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, 0, dayOfYear);
          return date;
        } // yyyy-MM-dd or YYYYMMDD


        token = patterns.MMDD.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;
          var day = parseInt(token[2], 10);

          if (!validateDate(year, month, day)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month, day);
          return date;
        } // YYYY-Www or YYYYWww


        token = patterns.Www.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;

          if (!validateWeekDate(year, week)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week);
        } // YYYY-Www-D or YYYYWwwD


        token = patterns.WwwD.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;
          var dayOfWeek = parseInt(token[2], 10) - 1;

          if (!validateWeekDate(year, week, dayOfWeek)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week, dayOfWeek);
        } // Invalid ISO-formatted date


        return null;
      }

      function parseTime(timeString) {
        var token;
        var hours;
        var minutes; // hh

        token = patterns.HH.exec(timeString);

        if (token) {
          hours = parseFloat(token[1].replace(',', '.'));

          if (!validateTime(hours)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR;
        } // hh:mm or hhmm


        token = patterns.HHMM.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseFloat(token[2].replace(',', '.'));

          if (!validateTime(hours, minutes)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
        } // hh:mm:ss or hhmmss


        token = patterns.HHMMSS.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseInt(token[2], 10);
          var seconds = parseFloat(token[3].replace(',', '.'));

          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
        } // Invalid ISO-formatted time


        return null;
      }

      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date = new Date(0);
        date.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date.setUTCDate(date.getUTCDate() + diff);
        return date;
      } // Validation functions


      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }

      function validateDate(year, month, date) {
        if (month < 0 || month > 11) {
          return false;
        }

        if (date != null) {
          if (date < 1) {
            return false;
          }

          var isLeapYear = isLeapYearIndex(year);

          if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }

          if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
            return false;
          }
        }

        return true;
      }

      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }

        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear && dayOfYear > 366) {
          return false;
        }

        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }

        return true;
      }

      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }

        if (day != null && (day < 0 || day > 6)) {
          return false;
        }

        return true;
      }

      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }

        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }

        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 122 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = getTimezoneOffsetInMilliseconds;
      var MILLISECONDS_IN_MINUTE = 60000;

      function getDateMillisecondsPart(date) {
        return date.getTime() % MILLISECONDS_IN_MINUTE;
      }
      /**
       * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
       * They usually appear for dates that denote time before the timezones were introduced
       * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
       * and GMT+01:00:00 after that date)
       *
       * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
       * which would lead to incorrect calculations.
       *
       * This function returns the timezone offset in milliseconds that takes seconds in account.
       */


      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime());
        var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        date.setSeconds(0, 0);
        var hasNegativeUTCOffset = baseTimezoneOffset > 0;
        var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date);
        return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
      }
      /***/

    },
    /* 123 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return EventsMixin;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return withEventsMixin;
      });

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * Events Mixin
       *
       * Allow classes to have their own events manager
       *
       * @param {Class} superClass
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var EventsMixin = function EventsMixin(superClass) {
        var _temp;

        return _temp = /*#__PURE__*/function (_superClass) {
          _inherits(_temp, _superClass);

          var _super = _createSuper(_temp);

          function _temp() {
            var _this;

            _classCallCheck(this, _temp);

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));
            _this.__handlers = {};
            return _this;
          }

          _createClass(_temp, [{
            key: "on",

            /**
             * Register an event handler
             *
             * @param {String} name event name
             * @param {Function} handler handler function
             */
            value: function on(name, handler) {
              this.__handlers[name] = this.__handlers[name] || [];

              this.__handlers[name].push(handler);
            }
            /**
             * Remove an event handler
             *
             * **Note :** if handler is not provided then all registered handler for the given event will be removed
             *
             * @param {String} name event name
             * @param {Function} handler handler function
             */

          }, {
            key: "off",
            value: function off(name, handler) {
              this.__handlers[name] = this.__handlers[name] || [];

              if (!handler) {
                delete this.__handlers[name];
              } else {
                for (var registeredHandler in this.__handlers) {
                  if (this.__handlers.hasOwnProperty(registeredHandler) && this.__handlers[registeredHandler] === handler) {
                    delete this.__handlers[name];
                  }
                }
              }
            }
            /**
             * Notify handlers
             *
             * @param {String} name event name
             * @param {Object} event payload
             */

          }, {
            key: "notify",
            value: function notify(name, payload) {
              var handlers = this.__handlers[name] || [];
              handlers.forEach(function (handler) {
                handler(payload);
              });
            }
          }]);

          return _temp;
        }(superClass), _temp;
      };
      /**
       * An events mixin decorator
       *
       * @param {Class} superClass
       *
       * @see {EventsMixin}
       */


      function withEventsMixin(superClass) {
        return EventsMixin(superClass);
      }
      /* unused harmony default export */


      var _unused_webpack_default_export = EventsMixin;
      /***/
    },
    /* 124 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__ = __webpack_require__(37);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__EventsMixin__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__style_scss__ = __webpack_require__(125);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__style_scss__);

      var _class, _class2, _init, _class3, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * DateTimeInput
       *
       * Simple DateTimeInput component which integrates the flatpickr
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeInput = Object(__WEBPACK_IMPORTED_MODULE_3__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inherits(DateTimeInput, _Component);

        var _super = _createSuper(DateTimeInput);
        /**
         * Constant which describes the event name that will be fired when a date
         * is selected using the date picker
         *
         * @type {String}
         */

        /**
         * The date picker instance
         *
         * @type {FlatpickrFn}
         */

        /**
         * The last selected date
         *
         * @type {Date|null}
         */

        /**
         * The component received params when init is called
         *s
         * @type {Object}
         */

        /**
         * Construct new DateTimeInput
         *
         * @param {Boolean} isEditor when true , the input will styled to fit as a cell editor
         */


        function DateTimeInput() {
          var _this;

          var isEditor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _classCallCheck(this, DateTimeInput);

          _this = _super.call(this);
          _this.picker = null;
          _this.selectedDate = null;
          _this._params = {};
          _this._gui = document.createElement('div');
          _this._gui.className = 'ag-cell-edit-wrapper';
          _this._gui.innerHTML =
          /* html */
          "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"datetime__input ".concat(isEditor ? 'datetime__input--editor ' : '', " ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n          <input class=\"datetime__input__input ").concat(isEditor ? 'ag-cell-edit-input ' : '', " ag-input-field-input ag-text-field-input\" type=\"text\" data-input>\n          <a class=\"datetime__input__clear\" data-clear>\n            <i class=\"datetime__input__clear__icon ag-icon ag-icon-cross\"></i>\n          </a>    \n      </div>\n    </div>\n    ");
          return _this;
        }
        /**
         * @inheritDoc
         */


        _createClass(DateTimeInput, [{
          key: "init",
          value: function init(params) {
            this._params = params;
            var enableTime = this.getOption('dateTimeEnableTime', params, true);
            var time_24hr = this.getOption('dateTimeEnable24HR', params, true);
            var enableSeconds = this.getOption('dateTimeEnableSeconds', params, false);
            var noCalendar = !this.getOption('dateTimeEnableCalendar', params, true);
            var dateFormat = this.getOption('dateTimeMask', params); // try to generate a default date format based on the options

            if (!dateFormat) {
              dateFormat = noCalendar ? '' : '%Y/%Mz/%Dz';

              if (enableTime) {
                dateFormat += time_24hr ? ' %Hz:%mz' : ' %hz:%mz';

                if (enableSeconds) {
                  dateFormat += ':%sz';
                }
              }
            }

            dateFormat = dateFormat.trim(); // init the date picker

            this.picker = flatpickr(this._gui, {
              wrap: true,
              // allow entering the date manually requires date parsing from string
              // this is a tough thing and requires libs like moment
              allowInput: false,
              onChange: this._onDateChanged,
              formatDate: this.formatDate,
              maxDate: this.getOption('dateTimeMax', params, null),
              minDate: this.getOption('dateTimeMin', params, null),
              defaultHour: this.getOption('dateTimeDefaultHour', params, 12),
              defaultMinute: this.getOption('dateTimeDefaultMinute', params, 0),
              disableMobile: this.getOption('dateTimeDisableMobile', params, false),
              weekNumbers: this.getOption('dateTimeEnableWeekNumber', params, false),
              locale: this._getPickerLocale(),
              noCalendar: noCalendar,
              dateFormat: dateFormat,
              enableTime: enableTime,
              enableSeconds: enableSeconds,
              time_24hr: time_24hr
            }); // force dialog overflow

            this.picker.calendarContainer.classList.add('ag-custom-component-popup');
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this.picker.destroy();
            this.off(DateTimeInput.ON_DATE_CHANGED);
          }
          /**
           * Set the picker date
           *
           * @param {Date|String} value the date value to set
           */

        }, {
          key: "setDate",
          value: function setDate(value) {
            this.picker.setDate(value, true);
          }
          /**
           * Open Picker
           */

        }, {
          key: "open",
          value: function open() {
            this.picker.open();

            this._gui.querySelector('input').focus();
          }
          /**
           * Close picker
           */

        }, {
          key: "close",
          value: function close() {
            this.picker.close();
          }
          /**
           * Reset the picker
           */

        }, {
          key: "reset",
          value: function reset() {
            /** this check because the tests fail here for some reasons  */
            if (this.picker.config) {
              this.picker.clear();
            }
          }
          /**
           * Format the date using `BBj.Masks.Types.date`
           *
           * @param {String} date date as a string
           * @param {String} format BBj date format
           *
           * @return {String} formatted date as string
           */

        }, {
          key: "formatDate",
          value: function formatDate(date, format) {
            var dateTimeFormatter = this.getOption('dateTimeFormatter', this._params);
            var locale = this.getOption('dateTimeLocale', this._params, Intl.DateTimeFormat().resolvedOptions().locale || 'en-US');

            if (dateTimeFormatter) {
              var type = _typeof(dateTimeFormatter);

              var expression = dateTimeFormatter;

              switch (type) {
                case 'string':
                  if (!(expression.indexOf('return') >= 0)) {
                    expression = 'return ' + expression + ';';
                  }

                  return new Function('date', 'format', 'locale', 'DateMask', expression)(date, format, locale, BBj.Masks.DateMask);

                case 'function':
                  return dateTimeFormatter(date, format, locale, BBj.Masks.DateMask);

                default:
                  throw new Error("Invalid dateTimeFormatter defined for column \"".concat(this._params.colDef.field, "\". The formatter should be an expression or plain function"));
              }
            } else {
              if (!format || format && format.indexOf('%') < 0) {
                return;
              }

              return BBj.Masks.DateMask.mask(date, format, locale);
            }
          }
          /**
           * Listen to date picker changes and update the selected date
           *
           * @param {Array} selectedDates  array of selected dates
           */

        }, {
          key: "_onDateChanged",
          value: function _onDateChanged(selectedDates) {
            this.selectedDate = selectedDates[0] || null;
            this.notify(DateTimeInput.ON_DATE_CHANGED, this.selectedDate);
          }
          /**
           * Get picker global localization which will work with any locale
           *
           * @return {Object}
           *
           * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/default.ts
           */

        }, {
          key: "_getPickerLocale",
          value: function _getPickerLocale() {
            var locale = Intl.DateTimeFormat().resolvedOptions().locale || 'en-US';
            var weekDaysShort = [];
            var weekDaysLong = [];

            for (var day = 4; day < 11; day++) {
              var date = new Date(1970, 1 - 1, day);
              weekDaysShort.push(date.toLocaleString(locale, {
                weekday: 'short'
              }).split(',')[0] // the date-time-format-timezone polyfill attach the date also
              );
              weekDaysLong.push(date.toLocaleString(locale, {
                weekday: 'long'
              }).split(',')[0] // the date-time-format-timezone polyfill attach the date also
              );
            }

            var monthsShort = [];
            var monthsLong = [];

            for (var month = 0; month < 12; month++) {
              var _date = new Date(1970, month, 4);

              monthsShort.push(_date.toLocaleString(locale, {
                month: 'short'
              }));
              monthsLong.push(_date.toLocaleString(locale, {
                month: 'long'
              }));
            }

            return {
              weekdays: {
                shorthand: weekDaysShort,
                longhand: weekDaysLong
              },
              months: {
                shorthand: monthsShort,
                longhand: monthsLong
              },
              daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
              firstDayOfWeek: BBj.Masks.Utils.Dates.getWeekStartByLocale(locale),
              // eslint-disable-next-line no-unused-vars
              ordinal: function ordinal(number) {
                return '';
              },
              rangeSeparator: '  ',
              weekAbbreviation: '',
              scrollTitle: '',
              toggleTitle: '',
              amPM: ['AM', 'PM'],
              yearAriaLabel: '',
              hourAriaLabel: '',
              minuteAriaLabel: ''
            };
          }
        }]);

        return DateTimeInput;
      }(__WEBPACK_IMPORTED_MODULE_4__Component__["a"
      /* default */
      ]), _class3.ON_DATE_CHANGED = 'DateTimeInput.ON_DATE_CHANGED', _temp), (_applyDecoratedDescriptor(_class2, "ON_DATE_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init = Object.getOwnPropertyDescriptor(_class2, "ON_DATE_CHANGED"), _init = _init ? _init.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init;
        }
      }), _class2), _applyDecoratedDescriptor(_class2.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "init"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "destroy"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "formatDate", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "formatDate"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "_onDateChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "_onDateChanged"), _class2.prototype)), _class2)) || _class;
      /* harmony default export */


      __webpack_exports__["a"] = DateTimeInput;
      /***/
    },
    /* 125 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(126);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 126 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".datetime__input{display:flex;align-items:center;width:100%;height:100%;overflow:hidden;border:1px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:3px}.datetime__input:focus,.datetime__input:active,.datetime__input:hover{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.datetime__input__input{flex:1;padding:6px;border:none;outline:none;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .datetime__input__input,.ag-theme-balham .datetime__input__input,.ag-theme-material .datetime__input__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .datetime__input__input,.ag-theme-balham-dark .datetime__input__input{background-color:var(--ag-background-color, #2d3436)}.datetime__input__clear{margin-left:1px;margin-top:1px;padding:6px;text-align:center;border:none;outline:none;cursor:pointer;color:inherit}.datetime__input--editor{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.datetime__input--editor .datetime__input__input{padding:0;padding-left:6px}\n", ""]); // exports

      /***/
    },
    /* 127 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(128);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 128 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".dateTimeFilter select{margin-bottom:9px;padding:6px;border-radius:3px;border:1px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));color:inherit}.dateTimeFilter select:focus,.dateTimeFilter select:active{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.dateTimeFilter select option{text-indent:6px}\n", ""]); // exports

      /***/
    },
    /* 129 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeEditor__ = __webpack_require__(130);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 130 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_date_fns_tz_utcToZonedTime__ = __webpack_require__(38);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__DateTimeInput__ = __webpack_require__(41);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__Component__ = __webpack_require__(0);

      var _class, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * DateTimeInput
       *
       * Simple DateTimeInput component which integrates the flatpickr
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **dateTimeEnableTime**   | false    | enable / disable time
       * | **dateTimeEnable24HR**   | false    | enable / disable time 24 format
       * | **dateTimeEnableSeconds**   | false    | enable / disable seconds management
       * | **dateTimeEnableCalendar**   | false    | enable / disable Calendar.
       * | **dateTimeMask**   | false    | The mask used to format the selected date
       * | **dateTimeMax**   | undefined    |  Max allowed date
       * | **dateTimeMin**   | undefined    |  Min allowed date
       * | **dateTimeFormatter**   | false    |  A function or expression to format the date (@see supported param)
       * | **dateTimeLocale**   | System default    |  A locale to use for date formatting
       * | **dateTimeDefaultHour**   | 12    |  Initial value of the hour element.
       * | **dateTimeDefaultMinute**   | 0    |  Initial value of the minute element.
       * | **dateTimeDisableMobile**   | false    |  Set disableMobile to true to always use the non-native picker.
       * | **dateTimeEnableWeekNumber**   | true    |  Enables display of week numbers in calendar.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeEditor = (_class = (_temp = /*#__PURE__*/function (_Component) {
        _inherits(DateTimeEditor, _Component);

        var _super = _createSuper(DateTimeEditor);

        function DateTimeEditor() {
          var _this;

          _classCallCheck(this, DateTimeEditor);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));
          _this._input = new __WEBPACK_IMPORTED_MODULE_3__DateTimeInput__["a"
          /* default */
          ](true);
          _this._value = null;
          _this._params = null;
          return _this;
        }

        _createClass(DateTimeEditor, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            this._params = params;
            this.focusAfterAttached = params.cellStartedEdit;

            if (this.focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                this._value = '';
              } else if (params.charPress !== null) {
                this._value = params.charPress;
              } else {
                this._value = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this.highlightAllOnFocus = true;
                }
              }
            } else {
              this._value = params.value;
            }

            this._value = DateTimeEditor.fixShortISO(this._value);

            this._input.init(params);

            this._input.on(__WEBPACK_IMPORTED_MODULE_3__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, this._onDateChange);

            if (this._value) {
              this._input.setDate(Object(__WEBPACK_IMPORTED_MODULE_2_date_fns_tz_utcToZonedTime__["a"
              /* default */
              ])(this._value, BBj.Masks.Utils.Dates.getTimezoneOrOffset()));
            }

            this._gui = this._input.getGui();
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._input.destroy();
          }
          /**
           * Gets called once after GUI is attached to DOM.
           * Make sure the container is always focused and listening to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (this.focusAfterAttached) {
              this.focusIn();
            }
          }
          /**
           * Get the final value to the grid, the result of the editing
           *
           * @return {Boolean}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._params.parseValue(this._value);
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._input.open();
          }
          /**
           * If doing full row edit, then gets called when tabbing out of the cell.
           */

        }, {
          key: "focusOut",
          value: function focusOut() {
            this._input.close();
          }
          /**
           * Update the editor value with selected date from the input
           *
           * @param {String} date
           */

        }, {
          key: "_onDateChange",
          value: function _onDateChange(date) {
            this._value = date instanceof Date ? date.toISOString() : '';
          }
        }], [{
          key: "fixShortISO",

          /**
           * Takes incomplete iso string and return a complete one
           *
           * @param {String} date incomplete iso string
           *
           * @return {String} complete iso string
           */
          value: function fixShortISO(value) {
            return BBj.Masks.Utils.Dates.fixShortISO(value);
          }
        }]);

        return DateTimeEditor;
      }(__WEBPACK_IMPORTED_MODULE_4__Component__["a"
      /* default */
      ]), _temp), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onDateChange", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onDateChange"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = DateTimeEditor;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)(module)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/** https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent  */
// eslint-disable-next-line no-extra-semi
;

(function () {
  if (typeof window.CustomEvent === 'function') {
    return false;
  } //If not IE


  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _init = __webpack_require__(54);

Object.keys(_init).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _init[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _init[key];
    }
  });
});

var _columns = __webpack_require__(17);

Object.keys(_columns).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _columns[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _columns[key];
    }
  });
});

var _rows = __webpack_require__(9);

Object.keys(_rows).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _rows[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _rows[key];
    }
  });
});

var _cells = __webpack_require__(20);

Object.keys(_cells).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cells[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _cells[key];
    }
  });
});

var _state = __webpack_require__(112);

Object.keys(_state).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _state[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _state[key];
    }
  });
});

var _toolpanel = __webpack_require__(113);

Object.keys(_toolpanel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _toolpanel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _toolpanel[key];
    }
  });
});

var _statusbar = __webpack_require__(114);

Object.keys(_statusbar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _statusbar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _statusbar[key];
    }
  });
});

var _overlays = __webpack_require__(115);

Object.keys(_overlays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _overlays[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _overlays[key];
    }
  });
});

var _context = __webpack_require__(116);

Object.keys(_context).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _context[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _context[key];
    }
  });
});

var _charts = __webpack_require__(19);

Object.keys(_charts).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _charts[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _charts[key];
    }
  });
});

var _jss = __webpack_require__(117);

Object.keys(_jss).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _jss[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _jss[key];
    }
  });
});

var _utilities = __webpack_require__(0);

Object.keys(_utilities).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _utilities[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _utilities[key];
    }
  });
});

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_init = gw_init;

var _columns = __webpack_require__(17);

var _rows = __webpack_require__(9);

var _menus = __webpack_require__(55);

var _charts = __webpack_require__(19);

var _utilities = __webpack_require__(0);

var _events = __webpack_require__(56);

var _template = _interopRequireDefault(__webpack_require__(21));

var _HTMLTooltip = _interopRequireDefault(__webpack_require__(109));

var _SuggestionEditor = _interopRequireDefault(__webpack_require__(110));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(7),
    deepParseJson = _require.deepParseJson;

function gw_init(options, license, data) {
  if (agGrid.LicenseManager && license) {
    agGrid.LicenseManager.setLicenseKey(license);
  }

  var id = options.context.id;
  var container = (0, _utilities.gw_getDocument)().getElementById(id);
  var containerClone = container.cloneNode(true);
  container.parentNode.replaceChild(containerClone, container);
  container = containerClone; // we make the grid options available as soon as possible

  var grid = (0, _utilities.gw_addGrid)(id, {
    container: container,
    options: options
  }); // TODO: use ag grid destroy

  container.innerHTML = '';
  var parsedOptions = gw_parseOptions(options);
  parsedOptions.rowData = data;
  var instance = new agGrid.Grid(container, parsedOptions);
  grid.instance = instance;
  grid.options = parsedOptions;
  console.log("%c Grid [".concat(id, "] settings : "), 'background: #222; color: #bada55', parsedOptions);
}
/**
 * Parse Options
 *
 * Parse the grid options and return
 * an object which can be passed to the grid
 *
 * @param {Object} options Grid options as Json Object
 *
 * @return {Object} options object
 */


function gw_parseOptions(options) {
  var deepParsedOptions = deepParseJson(JSON.stringify(options));
  var id = deepParsedOptions.context.id;
  var getDataPathTemplate = deepParsedOptions.context.getDataPath || ''; // TODO: do we need to control this setting from BBj ?

  var debounceDuration = 250;

  var finalOptions = _objectSpread(_objectSpread({}, deepParsedOptions), {
    getDocument: function getDocument() {
      return (0, _utilities.gw_getDocument)();
    },
    onCellEditingStarted: function onCellEditingStarted(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onCellEditingStopped: function onCellEditingStopped(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onCellValueChanged: function onCellValueChanged(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onRowEditingStarted: function onRowEditingStarted(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onRowValueChanged: function onRowValueChanged(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onRowEditingStopped: function onRowEditingStopped(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onGridReady: function onGridReady(e) {
      (0, _events.gw_onReadyEvent)(id, e);
    },
    onFilterChanged: function onFilterChanged(e) {
      (0, _events.gw_onFilterChanged)(id, e);
    },
    getRowId: function getRowId(data) {
      return (0, _rows.gw_getRowNodeId)(id, data);
    },
    getContextMenuItems: function getContextMenuItems(params) {
      return (0, _menus.gw_getContextMenu)(id, params);
    },
    getChartToolbarItems: _charts.gw_getChartToolbarItems,
    popupParent: (0, _utilities.gw_getDocument)().body,
    onRowDoubleClicked: (0, _events.gw_debounce)(_events.gw_onRowDoubleClicked, debounceDuration),
    onRowClicked: (0, _events.gw_debounce)(_events.gw_onRowClicked, debounceDuration),
    onCellClicked: (0, _events.gw_debounce)(_events.gw_onCellClickEvent, debounceDuration),
    onCellDoubleClicked: (0, _events.gw_debounce)(_events.gw_onCellClickEvent, debounceDuration),
    onSelectionChanged: (0, _events.gw_debounce)(_events.gw_onSelectionChanged, debounceDuration),
    onRangeSelectionChanged: (0, _events.gw_debounce)(_events.gw_onRangeSelectionChanged, debounceDuration),
    components: {
      BooleanFilter: Basis.AgGridComponents.BooleanFilter,
      BooleanRenderer: Basis.AgGridComponents.BooleanRenderer,
      BooleanEditor: Basis.AgGridComponents.BooleanEditor,
      NumberEditor: Basis.AgGridComponents.NumberEditor,
      TextEditor: Basis.AgGridComponents.TextEditor,
      DateTimeEditor: Basis.AgGridComponents.DateTimeEditor,
      DateTimeFilter: Basis.AgGridComponents.DateTimeFilter,
      ImageRenderer: Basis.AgGridComponents.ImageRenderer,
      TemplateRenderer: Basis.AgGridComponents.TemplateRenderer,
      HTMLTooltip: _HTMLTooltip.default,
      SuggestionEditor: _SuggestionEditor.default
    },
    context: _objectSpread(_objectSpread({}, deepParsedOptions.context), {
      document: (0, _utilities.gw_getDocument)(),
      window: (0, _utilities.gw_getWindow)()
    }),
    alignedGrids: []
  });

  if ( // eslint-disable-next-line no-prototype-builtins
  finalOptions.context.hasOwnProperty('navigateToNextCell') && finalOptions.context.navigateToNextCell) {
    finalOptions.navigateToNextCell = function (params) {
      return (0, _rows.gw_navigateToNextRow)(id, params);
    };
  }

  if (getDataPathTemplate && finalOptions.treeData) {
    var getDataPathTemplateComplied = (0, _template.default)(getDataPathTemplate);

    finalOptions.getDataPath = function (data) {
      return getDataPathTemplateComplied({
        data: data
      });
    };
  } // extend the column definitions


  (0, _columns.gw_extendColumnDefinitions)(finalOptions.columnDefs);
  return finalOptions;
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getContextMenu = gw_getContextMenu;

var _utilities = __webpack_require__(0);

var _utilities2 = __webpack_require__(1);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_getContextMenu(gridId, params) {
  var buildContextMenuAction = function buildContextMenuAction(params, id) {
    return function () {
      var node = (0, _utilities2.gw_parseNodeFromEvent)(params);
      var colId = params.column.colId;
      var value = params.value;
      (0, _utilities2.gw_sendEvent)((0, _utilities.gw_getGrid)(gridId).options.context, {
        type: 'gw.contextmenu',
        detail: JSON.stringify({
          r: node,
          c: colId,
          v: value,
          i: id
        })
      }, id);
    };
  };

  var parseMenu = function parseMenu(menu) {
    menu.forEach(function (item) {
      if (typeof item === 'string') {
        return;
      }

      item['action'] = buildContextMenuAction(params, item.id);

      if (item['cssClasses'] && !Array.isArray(item['cssClasses'])) {
        item['cssClasses'] = item['cssClasses'].split(' ');
      }

      if (item['subMenu']) {
        item['subMenu'] = parseMenu(item['subMenu']);
      }
    });
    return menu;
  };

  return parseMenu((0, _utilities.gw_getGrid)(gridId).options.context.contextMenu);
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "gw_onRowClicked", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRowClicked;
  }
});
Object.defineProperty(exports, "gw_onRowDoubleClicked", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRowDoubleClicked;
  }
});
Object.defineProperty(exports, "gw_onSelectionChanged", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onSelectionChanged;
  }
});
Object.defineProperty(exports, "gw_onCellClickEvent", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onCellClickEvent;
  }
});
Object.defineProperty(exports, "gw_onRangeSelectionChanged", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRangeSelectionChanged;
  }
});
Object.defineProperty(exports, "gw_onCellEditingEvent", {
  enumerable: true,
  get: function get() {
    return _editing.gw_onCellEditingEvent;
  }
});
Object.defineProperty(exports, "gw_onRowEditingEvent", {
  enumerable: true,
  get: function get() {
    return _editing.gw_onRowEditingEvent;
  }
});
Object.defineProperty(exports, "gw_onReadyEvent", {
  enumerable: true,
  get: function get() {
    return _ready.gw_onReadyEvent;
  }
});
Object.defineProperty(exports, "gw_debounce", {
  enumerable: true,
  get: function get() {
    return _utilities.gw_debounce;
  }
});
Object.defineProperty(exports, "gw_onFilterChanged", {
  enumerable: true,
  get: function get() {
    return _filters.gw_onFilterChanged;
  }
});

var _selections = __webpack_require__(57);

var _editing = __webpack_require__(58);

var _ready = __webpack_require__(59);

var _utilities = __webpack_require__(1);

var _filters = __webpack_require__(62);

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onRowDoubleClicked = gw_onRowDoubleClicked;
exports.gw_onRowClicked = gw_onRowClicked;
exports.gw_onSelectionChanged = gw_onSelectionChanged;
exports.gw_onRangeSelectionChanged = gw_onRangeSelectionChanged;
exports.gw_onCellClickEvent = gw_onCellClickEvent;

var _utilities = __webpack_require__(1);

var _utilities2 = __webpack_require__(0);

var _constants = __webpack_require__(3);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var CELL_CLICKING_EVENTS_MAP = {
  cellClicked: _constants.GW_EVENT_CELL_CLICK,
  cellDoubleClicked: _constants.GW_EVENT_CELL_DOUBLE_CLICK
};
/**
 * An handler for the grid `rowDoubleClicked` event
 *
 * The function will send a bbj event with `GW_NODE` as payload
 *
 * @param {Object} e The event's payload
 *
 * @listens agGrid.rowDoubleClicked
 * @fires gw.rowDoubleClick
 */

function gw_onRowDoubleClicked(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowDoubleClick',
    detail: JSON.stringify({
      k: (0, _utilities2.gw_getGrid)(context.id).keys
    })
  }, _constants.GW_EVENT_ROW_DOUBLE_CLICK);
}
/**
 * A handler for the grid `rowClicked` event
 *
 * @param {Object} e  The event payload
 *
 * @listens agGrid.rowClicked
 * @fires gw.rowClick
 */


function gw_onRowClicked(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowClick',
    detail: JSON.stringify({
      k: (0, _utilities2.gw_getGrid)(context.id).keys
    })
  }, _constants.GW_EVENT_ROW_CLICK);
}
/**
 * A handler for the grid `selectionChanged` event
 *
 * @param {Object} e  The event payload
 *
 * @listens agGrid.selectionChanged
 * @fires gw.rowSelect
 */


function gw_onSelectionChanged(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowSelect',
    detail: ''
  }, _constants.GW_EVENT_ROW_SELECT);
}
/**
 * A handler for the grid `rangeSelectionChanged` event
 *
 * @param {Object} e
 *
 * @listens agGrid.rangeSelectionChanged
 * @fires gw.rangeSelection
 */


function gw_onRangeSelectionChanged(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rangeSelection',
    detail: ''
  }, _constants.GW_EVENT_RANGE_SELECTION_CHANGED);
}
/**
 * A handler for the grid `cellClickEvent` & `cellDoubleClicked` event
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.cellClickEvent
 * @listens agGrid.cellDoubleClicked
 *
 * @fires gw.cellClicked
 * @fires gw.cellDoubleClicked
 */


function gw_onCellClickEvent(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  var id = context.id;
  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);

  if (parsed) {
    var type = e.type;
    (0, _utilities.gw_sendEvent)(context, {
      type: "gw.".concat(e.type),
      detail: JSON.stringify({
        r: parsed,
        // row
        v: (0, _utilities2.gw_escape)(e.value),
        // new value
        o: (0, _utilities2.gw_escape)(e.value),
        // odl value
        c: e.column.colId,
        // columns
        k: (0, _utilities2.gw_getGrid)(id).keys
      })
    }, CELL_CLICKING_EVENTS_MAP[type]);
  }
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onCellEditingEvent = gw_onCellEditingEvent;
exports.gw_onRowEditingEvent = gw_onRowEditingEvent;

var _utilities = __webpack_require__(1);

var _utilities2 = __webpack_require__(0);

var _constants = __webpack_require__(3);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CELL_EDITING_EVENTS_MAP = {
  cellEditingStarted: _constants.GW_EVENT_CELL_EDITING_STARTED,
  cellEditingStopped: _constants.GW_EVENT_CELL_EDITING_STOPPED,
  cellValueChanged: _constants.GW_EVENT_CELL_VALUE_CHANGED
};
var ROW_EDITING_EVENTS_MAP = {
  rowEditingStarted: _constants.GW_EVENT_ROW_EDITING_STARTED,
  rowEditingStopped: _constants.GW_EVENT_ROW_EDITING_STOPPED,
  rowValueChanged: _constants.GW_EVENT_ROW_VALUE_CHANGED
};
/**
 * An handler for the grid `cellEditingStarted` , `cellEditingStopped` and
 * `cellValueChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.cellEditingStarted
 * @listens agGrid.cellEditingStopped
 * @listens agGrid.cellValueChanged
 *
 * @fires gw.cellEditingStarted
 * @fires gw.cellEditingStopped
 * @fires gw.cellValueChanged
 */

function gw_onCellEditingEvent(id, e) {
  var value = e.hasOwnProperty('newValue') ? (0, _utilities2.gw_escape)(e.newValue) : (0, _utilities2.gw_escape)(e.value);
  var oldValue = e.hasOwnProperty('oldValue') ? (0, _utilities2.gw_escape)(e.oldValue) : e.hasOwnProperty('newValue') ? (0, _utilities2.gw_escape)(e.newValue) : (0, _utilities2.gw_escape)(e.value);

  if (value == oldValue && e.type === 'cellValueChanged') {
    return;
  }

  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);
  var type = e.type;
  var colId = e.column.colId;

  if (parsed) {
    (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
      type: "gw.".concat(type),
      detail: JSON.stringify({
        r: _objectSpread(_objectSpread({}, parsed), {
          cr: e.data
        }),
        // row (we always include the client row data)
        v: value,
        // new value
        o: oldValue,
        // old value
        c: colId // column

      })
    }, CELL_EDITING_EVENTS_MAP[type]);
  }
}
/**
 * An handler for the grid `rowEditingStarted` , `rowEditingStopped` and `rowValueChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.rowEditingStarted
 * @listens agGrid.rowEditingStopped
 * @listens agGrid.rowValueChanged
 *
 * @fires gw.rowEditingStarted
 * @fires gw.rowEditingStopped
 * @fires gw.rowValueChanged
 */


function gw_onRowEditingEvent(id, e) {
  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);

  if (parsed) {
    var type = e.type;
    (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
      type: "gw.".concat(e.type),
      detail: JSON.stringify(_objectSpread(_objectSpread({}, parsed), {
        cr: e.data
      })) // row (we always include the client row data)

    }, ROW_EDITING_EVENTS_MAP[type]);
  }
}

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onReadyEvent = gw_onReadyEvent;

var _utilities = __webpack_require__(1);

var _state = __webpack_require__(60);

var _keyboard = __webpack_require__(61);

var _utilities2 = __webpack_require__(0);

var _constants = __webpack_require__(3);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * On Ready Event
 *
 * The method will ignore first ready event and then register a debounced state
 * callback to send state events to BBj
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.gridReady
 * @fires gw.ready
 */
// eslint-disable-next-line no-unused-vars
function gw_onReadyEvent(id, _e) {
  var grid = (0, _utilities2.gw_getGrid)(id);
  (0, _utilities.gw_sendEvent)(grid.options.context, {
    type: 'gw.gridReady',
    detail: {}
  }, _constants.GW_EVENT_READY); // register state debounce monitor

  var stateDebounce = (0, _utilities.gw_debounce)(function (changeEvent) {
    (0, _state.gw_onStateChanged)(id, changeEvent);
  }, 500);
  ['sortChanged', 'filterChanged', 'columnVisible', 'columnPinned', 'columnResized', 'columnMoved', 'newColumnsLoaded', 'gridColumnsChanged', 'displayedColumnsChanged', 'virtualColumnsChanged', 'columnEverythingChanged', //'gridSizeChanged',
  'expandOrCollapseAll' //'toolPanelVisibleChanged'
  ].forEach(function (event) {
    grid.options.api.addEventListener(event, stateDebounce);
  }); // collect key downs information to be reported with other events

  grid.container.addEventListener('keydown', function (keydownEvent) {
    grid.keys = {
      c: keydownEvent.key,
      kc: keydownEvent.which || Number(keydownEvent.keyCode),
      ak: keydownEvent.altKey,
      sk: keydownEvent.shiftKey,
      ck: keydownEvent.ctrlKey
    };
  }); // clear collect keydown information

  grid.container.addEventListener('keyup', // eslint-disable-next-line no-unused-vars
  (0, _utilities.gw_debounce)(function (_e) {
    grid.keys = null;
  }, 250)); // register keyboard debounce monitor

  grid.container.addEventListener('keydown', (0, _utilities.gw_debounce)(function (keydownEvent) {
    (0, _keyboard.gw_onKeydown)(id, keydownEvent);
  }, 500));
  window.dispatchEvent(new CustomEvent("".concat(id, "-ready"), {
    detail: grid
  }));
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onStateChanged = gw_onStateChanged;

var _utilities = __webpack_require__(1);

var _utilities2 = __webpack_require__(0);

var _constants = __webpack_require__(3);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An handler for the grid `stateChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.stateChanged
 * @listens agGrid.rowEditingStopped
 *
 * @fires gw.stateChanged
 */
// eslint-disable-next-line no-unused-vars
function gw_onStateChanged(id, _e) {
  (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
    type: 'gw.stateChanged',
    detail: []
  }, _constants.GW_EVENT_GRID_STATE_CHANGE);
}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onKeydown = gw_onKeydown;

var _utilities = __webpack_require__(1);

var _constants = __webpack_require__(3);

var _utilities2 = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Compose a model of the keydown event and send it to BBj
 *
 * @param {String} id  the grid's id
 * @param {Event} keydownEvent keydown event
 */
function gw_onKeydown(id, keydownEvent) {
  (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
    type: "gw.keypress",
    detail: JSON.stringify({
      c: keydownEvent.key,
      kc: keydownEvent.which || Number(keydownEvent.keyCode),
      ak: keydownEvent.altKey,
      sk: keydownEvent.shiftKey,
      ck: keydownEvent.ctrlKey
    })
  }, _constants.GW_EVENT_KEYPRESS);
}

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onFilterChanged = gw_onFilterChanged;

var _utilities = __webpack_require__(1);

var _constants = __webpack_require__(3);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An handler for the grid `filterChanged` event
 *
 * @param {String} the grid's id
 * @param {Object} e The event's payload
 *
 * @listens agGrid.filterChanged
 * @fires gw.filterChanged
 */
function gw_onFilterChanged(id, e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.filterChanged',
    detail: {}
  }, _constants.GW_EVENT_FILTER_CHANGED);
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _copyObject = _interopRequireDefault(__webpack_require__(64));

var _createAssigner = _interopRequireDefault(__webpack_require__(74));

var _keysIn = _interopRequireDefault(__webpack_require__(80));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = (0, _createAssigner.default)(function (object, source, srcIndex, customizer) {
  (0, _copyObject.default)(source, (0, _keysIn.default)(source), object, customizer);
});
var _default = assignInWith;
exports.default = _default;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assignValue = _interopRequireDefault(__webpack_require__(65));

var _baseAssignValue = _interopRequireDefault(__webpack_require__(22));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      (0, _baseAssignValue.default)(object, key, newValue);
    } else {
      (0, _assignValue.default)(object, key, newValue);
    }
  }

  return object;
}

var _default = copyObject;
exports.default = _default;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseAssignValue = _interopRequireDefault(__webpack_require__(22));

var _eq = _interopRequireDefault(__webpack_require__(12));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && (0, _eq.default)(objValue, value)) || value === undefined && !(key in object)) {
    (0, _baseAssignValue.default)(object, key, value);
  }
}

var _default = assignValue;
exports.default = _default;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsNative = _interopRequireDefault(__webpack_require__(67));

var _getValue = _interopRequireDefault(__webpack_require__(73));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = (0, _getValue.default)(object, key);
  return (0, _baseIsNative.default)(value) ? value : undefined;
}

var _default = getNative;
exports.default = _default;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(24));

var _isMasked = _interopRequireDefault(__webpack_require__(70));

var _isObject = _interopRequireDefault(__webpack_require__(8));

var _toSource = _interopRequireDefault(__webpack_require__(72));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!(0, _isObject.default)(value) || (0, _isMasked.default)(value)) {
    return false;
  }

  var pattern = (0, _isFunction.default)(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0, _toSource.default)(value));
}

var _default = baseIsNative;
exports.default = _default;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(10));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

var _default = getRawTag;
exports.default = _default;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _default = objectToString;
exports.default = _default;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _coreJsData = _interopRequireDefault(__webpack_require__(71));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData.default && _coreJsData.default.keys && _coreJsData.default.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _default = isMasked;
exports.default = _default;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(11));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect overreaching core-js shims. */
var coreJsData = _root.default['__core-js_shared__'];
var _default = coreJsData;
exports.default = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _default = toSource;
exports.default = _default;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _default = getValue;
exports.default = _default;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseRest = _interopRequireDefault(__webpack_require__(26));

var _isIterateeCall = _interopRequireDefault(__webpack_require__(29));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return (0, _baseRest.default)(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && (0, _isIterateeCall.default)(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

var _default = createAssigner;
exports.default = _default;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apply = _interopRequireDefault(__webpack_require__(28));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return (0, _apply.default)(func, this, otherArgs);
  };
}

var _default = overRest;
exports.default = _default;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseSetToString = _interopRequireDefault(__webpack_require__(77));

var _shortOut = _interopRequireDefault(__webpack_require__(79));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = (0, _shortOut.default)(_baseSetToString.default);
var _default = setToString;
exports.default = _default;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constant = _interopRequireDefault(__webpack_require__(78));

var _defineProperty = _interopRequireDefault(__webpack_require__(23));

var _identity = _interopRequireDefault(__webpack_require__(27));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty.default ? _identity.default : function (func, string) {
  return (0, _defineProperty.default)(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': (0, _constant.default)(string),
    'writable': true
  });
};
var _default = baseSetToString;
exports.default = _default;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

var _default = constant;
exports.default = _default;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

var _default = shortOut;
exports.default = _default;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayLikeKeys = _interopRequireDefault(__webpack_require__(32));

var _baseKeysIn = _interopRequireDefault(__webpack_require__(90));

var _isArrayLike = _interopRequireDefault(__webpack_require__(13));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return (0, _isArrayLike.default)(object) ? (0, _arrayLikeKeys.default)(object, true) : (0, _baseKeysIn.default)(object);
}

var _default = keysIn;
exports.default = _default;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

var _default = baseTimes;
exports.default = _default;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsArguments = _interopRequireDefault(__webpack_require__(83));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = (0, _baseIsArguments.default)(function () {
  return arguments;
}()) ? _baseIsArguments.default : function (value) {
  return (0, _isObjectLike.default)(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var _default = isArguments;
exports.default = _default;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return (0, _isObjectLike.default)(value) && (0, _baseGetTag.default)(value) == argsTag;
}

var _default = baseIsArguments;
exports.default = _default;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(11));

var _stubFalse = _interopRequireDefault(__webpack_require__(85));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `exports`. */
var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root.default.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || _stubFalse.default;
var _default = isBuffer;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)(module)))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var _default = stubFalse;
exports.default = _default;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsTypedArray = _interopRequireDefault(__webpack_require__(87));

var _baseUnary = _interopRequireDefault(__webpack_require__(88));

var _nodeUtil = _interopRequireDefault(__webpack_require__(89));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil.default && _nodeUtil.default.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? (0, _baseUnary.default)(nodeIsTypedArray) : _baseIsTypedArray.default;
var _default = isTypedArray;
exports.default = _default;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _isLength = _interopRequireDefault(__webpack_require__(30));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return (0, _isObjectLike.default)(value) && (0, _isLength.default)(value.length) && !!typedArrayTags[(0, _baseGetTag.default)(value)];
}

var _default = baseIsTypedArray;
exports.default = _default;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

var _default = baseUnary;
exports.default = _default;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _freeGlobal = _interopRequireDefault(__webpack_require__(25));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `exports`. */
var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && _freeGlobal.default.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

var _default = nodeUtil;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)(module)))

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObject = _interopRequireDefault(__webpack_require__(8));

var _isPrototype = _interopRequireDefault(__webpack_require__(34));

var _nativeKeysIn = _interopRequireDefault(__webpack_require__(91));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!(0, _isObject.default)(object)) {
    return (0, _nativeKeysIn.default)(object);
  }

  var isProto = (0, _isPrototype.default)(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

var _default = baseKeysIn;
exports.default = _default;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var _default = nativeKeysIn;
exports.default = _default;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apply = _interopRequireDefault(__webpack_require__(28));

var _baseRest = _interopRequireDefault(__webpack_require__(26));

var _isError = _interopRequireDefault(__webpack_require__(35));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = (0, _baseRest.default)(function (func, args) {
  try {
    return (0, _apply.default)(func, undefined, args);
  } catch (e) {
    return (0, _isError.default)(e) ? e : new Error(e);
  }
});
var _default = attempt;
exports.default = _default;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _getPrototype = _interopRequireDefault(__webpack_require__(94));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!(0, _isObjectLike.default)(value) || (0, _baseGetTag.default)(value) != objectTag) {
    return false;
  }

  var proto = (0, _getPrototype.default)(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var _default = isPlainObject;
exports.default = _default;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _overArg = _interopRequireDefault(__webpack_require__(36));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var getPrototype = (0, _overArg.default)(Object.getPrototypeOf, Object);
var _default = getPrototype;
exports.default = _default;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayMap = _interopRequireDefault(__webpack_require__(37));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return (0, _arrayMap.default)(props, function (key) {
    return object[key];
  });
}

var _default = baseValues;
exports.default = _default;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eq = _interopRequireDefault(__webpack_require__(12));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || (0, _eq.default)(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

var _default = customDefaultsAssignIn;
exports.default = _default;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  "\u2028": 'u2028',
  "\u2029": 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

var _default = escapeStringChar;
exports.default = _default;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayLikeKeys = _interopRequireDefault(__webpack_require__(32));

var _baseKeys = _interopRequireDefault(__webpack_require__(99));

var _isArrayLike = _interopRequireDefault(__webpack_require__(13));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return (0, _isArrayLike.default)(object) ? (0, _arrayLikeKeys.default)(object) : (0, _baseKeys.default)(object);
}

var _default = keys;
exports.default = _default;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isPrototype = _interopRequireDefault(__webpack_require__(34));

var _nativeKeys = _interopRequireDefault(__webpack_require__(100));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!(0, _isPrototype.default)(object)) {
    return (0, _nativeKeys.default)(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

var _default = baseKeys;
exports.default = _default;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _overArg = _interopRequireDefault(__webpack_require__(36));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = (0, _overArg.default)(Object.keys, Object);
var _default = nativeKeys;
exports.default = _default;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _escape = _interopRequireDefault(__webpack_require__(102));

var _reEscape = _interopRequireDefault(__webpack_require__(107));

var _reEvaluate = _interopRequireDefault(__webpack_require__(108));

var _reInterpolate = _interopRequireDefault(__webpack_require__(38));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': _reEscape.default,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': _reEvaluate.default,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': _reInterpolate.default,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': _escape.default
    }
  }
};
var _default = templateSettings;
exports.default = _default;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _escapeHtmlChar = _interopRequireDefault(__webpack_require__(103));

var _toString = _interopRequireDefault(__webpack_require__(39));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = (0, _toString.default)(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar.default) : string;
}

var _default = escape;
exports.default = _default;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _basePropertyOf = _interopRequireDefault(__webpack_require__(104));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = (0, _basePropertyOf.default)(htmlEscapes);
var _default = escapeHtmlChar;
exports.default = _default;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

var _default = basePropertyOf;
exports.default = _default;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(10));

var _arrayMap = _interopRequireDefault(__webpack_require__(37));

var _isArray = _interopRequireDefault(__webpack_require__(33));

var _isSymbol = _interopRequireDefault(__webpack_require__(106));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol2.default ? _Symbol2.default.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if ((0, _isArray.default)(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return (0, _arrayMap.default)(value, baseToString) + '';
  }

  if ((0, _isSymbol.default)(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

var _default = baseToString;
exports.default = _default;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(4));

var _isObjectLike = _interopRequireDefault(__webpack_require__(5));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || (0, _isObjectLike.default)(value) && (0, _baseGetTag.default)(value) == symbolTag;
}

var _default = isSymbol;
exports.default = _default;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;
var _default = reEscape;
exports.default = _default;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;
var _default = reEvaluate;
exports.default = _default;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An improved tooltip component which supports HTML and behaves the same in both GUI and BUI
 *
 * @author Hyyan Abo Fakher
 */
var HTMLTooltip = /*#__PURE__*/function () {
  function HTMLTooltip() {
    _classCallCheck(this, HTMLTooltip);
  }

  _createClass(HTMLTooltip, [{
    key: "init",

    /**
     * Construct the component
     *
     * @param {Object} params the tooltip component params
     */
    value: function init(params) {
      var eGui = this.eGui = document.createElement('div');
      var tooltipValueGetter = params.colDef.tooltipValueGetter;
      var isHeader = params.rowIndex === undefined;
      var isGroupedHeader = isHeader && !!params.colDef.children;
      console.log(params); // eslint-disable-next-line no-prototype-builtins

      var data = !isHeader && !isGroupedHeader ? params.api.getDisplayedRowAtIndex(params.rowIndex).data : null;
      var theme = params.api.gridOptionsWrapper.eGridDiv.className.endsWith('dark') ? 'gw-tooltip-dark' : 'gw-tooltip-light';
      var tooltipField = params.colDef.tooltipField ? // eslint-disable-next-line no-prototype-builtins
      data && data.hasOwnProperty(params.colDef.tooltipField) ? data[params.colDef.tooltipField] : null : null;

      var passedParams = _objectSpread(_objectSpread(_objectSpread({}, params), {
        data: data
      }), {
        isHeader: isHeader,
        isGroupedHeader: isGroupedHeader,
        tooltipField: tooltipField
      });

      eGui.classList.add('gw-tooltip', theme);
      eGui.innerHTML = isHeader || isGroupedHeader ? params.value : tooltipField ? tooltipField : tooltipValueGetter ? tooltipValueGetter(passedParams) : params.value;
    }
    /**
     * Get the gui Instance
     *
     * @return {HTMLElement}
     */

  }, {
    key: "getGui",
    value: function getGui() {
      return this.eGui;
    }
  }]);

  return HTMLTooltip;
}();

var _default = HTMLTooltip;
exports.default = _default;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _autocompleter = _interopRequireDefault(__webpack_require__(111));

var _template = _interopRequireDefault(__webpack_require__(21));

var _utilities = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * An autocomplete cell editor written specifically to BBjGridExWidget
 *
 * @author Hyyan Abo Fakher
 */
var SuggestionEditor = /*#__PURE__*/function () {
  function SuggestionEditor() {
    _classCallCheck(this, SuggestionEditor);
  }

  _createClass(SuggestionEditor, [{
    key: "init",

    /**
     * Initialize the component
     *
     * @param {Object} params
     *
     * @return void
     */
    value: function init(params) {
      var pattern = params.textPattern || null;
      var required = params.textRequired || false;
      var title = params.textTitle || null;
      var debounceWaitMs = params.debounceWaitMs || 250;
      var startValue;
      this._focusAfterAttached = params.cellStartedEdit;

      if (this._focusAfterAttached) {
        var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

        if (keyPressBackspaceOrDelete) {
          startValue = '';
        } else if (params.charPress) {
          startValue = params.charPress;
        } else {
          startValue = params.value;

          if (params.keyPress != 113) {
            //F2
            this._highlightAllOnFocus = true;
          }
        }
      } else {
        startValue = params.value;
      }

      this._params = params;
      this._gui = document.createElement('div');
      this._gui.className = 'autocompleteInputWrapper ag-cell-edit-wrapper';
      this._gui.tabIndex = '0';
      this._gui.innerHTML =
      /* html */
      "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // input

      this._input = document.createElement('input');
      this._input.className = 'autocompleteInputWrapper__input ag-cell-edit-input ag-input-field-input ag-text-field-input';
      this._input.type = 'text';
      this._input.value = startValue;
      this._input.tabIndex = 0;

      this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

      if (pattern !== null) {
        this._input.setAttribute('pattern', pattern);
      }

      if (required === true) {
        this._input.setAttribute('required', 'required');
      }

      if (title !== null && title !== 'default') {
        this._input.title = title;
      }

      this._onChange = this._onChange.bind(this);

      this._input.addEventListener('input', this._onChange);

      this._input.addEventListener('change', this._onChange); // setup the autocomplete component


      this._renderItemTemplate = this._params.itemTemplate ? (0, _template.default)(this._params.itemTemplate) : '';
      this._renderGroupTemplate = this._params.groupTemplate ? (0, _template.default)(this._params.groupTemplate) : '';
      this._autocomplete = (0, _autocompleter.default)({
        input: this._input,
        debounceWaitMs: debounceWaitMs,
        // without this option enabled , the list wont be closed in GUI
        preventSubmit: true,
        fetch: this._onAutocompleteFetch.bind(this),
        onSelect: this._onAutocompleteSelect.bind(this),
        renderGroup: this._onAutocompleteRenderGroup.bind(this),
        render: this._onAutocompleteRenderItem.bind(this),
        customize: this._onAutocompleteCustomize.bind(this),
        emptyMsg: this._params.emptyMessage || null,
        minLength: this._params.minLength || 2,
        showOnFocus: this._params.showOnFocus || false,
        className: params.api.gridCore.eGridDiv.className.endsWith('dark') ? 'dark' : 'light'
      });
    }
    /**
     * Return the DOM element of the component, this is what the grid puts into the cell
     *
     * @return {HTMLElement}
     */

  }, {
    key: "getGui",
    value: function getGui() {
      return this._gui;
    }
    /**
     * Gets called once after GUI is attached to DOM.
     *
     * Make sure container is always focused to listen to key changes
     */

  }, {
    key: "afterGuiAttached",
    value: function afterGuiAttached() {
      if (this._highlightAllOnFocus) {
        this._input.select();
      } else {
        if (this._focusAfterAttached) {
          this.focusIn();
        }
      }
    }
    /**
     * Get The component value
     *
     * @return {Number}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this._input.value;
    }
    /**
     * If doing full row edit, then gets called when tabbing into the cell.
     */

  }, {
    key: "focusIn",
    value: function focusIn() {
      this._input.focus();
    }
    /**
     * Gets called once when editing is finished (eg if enter is pressed).
     *
     * @returns {Boolean} true when the result of the edit will be ignored. false otherwise
     */

  }, {
    key: "isCancelAfterEnd",
    value: function isCancelAfterEnd() {
      var _this = this;

      var allowCustomValues = this._params.allowCustomValues || false;

      var isValid = this._validateInput(this._input);

      if (isValid && allowCustomValues === false && this._lastFetchedData) {
        var filteredItems = this._lastFetchedData.filter(function (x) {
          return x.value === _this._input.value;
        });

        isValid = filteredItems.length === 1;
      }

      return !isValid;
    }
    /**
     * Gets called when the component is destroyed.
     *
     * Clear the registered event listeners and destroy the autocomplete
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._input.removeEventListener('input', this._onChange);

      this._input.removeEventListener('change', this._onChange);

      this._autocomplete.destroy();
    }
    /**
     * This method will be called to prepare suggestions and then pass them to autocomplete.
     *
     * @param {String} text the text in the input field
     * @param {Function} update a callback function that must be called after suggestions are prepared
     *
     * @returns {Boolean} false when the request is ignored , false otherwise
     */

  }, {
    key: "_onAutocompleteFetch",
    value: function _onAutocompleteFetch(text, update) {
      var _this2 = this;

      var suppressSuggestionOnInvalidInput = this._params.suppressSuggestionOnInvalidInput || false;

      var isValid = this._validateInput(this._input);

      if (suppressSuggestionOnInvalidInput && !isValid) {
        return false;
      }

      var id = this._params.eventId;
      document.addEventListener(id, function (event) {
        _this2._lastFetchedData = event.detail;
        update(event.detail);
      });
      window.basisDispatchCustomEvent(this._params.eGridCell, {
        type: 'gw.suggestion',
        detail: JSON.stringify({
          id: id,
          text: text,
          column: this._params.colDef.field,
          row: (0, _utilities.gw_parseNode)(this._params.node, this._params.api.gridOptionsWrapper.gridOptions.context)
        })
      });
      return true;
    }
    /**
     * This method will be called when user choose an item in autocomplete.
     *
     * @param {Object} item The selected item
     */

  }, {
    key: "_onAutocompleteSelect",
    value: function _onAutocompleteSelect(item) {
      this._input.value = item.value;
    }
    /**
     * This overrides the rendering function of autocomplete items.
     *
     * It will be called for each suggestion
     *
     * @param {Object} item suggestion object
     * @param {String} currentValue The current input field value
     *
     * @returns {HTMLElement}
     */

  }, {
    key: "_onAutocompleteRenderItem",
    value: function _onAutocompleteRenderItem(item, currentValue) {
      var div = document.createElement('div');
      div.className = 'suggestion-item';

      if (this._renderItemTemplate) {
        div.innerHTML = this._renderItemTemplate({
          item: item,
          currentValue: currentValue
        });
      } else {
        div.innerHTML = item.label;
      }

      return div;
    }
    /**
     * This overrides the rendering function of autocomplete groups.
     *
     * It will be called for each group
     *
     * @param {String} groupName The group name
     * @param {String} currentValue The current input field value
     *
     * @returns {HTMLElement}
     */

  }, {
    key: "_onAutocompleteRenderGroup",
    value: function _onAutocompleteRenderGroup(groupName, currentValue) {
      var div = document.createElement('div');
      div.className = 'suggestion-group';

      if (this._renderGroupTemplate) {
        div.innerHTML = this._renderGroupTemplate({
          groupName: groupName,
          currentValue: currentValue
        });
      } else {
        div.innerHTML = groupName;
      }

      return div;
    }
    /**
     * Hook on the autocomplete container render and change the width and the
     * height according to the options
     *
     * @param {HTMLElement} input
     * @param {HTMLElement} inputRect
     * @param {HTMLElement} container
     * @param {String} maxHeight
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "_onAutocompleteCustomize",
    value: function _onAutocompleteCustomize(input, inputRect, container, maxHeight) {
      if (this._params.width) {
        container.style.width = "".concat(this._params.width, "px");
      }

      if (this._params.height) {
        container.style.height = "".concat(this._params.height, "px");
      }
    }
    /**
     * List to the input changes and validate it
     *
     * @param {Event} The event object
     *
     * @returns {Boolean} true when valid , false otherwise
     */

  }, {
    key: "_onChange",
    value: function _onChange(event) {
      return this._validateInput(event.target);
    }
    /**
     * Do validate the given input element
     *
     * @param {HTMLInputElement} input input element
     *
     * @return {Boolean} true when valid , false otherwise
     */

  }, {
    key: "_validateInput",
    value: function _validateInput(input) {
      var isValid = input.checkValidity();

      if (!isValid) {
        input.classList.add('autocomplete-input-error');
        input.classList.remove('autocomplete-input-success');
      } else {
        input.classList.remove('autocomplete-input-error');
        input.classList.add('autocomplete-input-success');
      }

      return isValid;
    }
  }]);

  return SuggestionEditor;
}();

var _default = SuggestionEditor;
exports.default = _default;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function () {
  'use strict';
  /*
   * https://github.com/kraaden/autocomplete
   * Copyright (c) 2016 Denys Krasnoshchok
   * MIT License
   */

  function autocomplete(settings) {
    // just an alias to minimize JS file size
    var doc = document;
    var container = doc.createElement("div");
    var containerStyle = container.style;
    var userAgent = navigator.userAgent;
    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;
    var debounceWaitMs = settings.debounceWaitMs || 0;
    var preventSubmit = settings.preventSubmit || false; // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead

    var keyUpEventName = mobileFirefox ? "input" : "keyup";
    var items = [];
    var inputValue = "";
    var minLen = 2;
    var showOnFocus = settings.showOnFocus;
    var selected;
    var keypressCounter = 0;
    var debounceTimer;

    if (settings.minLength !== undefined) {
      minLen = settings.minLength;
    }

    if (!settings.input) {
      throw new Error("input undefined");
    }

    var input = settings.input;
    container.className = "autocomplete " + (settings.className || ""); // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning

    containerStyle.position = "absolute";
    /**
     * Detach the container from DOM
     */

    function detach() {
      var parent = container.parentNode;

      if (parent) {
        parent.removeChild(container);
      }
    }
    /**
     * Clear debouncing timer if assigned
     */


    function clearDebounceTimer() {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer);
      }
    }
    /**
     * Attach the container to DOM
     */


    function attach() {
      if (!container.parentNode) {
        doc.body.appendChild(container);
      }
    }
    /**
     * Check if container for autocomplete is displayed
     */


    function containerDisplayed() {
      return !!container.parentNode;
    }
    /**
     * Clear autocomplete state and hide container
     */


    function clear() {
      // prevent the update call if there are pending AJAX requests
      keypressCounter++;
      items = [];
      inputValue = "";
      selected = undefined;
      detach();
    }
    /**
     * Update autocomplete position
     */


    function updatePosition() {
      if (!containerDisplayed()) {
        return;
      }

      containerStyle.height = "auto";
      containerStyle.width = input.offsetWidth + "px";
      var maxHeight = 0;
      var inputRect;

      function calc() {
        var docEl = doc.documentElement;
        var clientTop = docEl.clientTop || doc.body.clientTop || 0;
        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
        var scrollTop = window.pageYOffset || docEl.scrollTop;
        var scrollLeft = window.pageXOffset || docEl.scrollLeft;
        inputRect = input.getBoundingClientRect();
        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
        var left = inputRect.left + scrollLeft - clientLeft;
        containerStyle.top = top + "px";
        containerStyle.left = left + "px";
        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);

        if (maxHeight < 0) {
          maxHeight = 0;
        }

        containerStyle.top = top + "px";
        containerStyle.bottom = "";
        containerStyle.left = left + "px";
        containerStyle.maxHeight = maxHeight + "px";
      } // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)


      calc();
      calc();

      if (settings.customize && inputRect) {
        settings.customize(input, inputRect, container, maxHeight);
      }
    }
    /**
     * Redraw the autocomplete div element with suggestions
     */


    function update() {
      // delete all children from autocomplete DOM container
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      } // function for rendering autocomplete suggestions


      var render = function render(item, currentValue) {
        var itemElement = doc.createElement("div");
        itemElement.textContent = item.label || "";
        return itemElement;
      };

      if (settings.render) {
        render = settings.render;
      } // function to render autocomplete groups


      var renderGroup = function renderGroup(groupName, currentValue) {
        var groupDiv = doc.createElement("div");
        groupDiv.textContent = groupName;
        return groupDiv;
      };

      if (settings.renderGroup) {
        renderGroup = settings.renderGroup;
      }

      var fragment = doc.createDocumentFragment();
      var prevGroup = "#9?$";
      items.forEach(function (item) {
        if (item.group && item.group !== prevGroup) {
          prevGroup = item.group;
          var groupDiv = renderGroup(item.group, inputValue);

          if (groupDiv) {
            groupDiv.className += " group";
            fragment.appendChild(groupDiv);
          }
        }

        var div = render(item, inputValue);

        if (div) {
          div.addEventListener("click", function (ev) {
            settings.onSelect(item, input);
            clear();
            ev.preventDefault();
            ev.stopPropagation();
          });

          if (item === selected) {
            div.className += " selected";
          }

          fragment.appendChild(div);
        }
      });
      container.appendChild(fragment);

      if (items.length < 1) {
        if (settings.emptyMsg) {
          var empty = doc.createElement("div");
          empty.className = "empty";
          empty.textContent = settings.emptyMsg;
          container.appendChild(empty);
        } else {
          clear();
          return;
        }
      }

      attach();
      updatePosition();
      updateScroll();
    }

    function updateIfDisplayed() {
      if (containerDisplayed()) {
        update();
      }
    }

    function resizeEventHandler() {
      updateIfDisplayed();
    }

    function scrollEventHandler(e) {
      if (e.target !== container) {
        updateIfDisplayed();
      } else {
        e.preventDefault();
      }
    }

    function keyupEventHandler(ev) {
      var keyCode = ev.which || ev.keyCode || 0;
      var ignore = [38
      /* Up */
      , 13
      /* Enter */
      , 27
      /* Esc */
      , 39
      /* Right */
      , 37
      /* Left */
      , 16
      /* Shift */
      , 17
      /* Ctrl */
      , 18
      /* Alt */
      , 20
      /* CapsLock */
      , 91
      /* WindowsKey */
      , 9
      /* Tab */
      ];

      for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {
        var key = ignore_1[_i];

        if (keyCode === key) {
          return;
        }
      }

      if (keyCode >= 112
      /* F1 */
      && keyCode <= 123
      /* F12 */
      ) {
          return;
        } // the down key is used to open autocomplete


      if (keyCode === 40
      /* Down */
      && containerDisplayed()) {
        return;
      }

      startFetch(0
      /* Keyboard */
      );
    }
    /**
     * Automatically move scroll bar if selected item is not visible
     */


    function updateScroll() {
      var elements = container.getElementsByClassName("selected");

      if (elements.length > 0) {
        var element = elements[0]; // make group visible

        var previous = element.previousElementSibling;

        if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
          element = previous;
        }

        if (element.offsetTop < container.scrollTop) {
          container.scrollTop = element.offsetTop;
        } else {
          var selectBottom = element.offsetTop + element.offsetHeight;
          var containerBottom = container.scrollTop + container.offsetHeight;

          if (selectBottom > containerBottom) {
            container.scrollTop += selectBottom - containerBottom;
          }
        }
      }
    }
    /**
     * Select the previous item in suggestions
     */


    function selectPrev() {
      if (items.length < 1) {
        selected = undefined;
      } else {
        if (selected === items[0]) {
          selected = items[items.length - 1];
        } else {
          for (var i = items.length - 1; i > 0; i--) {
            if (selected === items[i] || i === 1) {
              selected = items[i - 1];
              break;
            }
          }
        }
      }
    }
    /**
     * Select the next item in suggestions
     */


    function selectNext() {
      if (items.length < 1) {
        selected = undefined;
      }

      if (!selected || selected === items[items.length - 1]) {
        selected = items[0];
        return;
      }

      for (var i = 0; i < items.length - 1; i++) {
        if (selected === items[i]) {
          selected = items[i + 1];
          break;
        }
      }
    }

    function keydownEventHandler(ev) {
      var keyCode = ev.which || ev.keyCode || 0;

      if (keyCode === 38
      /* Up */
      || keyCode === 40
      /* Down */
      || keyCode === 27
      /* Esc */
      ) {
          var containerIsDisplayed = containerDisplayed();

          if (keyCode === 27
          /* Esc */
          ) {
              clear();
            } else {
            if (!containerDisplayed || items.length < 1) {
              return;
            }

            keyCode === 38
            /* Up */
            ? selectPrev() : selectNext();
            update();
          }

          ev.preventDefault();

          if (containerIsDisplayed) {
            ev.stopPropagation();
          }

          return;
        }

      if (keyCode === 13
      /* Enter */
      ) {
          if (selected) {
            settings.onSelect(selected, input);
            clear();
          }

          if (preventSubmit) {
            ev.preventDefault();
          }
        }
    }

    function focusEventHandler() {
      if (showOnFocus) {
        startFetch(1
        /* Focus */
        );
      }
    }

    function startFetch(trigger) {
      // if multiple keys were pressed, before we get update from server,
      // this may cause redrawing our autocomplete multiple times after the last key press.
      // to avoid this, the number of times keyboard was pressed will be
      // saved and checked before redraw our autocomplete box.
      var savedKeypressCounter = ++keypressCounter;
      var val = input.value;

      if (val.length >= minLen || trigger === 1
      /* Focus */
      ) {
          clearDebounceTimer();
          debounceTimer = window.setTimeout(function () {
            settings.fetch(val, function (elements) {
              if (keypressCounter === savedKeypressCounter && elements) {
                items = elements;
                inputValue = val;
                selected = items.length > 0 ? items[0] : undefined;
                update();
              }
            }, 0
            /* Keyboard */
            );
          }, trigger === 0
          /* Keyboard */
          ? debounceWaitMs : 0);
        } else {
        clear();
      }
    }

    function blurEventHandler() {
      // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM
      setTimeout(function () {
        if (doc.activeElement !== input) {
          clear();
        }
      }, 200);
    }
    /**
     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
     */


    container.addEventListener("mousedown", function (evt) {
      evt.stopPropagation();
      evt.preventDefault();
    });
    /**
     * Fixes #30: autocomplete closes when scrollbar is clicked in IE
     * See: https://stackoverflow.com/a/9210267/13172349
     */

    container.addEventListener("focus", function () {
      return input.focus();
    });
    /**
     * This function will remove DOM elements and clear event handlers
     */

    function destroy() {
      input.removeEventListener("focus", focusEventHandler);
      input.removeEventListener("keydown", keydownEventHandler);
      input.removeEventListener(keyUpEventName, keyupEventHandler);
      input.removeEventListener("blur", blurEventHandler);
      window.removeEventListener("resize", resizeEventHandler);
      doc.removeEventListener("scroll", scrollEventHandler, true);
      clearDebounceTimer();
      clear();
    } // setup event handlers


    input.addEventListener("keydown", keydownEventHandler);
    input.addEventListener(keyUpEventName, keyupEventHandler);
    input.addEventListener("blur", blurEventHandler);
    input.addEventListener("focus", focusEventHandler);
    window.addEventListener("resize", resizeEventHandler);
    doc.addEventListener("scroll", scrollEventHandler, true);
    return {
      destroy: destroy
    };
  }

  return autocomplete;
});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setState = gw_setState;
exports.gw_getState = gw_getState;

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setState(id, state) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  try {
    options.columnApi.applyColumnState({
      state: state.columns,
      applyOrder: true
    });
    options.columnApi.setColumnGroupState(state.groups);
    options.api.setFilterModel(state.filters);
  } catch (e) {
    console.warn('Failed to parse grid state from JSON', e);
  }
}

function gw_getState(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var columns = options.columnApi.getColumnState();
  var groups = options.columnApi.getColumnGroupState();
  var filters = options.api.getFilterModel();

  try {
    return JSON.stringify({
      columns: columns,
      groups: groups,
      filters: filters
    });
  } catch (e) {
    console.warn('Failed to convert the grid state to json', e);
  }
}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setSideBarVisible = gw_setSideBarVisible;
exports.gw_openToolpanel = gw_openToolpanel;
exports.gw_closeToolpanel = gw_closeToolpanel;
exports.gw_setFunctionsReadOnly = gw_setFunctionsReadOnly;

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setSideBarVisible(id, value) {
  (0, _utilities.gw_getGrid)(id).options.api.setSideBarVisible(Boolean(value));
}

function gw_openToolpanel(gridId, toolpanelId) {
  (0, _utilities.gw_getGrid)(gridId).options.api.openToolPanel(toolpanelId);
}

function gw_closeToolpanel(gridId, toolpanelId) {
  (0, _utilities.gw_getGrid)(gridId).options.api.closeToolPanel(toolpanelId);
}

function gw_setFunctionsReadOnly(id, readonly) {
  (0, _utilities.gw_getGrid)(id).options.api.setFunctionsReadOnly(Boolean(readonly));
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setStatusbarComponentVisibility = gw_setStatusbarComponentVisibility;

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setStatusbarComponentVisibility(id, key, visibility) {
  (0, _utilities.gw_getGrid)(id).options.api.getStatusPanel(key).setVisible(Boolean(visibility));
}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_showLoadingOverlay = gw_showLoadingOverlay;
exports.gw_showNoRowsOverlay = gw_showNoRowsOverlay;
exports.gw_hideOverlay = gw_hideOverlay;

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Show loading overlay
 *
 * @param {String} id the grid id
 */
function gw_showLoadingOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.showLoadingOverlay();
}
/**
 * Show 'no rows' overlay
 *
 * @param {String} id the grid id
 */


function gw_showNoRowsOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.showNoRowsOverlay();
}
/**
 * Clear all overlays
 *
 * @param {String} id the grid id
 */


function gw_hideOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.hideOverlay();
}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_updateContext = gw_updateContext;

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Update context
 *
 * @param {String} id The grid's id
 * @param {String} key The context's key to update
 * @param {String} value  The new context's value
 */
// export function gw_legacyUpdateContext(id, key, value) {
// 	gw_getGrid(id)
// 		.options
// 		.context[key] = JSON.parse(value);
// }

/**
 * Update context
 *
 * @param {String} id The grid's id
 * @param {Object} context The new context object
 */
function gw_updateContext(id, context) {
  (0, _utilities.gw_getGrid)(id).options.context = context;
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setStyle = gw_setStyle;
exports.gw_removeStyle = gw_removeStyle;

__webpack_require__(118);

var _utilities = __webpack_require__(0);

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.cloud>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Add new style
 *
 * Add new style to the document
 *
 * @param {String} selector css selector
 * @param {String} rules Json string for an array of rules
 */
function gw_setStyle(selector, rules) {
  jss.forDocument((0, _utilities.gw_getDocument)()).set(selector, JSON.parse(rules));
}
/**
 * Remove style
 *
 * Remove added style from thes document
 *
 * @param {String} selector css selector
 */


function gw_removeStyle(selector) {
  jss.forDocument((0, _utilities.gw_getDocument)()).remove(selector);
}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jss"] = __webpack_require__(119);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * JSS v0.6 - JavaScript Stylesheets
 * https://github.com/Box9/jss
 *
 * Copyright (c) 2011, David Tang
 * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)
 */
var jss = function () {
  var adjSelAttrRegex = /((?:\.|#)[^\.\s#]+)((?:\.|#)[^\.\s#]+)/g;
  var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;
  var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;
  var singleColonForPseudoElements; // flag for older browsers

  function getSelectorsAndRules(sheet) {
    var rules = sheet.cssRules || sheet.rules || [];
    var results = {};

    for (var i = 0; i < rules.length; i++) {
      // Older browsers and FF report pseudo element selectors in an outdated format
      var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);

      if (!results[selectorText]) {
        results[selectorText] = [];
      }

      results[selectorText].push({
        sheet: sheet,
        index: i,
        style: rules[i].style
      });
    }

    return results;
  }

  function getRules(sheet, selector) {
    var rules = sheet.cssRules || sheet.rules || [];
    var results = []; // Browsers report selectors in lowercase

    selector = selector.toLowerCase();

    for (var i = 0; i < rules.length; i++) {
      var selectorText = rules[i].selectorText; // Note - certain rules (e.g. @rules) don't have selectorText

      if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {
        results.push({
          sheet: sheet,
          index: i,
          style: rules[i].style
        });
      }
    }

    return results;
  }

  function addRule(sheet, selector) {
    var rules = sheet.cssRules || sheet.rules || [];
    var index = rules.length;
    var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);

    if (!pseudoElementRule) {
      addRuleToSheet(sheet, selector, index);
    }

    return {
      sheet: sheet,
      index: index,
      style: rules[index].style
    };
  }

  ;

  function addRuleToSheet(sheet, selector, index) {
    if (sheet.insertRule) {
      sheet.insertRule(selector + ' { }', index);
    } else {
      sheet.addRule(selector, null, index);
    }
  } // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651


  function addPseudoElementRule(sheet, selector, rules, index) {
    var doubleColonSelector;
    var singleColonSelector;

    if (doubleColonPseudoElRegex.exec(selector)) {
      doubleColonSelector = selector;
      singleColonSelector = toSingleColonPseudoElements(selector);
    } else if (singleColonPseudoElRegex.exec(selector)) {
      doubleColonSelector = toDoubleColonPseudoElements(selector);
      singleColonSelector = selector;
    } else {
      return false; // Not dealing with a pseudo element
    }

    if (!singleColonForPseudoElements) {
      // Assume modern browser and then check if successful
      addRuleToSheet(sheet, doubleColonSelector, index);

      if (rules.length <= index) {
        singleColonForPseudoElements = true;
      }
    }

    if (singleColonForPseudoElements) {
      addRuleToSheet(sheet, singleColonSelector, index);
    }

    return true;
  }

  function toDoubleColonPseudoElements(selector) {
    return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {
      return submatch1 + '::' + submatch3;
    });
  }

  function toSingleColonPseudoElements(selector) {
    return selector.replace(doubleColonPseudoElRegex, function (match, submatch1, submatch2) {
      return ':' + submatch2;
    });
  }

  function removeRule(rule) {
    var sheet = rule.sheet;

    if (sheet.deleteRule) {
      sheet.deleteRule(rule.index);
    } else if (sheet.removeRule) {
      sheet.removeRule(rule.index);
    }
  }

  function extend(dest, src) {
    for (var key in src) {
      if (!src.hasOwnProperty(key)) continue;
      dest[key] = src[key];
    }

    return dest;
  }

  function aggregateStyles(rules) {
    var aggregate = {};

    for (var i = 0; i < rules.length; i++) {
      extend(aggregate, declaredProperties(rules[i].style));
    }

    return aggregate;
  }

  function declaredProperties(style) {
    var declared = {};

    for (var i = 0; i < style.length; i++) {
      declared[style[i]] = style[toCamelCase(style[i])];
    }

    return declared;
  } // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined
  // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1


  function swapAdjSelAttr(selector) {
    var swap = '';
    var lastIndex = 0;

    while ((match = adjSelAttrRegex.exec(selector)) != null) {
      if (match[0] === '') break;
      swap += selector.substring(lastIndex, match.index);
      swap += selector.substr(match.index + match[1].length, match[2].length);
      swap += selector.substr(match.index, match[1].length);
      lastIndex = match.index + match[0].length;
    }

    swap += selector.substr(lastIndex);
    return swap;
  }

  ; // FF and older browsers store rules with pseudo elements using single-colon syntax

  function swapPseudoElSyntax(selector) {
    if (doubleColonPseudoElRegex.exec(selector)) {
      return toSingleColonPseudoElements(selector);
    }

    return selector;
  }

  function setStyleProperties(rule, properties) {
    for (var key in properties) {
      var value = properties[key];
      var importantIndex = value.indexOf(' !important'); // Modern browsers seem to handle overrides fine, but IE9 doesn't

      rule.style.removeProperty(key);

      if (importantIndex > 0) {
        rule.style.setProperty(key, value.substr(0, importantIndex), 'important');
      } else {
        rule.style.setProperty(key, value);
      }
    }
  }

  function toCamelCase(str) {
    return str.replace(/-([a-z])/g, function (match, submatch) {
      return submatch.toUpperCase();
    });
  }

  function transformCamelCasedPropertyNames(oldProps) {
    var newProps = {};

    for (var key in oldProps) {
      newProps[unCamelCase(key)] = oldProps[key];
    }

    return newProps;
  }

  function unCamelCase(str) {
    return str.replace(/([A-Z])/g, function (match, submatch) {
      return '-' + submatch.toLowerCase();
    });
  }

  var Jss = function Jss(doc) {
    this.doc = doc;
    this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];
    this.sheets = this.doc.styleSheets || [];
  };

  Jss.prototype = {
    // Returns JSS rules (selector is optional)
    get: function get(selector) {
      if (!this.defaultSheet) {
        return {};
      }

      if (selector) {
        return aggregateStyles(getRules(this.defaultSheet, selector));
      }

      var rules = getSelectorsAndRules(this.defaultSheet);

      for (selector in rules) {
        rules[selector] = aggregateStyles(rules[selector]);
      }

      return rules;
    },
    // Returns all rules (selector is required)
    getAll: function getAll(selector) {
      var properties = {};

      for (var i = 0; i < this.sheets.length; i++) {
        extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));
      }

      return properties;
    },
    // Adds JSS rules for the selector based on the given properties
    set: function set(selector, properties) {
      if (!this.defaultSheet) {
        this.defaultSheet = this._createSheet();
      }

      properties = transformCamelCasedPropertyNames(properties);
      var rules = getRules(this.defaultSheet, selector);

      if (!rules.length) {
        rules = [addRule(this.defaultSheet, selector)];
      }

      for (var i = 0; i < rules.length; i++) {
        setStyleProperties(rules[i], properties);
      }
    },
    // Removes JSS rules (selector is optional)
    remove: function remove(selector) {
      if (!this.defaultSheet) return;

      if (!selector) {
        this._removeSheet(this.defaultSheet);

        delete this.defaultSheet;
        return;
      }

      var rules = getRules(this.defaultSheet, selector);

      for (var i = 0; i < rules.length; i++) {
        removeRule(rules[i]);
      }

      return rules.length;
    },
    _createSheet: function _createSheet() {
      var styleNode = this.doc.createElement('style');
      styleNode.type = 'text/css';
      styleNode.rel = 'stylesheet';
      this.head.appendChild(styleNode);
      return styleNode.sheet;
    },
    _removeSheet: function _removeSheet(sheet) {
      var node = sheet.ownerNode;
      node.parentNode.removeChild(node);
    }
  };
  var exports = new Jss(document);

  exports.forDocument = function (doc) {
    return new Jss(doc);
  };

  return exports;
}();

 true && module.exports && (module.exports = jss); // CommonJS support

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(121);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(14)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = ".flatpickr-calendar {\n  background: transparent;\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  -webkit-animation: none;\n          animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 5px;\n  position: absolute;\n  width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-touch-action: manipulation;\n      touch-action: manipulation;\n  background: #fff;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n          box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n}\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 99999;\n}\n.flatpickr-calendar.animate.open {\n  -webkit-animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n          animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 2px;\n}\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 2px);\n}\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7) {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1) {\n  -webkit-box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n.flatpickr-calendar.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid #e6e6e6;\n}\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: '';\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.arrowRight:before,\n.flatpickr-calendar.rightMost:after,\n.flatpickr-calendar.arrowRight:after {\n  left: auto;\n  right: 22px;\n}\n.flatpickr-calendar.arrowCenter:before,\n.flatpickr-calendar.arrowCenter:after {\n  left: 50%;\n  right: 50%;\n}\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n}\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n}\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: #fff;\n}\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: #fff;\n}\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n.flatpickr-wrapper {\n  position: relative;\n  display: inline-block;\n}\n.flatpickr-months {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-months .flatpickr-month {\n  background: transparent;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n  height: 34px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  overflow: hidden;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  height: 34px;\n  padding: 10px;\n  z-index: 3;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-disabled,\n.flatpickr-months .flatpickr-next-month.flatpickr-disabled {\n  display: none;\n}\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  left: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  right: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: #959ea9;\n}\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  fill: #f64747;\n}\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n}\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  -webkit-transition: fill 0.1s;\n  transition: fill 0.1s;\n  fill: inherit;\n}\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n.numInputWrapper input {\n  width: 100%;\n}\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n.numInputWrapper input::-webkit-outer-spin-button,\n.numInputWrapper input::-webkit-inner-spin-button {\n  margin: 0;\n  -webkit-appearance: none;\n}\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid rgba(57,57,57,0.15);\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.numInputWrapper span:hover {\n  background: rgba(0,0,0,0.1);\n}\n.numInputWrapper span:active {\n  background: rgba(0,0,0,0.2);\n}\n.numInputWrapper span:after {\n  display: block;\n  content: \"\";\n  position: absolute;\n}\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid rgba(57,57,57,0.6);\n  top: 26%;\n}\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid rgba(57,57,57,0.6);\n  top: 40%;\n}\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n.numInputWrapper span svg path {\n  fill: rgba(0,0,0,0.5);\n}\n.numInputWrapper:hover {\n  background: rgba(0,0,0,0.05);\n}\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 7.48px 0 0 0;\n  line-height: 1;\n  height: 34px;\n  display: inline-block;\n  text-align: center;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n}\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0;\n  display: inline-block;\n}\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: rgba(0,0,0,0.5);\n  background: transparent;\n  pointer-events: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months {\n  appearance: menulist;\n  background: transparent;\n  border: none;\n  border-radius: 0;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: pointer;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  height: auto;\n  line-height: inherit;\n  margin: -1px 0 0 0;\n  outline: none;\n  padding: 0 0 0 0.5ch;\n  position: relative;\n  vertical-align: initial;\n  -webkit-box-sizing: border-box;\n  -webkit-appearance: menulist;\n  -moz-appearance: menulist;\n  width: auto;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:focus,\n.flatpickr-current-month .flatpickr-monthDropdown-months:active {\n  outline: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months .flatpickr-monthDropdown-month {\n  background-color: transparent;\n  outline: none;\n  padding: 0;\n}\n.flatpickr-weekdays {\n  background: transparent;\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  height: 28px;\n}\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: transparent;\n  color: rgba(0,0,0,0.54);\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-weight: bolder;\n}\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: start;\n  -webkit-align-items: flex-start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n  width: 307.875px;\n}\n.flatpickr-days:focus {\n  outline: 0;\n}\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n          flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-around;\n          justify-content: space-around;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n.dayContainer + .dayContainer {\n  -webkit-box-shadow: -1px 0 0 #e6e6e6;\n          box-shadow: -1px 0 0 #e6e6e6;\n}\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #393939;\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  -webkit-flex-basis: 14.2857143%;\n      -ms-flex-preferred-size: 14.2857143%;\n          flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 39px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  text-align: center;\n}\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: #e6e6e6;\n  border-color: #e6e6e6;\n}\n.flatpickr-day.today {\n  border-color: #959ea9;\n}\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: #959ea9;\n  background: #959ea9;\n  color: #fff;\n}\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: #569ff7;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  color: #fff;\n  border-color: #569ff7;\n}\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)) {\n  -webkit-box-shadow: -10px 0 0 #569ff7;\n          box-shadow: -10px 0 0 #569ff7;\n}\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n.flatpickr-day.inRange {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover {\n  cursor: not-allowed;\n  color: rgba(57,57,57,0.1);\n}\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n          box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n}\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n.flatpickr-weekwrapper {\n  float: left;\n}\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6;\n          box-shadow: 1px 0 0 #e6e6e6;\n}\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n.flatpickr-innerContainer {\n  display: block;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n}\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-time:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.flatpickr-time .numInputWrapper {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: #393939;\n}\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: #393939;\n}\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n.flatpickr-time input {\n  background: transparent;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  color: #393939;\n  font-size: 14px;\n  position: relative;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  float: left;\n  line-height: inherit;\n  color: #393939;\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-align-self: center;\n      -ms-flex-item-align: center;\n          align-self: center;\n}\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: #eee;\n}\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n@-webkit-keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n"

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(124);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(14)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 124 */
/***/ (function(module, exports) {

module.exports = "/*\r\n* This file is part of the BBjGridExWidget plugin.\r\n* (c) Basis Europe <eu@basis.cloud>\r\n*\r\n* For the full copyright and license information, please view the LICENSE\r\n* file that was distributed with this source code.\r\n*/\r\n\r\n.gw-alignment-cell-right,\r\n.gw-alignment-cell-right .ag-cell-value,\r\n.gw-alignment-cell-right .templateRenderer {\r\n  text-align: right;\r\n  -webkit-box-pack: end;\r\n      -ms-flex-pack: end;\r\n          justify-content: flex-end;\r\n  -webkit-box-flex: 1;\r\n      -ms-flex: 1;\r\n          flex: 1;\r\n}\r\n\r\n.gw-alignment-cell-center,\r\n.gw-alignment-cell-center .ag-cell-value,\r\n.gw-alignment-cell-center .templateRenderer {\r\n  text-align: center;\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n  -webkit-box-flex: 1;\r\n      -ms-flex: 1;\r\n          flex: 1;\r\n}\r\n\r\n.gw-alignment-cell-right .boolSwitch,\r\n.gw-alignment-cell-center .boolSwitch {\r\n  text-align: initial;\r\n}\r\n\r\n.gw-alignment-cell-center .boolSwitch__wrapper,\r\n.gw-alignment-cell-right .boolSwitch__wrapper {\r\n  width: auto;\r\n  height: auto;\r\n}\r\n\r\n.gw-alignment-cell-center .boolSwitch__wrapper {\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n}\r\n\r\n.gw-alignment-cell-right .boolSwitch__wrapper {\r\n  -webkit-box-pack: right;\r\n      -ms-flex-pack: right;\r\n          justify-content: right;\r\n}\r\n\r\n.gw-alignment-header-right .ag-header-cell-label {\r\n  -webkit-box-orient: horizontal;\r\n  -webkit-box-direction: reverse;\r\n      -ms-flex-direction: row-reverse;\r\n          flex-direction: row-reverse;\r\n}\r\n\r\n.gw-alignment-header-center .ag-header-cell-label {\r\n  display: -webkit-box;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n}\r\n\r\n.gw-alignment-header-center .ag-header-cell-text {\r\n  margin-left: -16px !important;\r\n}\r\n\r\n.gw-alignment-header-right .ag-cell-label-container,\r\n.gw-alignment-header-center .ag-cell-label-container {\r\n  -webkit-box-orient: horizontal;\r\n  -webkit-box-direction: normal;\r\n      -ms-flex-direction: row;\r\n          flex-direction: row;\r\n}\r\n\r\n.gw-tooltip {\r\n  position: absolute;\r\n  overflow: hidden;\r\n  pointer-events: none;\r\n  -webkit-transition: opacity 1s;\r\n  transition: opacity 1s;\r\n  border-radius: 3.1px;\r\n  padding: 10px;\r\n  -webkit-transition: opacity 260ms;\r\n  transition: opacity 260ms;\r\n}\r\n\r\n.gw-tooltip-light {\r\n  background-color: white;\r\n  -webkit-box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);\r\n          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);\r\n}\r\n\r\n.gw-tooltip-dark {\r\n  background-color: #1c1f20;\r\n  -webkit-box-shadow: 0 0 6px #5c5c5c;\r\n          box-shadow: 0 0 6px #5c5c5c;\r\n  color: white;\r\n}\r\n\r\n.ag-selection-checkbox.ag-invisible {\r\n  display: none !important;\r\n}\r\n\r\n.ag-cell-wrapper {\r\n  height: 100%;\r\n}\r\n"

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(126);

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(14)(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = ".autocompleteInputWrapper__input {\r\n  padding-left: 6px;\r\n  border: thin solid var(--ag-input-focus-border-color, rgba(33, 150, 243, 0.4));\r\n  border-radius: 3px;\r\n  background-color: var(--ag-background-color);\r\n  color: inherit;\r\n  outline: none;\r\n}\r\n\r\n.ag-theme-alpine .autocompleteInputWrapper__input,\r\n.ag-theme-balham .autocompleteInputWrapper__input,\r\n.ag-theme-material .autocompleteInputWrapper__input {\r\n  background-color: var(--ag-background-color, #fff);\r\n}\r\n\r\n.ag-theme-alpine-dark .autocompleteInputWrapper__input,\r\n.ag-theme-balham-dark .autocompleteInputWrapper__input {\r\n  background-color: var(--ag-background-color, #2d3436);\r\n}\r\n\r\n.autocomplete {\r\n  background-color: var(--ag-background-color, #fff);\r\n  z-index: 1000;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border: thin solid var(--ag-input-focus-border-color, rgba(33, 150, 243, 0.4));\r\n  border-top: 0;\r\n  border-radius: 3px;\r\n  border-top-left-radius: 0;\r\n  border-top-right-radius: 0;\r\n  overflow: auto;\r\n  -webkit-box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);\r\n          box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.autocomplete.dark {\r\n  background-color: var(--ag-background-color, #2d3436);\r\n  color: var(--ag-data-color, var(--ag-foreground-color, #fff));\r\n}\r\n\r\n.autocomplete .suggestion-group {\r\n  background: #eee;\r\n  padding: 5px 6px;\r\n  font-weight: bold;\r\n}\r\n\r\n.autocomplete.dark .suggestion-group {\r\n  background: var(--ag-background-color, #181d1f);\r\n}\r\n\r\n.autocomplete .suggestion-item {\r\n  padding: 10px;\r\n  cursor: pointer;\r\n}\r\n\r\n.autocomplete .suggestion-item:hover {\r\n  background-color: var(--ag-row-hover-color, rgba(33, 150, 244, 0.1));\r\n}\r\n\r\n.autocomplete .suggestion-item.selected {\r\n  background-color: var(\r\n    --ag-selected-row-background-color,\r\n    rgba(33, 150, 243, 0.3)\r\n  );\r\n}\r\n\r\n.autocomplete .empty {\r\n  padding: 8px 6px;\r\n}\r\n\r\n.autocomplete-input-error {\r\n  -webkit-box-shadow: 0 -2px 0 #e91e63 inset;\r\n          box-shadow: 0 -2px 0 #e91e63 inset;\r\n}\r\n\r\n.autocomplete-input-success {\r\n  -webkit-box-shadow: 0 -2px 0 #4caf50 inset;\r\n          box-shadow: 0 -2px 0 #4caf50 inset;\r\n}\r\n"

/***/ })
/******/ ])));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS91dGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy91dGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXAtcGFyc2UtanNvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvcm93cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYmotbWFza3Mvc3JjL1N0cmluZ01hc2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jiai1tYXNrcy9zcmMvTnVtYmVyTWFzay9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2NvbHVtbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4cHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9jaGFydHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9jZWxscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FwcGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYmotbWFza3MvZGlzdC9iYmotbWFza3MuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmJqLW1hc2tzL2Rpc3QvYmJqLW1hc2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNpcy1pbnB1dC1tYXNraW5nL2Rpc3QvYmFzaXMtaW5wdXQtbWFza2luZy5qcy1leHBvc2VkIiwid2VicGFjazovLy8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrOi93ZWJwYWNrL2Jvb3RzdHJhcCBmZDdmNjA0MjE5MmUxMjMyY2Y2NSIsIndlYnBhY2s6Ly8vd2VicGFjazovZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImJiai1tYXNrcy9zcmMvU3RyaW5nTWFza1wiLFwiY29tbW9uanMyXCI6XCJiYmotbWFza3Mvc3JjL1N0cmluZ01hc2tcIixcImFtZFwiOlwiYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrXCIsXCJyb290XCI6W1wiQkJqXCIsXCJNYXNrc1wiLFwiU3RyaW5nTWFza1wiXX0iLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dElucHV0L2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL1RleHRJbnB1dC9UZXh0SW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dElucHV0L3Rvb2xzLmpzIiwid2VicGFjazovLy8vc3JjL051bWJlcklucHV0L2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL051bWJlcklucHV0L051bWJlcklucHV0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiYmJqLW1hc2tzL3NyYy9OdW1iZXJNYXNrXCIsXCJjb21tb25qczJcIjpcImJiai1tYXNrcy9zcmMvTnVtYmVyTWFza1wiLFwiYW1kXCI6XCJiYmotbWFza3Mvc3JjL051bWJlck1hc2tcIixcInJvb3RcIjpbXCJCQmpcIixcIk1hc2tzXCIsXCJOdW1iZXJNYXNrXCJdfSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrL1N0cmluZ01hc2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jiai1tYXNrcy9zcmMvTnVtYmVyTWFzay9OdW1iZXJNYXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYXNpcy1hZ2dyaWQtY29tcG9uZW50cy9kaXN0L2Jhc2lzLWFnZ3JpZC1jb21wb25lbnRzLmpzLWV4cG9zZWQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2s6L3dlYnBhY2svYm9vdHN0cmFwIDBiYWUwNTllMmI1ZmUyNmM1YjEwIiwid2VicGFjazovLy8vc3JjL0NvbXBvbmVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL2F1dG9iaW5kLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvb3ZlcnJpZGUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9wcml2YXRlL3V0aWxzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi90b0ludGVnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5Td2l0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvVGVtcGxhdGVSZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FwcGx5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy8od2VicGFjaykvYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Vycm9yLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVJbnRlcnBvbGF0ZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9yZWFkb25seS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vdXRjVG9ab25lZFRpbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMtdHovZXNtL19saWIvdHpQYXJzZVRpbWV6b25lL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0V2ZW50c01peGluL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lSW5wdXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhbkVkaXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuRWRpdG9yL0Jvb2xlYW5FZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQ29tcG9uZW50L0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuU3dpdGNoL0Jvb2xlYW5Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9sYXp5LWluaXRpYWxpemUuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhblN3aXRjaC9zdHlsZS5zY3NzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5Td2l0Y2gvc3R5bGUuc2Nzcz83NmEzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuUmVuZGVyZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhblJlbmRlcmVyL0Jvb2xlYW5SZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuRmlsdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5GaWx0ZXIvQm9vbGVhbkZpbHRlci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuRmlsdGVyL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhbkZpbHRlci9zdHlsZS5zY3NzPzBkNWUiLCJ3ZWJwYWNrOi8vLy9zcmMvTnVtYmVyRWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL051bWJlckVkaXRvci9OdW1iZXJFZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvTnVtYmVyRWRpdG9yL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy9zcmMvTnVtYmVyRWRpdG9yL3N0eWxlLnNjc3M/YWEwZSIsIndlYnBhY2s6Ly8vL3NyYy9UZXh0RWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL1RleHRFZGl0b3IvVGV4dEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9UZXh0RWRpdG9yL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dEVkaXRvci9zdHlsZS5zY3NzPzA5MWIiLCJ3ZWJwYWNrOi8vLy9zcmMvVGVtcGxhdGVSZW5kZXJlci9UZW1wbGF0ZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvYXNzaWduSW5XaXRoLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Nob3J0T3V0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hdHRlbXB0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lc2NhcGVTdHJpbmdDaGFyLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZVNldHRpbmdzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lc2NhcGVIdG1sQ2hhci5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIndlYnBhY2s6Ly8vL3NyYy9JbWFnZVJlbmRlcmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0ltYWdlUmVuZGVyZXIvSW1hZ2VSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUZpbHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUZpbHRlci9EYXRlVGltZUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vX2xpYi90elRva2VuaXplRGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vc3ViTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9hZGRNaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vdG9EYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvRXZlbnRzTWl4aW4vRXZlbnRzTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy9zcmMvRGF0ZVRpbWVJbnB1dC9EYXRlVGltZUlucHV0LmpzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lSW5wdXQvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUlucHV0L3N0eWxlLnNjc3M/NGY2NyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUZpbHRlci9zdHlsZS5zY3NzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRmlsdGVyL3N0eWxlLnNjc3M/NzZmYiIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUVkaXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUVkaXRvci9EYXRlVGltZUVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcG9seWZpbGxzLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbml0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvbWVudXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzL3NlbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy9lZGl0aW5nLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvcmVhZHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzL2tleWJvYXJkLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvZmlsdGVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hdHRlbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZVN0cmluZ0NoYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXZhbHVhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSFRNTFRvb2x0aXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvU3VnZ2VzdGlvbkVkaXRvci5qcyIsIndlYnBhY2s6Ly8vYXV0b2NvbXBsZXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9hcGkvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS90b29scGFuZWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9zdGF0dXNiYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9vdmVybGF5cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9qc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy9qc3MuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanNzL2pzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmNzcz8wOTQ3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlL2NsYXNzZXMuY3NzPzA1NTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlL2NsYXNzZXMuY3NzIiwid2VicGFjazovLy8uL3NyYy9zdHlsZS9zdWdnZXN0aW9uLWVkaXRvci5jc3M/M2YyNCIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUvc3VnZ2VzdGlvbi1lZGl0b3IuY3NzIl0sIm5hbWVzIjpbImd3X2dldERvY3VtZW50IiwiJGRvYyIsImRvY3VtZW50IiwiZ3dfZ2V0V2luZG93IiwiJHduZCIsIndpbmRvdyIsImd3X2VzY2FwZSIsInZhbHVlIiwidW5kZWZpbmVkIiwiZ3dfdXVpZCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJnd19nZXRHcmlkIiwiaWQiLCJCQmpHcmlkRXhXaWRnZXQiLCJncmlkIiwicmVnaXN0ZXJlZEdyaWRzIiwiSlNPTiIsInN0cmluZ2lmeSIsIk9iamVjdCIsImtleXMiLCJUeXBlRXJyb3IiLCJnd19hZGRHcmlkIiwib3B0aW9ucyIsImd3X2RlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJpbW1lZGlhdGUiLCJ0aW1lb3V0IiwiY29udGV4dCIsImFyZ3MiLCJhcmd1bWVudHMiLCJsYXRlciIsImFwcGx5IiwiY2FsbE5vdyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJnd19zZW5kRXZlbnQiLCJwYXlsb2FkIiwiZXZlbnRJZCIsInJlZ2lzdGVyZWRJbnRlcmVzdHMiLCJpbnRlcmVzdHMiLCJpbmNsdWRlcyIsImRpdiIsImdldEVsZW1lbnRCeUlkIiwiaW5kZXhPZiIsInBsYXRmb3JtIiwiaHRtbHZpZXdJZCIsImNvbnRhaW5lciIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJiYXNpc0Rpc3BhdGNoQ3VzdG9tRXZlbnQiLCJnd19wYXJzZU5vZGUiLCJub2RlIiwiZ3JvdXAiLCJnZXRSb3dOb2RlSWQiLCJyb3dQaW5uZWQiLCJpIiwiaGFzT3duUHJvcGVydHkiLCJkYXRhIiwieCIsInJvd0luZGV4IiwicCIsInBhcmVudCIsImtleSIsImNoaWxkSW5kZXgiLCJzIiwiQm9vbGVhbiIsInNlbGVjdGVkIiwiY3IiLCJwcCIsImd3X3BhcnNlTm9kZUZyb21FdmVudCIsImUiLCJnIiwiRnVuY3Rpb24iLCJtb2R1bGUiLCJleHBvcnRzIiwiR1dfRVZFTlRfUk9XX1NFTEVDVCIsIkdXX0VWRU5UX1JPV19DTElDSyIsIkdXX0VWRU5UX1JPV19ET1VCTEVfQ0xJQ0siLCJHV19FVkVOVF9DRUxMX0NMSUNLIiwiR1dfRVZFTlRfQ0VMTF9ET1VCTEVfQ0xJQ0siLCJHV19FVkVOVF9DRUxMX0VESVRJTkdfU1RBUlRFRCIsIkdXX0VWRU5UX0NFTExfRURJVElOR19TVE9QUEVEIiwiR1dfRVZFTlRfQ0VMTF9WQUxVRV9DSEFOR0VEIiwiR1dfRVZFTlRfUk9XX0VESVRJTkdfU1RBUlRFRCIsIkdXX0VWRU5UX1JPV19FRElUSU5HX1NUT1BQRUQiLCJHV19FVkVOVF9ST1dfVkFMVUVfQ0hBTkdFRCIsIkdXX0VWRU5UX0dSSURfU1RBVEVfQ0hBTkdFIiwiR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRUQiLCJHV19FVkVOVF9LRVlQUkVTUyIsIkdXX0VWRU5UX0ZJTFRFUl9DSEFOR0VEIiwiR1dfRVZFTlRfUkVBRFkiLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwic3ltVG9TdHJpbmdUYWciLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNoaWxkcmVuIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibCIsImRlZXBQYXJzZUpzb24iLCJqc29uU3RyaW5nIiwicGFyc2UiLCJlcnIiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJ2YWwiLCJyZWR1Y2UiLCJvYmoiLCJpc09iamVjdCIsInR5cGUiLCJnd19zZXRRdWlja0ZpbHRlciIsImZpbHRlciIsImFwaSIsInNldFF1aWNrRmlsdGVyIiwiZ3dfZXhwYW5kQWxsIiwiZXhwYW5kQWxsIiwiZ3dfY29sbGFwc2VBbGwiLCJjb2xsYXBzZUFsbCIsImd3X2Vuc3VyZUluZGV4VmlzaWJsZSIsImluZGV4IiwicG9zaXRpb24iLCJnZXRSb3dOb2RlIiwiZW5zdXJlTm9kZVZpc2libGUiLCJlbnN1cmVJbmRleFZpc2libGUiLCJOdW1iZXIiLCJnd19uYXZpZ2F0ZVRvTmV4dFJvdyIsInBhcmFtcyIsInByZXZpb3VzQ2VsbCIsInByZXZpb3VzQ2VsbFBvc2l0aW9uIiwic3VnZ2VzdGVkTmV4dENlbGwiLCJuZXh0Q2VsbFBvc2l0aW9uIiwiS0VZX1VQIiwiS0VZX0RPV04iLCJLRVlfTEVGVCIsIktFWV9SSUdIVCIsInJvdyIsImdldERpc3BsYXllZFJvd0F0SW5kZXgiLCJnZXRGaXJzdERpc3BsYXllZFJvdyIsInNldFNlbGVjdGVkIiwiZm9yRWFjaE5vZGUiLCJnZXRMYXN0RGlzcGxheWVkUm93IiwiRXJyb3IiLCJnd19nZXRSb3dOb2RlSWQiLCJfaWQiLCJyb3dOb2RlSWQiLCJncmlkT3B0aW9uc1dyYXBwZXIiLCJncmlkT3B0aW9ucyIsImd3X3NldFJvd0RhdGEiLCJqc29uIiwic2V0Um93RGF0YSIsInJvd0RhdGEiLCJnd191cGRhdGVSb3dEYXRhIiwidHJhbnNhY3Rpb24iLCJiYXRjaFVwZGF0ZSIsInJlbW92ZSIsImxlbmd0aCIsIml0ZW1zIiwiZm9yRWFjaCIsInB1c2giLCJhZGQiLCJyZXZlcnNlIiwiYXBwbHlUcmFuc2FjdGlvbiIsImFwcGx5VHJhbnNhY3Rpb25Bc3luYyIsImd3X3NldFJvd3NIZWlnaHQiLCJoZWlnaHQiLCJzZXRSb3dIZWlnaHQiLCJvblJvd0hlaWdodENoYW5nZWQiLCJnd19zZXRSb3dIZWlnaHQiLCJjb25zb2xlIiwid2FybiIsImd3X3Jlc2V0Um93SGVpZ2h0cyIsInJlc2V0Um93SGVpZ2h0cyIsImd3X3NldFNlbGVjdGVkUm93cyIsInJvd3MiLCJmb3JFYWNoTm9kZUFmdGVyRmlsdGVyQW5kU29ydCIsIlN0cmluZyIsImV4cGFuZGVkIiwib25Hcm91cEV4cGFuZGVkT3JDb2xsYXBzZWQiLCJnd19zZWxlY3RBbGwiLCJmaWx0ZXJlZCIsInNlbGVjdEFsbEZpbHRlcmVkIiwic2VsZWN0QWxsIiwiZ3dfZGVzZWxlY3RBbGwiLCJkZXNlbGVjdEFsbEZpbHRlcmVkIiwiZGVzZWxlY3RBbGwiLCJnd19nZXRTZWxlY3RlZFJvd3MiLCJub2RlcyIsImdldFNlbGVjdGVkTm9kZXMiLCJwYXJzZWQiLCJnd19nZXRTZWxlY3RlZFJvdyIsImd3X2dldFJvdyIsImd3X2dldFJvd3MiLCJwaGFzZSIsImZpbHRlckV4cHJlc3Npb24iLCJjYW5Qcm9jZXNzIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsImNvbERlZiIsImdyaWRBcGkiLCJjb2x1bW5BcGkiLCJnZXRWYWx1ZSIsImNvbHVtbiIsImNvbHVtbkdyb3VwIiwiZ3dfcmVkcmF3Um93cyIsInJlZHJhd1Jvd3MiLCJnd19zZXRQaW5uZWRUb3BSb3dEYXRhIiwic2V0UGlubmVkVG9wUm93RGF0YSIsImd3X3NldFBpbm5lZEJvdHRvbVJvd0RhdGEiLCJzZXRQaW5uZWRCb3R0b21Sb3dEYXRhIiwicm9vdCIsImZyZWVTZWxmIiwic2VsZiIsImZyZWVHbG9iYWwiLCJlcSIsIm90aGVyIiwiaXNBcnJheUxpa2UiLCJTdHJpbmdNYXNrIiwiTnVtYmVyTWFzayIsInJlcXVpcmUiLCJnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyIsImRlZmluaXRpb25zIiwiZGVmIiwiY2hlY2tib3hTZWxlY3Rpb24iLCJnd19pc1Nob3dTZWxlY3Rpb25DaGVja2JveCIsImhlYWRlckNoZWNrYm94U2VsZWN0aW9uIiwiZ3dfaXNIZWFkZXJDaGVja2JveFNlbGVjdGlvbiIsInRvb2x0aXBWYWx1ZUdldHRlckV4cHJlc3Npb24iLCJ0b29sdGlwVmFsdWVHZXR0ZXIiLCJ0b29sdGlwQ29tcG9uZW50IiwiZWRpdGFibGUiLCJyb3dTcGFuIiwiY29sU3BhbiIsImd3X3NldENvbHVtbkRlZmluaXRpb25zIiwiZGVlcFBhcnNlZERlZmluaXRpb25zIiwic2V0Q29sdW1uRGVmcyIsImNvbHVtbkRlZnMiLCJnd19zaXplQ29sdW1uc1RvRml0Iiwid2lkdGgiLCJjb2x1bW5zQVBJIiwic2l6ZUNvbHVtbnNUb0ZpdCIsImd3X2F1dG9TaXplQ29sdW1ucyIsInNraXBIZWFkZXIiLCJjb2x1bW5zIiwiYWxsQ29sdW1uSWRzIiwiZ2V0QWxsQ29sdW1ucyIsImNvbElkIiwiYXV0b1NpemVDb2x1bW5zIiwiZ3dfZW5zdXJlQ29sdW1uVmlzaWJsZSIsImNvbHVtbklkIiwiZW5zdXJlQ29sdW1uVmlzaWJsZSIsImd3X3NldENvbHVtbldpZHRoIiwic2V0Q29sdW1uV2lkdGgiLCJnd19waW5Db2x1bW4iLCJwaW4iLCJzZXRDb2x1bW5QaW5uZWQiLCJnd19tb3ZlQ29sdW1uIiwidG9JbmRleCIsIm1vdmVDb2x1bW4iLCJwYXJhbSIsInNob3dTZWxlY3Rpb25DaGVja2JveCIsImdldEFsbERpc3BsYXllZENvbHVtbnMiLCJzaG93SGVhZGVyU2VsZWN0aW9uQ2hlY2tib3giLCJnd19hZGRSb3dHcm91cENvbHVtbiIsInNldCIsInNwbGl0IiwidHJpbSIsImd3X3JlbW92ZVJvd0dyb3VwQ29sdW1uIiwicmVtb3ZlUm93R3JvdXBDb2x1bW5zIiwiZ3dfZ2V0UGl2b3RNb2RlIiwiaXNQaXZvdE1vZGUiLCJnd19zZXRQaXZvdE1vZGUiLCJtb2RlIiwic2V0UGl2b3RNb2RlIiwiZ3dfYWRkUGl2b3RDb2x1bW5zIiwiZ3dfcmVtb3ZlUGl2b3RDb2x1bW5zIiwicmVtb3ZlUGl2b3RDb2x1bW5zIiwiZ3dfYWRkVmFsdWVDb2x1bW5zIiwiYWRkVmFsdWVDb2x1bW5zIiwiZ3dfcmVtb3ZlVmFsdWVDb2x1bW5zIiwicmVtb3ZlVmFsdWVDb2x1bW5zIiwiZ3dfc2V0U29ydE1vZGVsIiwibW9kZWwiLCJhc0FycmF5IiwicGFyc2VkTW9kZWwiLCJzb3J0IiwiYXBwbHlDb2x1bW5TdGF0ZSIsInN0YXRlIiwiYXBwbHlPcmRlciIsImRlZmF1bHRTdGF0ZSIsImdldENvbHVtblN0YXRlIiwiZ3dfcmVmcmVzaEhlYWRlciIsImd3X3NldENvbHVtblZpc2libGUiLCJ2aXNpYmxlIiwic2V0Q29sdW1uc1Zpc2libGUiLCJnd19hZGRBbGlnbmVkR3JpZCIsImdyaWRJZCIsImN1cnJlbnRHcmlkT3B0aW9uIiwicmVnaXN0ZXIiLCJ0YXJnZXRHcmlkT3B0aW9uIiwiYWxpZ25lZEdyaWRzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNwbGljZSIsImd3X3JlbW92ZUFsaWduZWRHcmlkIiwiZ3dfY29tcGlsZUV4cHJlc3Npb24iLCJleHByZXNzaW9uIiwiZXhwcmVzc2lvbkNhY2hlIiwiZnVuY3Rpb25Cb2R5IiwidGhlRnVuY3Rpb24iLCJnd19leGVjdXRlRXhwcmVzc2lvbiIsImphdmFTY3JpcHRGdW5jdGlvbiIsInJlc3VsdCIsImxvZyIsImd3X2dldENoYXJ0VG9vbGJhckl0ZW1zIiwiY2hhcnRUb29sYmFySXRlbXMiLCJnd19hZGRDaGFydFJhbmdlIiwicmFuZ2UiLCJwciIsImNlbGxSYW5nZSIsInJlZiIsImNyZWF0ZVJhbmdlQ2hhcnQiLCJ1dWlkIiwiY3JlYXRlZF9jaGFydHMiLCJnd19kZXN0cm95Q2hhcnQiLCJkZXN0cm95Q2hhcnQiLCJjaGFydCIsImd3X3N0YXJ0RWRpdGluZ0NlbGwiLCJjb2xLZXkiLCJrZXlQcmVzcyIsImNoYXJQcmVzcyIsInN0YXJ0RWRpdGluZ0NlbGwiLCJnd19zdG9wRWRpdGluZyIsImNhbmNlbCIsInN0b3BFZGl0aW5nIiwiZ3dfdGFiVG9OZXh0Q2VsbCIsInRhYlRvTmV4dENlbGwiLCJnd190YWJUb1ByZXZpb3VzQ2VsbCIsInRhYlRvUHJldmlvdXNDZWxsIiwiZ3dfc2V0Rm9jdXNlZENlbGwiLCJmbG9hdGluZyIsImdldEVkaXRpbmdDZWxscyIsImZvY3VzIiwiZiIsImxhc3RGb2N1c2VkQ2VsbCIsImdldEZvY3VzZWRDZWxsIiwiZ2V0QWxsR3JpZENvbHVtbnMiLCJpc0ludGVnZXIiLCJzZXRGb2N1c2VkQ2VsbCIsImd3X2dldFJhbmdlU2VsZWN0aW9ucyIsInJhbmdlcyIsImdldENlbGxSYW5nZXMiLCJnZXRNb2RlbCIsImFjY3VtdWxhdG9yIiwiY3VycmVudCIsInN0YXJJbmRleCIsIm1pbiIsInN0YXJ0Um93IiwiZW5kUm93IiwiZW5kSW5kZXgiLCJtYXgiLCJnZXRSb3ciLCJwYXJzZWROb2RlIiwiZ3dfcGFyc2VBZGRDZWxsUmFuZ2UiLCJzdGFydCIsImVuZCIsInJvd1N0YXJ0SW5kZXgiLCJhYnMiLCJyb3dFbmRJbmRleCIsImd3X2FkZENlbGxSYW5nZSIsImFkZENlbGxSYW5nZSIsImd3X2NsZWFyUmFuZ2VTZWxlY3Rpb24iLCJjbGVhclJhbmdlU2VsZWN0aW9uIiwiSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCIsInJlRW1wdHlTdHJpbmdMZWFkaW5nIiwicmVFbXB0eVN0cmluZ01pZGRsZSIsInJlRW1wdHlTdHJpbmdUcmFpbGluZyIsInJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsInRlbXBsYXRlIiwic3RyaW5nIiwiZ3VhcmQiLCJzZXR0aW5ncyIsInRlbXBsYXRlU2V0dGluZ3MiLCJpbXBvcnRzIiwiXyIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJzb3VyY2UiLCJyZURlbGltaXRlcnMiLCJSZWdFeHAiLCJlc2NhcGUiLCJyZUludGVycG9sYXRlIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJjYWxsIiwibWF0Y2giLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwib2Zmc2V0Iiwic2xpY2UiLCJlc2NhcGVTdHJpbmdDaGFyIiwidmFyaWFibGUiLCJ0ZXN0IiwiYmFzZUFzc2lnblZhbHVlIiwib2JqZWN0IiwiYXN5bmNUYWciLCJmdW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwidGFnIiwiZ2xvYmFsIiwiYmFzZVJlc3QiLCJpZGVudGl0eSIsInRoaXNBcmciLCJpc0l0ZXJhdGVlQ2FsbCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJpc0xlbmd0aCIsInJlSXNVaW50IiwiaXNJbmRleCIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvIiwiZG9tRXhjVGFnIiwiZXJyb3JUYWciLCJpc0Vycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwiYXJnIiwiYXJyYXlNYXAiLCJhcnJheSIsIml0ZXJhdGVlIiwid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJmYWN0b3J5IiwiZGVmaW5lIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJtIiwiZCIsImdldHRlciIsIm8iLCJjb25maWd1cmFibGUiLCJuIiwiX19lc01vZHVsZSIsImdldERlZmF1bHQiLCJnZXRNb2R1bGVFeHBvcnRzIiwicHJvcGVydHkiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwidG9JbnRlZ2VyIiwiZGlydHlOdW1iZXIiLCJOYU4iLCJudW1iZXIiLCJpc05hTiIsImNlaWwiLCJmbG9vciIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fIiwidHpQYXJzZVRpbWV6b25lIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190elRva2VuaXplRGF0ZV9pbmRleF9qc19fIiwiTUlMTElTRUNPTkRTX0lOX0hPVVIiLCJNSUxMSVNFQ09ORFNfSU5fTUlOVVRFIiwicGF0dGVybnMiLCJ0aW1lem9uZSIsInRpbWV6b25lWiIsInRpbWV6b25lSEgiLCJ0aW1lem9uZUhITU0iLCJ0aW1lem9uZUlBTkEiLCJ0aW1lem9uZVN0cmluZyIsImRhdGUiLCJ0b2tlbiIsImFic29sdXRlT2Zmc2V0IiwiZXhlYyIsImhvdXJzIiwicGFyc2VJbnQiLCJ2YWxpZGF0ZVRpbWV6b25lIiwibWludXRlcyIsInRva2VucyIsImFzVVRDIiwiRGF0ZSIsIlVUQyIsInRpbWVzdGFtcFdpdGhNc1plcm9lZCIsImdldFRpbWUiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1N0cmluZ01hc2tfXyIsIlV0aWxzIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19TdHJpbmdNYXNrX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1R5cGVzX18iLCJEYXRlcyIsImdldERheU9mWWVhciIsImdldFdlZWtOdW1iZXIiLCJnZXRXZWVrU3RhcnRCeUxvY2FsZSIsIklTX0RBVEVfUkVHRVgiLCJJU19USU1FX1JFR0VYIiwiZml4U2hvcnRJU08iLCJnZXRUaW1lem9uZU9yT2Zmc2V0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJtYXNrIiwiX21hc2siLCJncm91cGluZ1NlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3IiLCJmb3JjZVRyYWlsaW5nWmVyb3MiLCJsb29zZSIsIm1hc2tMZW4iLCJzdHIiLCJtYXNrQmVmb3JlRGVjaW1hbCIsIm1hc2tBZnRlckRlY2ltYWwiLCJmb3VuZERlY2ltYWwiLCJjaGFyQXQiLCJudW0iLCJfcm91bmQiLCJieXRlcyIsIl90b0NoYXJBcnJheSIsImluTGVuIiwibnVtQmVmb3JlRGVjaW1hbCIsIm51bUFmdGVyRGVjaW1hbCIsIl9pIiwiX2kyIiwiZmlsbEJ5dGUiLCJmbG9hdEJ5dGUiLCJpblBvcyIsIm91dFBvcyIsImZsb2F0UG9zIiwiZmlsbEluaXQiLCJpc05lZ2F0aXZlIiwiX2dldFNpZ24iLCJlbWl0RGVjaW1hbCIsImZvdW5kWmVybyIsImZvdW5kRGlnaXQiLCJjdXJyZW5jeSIsInJldCIsIm1hc2tQb3MiLCJfbSIsImpvaW4iLCJfc2hpZnQiLCJwcmVjaXNpb24iLCJyZXZlcnNlU2hpZnQiLCJudW1BcnJheSIsInJvdW5kIiwic2lnbnVtIiwiY2hhcnMiLCJjb25jYXQiLCJzdWJzdHJpbmciLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZGF0ZV9mbnNfdHpfdXRjVG9ab25lZFRpbWVfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV93ZWVrc3RhcnRfXyIsImxvY2FsZSIsImdldEZ1bGxZZWFyIiwiZGlmZiIsImdldFRpbWV6b25lT2Zmc2V0Iiwib25lRGF5IiwiZGF5IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwicmVzb2x2ZWRPcHRpb25zIiwidGltZVpvbmUiLCJwYWQiLCJ3ZWVrU3RhcnQiLCJnZXRNb250aCIsImdldERhdGUiLCJkYXlOdW0iLCJnZXRVVENEYXkiLCJzZXRVVENEYXRlIiwiZ2V0VVRDRGF0ZSIsInllYXJTdGFydCIsImdldFVUQ0Z1bGxZZWFyIiwiRGF0ZU1hc2siLCJkYXRlT2JqZWN0IiwidHJhbnNsYXRpb24iLCJfYnVpbGRUcmFuc2xhdGlvbiIsInllYXIiLCJtb250aCIsIm1vbnRoU2hvcnQiLCJmb3JtYXQiLCJtb250aExvbmciLCJkYXlTaG9ydCIsIndlZWtkYXkiLCJkYXlMb25nIiwiZ2V0TWludXRlcyIsInNlY29uZHMiLCJnZXRTZWNvbmRzIiwiaG91cnMyNCIsImdldEhvdXJzIiwiaG91cnMxMiIsImRheU9mWWVhciIsImRheU9mV2VlayIsImdldERheSIsIndlZWtOdW1iZXIiLCJrIiwiZGF0ZURldGFpbHMiLCJZeiIsInN1YnN0ciIsIllzIiwiWWwiLCJZcCIsImZyb21DaGFyQ29kZSIsIllkIiwiWSIsIk16IiwiTXMiLCJNbCIsIk1wIiwiTWQiLCJNIiwiRHoiLCJEcyIsIkRsIiwiRHAiLCJEZCIsIkQiLCJIeiIsIkhzIiwiSGwiLCJIcCIsIkhkIiwiSCIsImh6IiwiaHMiLCJobCIsImhwIiwiaGQiLCJoIiwibXoiLCJtcyIsIm1sIiwibXAiLCJtZCIsInN6Iiwic3MiLCJzbCIsInNwIiwic2QiLCJQUCIsIlAiLCJKeiIsIkpzIiwiSmwiLCJKZCIsIkoiLCJXeiIsIldzIiwiV2wiLCJXcCIsIldkIiwiVyIsInd6Iiwid3MiLCJ3bCIsIndwIiwid2QiLCJ3IiwidXRjVG9ab25lZFRpbWUiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2xpYl90elBhcnNlVGltZXpvbmVfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fc3ViTWlsbGlzZWNvbmRzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3RvRGF0ZV9fIiwiZGlydHlEYXRlIiwidXRjRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsIm9mZnNldE1pbGxpc2Vjb25kcyIsInR6VG9rZW5pemVEYXRlIiwiZHRmIiwiZ2V0RGF0ZVRpbWVGb3JtYXQiLCJmb3JtYXRUb1BhcnRzIiwicGFydHNPZmZzZXQiLCJoYWNreU9mZnNldCIsInR5cGVUb1BvcyIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJmb3JtYXR0ZWQiLCJmaWxsZWQiLCJwb3MiLCJkdGZDYWNoZSIsInRlc3REYXRlRm9ybWF0dGVkIiwiaG91cjEyIiwiaG91ckN5Y2xlU3VwcG9ydGVkIiwiaG91ckN5Y2xlIiwic3ViTWlsbGlzZWNvbmRzIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdG9JbnRlZ2VyX2luZGV4X2pzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2FkZE1pbGxpc2Vjb25kc19pbmRleF9qc19fIiwiZGlydHlBbW91bnQiLCJhbW91bnQiLCJhZGRNaWxsaXNlY29uZHMiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3RvRGF0ZV9pbmRleF9qc19fIiwidGltZXN0YW1wIiwidG9EYXRlIiwiYXJndW1lbnQiLCJhcmdTdHIiLCJzdGFjayIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kYXRlX2Zuc19lc21fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2RhdGVfZm5zX2VzbV9saWJfZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kc19pbmRleF9qc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19saWJfdHpQYXJzZVRpbWV6b25lX18iLCJERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIiwiZGF0ZVRpbWVEZWxpbWV0ZXIiLCJwbGFpblRpbWUiLCJ0aW1lWm9uZURlbGltZXRlciIsIllZIiwiWVlZIiwiWVlZWSIsIllZWVlZIiwiTU0iLCJEREQiLCJNTUREIiwiV3d3IiwiV3d3RCIsIkhIIiwiSEhNTSIsIkhITU1TUyIsImRpcnR5T3B0aW9ucyIsImFkZGl0aW9uYWxEaWdpdHMiLCJSYW5nZUVycm9yIiwiZGF0ZVN0cmluZ3MiLCJzcGxpdERhdGVTdHJpbmciLCJwYXJzZVllYXJSZXN1bHQiLCJwYXJzZVllYXIiLCJyZXN0RGF0ZVN0cmluZyIsInBhcnNlRGF0ZSIsInRpbWUiLCJwYXJzZVRpbWUiLCJkYXRlU3RyaW5nIiwidGltZVN0cmluZyIsInBhdHRlcm5ZWVkiLCJwYXR0ZXJuWVlZWVkiLCJ5ZWFyU3RyaW5nIiwiY2VudHVyeVN0cmluZyIsIndlZWsiLCJzZXRVVENGdWxsWWVhciIsInZhbGlkYXRlRGF0ZSIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsInZhbGlkYXRlV2Vla0RhdGUiLCJkYXlPZklTT1dlZWtZZWFyIiwicGFyc2VGbG9hdCIsInZhbGlkYXRlVGltZSIsImlzb1dlZWtZZWFyIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiREFZU19JTl9NT05USCIsIkRBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSIiwiaXNMZWFwWWVhckluZGV4IiwiaXNMZWFwWWVhciIsImdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMiLCJiYXNlVGltZXpvbmVPZmZzZXQiLCJzZXRTZWNvbmRzIiwibWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQiLCJnZXRXZWVrU3RhcnRCeUxvY2FsZSQxIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19hcGlfanNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbGFuZ1JlZ2lvbk1hcF9qc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19yZWdpb25EYXlNYXBfanNfXyIsImdldFdlZWtTdGFydEJ5UmVnaW9uJDEiLCJyZWdpb25Db2RlIiwiZ2V0V2Vla1N0YXJ0QnlSZWdpb24iLCJyZWdpb25EYXlNYXAiLCJjb2RlIiwidG9VcHBlckNhc2UiLCJsYW5nUmVnaW9uTWFwIiwidG9Mb3dlckNhc2UiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJlbiIsInpoIiwiemhfaGFucyIsImhhbnMiLCJ3dXUiLCJoc24iLCJoYWsiLCJuYW4iLCJnYW4iLCJoaSIsInRlIiwibXIiLCJ0YSIsImd1Iiwia24iLCJvciIsInBhX2d1cnUiLCJiaG8iLCJhd2EiLCJhcyIsIm13ciIsIm1haSIsIm1hZyIsImJnYyIsImhuZSIsImRjYyIsImR6IiwidG4iLCJhbSIsIm9tIiwicXVjIiwianYiLCJzdSIsIm1hZCIsIm1zX2FyYWIiLCJnYSIsImhlIiwiamFtIiwiamEiLCJrbSIsImtvIiwibG8iLCJtaCIsIm15IiwibXQiLCJuZSIsImZpbCIsImNlYiIsImlsbyIsInVyIiwicGEiLCJwYV9hcmFiIiwiYXJhYiIsImxhaCIsInBzIiwic2RfYXJhYiIsInNrciIsImduIiwidGgiLCJ0dHMiLCJhZWIiLCJ6aF9oYW50IiwiaGFudCIsInNtIiwienUiLCJzbiIsImFycSIsImFyIiwiYXJ6IiwiZmEiLCJhel9hcmFiIiwiYXJ5IiwiYm4iLCJya3QiLCJkdiIsIkFHIiwiQVRHIiwiQVIiLCJBUkciLCJBUyIsIkFTTSIsIkFVIiwiQVVTIiwiQlIiLCJCUkEiLCJCUyIsIkJIUyIsIkJUIiwiQlROIiwiQlciLCJCV0EiLCJCWiIsIkJMWiIsIkNBIiwiQ0FOIiwiQ04iLCJDSE4iLCJDTyIsIkNPTCIsIkRNIiwiRE1BIiwiRE8iLCJET00iLCJFVCIsIkVUSCIsIkdUIiwiR1RNIiwiR1UiLCJHVU0iLCJISyIsIkhLRyIsIkhOIiwiSE5EIiwiSUQiLCJJRE4iLCJJRSIsIklSTCIsIklMIiwiSVNSIiwiSU4iLCJJTkQiLCJKTSIsIkpBTSIsIkpQIiwiSlBOIiwiS0UiLCJLRU4iLCJLSCIsIktITSIsIktSIiwiS09SIiwiTEEiLCJMQTAiLCJNSCIsIk1ITCIsIk1NUiIsIk1PIiwiTUFDIiwiTVQiLCJNTFQiLCJNWCIsIk1FWCIsIk1aIiwiTU9aIiwiTkkiLCJOSUMiLCJOUCIsIk5QTCIsIk5aIiwiTlpMIiwiUEEiLCJQQU4iLCJQRSIsIlBFUiIsIlBIIiwiUEhMIiwiUEsiLCJQQUsiLCJQUiIsIlBSSSIsIlBZIiwiUFJZIiwiU0EiLCJTQVUiLCJTRyIsIlNHUCIsIlNWIiwiU0xWIiwiVEgiLCJUSEEiLCJUTiIsIlRVTiIsIlRUIiwiVFRPIiwiVFciLCJUV04iLCJVTSIsIlVNSSIsIlVTIiwiVVNBIiwiVkUiLCJWRU4iLCJWSSIsIlZJUiIsIldTIiwiV1NNIiwiWUUiLCJZRU0iLCJaQSIsIlpBRiIsIlpXIiwiWldFIiwiQUUiLCJBUkUiLCJBRiIsIkFGRyIsIkJIIiwiQkhSIiwiREoiLCJESkkiLCJEWiIsIkRaQSIsIkVHIiwiRUdZIiwiSVEiLCJJUlEiLCJJUiIsIklSTiIsIkpPIiwiSk9SIiwiS1ciLCJLV1QiLCJMWSIsIkxCWSIsIk1BIiwiTUFSIiwiT00iLCJPTU4iLCJRQSIsIlFBVCIsIlNEIiwiU0ROIiwiU1kiLCJTWVIiLCJCRCIsIkJHRCIsIk1WIiwiTURWIiwiaXNOdW1iZXJSZWdleCIsImlzV2hpdGVzcGFjZVJlZ2V4IiwicHVuY3R1YXRpb25MaXN0IiwiaXNMb3dlckNhc2UiLCJpc1VwcGVyQ2FzZSIsInBhc3NPclRocm93RXJyb3IiLCJfY2hhciIsInN0ckxlbiIsIm1hc2tCeXRlIiwiX2J5dGUiLCJfYnl0ZTIiLCJfYnl0ZTMiLCJfYnl0ZTQiLCJfYnl0ZTUiLCJfYnl0ZTYiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1R5cGVzX18iLCJUeXBlcyIsIl9udW1iZXIiLCJfZGF0ZSIsIlRleHRJbnB1dCIsImVsZW1lbnRzIiwiZG9jIiwiY3NzQ2xhc3NFcnJvciIsImNzc0NsYXNzU3VjY2VzcyIsIm9uVXBkYXRlIiwib25JbnZhbGlkIiwiaW5wdXQiLCJwYXJlbnRDbGFzcyIsImlzV3JhcHBlZCIsImlucHV0SWQiLCJpbnB1dE5hbWUiLCJvcmlnaW5hbFBhdHRlcm4iLCJkZWZhdWx0UGF0dGVybiIsImdlbmVyYXRlUGF0dGVybkZyb21NYXNrIiwicGF0dGVybiIsIndyYXAiLCJ1bm1hc2tJbnB1dCIsIm1hc2tJZk5vdE1hc2tlZCIsInVubWFzayIsInRleHRJbnB1dCIsImV2ZW50VHlwZSIsImtleUNvZGUiLCJrZXlDb250ZW50IiwiaW5zZXJ0UG9zaXRpb24iLCJmaW5kQ2FyZXRQb3NpdGlvbiIsIm1hc2tFcnJvciIsInNlbGVjdGlvblN0YXJ0IiwidW5tYXNrZWRWYWx1ZSIsImlzVmFsaWQiLCJ2YWx1ZU1hc2tlZCIsInZhbHVlVW5tYXNrZWQiLCJlcnJvciIsIlNVUFBPUlRFRF9NQVNLUyIsIklTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEIiwiZXZhbCIsImlzTWFza2VkVmFsdWUiLCJjYWNoZUtleSIsIm1hc2tBc0FycnkiLCJyZWdleCIsIm1hc2tBc0FycmF5IiwibWFza2VkVmFsdWVBc0FycmF5IiwibWFza2VkVmFsdWUiLCJ1bm1hc2tlZCIsImVsIiwiZWxIYXNNYXNrIiwiTnVtYmVySW5wdXQiLCJjb3VudERlY2ltYWxzIiwiYWN0dWFsSW5wdXQiLCJhY3R1YWxJbnB1dElkIiwiYWN0dWFsSW5wdXROYW1lIiwiYWN0dWFsSW5wdXRTdGVwIiwiYWN0dWFsSW5wdXRNYXgiLCJhY3R1YWxJbnB1dE1pbiIsImFjdHVhbElucHV0R3JvdXBpbmdTZXBhcmF0b3IiLCJhY3R1YWxJbnB1dERlY2ltYWxTZXBhcmF0b3IiLCJhY3R1YWxJbnB1dEZvcmNlVHJhaWxpbmdaZXJvcyIsImFjdHVhbElucHV0TWFzayIsImFjdHVhbElucHV0Q2xhc3NlcyIsImFjdHVhbElucHV0UmVxdWlyZWQiLCJ1bm1hc2tlZElucHV0IiwiZGVjaW1hbHMiLCJzdGVwIiwid3JhcHBlciIsInJlc3RvcmUiLCJjaGFyIiwiYnl0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsIl9fc3ByZWFkQXJyYXlzIiwiaWwiLCJhIiwiaiIsImpsIiwiSE9PS1MiLCJkZWZhdWx0cyIsIl9kaXNhYmxlIiwiX2VuYWJsZSIsImFsbG93SW5wdXQiLCJhbGxvd0ludmFsaWRQcmVsb2FkIiwiYWx0Rm9ybWF0IiwiYWx0SW5wdXQiLCJhbHRJbnB1dENsYXNzIiwiYW5pbWF0ZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImFyaWFEYXRlRm9ybWF0IiwiYXV0b0ZpbGxEZWZhdWx0VGltZSIsImNsaWNrT3BlbnMiLCJjbG9zZU9uU2VsZWN0IiwiY29uanVuY3Rpb24iLCJkYXRlRm9ybWF0IiwiZGVmYXVsdEhvdXIiLCJkZWZhdWx0TWludXRlIiwiZGVmYXVsdFNlY29uZHMiLCJkaXNhYmxlIiwiZGlzYWJsZU1vYmlsZSIsImVuYWJsZSIsImVuYWJsZVNlY29uZHMiLCJlbmFibGVUaW1lIiwiZXJyb3JIYW5kbGVyIiwiZ2V0V2VlayIsImdpdmVuRGF0ZSIsInNldEhvdXJzIiwic2V0RGF0ZSIsIndlZWsxIiwiaG91ckluY3JlbWVudCIsImlnbm9yZWRGb2N1c0VsZW1lbnRzIiwiaW5saW5lIiwibWludXRlSW5jcmVtZW50IiwibW9udGhTZWxlY3RvclR5cGUiLCJuZXh0QXJyb3ciLCJub0NhbGVuZGFyIiwibm93Iiwib25DaGFuZ2UiLCJvbkNsb3NlIiwib25EYXlDcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbktleURvd24iLCJvbk1vbnRoQ2hhbmdlIiwib25PcGVuIiwib25QYXJzZUNvbmZpZyIsIm9uUmVhZHkiLCJvblZhbHVlVXBkYXRlIiwib25ZZWFyQ2hhbmdlIiwib25QcmVDYWxlbmRhclBvc2l0aW9uIiwicGx1Z2lucyIsInBvc2l0aW9uRWxlbWVudCIsInByZXZBcnJvdyIsInNob3J0aGFuZEN1cnJlbnRNb250aCIsInNob3dNb250aHMiLCJzdGF0aWMiLCJ0aW1lXzI0aHIiLCJ3ZWVrTnVtYmVycyIsImVuZ2xpc2giLCJ3ZWVrZGF5cyIsInNob3J0aGFuZCIsImxvbmdoYW5kIiwibW9udGhzIiwiZGF5c0luTW9udGgiLCJmaXJzdERheU9mV2VlayIsIm9yZGluYWwiLCJudGgiLCJyYW5nZVNlcGFyYXRvciIsIndlZWtBYmJyZXZpYXRpb24iLCJzY3JvbGxUaXRsZSIsInRvZ2dsZVRpdGxlIiwiYW1QTSIsInllYXJBcmlhTGFiZWwiLCJtb250aEFyaWFMYWJlbCIsImhvdXJBcmlhTGFiZWwiLCJtaW51dGVBcmlhTGFiZWwiLCJpbnQiLCJib29sIiwiZGVib3VuY2UiLCJhcnJheWlmeSIsInRvZ2dsZUNsYXNzIiwiZWxlbSIsImNsYXNzTmFtZSIsImNsYXNzTGlzdCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZW50IiwidGV4dENvbnRlbnQiLCJjbGVhck5vZGUiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJmaW5kUGFyZW50IiwiY29uZGl0aW9uIiwicGFyZW50Tm9kZSIsImNyZWF0ZU51bWJlcklucHV0IiwiaW5wdXRDbGFzc05hbWUiLCJvcHRzIiwibnVtSW5wdXQiLCJhcnJvd1VwIiwiYXJyb3dEb3duIiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJnZXRFdmVudFRhcmdldCIsImV2ZW50IiwiY29tcG9zZWRQYXRoIiwicGF0aCIsImRvTm90aGluZyIsIm1vbnRoVG9TdHIiLCJtb250aE51bWJlciIsInJldkZvcm1hdCIsIkYiLCJkYXRlT2JqIiwibW9udGhOYW1lIiwic2V0TW9udGgiLCJHIiwiSyIsInNob3J0TW9udGgiLCJTIiwiVSIsInVuaXhTZWNvbmRzIiwid2Vla051bSIsInNldEZ1bGxZZWFyIiwiWiIsIklTT0RhdGUiLCJzZXRNaW51dGVzIiwidSIsInVuaXhNaWxsU2Vjb25kcyIsInkiLCJ0b2tlblJlZ2V4IiwiZm9ybWF0cyIsInRvSVNPU3RyaW5nIiwiY3JlYXRlRGF0ZUZvcm1hdHRlciIsIl9hIiwiX2IiLCJjb25maWciLCJfYyIsImwxMG4iLCJfZCIsImlzTW9iaWxlIiwiZnJtdCIsIm92ZXJyaWRlTG9jYWxlIiwiZm9ybWF0RGF0ZSIsImFyciIsImNyZWF0ZURhdGVQYXJzZXIiLCJnaXZlbkZvcm1hdCIsInRpbWVsZXNzIiwiY3VzdG9tTG9jYWxlIiwicGFyc2VkRGF0ZSIsImRhdGVPcmlnIiwidG9GaXhlZCIsImRhdGVzdHIiLCJtYXRjaGVkIiwib3BzIiwibWF0Y2hJbmRleCIsInJlZ2V4U3RyIiwidG9rZW5fMSIsImlzQmFja1NsYXNoIiwiZXNjYXBlZCIsImZuIiwiY29tcGFyZURhdGVzIiwiZGF0ZTEiLCJkYXRlMiIsImlzQmV0d2VlbiIsInRzIiwidHMxIiwidHMyIiwiZHVyYXRpb24iLCJEQVkiLCJfbG9vcF8xIiwiYXJnc18xIiwiREVCT1VOQ0VEX0NIQU5HRV9NUyIsIkZsYXRwaWNrckluc3RhbmNlIiwiZWxlbWVudCIsImluc3RhbmNlQ29uZmlnIiwiZmxhdHBpY2tyIiwiZGVmYXVsdENvbmZpZyIsIl9oYW5kbGVycyIsInBsdWdpbkVsZW1lbnRzIiwibG9hZGVkUGx1Z2lucyIsIl9iaW5kIiwiYmluZCIsIl9zZXRIb3Vyc0Zyb21EYXRlIiwic2V0SG91cnNGcm9tRGF0ZSIsIl9wb3NpdGlvbkNhbGVuZGFyIiwicG9zaXRpb25DYWxlbmRhciIsImNoYW5nZU1vbnRoIiwiY2hhbmdlWWVhciIsImNsZWFyIiwiY2xvc2UiLCJfY3JlYXRlRWxlbWVudCIsImRlc3Ryb3kiLCJpc0VuYWJsZWQiLCJqdW1wVG9EYXRlIiwib3BlbiIsInJlZHJhdyIsInRvZ2dsZSIsInNldHVwSGVscGVyRnVuY3Rpb25zIiwidXRpbHMiLCJnZXREYXlzSW5Nb250aCIsInlyIiwiY3VycmVudE1vbnRoIiwiY3VycmVudFllYXIiLCJpbml0IiwiaXNPcGVuIiwicGFyc2VDb25maWciLCJzZXR1cExvY2FsZSIsInNldHVwSW5wdXRzIiwic2V0dXBEYXRlcyIsImJ1aWxkIiwiYmluZEV2ZW50cyIsInNlbGVjdGVkRGF0ZXMiLCJsYXRlc3RTZWxlY3RlZERhdGVPYmoiLCJtaW5EYXRlIiwidXBkYXRlVmFsdWUiLCJzZXRDYWxlbmRhcldpZHRoIiwiaXNTYWZhcmkiLCJ0cmlnZ2VyRXZlbnQiLCJiaW5kVG9JbnN0YW5jZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGVuZGFyQ29udGFpbmVyIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiZGlzcGxheSIsImRheXNDb250YWluZXIiLCJkYXlzV2lkdGgiLCJkYXlzIiwib2Zmc2V0V2lkdGgiLCJ3ZWVrV3JhcHBlciIsInJlbW92ZVByb3BlcnR5IiwidXBkYXRlVGltZSIsImRlZmF1bHREYXRlIiwiZ2V0RGVmYXVsdEhvdXJzIiwidGltZVdyYXBwZXIiLCJwcmV2VmFsdWUiLCJfaW5wdXQiLCJzZXRIb3Vyc0Zyb21JbnB1dHMiLCJfZGVib3VuY2VkQ2hhbmdlIiwiYW1wbTJtaWxpdGFyeSIsIm1pbGl0YXJ5MmFtcG0iLCJob3VyRWxlbWVudCIsIm1pbnV0ZUVsZW1lbnQiLCJzZWNvbmRFbGVtZW50IiwibGltaXRNaW5Ib3VycyIsIm1pblRpbWUiLCJtaW5EYXRlSGFzVGltZSIsImxpbWl0TWF4SG91cnMiLCJtYXhUaW1lIiwibWF4RGF0ZSIsIm1heERhdGVIYXNUaW1lIiwibWluSHIiLCJtaW5NaW51dGVzIiwibWF4SHIiLCJtYXhNaW51dGVzIiwib25ZZWFySW5wdXQiLCJldmVudFRhcmdldCIsImRlbHRhIiwiaGFuZGxlciIsImV2IiwidHJpZ2dlckNoYW5nZSIsImV2dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZXR1cE1vYmlsZSIsImRlYm91bmNlZFJlc2l6ZSIsIm9uUmVzaXplIiwib25Nb3VzZU92ZXIiLCJib2R5Iiwib250b3VjaHN0YXJ0IiwiZG9jdW1lbnRDbGljayIsImNhcHR1cmUiLCJtb250aE5hdiIsIm9uTW9udGhOYXZDbGljayIsInNlbGVjdERhdGUiLCJ0aW1lQ29udGFpbmVyIiwic2VsVGV4dCIsInNlbGVjdCIsInRpbWVJbmNyZW1lbnQiLCJvbkJsdXIiLCJqdW1wRGF0ZSIsImp1bXBUbyIsIm9sZFllYXIiLCJvbGRNb250aCIsImJ1aWxkTW9udGhTd2l0Y2giLCJpbmNyZW1lbnROdW1JbnB1dCIsImNvbnRhaW5zIiwiaW5wdXRFbGVtIiwiY3JlYXRlRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwidGFiSW5kZXgiLCJidWlsZE1vbnRoTmF2IiwiaW5uZXJDb250YWluZXIiLCJidWlsZFdlZWtzIiwickNvbnRhaW5lciIsImJ1aWxkV2Vla2RheXMiLCJidWlsZERheXMiLCJidWlsZFRpbWUiLCJjdXN0b21BcHBlbmQiLCJhcHBlbmRUbyIsIm5vZGVUeXBlIiwiaW5zZXJ0QmVmb3JlIiwibmV4dFNpYmxpbmciLCJjcmVhdGVEYXkiLCJkYXlOdW1iZXIiLCJkYXRlSXNFbmFibGVkIiwiZGF5RWxlbWVudCIsIiRpIiwidG9kYXlEYXRlRWxlbSIsImlzRGF0ZVNlbGVjdGVkIiwic2VsZWN0ZWREYXRlRWxlbSIsImlzRGF0ZUluUmFuZ2UiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJmb2N1c09uRGF5RWxlbSIsInRhcmdldE5vZGUiLCJnZXRGaXJzdEF2YWlsYWJsZURheSIsInN0YXJ0TW9udGgiLCJlbmRNb250aCIsInN0YXJ0SW5kZXgiLCJnZXROZXh0QXZhaWxhYmxlRGF5IiwiZ2l2ZW5Nb250aCIsImxvb3BEZWx0YSIsIm51bU1vbnRoRGF5cyIsImZvY3VzT25EYXkiLCJkYXlGb2N1c2VkIiwiaXNJblZpZXciLCJhY3RpdmVFbGVtZW50Iiwic3RhcnRFbGVtIiwiYnVpbGRNb250aERheXMiLCJmaXJzdE9mTW9udGgiLCJwcmV2TW9udGhEYXlzIiwiaXNNdWx0aU1vbnRoIiwicHJldk1vbnRoRGF5Q2xhc3MiLCJuZXh0TW9udGhEYXlDbGFzcyIsImRheUluZGV4IiwiZGF5Q29udGFpbmVyIiwiZnJhZyIsInNob3VsZEJ1aWxkTW9udGgiLCJtb250aHNEcm9wZG93bkNvbnRhaW5lciIsImlubmVySFRNTCIsImJ1aWxkTW9udGgiLCJtb250aE5hdkZyYWdtZW50IiwibW9udGhFbGVtZW50Iiwic2VsZWN0ZWRNb250aCIsInllYXJJbnB1dCIsInRhYmluZGV4IiwieWVhckVsZW1lbnQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImRpc2FibGVkIiwiYnVpbGRNb250aHMiLCJwcmV2TW9udGhOYXYiLCJ5ZWFyRWxlbWVudHMiLCJtb250aEVsZW1lbnRzIiwibmV4dE1vbnRoTmF2IiwiX19oaWRlUHJldk1vbnRoQXJyb3ciLCJfX2hpZGVOZXh0TW9udGhBcnJvdyIsImN1cnJlbnRZZWFyRWxlbWVudCIsInVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgiLCJzZXBhcmF0b3IiLCJob3VySW5wdXQiLCJtaW51dGVJbnB1dCIsInNlY29uZElucHV0IiwiZ2V0QXR0cmlidXRlIiwidGl0bGUiLCJ3ZWVrZGF5Q29udGFpbmVyIiwidXBkYXRlV2Vla2RheXMiLCJpc09mZnNldCIsIl9oaWRlUHJldk1vbnRoQXJyb3ciLCJfaGlkZU5leHRNb250aEFycm93IiwidHJpZ2dlckNoYW5nZUV2ZW50IiwidG9Jbml0aWFsIiwibW9iaWxlSW5wdXQiLCJfaW5pdGlhbERhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibGFzdENoaWxkIiwiX3R5cGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpc0NhbGVuZGFyRWxlbSIsImV2ZW50VGFyZ2V0XzEiLCJpc0NhbGVuZGFyRWxlbWVudCIsImlzSW5wdXQiLCJsb3N0Rm9jdXMiLCJyZWxhdGVkVGFyZ2V0IiwiaXNJZ25vcmVkIiwic29tZSIsIm5ld1llYXIiLCJuZXdZZWFyTnVtIiwiaXNOZXdZZWFyIiwiZGF0ZVRvQ2hlY2siLCJmcm9tIiwidG8iLCJhbGxvd0tleWRvd24iLCJhbGxvd0lubGluZUtleWRvd24iLCJibHVyIiwiaXNUaW1lT2JqIiwicHJldmVudERlZmF1bHQiLCJmb2N1c0FuZENsb3NlIiwiZGVsdGFfMSIsImN0cmxLZXkiLCJzdG9wUHJvcGFnYXRpb24iLCJlbGVtcyIsInNoaWZ0S2V5IiwiaG92ZXJEYXRlIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJpbml0aWFsRGF0ZSIsInJhbmdlU3RhcnREYXRlIiwicmFuZ2VFbmREYXRlIiwiY29udGFpbnNEaXNhYmxlZCIsIm1pblJhbmdlIiwibWF4UmFuZ2UiLCJkYXlFbGVtIiwib3V0T2ZSYW5nZSIsIl9wb3NpdGlvbkVsZW1lbnQiLCJjbGljayIsIndhc09wZW4iLCJtaW5NYXhEYXRlU2V0dGVyIiwiaW52ZXJzZURhdGVPYmoiLCJib29sT3B0cyIsInVzZXJDb25maWciLCJkYXRhc2V0IiwiZGF0ZXMiLCJwYXJzZURhdGVSdWxlcyIsInRpbWVNb2RlIiwiZGVmYXVsdERhdGVGb3JtYXQiLCJkZWZhdWx0QWx0Rm9ybWF0IiwiX21pbkRhdGUiLCJfbWF4RGF0ZSIsIm1pbk1heFRpbWVTZXR0ZXIiLCJfbWluVGltZSIsIl9tYXhUaW1lIiwiaG9vayIsInBsdWdpbkNvbmYiLCJnZXRJbnB1dEVsZW0iLCJxdWVyeVNlbGVjdG9yIiwibDEwbnMiLCJkZWZhdWx0IiwiY3VzdG9tUG9zaXRpb25FbGVtZW50IiwiY2FsZW5kYXJIZWlnaHQiLCJhY2MiLCJjaGlsZCIsIm9mZnNldEhlaWdodCIsImNhbGVuZGFyV2lkdGgiLCJjb25maWdQb3MiLCJjb25maWdQb3NWZXJ0aWNhbCIsImNvbmZpZ1Bvc0hvcml6b250YWwiLCJpbnB1dEJvdW5kcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRpc3RhbmNlRnJvbUJvdHRvbSIsImlubmVySGVpZ2h0IiwiYm90dG9tIiwic2hvd09uVG9wIiwidG9wIiwicGFnZVlPZmZzZXQiLCJsZWZ0IiwicGFnZVhPZmZzZXQiLCJpc0NlbnRlciIsImlzUmlnaHQiLCJyaWdodCIsInJpZ2h0TW9zdCIsImNlbnRlck1vc3QiLCJnZXREb2N1bWVudFN0eWxlU2hlZXQiLCJib2R5V2lkdGgiLCJjZW50ZXJMZWZ0IiwiY2VudGVyQmVmb3JlIiwiY2VudGVyQWZ0ZXIiLCJjZW50ZXJJbmRleCIsImNzc1J1bGVzIiwiY2VudGVyU3R5bGUiLCJpbnNlcnRSdWxlIiwiZWRpdGFibGVTaGVldCIsInN0eWxlU2hlZXRzIiwic2hlZXQiLCJjcmVhdGVTdHlsZVNoZWV0IiwiaGVhZCIsIm1zTWF4VG91Y2hQb2ludHMiLCJpc1NlbGVjdGFibGUiLCJzZWxlY3RlZERhdGUiLCJzaG91bGRDaGFuZ2VNb250aCIsInNlbGVjdGVkSW5kZXgiLCJiIiwic2luZ2xlIiwiQ0FMTEJBQ0tTIiwib3B0aW9uIiwic2V0U2VsZWN0ZWREYXRlIiwiaW5wdXREYXRlIiwicnVsZSIsInByZWxvYWRlZERhdGUiLCJub2RlTmFtZSIsInBsYWNlaG9sZGVyIiwicmVxdWlyZWQiLCJpbnB1dFR5cGUiLCJtb2JpbGVGb3JtYXRTdHIiLCJkZWZhdWx0VmFsdWUiLCJob29rcyIsImluaXRFdmVudCIsImdldERhdGVTdHIiLCJkT2JqIiwiaXNQcmV2TW9udGgiLCJpc05leHRNb250aCIsImlzS2V5RG93biIsImN1clZhbHVlIiwid2hpY2giLCJpc0hvdXJFbGVtIiwiaXNNaW51dGVFbGVtIiwiX2ZsYXRwaWNrciIsIm5vZGVMaXN0IiwiSFRNTEVsZW1lbnQiLCJpbnN0YW5jZXMiLCJIVE1MQ29sbGVjdGlvbiIsIk5vZGVMaXN0Iiwic2VsZWN0b3IiLCJOb2RlIiwibG9jYWxpemUiLCJzZXREZWZhdWx0cyIsImpRdWVyeSIsImZwX2luY3IiLCJDb21wb25lbnQiLCJnZXRQcm90b3R5cGVPZiIsIm1hcFN0b3JlIiwic3VwZXJTdG9yZSIsImRlc2NzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImtsYXNzIiwiZ2V0T3duS2V5cyIsImRlc2MiLCJhdXRvYmluZE1ldGhvZCIsImdldEJvdW5kU3VwZXIiLCJib3VuZEZuIiwiY3JlYXRlRGVmYXVsdFNldHRlciIsImF1dG9iaW5kQ2xhc3MiLCJoYW5kbGUiLCJHRU5FUklDX0ZVTkNUSU9OX0VSUk9SIiwiRlVOQ1RJT05fUkVHRVhQIiwiU3ludGF4RXJyb3JSZXBvcnRlciIsInRvcGljIiwicGFyZW50S2xhc3MiLCJjaGlsZEtsYXNzIiwicGFyZW50RGVzY3JpcHRvciIsImNoaWxkRGVzY3JpcHRvciIsIm1zZyIsInJlcG9ydGVyIiwicGFyZW50VmFsdWVUeXBlIiwiY2hpbGRWYWx1ZVR5cGUiLCJpc0Z1bmN0aW9uT3ZlclVuZGVmaW5lZCIsImNoZWNrRnVuY3Rpb25TaWduYXR1cmVzIiwicGFyZW50SGFzR2V0dGVyIiwiY2hpbGRIYXNHZXR0ZXIiLCJwYXJlbnRIYXNTZXR0ZXIiLCJjaGlsZEhhc1NldHRlciIsInBhcmVudFR5cGUiLCJnZXREZXNjcmlwdG9yVHlwZSIsImNoaWxkVHlwZSIsImNoZWNrRGF0YURlc2NyaXB0b3JzIiwiY2hlY2tBY2Nlc3NvckRlc2NyaXB0b3JzIiwic3VnZ2VzdGlvblRyYW5zZm9ybXMiLCJzdWdnZXN0aW9uIiwic3VwZXJLbGFzcyIsInN1cGVyRGVzY3JpcHRvciIsInN1Z2dlc3RlZEtleSIsImZpbmRQb3NzaWJsZUFsdGVybmF0aXZlcyIsImNoZWNrRGVzY3JpcHRvcnMiLCJkZWNvcmF0ZSIsImxpc3QiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiaXRlbSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiY3NzTWFwcGluZyIsInVzZVNvdXJjZU1hcCIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwiYmFzZTY0IiwiYnRvYSIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UmF3VGFnIiwib2JqZWN0VG9TdHJpbmciLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaXNEZXNjcmlwdG9yIiwiZW50cnlBcmdzIiwiaGFuZGxlRGVzY3JpcHRvciIsIk1ldGEiLCJsYXp5SW5pdGlhbGl6ZSIsIk1FVEFfS0VZIiwic2VlbkRlcHJlY2F0aW9ucyIsIkJvb2xlYW5Td2l0Y2giLCJUZW1wbGF0ZVJlbmRlcmVyIiwiZ2V0TmF0aXZlIiwic2V0VG9TdHJpbmciLCJvdmVyUmVzdCIsImlzQXJndW1lbnRzIiwiaXNCdWZmZXIiLCJpc1R5cGVkQXJyYXkiLCJiYXNlVGltZXMiLCJvcmlnaW5hbE1vZHVsZSIsImlzUGxhaW5PYmplY3QiLCJiYXNlVG9TdHJpbmciLCJFdmVudHNNaXhpbiIsIkRhdGVUaW1lSW5wdXQiLCJCb29sZWFuRWRpdG9yIiwia2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSIsInN3aXRjaGVyIiwidHJ1ZVZhbHVlIiwiZmFsc2VWYWx1ZSIsInZhbHVlQXNTdHJpbmciLCJfZ3VpIiwiZmFsbGJhY2siLCJBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnIiwid2luIiwiaW5pdGlhbFZhbHVlIiwibGlzdGVuZXIiLCJib29sU3dpdGNoIiwibGFiZWwiLCJvdmVycmlkZSIsImF1dG9iaW5kIiwiaW5pdGlhbGl6ZXIiLCJ1cGRhdGUiLCJsb2NhdGlvbiIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJ1bnF1b3RlZE9yaWdVcmwiLCJuZXdVcmwiLCJCb29sZWFuUmVuZGVyZXIiLCJpc0luaXQiLCJib29sZWFuVHJ1ZVJlbmRlclZhbHVlIiwiYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUiLCJib29sZWFuVHJ1ZVZhbHVlIiwiYm9vbGVhbkZhbHNlVmFsdWUiLCJCb29sZWFuRmlsdGVyIiwidG9UaXRsZUNhc2UiLCJ3b3JkIiwic3RyaXBIVE1MIiwidG1wIiwiX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbiIsInRyYW5zbGF0ZSIsImlzQ2xlYXJGaWx0ZXIiLCJpc1Jlc2V0QnV0dG9uIiwiaXNBcHBseUJ1dHRvbiIsInJlc2V0IiwiYXBwbHlGaWx0ZXJQYW5lbCIsImZpbHRlclR5cGUiLCJmaWx0ZXJUZXh0QXNTdHJpbmciLCJOdW1iZXJFZGl0b3IiLCJzdGFydFZhbHVlIiwiQmFzaXMiLCJfb25OdW1iZXJJbnB1dEludmFsaWQiLCJjYXN0ZWQiLCJyZXRWYWx1ZSIsIl9tYXNrZWQiLCJpc05hdmlnYXRpb25LZXkiLCJUZXh0RWRpdG9yIiwiX29uVGV4dElucHV0SW52YWxpZCIsImFzc2lnbkluV2l0aCIsImJhc2VWYWx1ZXMiLCJhdHRlbXB0IiwiY3JlYXRlQXNzaWduZXIiLCJjb3B5T2JqZWN0Iiwia2V5c0luIiwiaXNOZXciLCJjdXN0b21pemVyIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VJc05hdGl2ZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJpc01hc2tlZCIsInRvU291cmNlIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJjb3JlSnNEYXRhIiwic291cmNlcyIsImFzc2lnbmVyIiwibmF0aXZlTWF4Iiwib3RoZXJBcmdzIiwic2hvcnRPdXQiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJiYXNlS2V5c0luIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJiYXNlSXNBcmd1bWVudHMiLCJhcmdzVGFnIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwic3R1YkZhbHNlIiwibm9kZUlzVHlwZWRBcnJheSIsIm5vZGVVdGlsIiwiYmFzZVVuYXJ5IiwiYmFzZUlzVHlwZWRBcnJheSIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZVByb2Nlc3MiLCJ0eXBlcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJvYmplY3RDdG9yU3RyaW5nIiwiZ2V0UHJvdG90eXBlIiwic3RyaW5nRXNjYXBlcyIsImJhc2VLZXlzIiwibmF0aXZlS2V5cyIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsImVzY2FwZUh0bWxDaGFyIiwiaHRtbEVzY2FwZXMiLCJiYXNlUHJvcGVydHlPZiIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImlzU3ltYm9sIiwic3ltYm9sVGFnIiwiSW1hZ2VSZW5kZXJlciIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImltYWdlTGlzdCIsIkRhdGVUaW1lRmlsdGVyIiwiVE9LRU5TIiwiVE9LRU5fRVFVQUwiLCJUT0tFTl9OT1RfRVFVQUwiLCJUT0tFTl9MRVNTIiwiVE9LRU5fR1JFQVRFUiIsIlRPS0VOX1JBTkdFIiwiVE9LRU5fQU5EIiwiVE9LRU5fT1IiLCJDb25kaXRpb25QYW5lbCIsIndpdGhFdmVudHNNaXhpbiIsIl9maWx0ZXJUaW1lSW5wdXQiLCJfZmlsdGVyVG9EYXRlVGltZUlucHV0IiwiX2ZpbHRlck9wdGlvbnMiLCJfZGVmYXVsdE9wdGlvbiIsIm9wdGlvbnNUcmFuc2xhdGlvbnMiLCJndWkiLCJmaWx0ZXJPcHRpb25zIiwic2VsZWN0RWwiLCJmaWx0ZXJJbnB1dCIsImZpbHRlclRvSW5wdXQiLCJmaWx0ZXJEYXRlVG8iLCJPTl9DT05ESVRJT05fQ0hBTkdFRCIsInJlYWRvbmx5IiwiZmlsdGVyVG8iLCJKb2luQ29uZGl0aW9uUGFuZWwiLCJfZmlyc3RDb25kaXRpb25QYW5lbCIsIl9zZWNvbmRDb25kaXRpb25QYW5lbCIsIl9vcGVyYXRvclBhbmVsIiwiX3BhcmFtcyIsImlkT25lIiwiaWRUd28iLCJzdXBwcmVzc0FuZE9yQ29uZGl0aW9uIiwic2Vjb25kQ29uZGl0aW9uR3VpIiwib3BlcmF0b3JQYW5lbEd1aSIsIk9OX0pPSU5fQ09ORElUSU9OX0NIQU5HRUQiLCJjb25kaXRpb24xIiwiY29uZGl0aW9uMiIsIm9wZXJhdG9yIiwiX0pvaW5Db25kaXRpb25QYW5lbCIsIl9zdGF0ZSIsIl9kb2VzRmlsdGVyUGFzc09wdGlvbnMiLCJpblJhbmdlSW5jbHVzaXZlIiwidmFsdWVHZXR0ZXIiLCJkb2VzUGFzc0ZpcnN0Q29uZGl0aW9uIiwiZG9lc1Bhc3NTZWNvbmRDb25kaXRpb24iLCJjbG9uZSIsImRhdGVUaW1lTWFzayIsIkJCaiIsImZpcnN0Q29uZGl0aW9uQXNTdHJpbmciLCJzZWNvbmRDb25kaXRpb25Bc1N0cmluZyIsIm9wZXJhdG9yQXNTdHJpbmciLCJwYXNzZWQiLCJpc0FwcGx5QnV0dG9uQWN0aXZlIiwicmVxdWlyZWRBcmdzIiwiaGFzTmVnYXRpdmVVVENPZmZzZXQiLCJnZXREYXRlTWlsbGlzZWNvbmRzUGFydCIsImhhbmRsZXJzIiwiaXNFZGl0b3IiLCJwaWNrZXIiLCJkYXRlVGltZUZvcm1hdHRlciIsIndlZWtEYXlzU2hvcnQiLCJ3ZWVrRGF5c0xvbmciLCJtb250aHNTaG9ydCIsIm1vbnRoc0xvbmciLCJPTl9EQVRFX0NIQU5HRUQiLCJEYXRlVGltZUVkaXRvciIsIl92YWx1ZSIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkZXRhaWwiLCJpbml0Q3VzdG9tRXZlbnQiLCJFdmVudCIsImd3X2luaXQiLCJsaWNlbnNlIiwiYWdHcmlkIiwiTGljZW5zZU1hbmFnZXIiLCJzZXRMaWNlbnNlS2V5IiwiY29udGFpbmVyQ2xvbmUiLCJjbG9uZU5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJwYXJzZWRPcHRpb25zIiwiZ3dfcGFyc2VPcHRpb25zIiwiR3JpZCIsImRlZXBQYXJzZWRPcHRpb25zIiwiZ2V0RGF0YVBhdGhUZW1wbGF0ZSIsImdldERhdGFQYXRoIiwiZGVib3VuY2VEdXJhdGlvbiIsImZpbmFsT3B0aW9ucyIsImdldERvY3VtZW50Iiwib25DZWxsRWRpdGluZ1N0YXJ0ZWQiLCJvbkNlbGxFZGl0aW5nU3RvcHBlZCIsIm9uQ2VsbFZhbHVlQ2hhbmdlZCIsIm9uUm93RWRpdGluZ1N0YXJ0ZWQiLCJvblJvd1ZhbHVlQ2hhbmdlZCIsIm9uUm93RWRpdGluZ1N0b3BwZWQiLCJvbkdyaWRSZWFkeSIsIm9uRmlsdGVyQ2hhbmdlZCIsImdldFJvd0lkIiwiZ2V0Q29udGV4dE1lbnVJdGVtcyIsImdldENoYXJ0VG9vbGJhckl0ZW1zIiwicG9wdXBQYXJlbnQiLCJvblJvd0RvdWJsZUNsaWNrZWQiLCJnd19vblJvd0RvdWJsZUNsaWNrZWQiLCJvblJvd0NsaWNrZWQiLCJnd19vblJvd0NsaWNrZWQiLCJvbkNlbGxDbGlja2VkIiwiZ3dfb25DZWxsQ2xpY2tFdmVudCIsIm9uQ2VsbERvdWJsZUNsaWNrZWQiLCJvblNlbGVjdGlvbkNoYW5nZWQiLCJnd19vblNlbGVjdGlvbkNoYW5nZWQiLCJvblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCIsImd3X29uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkIiwiY29tcG9uZW50cyIsIkFnR3JpZENvbXBvbmVudHMiLCJIVE1MVG9vbHRpcCIsIlN1Z2dlc3Rpb25FZGl0b3IiLCJuYXZpZ2F0ZVRvTmV4dENlbGwiLCJ0cmVlRGF0YSIsImdldERhdGFQYXRoVGVtcGxhdGVDb21wbGllZCIsImd3X2dldENvbnRleHRNZW51IiwiYnVpbGRDb250ZXh0TWVudUFjdGlvbiIsInBhcnNlTWVudSIsIm1lbnUiLCJjb250ZXh0TWVudSIsIkNFTExfQ0xJQ0tJTkdfRVZFTlRTX01BUCIsImNlbGxDbGlja2VkIiwiY2VsbERvdWJsZUNsaWNrZWQiLCJDRUxMX0VESVRJTkdfRVZFTlRTX01BUCIsImNlbGxFZGl0aW5nU3RhcnRlZCIsImNlbGxFZGl0aW5nU3RvcHBlZCIsImNlbGxWYWx1ZUNoYW5nZWQiLCJST1dfRURJVElOR19FVkVOVFNfTUFQIiwicm93RWRpdGluZ1N0YXJ0ZWQiLCJyb3dFZGl0aW5nU3RvcHBlZCIsInJvd1ZhbHVlQ2hhbmdlZCIsImd3X29uQ2VsbEVkaXRpbmdFdmVudCIsImd3X29uUm93RWRpdGluZ0V2ZW50IiwiZ3dfb25SZWFkeUV2ZW50IiwiX2UiLCJzdGF0ZURlYm91bmNlIiwiY2hhbmdlRXZlbnQiLCJrZXlkb3duRXZlbnQiLCJrYyIsImFrIiwiYWx0S2V5Iiwic2siLCJjayIsImd3X29uU3RhdGVDaGFuZ2VkIiwiZ3dfb25LZXlkb3duIiwiZ3dfb25GaWx0ZXJDaGFuZ2VkIiwic3JjSW5kZXgiLCJJRV9QUk9UTyIsInByb2Nlc3MiLCJiaW5kaW5nIiwic3JjVmFsdWUiLCJjaHIiLCJlR3VpIiwiaXNIZWFkZXIiLCJpc0dyb3VwZWRIZWFkZXIiLCJ0aGVtZSIsImVHcmlkRGl2IiwiZW5kc1dpdGgiLCJ0b29sdGlwRmllbGQiLCJwYXNzZWRQYXJhbXMiLCJ0ZXh0UGF0dGVybiIsInRleHRSZXF1aXJlZCIsInRleHRUaXRsZSIsImRlYm91bmNlV2FpdE1zIiwiX2ZvY3VzQWZ0ZXJBdHRhY2hlZCIsImNlbGxTdGFydGVkRWRpdCIsIl9oaWdobGlnaHRBbGxPbkZvY3VzIiwiX29uQ2hhbmdlIiwiX3JlbmRlckl0ZW1UZW1wbGF0ZSIsIml0ZW1UZW1wbGF0ZSIsIl9yZW5kZXJHcm91cFRlbXBsYXRlIiwiZ3JvdXBUZW1wbGF0ZSIsIl9hdXRvY29tcGxldGUiLCJwcmV2ZW50U3VibWl0IiwiZmV0Y2giLCJfb25BdXRvY29tcGxldGVGZXRjaCIsIm9uU2VsZWN0IiwiX29uQXV0b2NvbXBsZXRlU2VsZWN0IiwicmVuZGVyR3JvdXAiLCJfb25BdXRvY29tcGxldGVSZW5kZXJHcm91cCIsInJlbmRlciIsIl9vbkF1dG9jb21wbGV0ZVJlbmRlckl0ZW0iLCJjdXN0b21pemUiLCJfb25BdXRvY29tcGxldGVDdXN0b21pemUiLCJlbXB0eU1zZyIsImVtcHR5TWVzc2FnZSIsIm1pbkxlbmd0aCIsInNob3dPbkZvY3VzIiwiZ3JpZENvcmUiLCJmb2N1c0luIiwiYWxsb3dDdXN0b21WYWx1ZXMiLCJfdmFsaWRhdGVJbnB1dCIsIl9sYXN0RmV0Y2hlZERhdGEiLCJmaWx0ZXJlZEl0ZW1zIiwidGV4dCIsInN1cHByZXNzU3VnZ2VzdGlvbk9uSW52YWxpZElucHV0IiwiZUdyaWRDZWxsIiwiZmllbGQiLCJjdXJyZW50VmFsdWUiLCJncm91cE5hbWUiLCJpbnB1dFJlY3QiLCJtYXhIZWlnaHQiLCJjaGVja1ZhbGlkaXR5IiwiZ3dfc2V0U3RhdGUiLCJzZXRDb2x1bW5Hcm91cFN0YXRlIiwiZ3JvdXBzIiwic2V0RmlsdGVyTW9kZWwiLCJmaWx0ZXJzIiwiZ3dfZ2V0U3RhdGUiLCJnZXRDb2x1bW5Hcm91cFN0YXRlIiwiZ2V0RmlsdGVyTW9kZWwiLCJnd19zZXRTaWRlQmFyVmlzaWJsZSIsInNldFNpZGVCYXJWaXNpYmxlIiwiZ3dfb3BlblRvb2xwYW5lbCIsInRvb2xwYW5lbElkIiwib3BlblRvb2xQYW5lbCIsImd3X2Nsb3NlVG9vbHBhbmVsIiwiY2xvc2VUb29sUGFuZWwiLCJnd19zZXRGdW5jdGlvbnNSZWFkT25seSIsInNldEZ1bmN0aW9uc1JlYWRPbmx5IiwiZ3dfc2V0U3RhdHVzYmFyQ29tcG9uZW50VmlzaWJpbGl0eSIsImdldFN0YXR1c1BhbmVsIiwic2V0VmlzaWJsZSIsImd3X3Nob3dMb2FkaW5nT3ZlcmxheSIsInNob3dMb2FkaW5nT3ZlcmxheSIsImd3X3Nob3dOb1Jvd3NPdmVybGF5Iiwic2hvd05vUm93c092ZXJsYXkiLCJnd19oaWRlT3ZlcmxheSIsImhpZGVPdmVybGF5IiwiZ3dfdXBkYXRlQ29udGV4dCIsImd3X3NldFN0eWxlIiwicnVsZXMiLCJqc3MiLCJmb3JEb2N1bWVudCIsImd3X3JlbW92ZVN0eWxlIiwiYWRqU2VsQXR0clJlZ2V4IiwiZG91YmxlQ29sb25Qc2V1ZG9FbFJlZ2V4Iiwic2luZ2xlQ29sb25Qc2V1ZG9FbFJlZ2V4Iiwic2luZ2xlQ29sb25Gb3JQc2V1ZG9FbGVtZW50cyIsImdldFNlbGVjdG9yc0FuZFJ1bGVzIiwicmVzdWx0cyIsInNlbGVjdG9yVGV4dCIsInRvRG91YmxlQ29sb25Qc2V1ZG9FbGVtZW50cyIsImdldFJ1bGVzIiwic3dhcEFkalNlbEF0dHIiLCJzd2FwUHNldWRvRWxTeW50YXgiLCJhZGRSdWxlIiwicHNldWRvRWxlbWVudFJ1bGUiLCJhZGRQc2V1ZG9FbGVtZW50UnVsZSIsImFkZFJ1bGVUb1NoZWV0IiwiZG91YmxlQ29sb25TZWxlY3RvciIsInNpbmdsZUNvbG9uU2VsZWN0b3IiLCJ0b1NpbmdsZUNvbG9uUHNldWRvRWxlbWVudHMiLCJzdWJtYXRjaDEiLCJzdWJtYXRjaDIiLCJzdWJtYXRjaDMiLCJyZW1vdmVSdWxlIiwiZGVsZXRlUnVsZSIsImV4dGVuZCIsImRlc3QiLCJzcmMiLCJhZ2dyZWdhdGVTdHlsZXMiLCJhZ2dyZWdhdGUiLCJkZWNsYXJlZFByb3BlcnRpZXMiLCJkZWNsYXJlZCIsInRvQ2FtZWxDYXNlIiwic3dhcCIsImxhc3RJbmRleCIsInNldFN0eWxlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJpbXBvcnRhbnRJbmRleCIsInNldFByb3BlcnR5Iiwic3VibWF0Y2giLCJ0cmFuc2Zvcm1DYW1lbENhc2VkUHJvcGVydHlOYW1lcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJ1bkNhbWVsQ2FzZSIsIkpzcyIsInNoZWV0cyIsImRlZmF1bHRTaGVldCIsImdldEFsbCIsIl9jcmVhdGVTaGVldCIsIl9yZW1vdmVTaGVldCIsInN0eWxlTm9kZSIsInJlbCIsIm93bmVyTm9kZSIsImNzcyIsInByb3RvY29sIiwiaG9zdCIsInBhdGhuYW1lIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsIiQxIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLFNBQVNBLGNBQVQsR0FBMEI7QUFDL0IsU0FBTyxPQUFPQyxJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixHQUFxQ0MsUUFBNUM7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDTyxTQUFTQyxZQUFULEdBQXdCO0FBQzdCLFNBQU8sT0FBT0MsSUFBUCxLQUFnQixX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QUFzSCxxQ0FBcUMsb0NBQW9DLGtDQUFrQyxrQ0FBa0MsS0FBSyxxQkFBcUIseUJBQXlCLHVCQUF1QiwyQkFBMkIscUNBQXFDLDZCQUE2QiwyQkFBMkIsb0JBQW9CLHdDQUF3QyxnQ0FBZ0MsS0FBSywyQkFBMkIsOEJBQThCLHNEQUFzRCxzREFBc0QsS0FBSywwQkFBMEIsZ0NBQWdDLDBDQUEwQywwQ0FBMEMsbUJBQW1CLEtBQUssNkNBQTZDLCtCQUErQixLQUFLLDBCQUEwQixtQkFBbUIsS0FBSyxLOzs7Ozs7O0FDQzUvRixjQUFjLG1CQUFPLENBQUMsR0FBMEU7O0FBRWhHLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsRUFBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFLEU7Ozs7OztBQ3JCZixvREFBb0Qsd0JBQXdCLHFGQUFxRix5QkFBeUIsbURBQW1ELHFCQUFxQixvQkFBb0IsS0FBSyx5S0FBeUsseURBQXlELEtBQUssMkhBQTJILDREQUE0RCxLQUFLLHVCQUF1Qix5REFBeUQsb0JBQW9CLHFDQUFxQyxxQ0FBcUMscUZBQXFGLG9CQUFvQix5QkFBeUIsZ0NBQWdDLGlDQUFpQyxxQkFBcUIsMERBQTBELDBEQUEwRCxLQUFLLDRCQUE0Qiw0REFBNEQsb0VBQW9FLEtBQUsseUNBQXlDLHVCQUF1Qix1QkFBdUIsd0JBQXdCLEtBQUssOENBQThDLHNEQUFzRCxLQUFLLHdDQUF3QyxvQkFBb0Isc0JBQXNCLEtBQUssOENBQThDLDJFQUEyRSxLQUFLLGlEQUFpRCw4R0FBOEcsS0FBSyw4QkFBOEIsdUJBQXVCLEtBQUssbUNBQW1DLGlEQUFpRCxpREFBaUQsS0FBSyxxQ0FBcUMsaURBQWlELGlEQUFpRCxLQUFLLEsiLCJmaWxlIjoiYmJqLWdyaWQtd2lkZ2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDQwKTtcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEdldCBkb2N1bWVudFxyXG4gKlxyXG4gKiBHZXQgdGhlIGRvY3VtZW50IGluc3RhbmNlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBCQmogZW52XHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gRG9jdW1lbnQgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXREb2N1bWVudCgpIHtcclxuICByZXR1cm4gdHlwZW9mICRkb2MgIT09ICd1bmRlZmluZWQnID8gJGRvYyA6IGRvY3VtZW50XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgd2luZG93XHJcbiAqXHJcbiAqIEdldCB0aGUgd2luZG93IGluc3RhbmNlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBCQmogZW52XHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gV2luZG93IGluc3RhbmNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0V2luZG93KCkge1xyXG4gIHJldHVybiB0eXBlb2YgJHduZCAhPT0gJ3VuZGVmaW5lZCcgPyAkd25kIDogd2luZG93XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFc2NhcGUgVmFsdWVcclxuICpcclxuICogQ2hhbmdlIG51bGwgYW5kIHVuZGVmaW5lZCB0byBlbXB0eSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVzY2FwZWQgdmFsdWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19lc2NhcGUodmFsdWUpIHtcclxuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogJydcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIHV1aWRcclxuICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvY3JlYXRlLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfdXVpZCgpIHtcclxuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XHJcbiAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCxcclxuICAgICAgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OFxyXG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBHcmlkXHJcbiAqXHJcbiAqIFJldHJpZXZlIHRoZSBncmlkIGluc3RhbmNlIGZyb20gYHdpbmRvdy5CQmpHcmlkRXhXaWRnZXRgIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdHxudWxsfSBUaGUgZ3JpZCdzIGluc3RhbmNlIG9mciBudWxsXHJcbiAqIEB0aHJvd3MgVHlwZUVycm9yIHdoZW4gdGhlIGdyaWQgaW5zdGFuY2UgaXMgbm90IGZvdW5kXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0R3JpZChpZCkge1xyXG4gIHdpbmRvdy5CQmpHcmlkRXhXaWRnZXQgPSB3aW5kb3cuQkJqR3JpZEV4V2lkZ2V0IHx8IHt9XHJcbiAgY29uc3QgZ3JpZCA9IHdpbmRvdy5CQmpHcmlkRXhXaWRnZXRbaWRdIHx8IG51bGxcclxuXHJcbiAgaWYgKCFncmlkKSB7XHJcbiAgICBjb25zdCByZWdpc3RlcmVkR3JpZHMgPSBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyh3aW5kb3cuQkJqR3JpZEV4V2lkZ2V0KSlcclxuICAgIC8vZ2V0RnVuY0FyZ3MoZnVuYykuZm9yRWFjaCgoa2V5LCBpKSA9PiBhcmdzT2JqW2tleV0gPSBhcmdzW2ldKTtcclxuXHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICBgXFxuXFxuW0dyaWQgTm90IEZvdW5kXSBUaGUgbWV0aG9kIGFza2VkIGZvciBub24tZXhpc3RlbnQgZ3JpZCBpbnN0YW5jZS5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5SZXF1aXJlZCBHcmlkIElkIDogJHtpZH0gICBcclxuUmVnaXN0ZXJlZCBHcmlkcyA6ICR7cmVnaXN0ZXJlZEdyaWRzfVxyXG5gXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICByZXR1cm4gZ3JpZFxyXG59XHJcblxyXG4vKipcclxuICogQWRkIEdyaWRcclxuICpcclxuICogU3RvcmUgYSBuZXcgZ3JpZCBpbnN0YW5jZSBieSBpbiB0aGUgYHdpbmRvdy5CQmpHcmlkRXhXaWRnZXRgIGFycmF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICBUaGUgZ3JpZCdzIG9wdGlvbnNcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSBTdG9yZWQgZ3JpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZEdyaWQoaWQsIG9wdGlvbnMpIHtcclxuICB3aW5kb3cuQkJqR3JpZEV4V2lkZ2V0ID0gd2luZG93LkJCakdyaWRFeFdpZGdldCB8fCB7fVxyXG4gIHdpbmRvdy5CQmpHcmlkRXhXaWRnZXRbaWRdID0gb3B0aW9uc1xyXG5cclxuICByZXR1cm4gZ3dfZ2V0R3JpZChpZClcclxufVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXREb2N1bWVudCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcblxyXG4vKiogaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvamF2YXNjcmlwdC1kZWJvdW5jZS1mdW5jdGlvbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XHJcbiAgdmFyIHRpbWVvdXRcclxuICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IHRoaXMsXHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNcclxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aW1lb3V0ID0gbnVsbFxyXG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xyXG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXRcclxuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpXHJcbiAgICBpZiAoY2FsbE5vdykge1xyXG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2VuZCBhbiBldmVudCB0byBCQmogc2lkZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBjb250ZXh0IHRoZSBncmlkJ3MgY29udGV4dFxyXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgdGhlIGV2ZW50IHBheWxvYWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50SWQgdGhlIGV2ZW50J3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZW5kRXZlbnQoY29udGV4dCwgcGF5bG9hZCA9IHt9LCBldmVudElkID0gW10pIHtcclxuICBjb25zdCByZWdpc3RlcmVkSW50ZXJlc3RzID0gY29udGV4dC5pbnRlcmVzdHMgfHwgW11cclxuXHJcbiAgaWYgKHJlZ2lzdGVyZWRJbnRlcmVzdHMuaW5jbHVkZXMoZXZlbnRJZCkpIHtcclxuICAgIGNvbnN0IGRpdiA9IGd3X2dldERvY3VtZW50KCkuZ2V0RWxlbWVudEJ5SWQoYCR7Y29udGV4dC5pZH1gKVxyXG5cclxuICAgIC8vIGJ1aSBvciB3ZWJhcHBcclxuICAgIGlmIChbNSwgNl0uaW5kZXhPZihjb250ZXh0LnBsYXRmb3JtKSA+IC0xKSB7XHJcbiAgICAgIGNvbnN0IGh0bWx2aWV3SWQgPSBgaHRtbHZpZXctJHtjb250ZXh0LmlkfWBcclxuICAgICAgY29uc3QgY29udGFpbmVyID0gZ3dfZ2V0RG9jdW1lbnQoKS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGh0bWx2aWV3SWQpWzBdXHJcbiAgICAgIGlmICh0eXBlb2YgY29udGFpbmVyLmJhc2lzRGlzcGF0Y2hDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnRhaW5lci5iYXNpc0Rpc3BhdGNoQ3VzdG9tRXZlbnQoZGl2LCBwYXlsb2FkKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHdpbmRvdy5iYXNpc0Rpc3BhdGNoQ3VzdG9tRXZlbnQoZGl2LCBwYXlsb2FkKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3aW5kb3cuYmFzaXNEaXNwYXRjaEN1c3RvbUV2ZW50KGRpdiwgcGF5bG9hZClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBCQmpHcmlkRXhXaWRnZXRSb3dcclxuICpcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGFyZW50S2V5XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGlsZEluZGV4XHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2VsZWN0ZWRcclxuICovXHJcblxyXG4vKipcclxuICogUGFyc2UgYSBub2RlIGFzIEJCakdyaWRFeFdpZGdldFJvd1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBhZyBncmlkIG5vZGVcclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgIGFnIGdyaWQgY29udGV4dFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QkJqR3JpZEV4V2lkZ2V0Um93fEJvb2xlYW59IG9iamVjdCBmb3JtYXR0ZWQgYXMgQkJqR3JpZEV4V2lkZ2V0Um93LlxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIGlmIHRoZSBub2RlIGlzIGZvciBncm91cCBub2RlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcGFyc2VOb2RlKG5vZGUsIGNvbnRleHQpIHtcclxuICBpZiAodHJ1ZSA9PT0gbm9kZS5ncm91cCkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfSAvLyB3ZSBkbyBub3QgbWFuYWdlIGdyb3Vwc1xyXG5cclxuICBjb25zdCBnZXRSb3dOb2RlSWQgPSBub2RlLnJvd1Bpbm5lZCA/ICdfX1JPV19JTkRFWCcgOiBjb250ZXh0LmdldFJvd05vZGVJZFxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgaTpcclxuICAgICAgY29udGV4dC5oYXNPd25Qcm9wZXJ0eSgnZ2V0Um93Tm9kZUlkJykgJiYgbm9kZS5kYXRhW2dldFJvd05vZGVJZF1cclxuICAgICAgICA/IG5vZGUuZGF0YVtnZXRSb3dOb2RlSWRdXHJcbiAgICAgICAgOiBub2RlLmlkLCAvLyBpZFxyXG4gICAgeDogbm9kZS5yb3dJbmRleCwgLy8gaW5kZXhcclxuICAgIHA6XHJcbiAgICAgIG5vZGUuaGFzT3duUHJvcGVydHkoJ3BhcmVudCcpICYmIG5vZGUucGFyZW50Lmhhc093blByb3BlcnR5KCdrZXknKVxyXG4gICAgICAgID8gbm9kZS5wYXJlbnQua2V5XHJcbiAgICAgICAgOiAnJywgLy8gcGFyZW50IGtleVxyXG4gICAgYzogbm9kZS5yb3dQaW5uZWQgPyAtMSA6IG5vZGUuY2hpbGRJbmRleCwgLy9jaGlsZEluZGV4XHJcbiAgICBzOiBCb29sZWFuKG5vZGUuc2VsZWN0ZWQpLCAvLyBzZWxlY3RlZFxyXG4gICAgLy8gY2xpZW50IHJvd1xyXG4gICAgY3I6XHJcbiAgICAgIGNvbnRleHQuaGFzT3duUHJvcGVydHkoJ2luY2x1ZGVDbGllbnRSb3dEYXRhJykgJiZcclxuICAgICAgY29udGV4dFsnaW5jbHVkZUNsaWVudFJvd0RhdGEnXSA9PT0gdHJ1ZVxyXG4gICAgICAgID8gbm9kZS5kYXRhXHJcbiAgICAgICAgOiBudWxsLFxyXG4gICAgcHA6IG5vZGUucm93UGlubmVkLCAvLyBwaW4gcG9zaXRpb25cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBub2RlIGZyb20gZXZlbnRcclxuICpcclxuICogUGFyc2Ugbm9kZSBpbiB0aGUgcGFTc2VkIGV2ZW50IGFzIEJCakdyaWRFeFdpZGdldFJvd1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QkJqR3JpZEV4V2lkZ2V0Um93fVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3BhcnNlTm9kZUZyb21FdmVudChlKSB7XHJcbiAgcmV0dXJuIGd3X3BhcnNlTm9kZShlLm5vZGUsIGUuY29udGV4dClcclxufVxyXG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8vIHNlbGVjdGlvbiBjb25zdGFudHNcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX1JPV19TRUxFQ1QgPSA2OVxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUk9XX0NMSUNLID0gNTAxMVxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUk9XX0RPVUJMRV9DTElDSyA9IDUyXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9DRUxMX0NMSUNLID0gNTAwMVxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfQ0VMTF9ET1VCTEVfQ0xJQ0sgPSA1MDAyXHJcblxyXG4vLyBlZGl0aW5nIGNvbnN0YW50c1xyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUQVJURUQgPSA1MDAzXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9DRUxMX0VESVRJTkdfU1RPUFBFRCA9IDUwMDRcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX0NFTExfVkFMVUVfQ0hBTkdFRCA9IDUwMDVcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX1JPV19FRElUSU5HX1NUQVJURUQgPSA1MDA2XHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9ST1dfRURJVElOR19TVE9QUEVEID0gNTAwN1xyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUk9XX1ZBTFVFX0NIQU5HRUQgPSA1MDEyXHJcblxyXG4vLyBzdGF0ZSBjb25zdGFudHNcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX0dSSURfU1RBVEVfQ0hBTkdFID0gNTAwOFxyXG5cclxuLy8gcmFuZ2Ugc2VsZWN0aW9uXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9SQU5HRV9TRUxFQ1RJT05fQ0hBTkdFRCA9IDUwMDlcclxuXHJcbi8vIGtleWJvYXJkIGV2ZW50c1xyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfS0VZUFJFU1MgPSA1MDEwXHJcblxyXG4vLyBmaWx0ZXJzXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9GSUxURVJfQ0hBTkdFRCA9IDUwMTNcclxuXHJcbi8vIHJlYWR5XHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9SRUFEWSA9IDUwMTRcclxuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBbUmVjdXJzaXZlbHkgcGFyc2VzIGEgc3RyaW5naWZpZWQgSlNPTl1cbiAqIEBwYXJhbSAge1t0eXBlXX0ganNvblN0cmluZyBbc3RyaW5naWZpZWQganNvbiB0byBwYXJzZV1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICBbbm9ybWFsaXplZCBKYXZhc2NyaXB0IG9iamVjdF1cbiAqL1xuZnVuY3Rpb24gZGVlcFBhcnNlSnNvbihqc29uU3RyaW5nKSB7XG4gIC8vIGlmIG5vdCBzdHJpbmdpZmllZCBqc29uIHJhdGhlciBhIHNpbXBsZSBzdHJpbmcgdmFsdWUgdGhlbiBKU09OLnBhcnNlIHdpbGwgdGhyb3cgZXJyb3JcbiAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIHJlY3Vyc2lvblxuICBpZiAodHlwZW9mIGpzb25TdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkZWVwUGFyc2VKc29uKEpTT04ucGFyc2UoanNvblN0cmluZykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGpzb25TdHJpbmc7XG4gICAgfVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoanNvblN0cmluZykpIHtcbiAgICAvLyBpZiBhbiBhcnJheSBpcyByZWNlaXZlZCwgbWFwIG92ZXIgdGhlIGFycmF5IGFuZCBkZWVwUGFyc2UgZWFjaCB2YWx1ZVxuICAgIHJldHVybiBqc29uU3RyaW5nLm1hcCh2YWwgPT4gZGVlcFBhcnNlSnNvbih2YWwpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ29iamVjdCcgJiYganNvblN0cmluZyAhPT0gbnVsbCkge1xuICAgIC8vIGlmIGFuIG9iamVjdCBpcyByZWNlaXZlZCB0aGVuIGRlZXBQYXJzZSBlYWNoIGVsZW1lbnQgaW4gdGhlIG9iamVjdFxuICAgIC8vIHR5cGVvZiBudWxsIHJldHVybnMgJ29iamVjdCcgdG9vLCBzbyB3ZSBoYXZlIHRvIGVsaW1pbmF0ZSB0aGF0XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGpzb25TdHJpbmcpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgIG9ialtrZXldID0gZGVlcFBhcnNlSnNvbihqc29uU3RyaW5nW2tleV0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlIHJldHVybiB3aGF0ZXZlciB3YXMgcmVjZWl2ZWRcbiAgICByZXR1cm4ganNvblN0cmluZztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVlcFBhcnNlSnNvbiB9O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QEJhc2lzLkFnR3JpZENvbXBvbmVudHMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X3BhcnNlTm9kZSB9IGZyb20gJ2V2ZW50cy91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X2V4ZWN1dGVFeHByZXNzaW9uIH0gZnJvbSAnLi4vZXhwcmVzc2lvbidcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRRdWlja0ZpbHRlcihpZCwgZmlsdGVyKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0UXVpY2tGaWx0ZXIoZmlsdGVyKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZXhwYW5kQWxsKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuZXhwYW5kQWxsKClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2NvbGxhcHNlQWxsKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuY29sbGFwc2VBbGwoKVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIHRoZSByb3cgaW5kZXggaXMgdmlzaWJsZSBieSB2ZXJ0aWNhbGx5IHNjcm9sbGluZyB0aGUgZ3JpZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbmRleCB0aGUgcm93IGluZGV4IG9yIGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24geyd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbScsIHVuZGVmaW5lZC9udWxsfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Vuc3VyZUluZGV4VmlzaWJsZShpZCwgaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgY29uc3QgYXBpID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGlcclxuICBjb25zdCBub2RlID0gYXBpLmdldFJvd05vZGUoaW5kZXgpXHJcblxyXG4gIGlmIChub2RlKSB7XHJcbiAgICBhcGkuZW5zdXJlTm9kZVZpc2libGUobm9kZSwgcG9zaXRpb24pXHJcbiAgfSBlbHNlIHtcclxuICAgIGFwaS5lbnN1cmVJbmRleFZpc2libGUoTnVtYmVyKGluZGV4KSwgcG9zaXRpb24pXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfbmF2aWdhdGVUb05leHRSb3coaWQsIHBhcmFtcykge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgbGV0IHByZXZpb3VzQ2VsbCA9IHBhcmFtcy5wcmV2aW91c0NlbGxQb3NpdGlvblxyXG4gIGxldCBzdWdnZXN0ZWROZXh0Q2VsbCA9IHBhcmFtcy5uZXh0Q2VsbFBvc2l0aW9uXHJcblxyXG4gIGNvbnN0IEtFWV9VUCA9ICdBcnJvd1VwJ1xyXG4gIGNvbnN0IEtFWV9ET1dOID0gJ0Fycm93RG93bidcclxuICBjb25zdCBLRVlfTEVGVCA9ICdBcnJvd0xlZnQnXHJcbiAgY29uc3QgS0VZX1JJR0hUID0gJ0Fycm93UmlnaHQnXHJcblxyXG4gIHN3aXRjaCAocGFyYW1zLmtleSkge1xyXG4gICAgY2FzZSBLRVlfRE9XTjpcclxuICAgICAgLy8gc2V0IHNlbGVjdGVkIGNlbGwgb24gY3VycmVudCBjZWxsICsgMVxyXG4gICAgICBpZiAoc3VnZ2VzdGVkTmV4dENlbGwgJiYgIXN1Z2dlc3RlZE5leHRDZWxsLnJvd1Bpbm5lZCkge1xyXG4gICAgICAgIGlmIChwcmV2aW91c0NlbGwucm93UGlubmVkKSB7XHJcbiAgICAgICAgICBjb25zdCByb3cgPSBvcHRpb25zLmFwaS5nZXREaXNwbGF5ZWRSb3dBdEluZGV4KFxyXG4gICAgICAgICAgICBvcHRpb25zLmFwaS5nZXRGaXJzdERpc3BsYXllZFJvdygpXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICBpZiAocm93KSB7XHJcbiAgICAgICAgICAgIHJvdy5zZXRTZWxlY3RlZCh0cnVlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvcHRpb25zLmFwaS5mb3JFYWNoTm9kZShub2RlID0+IHtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2VsbC5yb3dJbmRleCArIDEgPT09IG5vZGUucm93SW5kZXgpIHtcclxuICAgICAgICAgICAgICBub2RlLnNldFNlbGVjdGVkKHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3VnZ2VzdGVkTmV4dENlbGxcclxuICAgIGNhc2UgS0VZX1VQOlxyXG4gICAgICAvLyBzZXQgc2VsZWN0ZWQgY2VsbCBvbiBjdXJyZW50IGNlbGwgLSAxXHJcbiAgICAgIGlmIChzdWdnZXN0ZWROZXh0Q2VsbCAmJiAhc3VnZ2VzdGVkTmV4dENlbGwucm93UGlubmVkKSB7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzQ2VsbC5yb3dQaW5uZWQpIHtcclxuICAgICAgICAgIGNvbnN0IHJvdyA9IG9wdGlvbnMuYXBpLmdldERpc3BsYXllZFJvd0F0SW5kZXgoXHJcbiAgICAgICAgICAgIG9wdGlvbnMuYXBpLmdldExhc3REaXNwbGF5ZWRSb3coKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgaWYgKHJvdykge1xyXG4gICAgICAgICAgICByb3cuc2V0U2VsZWN0ZWQodHJ1ZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0aW9ucy5hcGkuZm9yRWFjaE5vZGUobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0NlbGwucm93SW5kZXggLSAxID09PSBub2RlLnJvd0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgbm9kZS5zZXRTZWxlY3RlZCh0cnVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc3VnZ2VzdGVkTmV4dENlbGxcclxuICAgIGNhc2UgS0VZX0xFRlQ6XHJcbiAgICBjYXNlIEtFWV9SSUdIVDpcclxuICAgICAgcmV0dXJuIHN1Z2dlc3RlZE5leHRDZWxsXHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHN1cGVyIHN0cmFuZ2Uga2V5Ym9hcmQnKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByb3cgYmFzZWQgb24gYGdldFJvd05vZGVJZGAgY29uZmlnIGRlZmluZWQgaW4gdGhlIGdyaWQgY29udGV4dFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JpZCAgdGhlIGdyaWQgb2JqZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0Um93Tm9kZUlkKF9pZCwgZ3JpZCkge1xyXG4gIGNvbnN0IHJvd05vZGVJZCA9IGdyaWQuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0LmdldFJvd05vZGVJZFxyXG4gIHJldHVybiBncmlkLmRhdGFbcm93Tm9kZUlkXVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBncmlkJ3MgZGF0YSBzZXRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IGpzb24ganNvbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIG5ldyBkYXRhc2V0IHRvIHVwZGF0ZSB0aGUgZ3JpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFJvd0RhdGEoaWQsIGpzb24pIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG5cclxuICBvcHRpb25zLmFwaS5zZXRSb3dEYXRhKGpzb24pXHJcbiAgb3B0aW9ucy5yb3dEYXRhID0ganNvblxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBncmlkIHdpdGggYSB0cmFuc2FjdGlvbiBvYmplY3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNhY3Rpb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd191cGRhdGVSb3dEYXRhKGlkLCB0cmFuc2FjdGlvbiwgYmF0Y2hVcGRhdGUpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG5cclxuICBpZiAodHJhbnNhY3Rpb24ucmVtb3ZlLmxlbmd0aCkge1xyXG4gICAgbGV0IGl0ZW1zID0gW11cclxuXHJcbiAgICB0cmFuc2FjdGlvbi5yZW1vdmUuZm9yRWFjaChpbmRleCA9PiB7XHJcbiAgICAgIGl0ZW1zLnB1c2gob3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShpbmRleCkuZGF0YSlcclxuICAgIH0pXHJcblxyXG4gICAgdHJhbnNhY3Rpb24ucmVtb3ZlID0gaXRlbXNcclxuICB9XHJcblxyXG4gIGlmICh0cmFuc2FjdGlvbi5hZGQubGVuZ3RoKSB7XHJcbiAgICB0cmFuc2FjdGlvbi5hZGQgPSB0cmFuc2FjdGlvbi5hZGQucmV2ZXJzZSgpXHJcbiAgfVxyXG5cclxuICBpZiAoIWJhdGNoVXBkYXRlKSB7XHJcbiAgICBvcHRpb25zLmFwaS5hcHBseVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHRpb25zLmFwaS5hcHBseVRyYW5zYWN0aW9uQXN5bmModHJhbnNhY3Rpb24pXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBoZWlnaHQgb2YgYWxsIHJvd3NcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgdGhlIHJvdyBoZWlnaHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRSb3dzSGVpZ2h0KGlkLCBoZWlnaHQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcblxyXG4gIGFwaS5mb3JFYWNoTm9kZShyb3cgPT4ge1xyXG4gICAgcm93LnNldFJvd0hlaWdodChoZWlnaHQpXHJcbiAgfSlcclxuXHJcbiAgYXBpLm9uUm93SGVpZ2h0Q2hhbmdlZCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGdpdmVuIHJvdyBoZWlnaHRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaW5kZXggdGhlIHJvdyBpbmRleCBvciBrZXlcclxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCB0aGUgbmV3IGhlaWdodFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFJvd0hlaWdodChpZCwgaW5kZXgsIGhlaWdodCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgYXBpID0gb3B0aW9ucy5hcGlcclxuICBjb25zdCByb3cgPSBhcGkuZ2V0Um93Tm9kZShpbmRleCkgfHwgYXBpLmdldERpc3BsYXllZFJvd0F0SW5kZXgoaW5kZXgpXHJcblxyXG4gIGlmIChyb3cpIHtcclxuICAgIHJvdy5zZXRSb3dIZWlnaHQoaGVpZ2h0KVxyXG4gICAgb3B0aW9ucy5hcGkub25Sb3dIZWlnaHRDaGFuZ2VkKClcclxuICB9IGVsc2Uge1xyXG4gICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gc2V0IGhlaWdodCBmb3Igcm93ICR7aW5kZXh9LiBSb3cgY2Fubm90IGJlIGZvdW5kYClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNldCB0aGUgcm93IGhlaWdodFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVzZXRSb3dIZWlnaHRzKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkucmVzZXRSb3dIZWlnaHRzKClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbGVjdCByb3cgb3IgbW9yZSBiYXNlZCBvbiB0aGUgcm93IGlkIG9yIGluZGV4XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJvd3MgYW4gYXJyYXkgb2Ygcm93IGtleXMgYW5kIGluZGV4ZXMgdG8gc2VsZWN0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0U2VsZWN0ZWRSb3dzKGlkLCByb3dzKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBhcGkgPSBvcHRpb25zLmFwaVxyXG5cclxuICBhcGkuZm9yRWFjaE5vZGVBZnRlckZpbHRlckFuZFNvcnQobm9kZSA9PiB7XHJcbiAgICBpZiAoXHJcbiAgICAgIHJvd3MuaW5kZXhPZihTdHJpbmcobm9kZS5yb3dJbmRleCkpID4gLTEgfHxcclxuICAgICAgcm93cy5pbmRleE9mKFN0cmluZyhub2RlLmlkKSkgPiAtMVxyXG4gICAgKSB7XHJcbiAgICAgIG5vZGUuc2V0U2VsZWN0ZWQodHJ1ZSlcclxuICAgICAgbm9kZS5leHBhbmRlZCA9IHRydWVcclxuICAgIH1cclxuICB9KVxyXG5cclxuICBhcGkub25Hcm91cEV4cGFuZGVkT3JDb2xsYXBzZWQoKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2VsZWN0QWxsKGlkLCBmaWx0ZXJlZCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIGlmICgxID09PSBmaWx0ZXJlZCkge1xyXG4gICAgb3B0aW9ucy5hcGkuc2VsZWN0QWxsRmlsdGVyZWQoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHRpb25zLmFwaS5zZWxlY3RBbGwoKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Rlc2VsZWN0QWxsKGlkLCBmaWx0ZXJlZCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIGlmICgxID09PSBmaWx0ZXJlZCkge1xyXG4gICAgb3B0aW9ucy5hcGkuZGVzZWxlY3RBbGxGaWx0ZXJlZCgpXHJcbiAgfSBlbHNlIHtcclxuICAgIG9wdGlvbnMuYXBpLmRlc2VsZWN0QWxsKClcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgcm93c1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgZ3JpZCdzIGlkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9ICBzZWxlY3RlZCByb3dzIGFzIEpTT05cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRTZWxlY3RlZFJvd3MoaWQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IG5vZGVzID0gb3B0aW9ucy5hcGkuZ2V0U2VsZWN0ZWROb2RlcygpXHJcbiAgbGV0IHBhcnNlZCA9IFtdXHJcblxyXG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICBwYXJzZWQucHVzaChnd19wYXJzZU5vZGUobm9kZSwgb3B0aW9ucy5jb250ZXh0KSlcclxuICB9KVxyXG5cclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkKVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBsYXN0IHNlbGVjdGVkIHJvd1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgZ3JpZCdzIGlkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHNlbGVjdGVkIHJvdyBhcyBKU09OXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0U2VsZWN0ZWRSb3coaWQpIHtcclxuICBjb25zdCByb3dzID0gSlNPTi5wYXJzZShnd19nZXRTZWxlY3RlZFJvd3MoaWQpKVxyXG5cclxuICBpZiAocm93cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyb3dzW3Jvd3MubGVuZ3RoIC0gMV0pXHJcbiAgfVxyXG5cclxuICByZXR1cm4gJydcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcm93IGJ5IGl0cyBpZCBvciBpbmRleFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gaW5kZXhcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSByb3cgYXMgSlNPTlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFJvdyhpZCwgaW5kZXgpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcclxuICAgIGd3X3BhcnNlTm9kZShvcHRpb25zLmFwaS5nZXRSb3dOb2RlKGluZGV4KSwgb3B0aW9ucy5jb250ZXh0KVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCByb3dzIGZyb20gdGhlIGdyaWRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHBoYXNlIFRoZSByb3dzIHBoYXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJFeHByZXNzaW9uIEEgZmlsdGVyIGV4cHJlc3Npb25cclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSBKc29uIHN0cmluZ2lmaWVkIGFycmF5IG9mIHJvd3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRSb3dzKGlkLCBwaGFzZSwgZmlsdGVyRXhwcmVzc2lvbikge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgcGFyc2VkID0gW11cclxuXHJcbiAgb3B0aW9ucy5hcGlbcGhhc2VdKG5vZGUgPT4ge1xyXG4gICAgaWYgKCFub2RlLmdyb3VwKSB7XHJcbiAgICAgIGlmIChmaWx0ZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgICAgY29uc3QgY2FuUHJvY2VzcyA9IGd3X2V4ZWN1dGVFeHByZXNzaW9uKGZpbHRlckV4cHJlc3Npb24sIHtcclxuICAgICAgICAgIHZhbHVlOiBub2RlLmRhdGEsXHJcbiAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgICBvbGRWYWx1ZTogbnVsbCxcclxuICAgICAgICAgIG5ld1ZhbHVlOiBudWxsLFxyXG4gICAgICAgICAgbm9kZTogbm9kZSxcclxuICAgICAgICAgIGRhdGE6IG5vZGUuZGF0YSxcclxuICAgICAgICAgIGNvbERlZjogbnVsbCxcclxuICAgICAgICAgIHJvd0luZGV4OiBub2RlLnJvd0luZGV4LFxyXG4gICAgICAgICAgYXBpOiBub2RlLmdyaWRBcGksXHJcbiAgICAgICAgICBjb2x1bW5BcGk6IG5vZGUuY29sdW1uQXBpLFxyXG4gICAgICAgICAgZ2V0VmFsdWU6ICgpID0+IG5vZGUuZGF0YSxcclxuICAgICAgICAgIGNvbHVtbjogbnVsbCxcclxuICAgICAgICAgIGNvbHVtbkdyb3VwOlxyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgICAgIG5vZGUuaGFzT3duUHJvcGVydHkoJ3BhcmVudCcpICYmIG5vZGUucGFyZW50Lmhhc093blByb3BlcnR5KCdrZXknKVxyXG4gICAgICAgICAgICAgID8gbm9kZS5wYXJlbnQua2V5XHJcbiAgICAgICAgICAgICAgOiAnJyxcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBpZiAoY2FuUHJvY2Vzcykge1xyXG4gICAgICAgICAgcGFyc2VkLnB1c2goZ3dfcGFyc2VOb2RlKG5vZGUsIG9wdGlvbnMuY29udGV4dCkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcnNlZC5wdXNoKGd3X3BhcnNlTm9kZShub2RlLCBvcHRpb25zLmNvbnRleHQpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGdyaWQgdG8gcmVtb3ZlIGEgcm93IGZyb20gdGhlIERPTSBhbmQgcmVjcmVhdGUgaXQgYWdhaW4gZnJvbSBzY3JhdGNoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgZ3JpZCdzIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVkcmF3Um93cyhpZCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnJlZHJhd1Jvd3MoKVxyXG59XHJcblxyXG4vKipcclxuICogUGluIGFuIGFycmF5IG9mIHRvdyB0byB0aGUgdG9wIG9mIHRoZSBncmlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgb2Ygcm93c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFBpbm5lZFRvcFJvd0RhdGEoaWQsIGRhdGEpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zZXRQaW5uZWRUb3BSb3dEYXRhKGRhdGEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQaW4gYW4gYXJyYXkgb2YgdG93IHRvIHRoZSBib3R0b20gb2YgdGhlIGdyaWRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBhcnJheSBvZiByb3dzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0UGlubmVkQm90dG9tUm93RGF0YShpZCwgZGF0YSkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnNldFBpbm5lZEJvdHRvbVJvd0RhdGEoZGF0YSlcclxufVxyXG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBTdHJpbmdNYXNrIGZyb20gJy4vU3RyaW5nTWFzaydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0cmluZ01hc2tcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgTnVtYmVyTWFzayBmcm9tICcuL051bWJlck1hc2snXHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJNYXNrXHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19leGVjdXRlRXhwcmVzc2lvbiB9IGZyb20gJy4uL2V4cHJlc3Npb24nXHJcbmNvbnN0IHsgZGVlcFBhcnNlSnNvbiB9ID0gcmVxdWlyZSgnZGVlcC1wYXJzZS1qc29uJylcclxuXHJcbi8qKlxyXG4gKiBFeHRlbmQgdGhlIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKlxyXG4gKiBFeHRlbmQgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyB3aXRoIG9wdGlvbnMgd2hpY2ggY2FuIG5vdCBiZSBoYW5kbGVkIGluIEJCalxyXG4gKiAoZXg6IGF0dGFjaGluZyBjYWxsYmFja3MpXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmluaXRpb25zIGFycmF5IG9mIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2V4dGVuZENvbHVtbkRlZmluaXRpb25zKGRlZmluaXRpb25zKSB7XHJcbiAgZm9yIChsZXQgaSBpbiBkZWZpbml0aW9ucykge1xyXG4gICAgY29uc3QgZGVmID0gZGVmaW5pdGlvbnNbaV1cclxuXHJcbiAgICBkZWYuY2hlY2tib3hTZWxlY3Rpb24gPSBkZWYuY2hlY2tib3hTZWxlY3Rpb24gfHwgZ3dfaXNTaG93U2VsZWN0aW9uQ2hlY2tib3hcclxuICAgIGRlZi5oZWFkZXJDaGVja2JveFNlbGVjdGlvbiA9XHJcbiAgICAgIGRlZi5oZWFkZXJDaGVja2JveFNlbGVjdGlvbiB8fCBnd19pc0hlYWRlckNoZWNrYm94U2VsZWN0aW9uXHJcblxyXG4gICAgY29uc3QgdG9vbHRpcFZhbHVlR2V0dGVyRXhwcmVzc2lvbiA9IGRlZi50b29sdGlwVmFsdWVHZXR0ZXJcclxuICAgIGlmICh0b29sdGlwVmFsdWVHZXR0ZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgIGRlZi50b29sdGlwVmFsdWVHZXR0ZXIgPSBwYXJhbXMgPT5cclxuICAgICAgICBnd19leGVjdXRlRXhwcmVzc2lvbih0b29sdGlwVmFsdWVHZXR0ZXJFeHByZXNzaW9uLCBwYXJhbXMpXHJcbiAgICB9XHJcblxyXG4gICAgZGVmLnRvb2x0aXBDb21wb25lbnQgPSAnSFRNTFRvb2x0aXAnXHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiB0eXBlb2YgZGVmLmVkaXRhYmxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCBlZGl0YWJsZSA9IGRlZi5lZGl0YWJsZVxyXG4gICAgICBkZWYuZWRpdGFibGUgPSBwYXJhbXMgPT4gZ3dfZXhlY3V0ZUV4cHJlc3Npb24oZWRpdGFibGUsIHBhcmFtcylcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICBpZiAoZGVmLmhhc093blByb3BlcnR5KCdyb3dTcGFuJykgJiYgdHlwZW9mIGRlZi5yb3dTcGFuID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCByb3dTcGFuID0gZGVmLnJvd1NwYW5cclxuICAgICAgZGVmLnJvd1NwYW4gPSBwYXJhbXMgPT4gZ3dfZXhlY3V0ZUV4cHJlc3Npb24ocm93U3BhbiwgcGFyYW1zKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcclxuICAgIGlmIChkZWYuaGFzT3duUHJvcGVydHkoJ2NvbFNwYW4nKSAmJiB0eXBlb2YgZGVmLmNvbFNwYW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBkZWYuY29sU3BhblxyXG4gICAgICBkZWYuY29sU3BhbiA9IHBhcmFtcyA9PiBnd19leGVjdXRlRXhwcmVzc2lvbihjb2xTcGFuLCBwYXJhbXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRyZW4nKSkge1xyXG4gICAgICBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyhkZWYuY2hpbGRyZW4pXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmluaXRpb25zIGFycmF5IG9mIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldENvbHVtbkRlZmluaXRpb25zKGlkLCBkZWZpbml0aW9ucykge1xyXG4gIGNvbnN0IGdyaWQgPSBnd19nZXRHcmlkKGlkKVxyXG4gIGNvbnN0IGRlZXBQYXJzZWREZWZpbml0aW9ucyA9IGRlZXBQYXJzZUpzb24oSlNPTi5zdHJpbmdpZnkoZGVmaW5pdGlvbnMpKVxyXG5cclxuICBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyhkZWVwUGFyc2VkRGVmaW5pdGlvbnMpXHJcblxyXG4gIGdyaWQub3B0aW9ucy5hcGkuc2V0Q29sdW1uRGVmcyhkZWVwUGFyc2VkRGVmaW5pdGlvbnMpXHJcbiAgZ3JpZC5vcHRpb25zLmNvbHVtbkRlZnMgPSBkZWVwUGFyc2VkRGVmaW5pdGlvbnNcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGNvbHVtbnMgZml0IHRoZSBzY3JlZW5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZSB3aWR0aCB0byB1c2UgdG8gZml0IGFsbCBjb2x1bW5zIGluXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2l6ZUNvbHVtbnNUb0ZpdChpZCwgd2lkdGgpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcbiAgY29uc3QgY29sdW1uc0FQSSA9IG9wdGlvbnMuY29sdW1uQXBpXHJcbiAgaWYgKHdpZHRoKSB7XHJcbiAgICBjb2x1bW5zQVBJLnNpemVDb2x1bW5zVG9GaXQoTnVtYmVyKHdpZHRoKSlcclxuICB9IGVsc2Uge1xyXG4gICAgYXBpLnNpemVDb2x1bW5zVG9GaXQoKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFdvcmsgb3V0IHRoZSBiZXN0IHdpZHRoIHRvIGZpdCB0aGUgY29udGVudHMgb2YgdGhlIGNlbGxzIGluIHRoZSBjb2x1bW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBIZWFkZXI9ZmFsc2VdIHdoZW4gdHJ1ZSBpbmRpY2F0ZSB0aGF0IHRoZSBoZWFkZXIgY29udGVudCAoaGVhZGVyTmFtZSkgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHdoZW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uXHJcbiAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gW2NvbHVtbnM9bnVsbF0gYW4gYXJyYXkgb2YgY29sdW1ucyBpZHMgdG8gYXV0byBzaXplIG9yIG51bGwgdG8gYXV0byBzaXplIGFsbCBjb2x1bW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYXV0b1NpemVDb2x1bW5zKGlkLCBza2lwSGVhZGVyID0gZmFsc2UsIGNvbHVtbnMgPSBudWxsKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBjb2x1bW5zQVBJID0gb3B0aW9ucy5jb2x1bW5BcGlcclxuXHJcbiAgaWYgKCEoY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCkpIHtcclxuICAgIGNvbnN0IGFsbENvbHVtbklkcyA9IFtdXHJcblxyXG4gICAgY29sdW1uc0FQSS5nZXRBbGxDb2x1bW5zKCkuZm9yRWFjaChjb2x1bW4gPT4ge1xyXG4gICAgICBhbGxDb2x1bW5JZHMucHVzaChjb2x1bW4uY29sSWQpXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbHVtbnNBUEkuYXV0b1NpemVDb2x1bW5zKGFsbENvbHVtbklkcywgQm9vbGVhbihza2lwSGVhZGVyKSlcclxuICB9IGVsc2Uge1xyXG4gICAgY29sdW1uc0FQSS5hdXRvU2l6ZUNvbHVtbnMoY29sdW1ucywgQm9vbGVhbihza2lwSGVhZGVyKSlcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZXMgdGhlIGNvbHVtbiBpcyB2aXNpYmxlLCBzY3JvbGxpbmcgdGhlIHRhYmxlIGlmIG5lZWRlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5JZCAgdGhlIGNvbHVtbiBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Vuc3VyZUNvbHVtblZpc2libGUoaWQsIGNvbHVtbklkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuZW5zdXJlQ29sdW1uVmlzaWJsZShjb2x1bW5JZClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBDb2x1bW4gV2lkdGhcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5JZCBUaGUgY29sdW1uIGlkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2lkdGggVGhlIG5ldyBjb2x1bW4gd2lkdGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRDb2x1bW5XaWR0aChpZCwgY29sdW1uSWQsIHdpZHRoKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb2x1bW5BcGkuc2V0Q29sdW1uV2lkdGgoY29sdW1uSWQsIE51bWJlcih3aWR0aCkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQaW4gQ29sdW1uXHJcbiAqXHJcbiAqIFBpbiBhIGNvbHVtbiB0byBhIHNwZWNpZmljIGRpcmVjdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbklkIFRoZSBjb2x1bW4gaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHBpbiBUaGUgcGluIGRpcmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3BpbkNvbHVtbihpZCwgY29sdW1uSWQsIHBpbikge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnNldENvbHVtblBpbm5lZChjb2x1bW5JZCwgcGluKVxyXG59XHJcblxyXG4vKipcclxuICogTW92ZSBDb2x1bW5cclxuICpcclxuICogTW92ZSBjb2x1bW4gdG8gYSBzcGVjaWZpYyBpbmRleFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbklkIFRoZSBjb2x1bW4gaWRcclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB0b0luZGV4IFRoZSBuZXcgY29sdW1uIGluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfbW92ZUNvbHVtbihpZCwgY29sdW1uSWQsIHRvSW5kZXgpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5tb3ZlQ29sdW1uKGNvbHVtbklkLCB0b0luZGV4KVxyXG59XHJcblxyXG4vKipcclxuICogU2hvdyAvIEhpZGUgc2VsZWN0aW9uIGNoZWNrYm94IGJhc2VkIG9uIHRoZSBmaXJzdCBjb2x1bW5cclxuICpcclxuICogVGhlIGZ1bmN0aW9uIG1ha2Ugc3VyZSB0aGF0IHRoZSBzZWxlY3Rpb24gY2hlY2tib3ggaXMgYWx3YXlzIHNob3duIG9uIHRoZVxyXG4gKiBmaXJzdCBjb2x1bW5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBmaXJzdCBjb2x1bW4gLCBmYWxzZSBpZiBub3QgdGhlIGZpcnN0IGNvbHVtbiBvciBpZiB0aGVcclxuICogICAgICAgICAgICAgICAgICAgZ3JpZCdzIGBDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGAgaXMgZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19pc1Nob3dTZWxlY3Rpb25DaGVja2JveChwYXJhbSkge1xyXG4gIGlmICghcGFyYW0uY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3gpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY29sdW1ucyA9IHBhcmFtLmNvbHVtbkFwaS5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKClcclxuXHJcbiAgcmV0dXJuIGNvbHVtbnNbMF0gPT09IHBhcmFtLmNvbHVtblxyXG59XHJcblxyXG4vKipcclxuICogU2hvdyAvIEhpZGUgaGVhZGVyIHNlbGVjdGlvbiBjaGVja2JveCBiYXNlZCBvbiB0aGUgZmlyc3QgY29sdW1uXHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiBtYWtlIHN1cmUgdGhhdCB0aGUgaGVhZGVyIHNlbGVjdGlvbiBjaGVja2JveCBpcyBhbHdheXMgc2hvd24gb24gdGhlXHJcbiAqIGZpcnN0IGNvbHVtblxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1cclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIGZpcnN0IGNvbHVtbiAsIGZhbHNlIGlmIG5vdCB0aGUgZmlyc3QgY29sdW1uIG9yIGlmIHRoZVxyXG4gKiAgICAgICAgICAgICAgICAgICBncmlkJ3MgYENvbnRleHQuc2hvd0hlYWRlclNlbGVjdGlvbkNoZWNrYm94YCBpcyBmYWxzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2lzSGVhZGVyQ2hlY2tib3hTZWxlY3Rpb24ocGFyYW0pIHtcclxuICBjb25zdCBjb250ZXh0ID0gcGFyYW0uYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcblxyXG4gIGlmICghY29udGV4dC5zaG93SGVhZGVyU2VsZWN0aW9uQ2hlY2tib3gpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY29sdW1ucyA9IHBhcmFtLmNvbHVtbkFwaS5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKClcclxuXHJcbiAgcmV0dXJuIGNvbHVtbnNbMF0gPT09IHBhcmFtLmNvbHVtblxyXG59XHJcblxyXG4vKipcclxuICogRW5hYmxlIHJvdyBncm91cGluZyBmb3IgY29sdW1uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBjb2x1bW5zXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0ICBXaGVuIHRydWUgLCBgc2V0Um93R3JvdXBDb2x1bW5zYCB3aWxsIGJlIHVzZWQgLCBgYWRkUm93R3JvdXBDb2x1bW5zYCBvdGhlcndpc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19hZGRSb3dHcm91cENvbHVtbihpZCwgY29sdW1ucywgc2V0KSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb2x1bW5BcGlbXHJcbiAgICBzZXQgPyAnc2V0Um93R3JvdXBDb2x1bW5zJyA6ICdhZGRSb3dHcm91cENvbHVtbnMnXHJcbiAgXShjb2x1bW5zLnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpKVxyXG59XHJcblxyXG4vKipcclxuICogRGlzYWJsZSByb3cgZ3JvdXBpbmcgZm9yIGNvbHVtbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5zICBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgY29sdW1uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3JlbW92ZVJvd0dyb3VwQ29sdW1uKGlkLCBjb2x1bW5zKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb2x1bW5BcGkucmVtb3ZlUm93R3JvdXBDb2x1bW5zKFxyXG4gICAgY29sdW1ucy5zcGxpdCgnLCcpLm1hcChpID0+IGkudHJpbSgpKVxyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFBpdm90TW9kZShpZCkge1xyXG4gIHJldHVybiBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5pc1Bpdm90TW9kZSgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgLyBkaXNiYWxlIHBpdm90IG1vZGVcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbW9kZSB3aGVuIHRydWVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRQaXZvdE1vZGUoaWQsIG1vZGUpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5zZXRQaXZvdE1vZGUoISFOdW1iZXIobW9kZSkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgcGl2b3QgZm9yIGNvbHVtbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5zICBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgY29sdW1uc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNldCAgV2hlbiB0cnVlICwgYGFkZFBpdm90Q29sdW1uc2Agd2lsbCBiZSB1c2VkICwgYHNldFBpdm90Q29sdW1uc2Agb3RoZXJ3aXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYWRkUGl2b3RDb2x1bW5zKGlkLCBjb2x1bW5zLCBzZXQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaVtzZXQgPyAnc2V0UGl2b3RDb2x1bW5zJyA6ICdhZGRQaXZvdENvbHVtbnMnXShcclxuICAgIGNvbHVtbnMuc3BsaXQoJywnKS5tYXAoaSA9PiBpLnRyaW0oKSlcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlIHBpdm90IGZvciBjb2x1bW5zXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1ucyAgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGNvbHVtbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19yZW1vdmVQaXZvdENvbHVtbnMoaWQsIGNvbHVtbnMpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5yZW1vdmVQaXZvdENvbHVtbnMoXHJcbiAgICBjb2x1bW5zLnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogRW5hYmxlIHZhbHVlIGZvciBjb2x1bW5zXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1ucyAgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGNvbHVtbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19hZGRWYWx1ZUNvbHVtbnMoaWQsIGNvbHVtbnMpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5hZGRWYWx1ZUNvbHVtbnMoXHJcbiAgICBjb2x1bW5zLnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogRGlzYWJsZSB2YWx1ZSBmb3IgY29sdW1uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBjb2x1bW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVtb3ZlVmFsdWVDb2x1bW5zKGlkLCBjb2x1bW5zKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb2x1bW5BcGkucmVtb3ZlVmFsdWVDb2x1bW5zKFxyXG4gICAgY29sdW1ucy5zcGxpdCgnLCcpLm1hcChpID0+IGkudHJpbSgpKVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY29sdW1uIHNvcnRpbmcgbW9kZWxcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlbCBtb2RlbCBhcyBqc29uIGFycmF5XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0U29ydE1vZGVsKGlkLCBtb2RlbCkge1xyXG4gIGNvbnN0IGFzQXJyYXkgPSBKU09OLnBhcnNlKG1vZGVsKVxyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgcGFyc2VkTW9kZWwgPSBbXVxyXG4gIGFzQXJyYXkuZm9yRWFjaChpID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGkpIHtcclxuICAgICAgcGFyc2VkTW9kZWwucHVzaCh7XHJcbiAgICAgICAgY29sSWQ6IGtleSxcclxuICAgICAgICBzb3J0OiBpW2tleV0sXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgb3B0aW9ucy5jb2x1bW5BcGkuYXBwbHlDb2x1bW5TdGF0ZSh7XHJcbiAgICBzdGF0ZTogcGFyc2VkTW9kZWwsXHJcbiAgICBhcHBseU9yZGVyOiBmYWxzZSxcclxuICAgIGRlZmF1bHRTdGF0ZTogb3B0aW9ucy5jb2x1bW5BcGkuZ2V0Q29sdW1uU3RhdGUoKSxcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogUmVkcmF3cyB0aGUgaGVhZGVyLiBVc2VmdWwgaWYgYSBjb2x1bW4gbmFtZSBjaGFuZ2VzLFxyXG4gKiBvciBzb21ldGhpbmcgZWxzZSB0aGF0IGNoYW5nZXMgaG93IHRoZSBjb2x1bW4gaGVhZGVyIGlzIGRpc3BsYXllZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3JlZnJlc2hIZWFkZXIoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5yZWRyYXdSb3dzKClcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBjb2x1bW4gdmlhYmlsaXR5XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY29sdW1uIGlkc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgdHJ1ZSB0byBtYWtlIHRoZSBjb2x1bW5zIHZpc2libGUgLCBmYWxzZSB0byBoaWRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0Q29sdW1uVmlzaWJsZShpZCwgY29sdW1ucywgdmlzaWJsZSkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnNldENvbHVtbnNWaXNpYmxlKFxyXG4gICAgY29sdW1ucy5zcGxpdCgnLCcpLFxyXG4gICAgQm9vbGVhbih2aXNpYmxlKVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsaWduIHR3byBncmlkIHRvZ2V0aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgY3VycmVudCBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGdyaWRJZCBUaGUgdGFyZ2V0IGdyaWQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZEFsaWduZWRHcmlkKGlkLCBncmlkSWQpIHtcclxuICBjb25zdCBjdXJyZW50R3JpZE9wdGlvbiA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCByZWdpc3RlciA9ICgpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEdyaWRPcHRpb24gPSBnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9uc1xyXG4gICAgY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLnB1c2godGFyZ2V0R3JpZE9wdGlvbilcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZWdpc3RlcigpXHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjdXJyZW50R3JpZE9wdGlvbi5hbGlnbmVkR3JpZHMucHVzaChncmlkSWQpXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgJHtncmlkSWR9LXJlYWR5YCwgKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleE9mID0gY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLmluZGV4T2YoZ3JpZElkKVxyXG4gICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XHJcbiAgICAgICAgY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLnNwbGljZShpbmRleE9mLCAxKVxyXG4gICAgICAgIHJlZ2lzdGVyKClcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYWxpZ25lZCBncmlkc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGN1cnJlbnQgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBncmlkSWQgVGhlIHRhcmdldCBncmlkJ3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19yZW1vdmVBbGlnbmVkR3JpZChpZCwgZ3JpZElkKSB7XHJcbiAgY29uc3QgY3VycmVudEdyaWRPcHRpb24gPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgYWxpZ25lZEdyaWRzID0gY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzXHJcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBhbGlnbmVkR3JpZHMubGVuZ3RoOyB4KyspIHtcclxuICAgIGNvbnN0IGdyaWQgPSBhbGlnbmVkR3JpZHNbeF1cclxuICAgIGlmIChcclxuICAgICAgKHR5cGVvZiBncmlkID09PSAnc3RyaW5nJyAmJiBncmlkID09PSBncmlkSWQpIHx8XHJcbiAgICAgIGdyaWQuY29udGV4dC5pZCA9PT0gZ3JpZElkXHJcbiAgICApIHtcclxuICAgICAgYWxpZ25lZEdyaWRzLnNwbGljZSh4LCAxKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBhIGpzIGZ1bmN0aW9uIGZyb20gdGhlIGdpdmVuIGV4cHJlc3Npb25cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25cclxuICpcclxuICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZXhwcmVzc2lvbiBjYWNoZSBoYXMgYmVlbiBpbml0aWFsaXplZFxyXG4gIGlmICh0eXBlb2YgZ3dfY29tcGlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbkNhY2hlID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBnd19jb21waWxlRXhwcmVzc2lvbi5leHByZXNzaW9uQ2FjaGUgPSBbXVxyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2sgY2FjaGUgZmlyc3RcclxuICBpZiAoZ3dfY29tcGlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbkNhY2hlW2V4cHJlc3Npb25dKSB7XHJcbiAgICByZXR1cm4gZ3dfY29tcGlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbkNhY2hlW2V4cHJlc3Npb25dXHJcbiAgfVxyXG5cclxuICAvLyBpZiBub3QgZm91bmQgaW4gY2FjaGUsIHJldHVybiB0aGUgZnVuY3Rpb25cclxuICBsZXQgZnVuY3Rpb25Cb2R5ID0gbnVsbFxyXG4gIC8vIGlmIHRoZSBleHByZXNzaW9uIGhhcyB0aGUgJ3JldHVybicgd29yZCBpbiBpdCwgdGhlbiB1c2UgYXMgaXMsXHJcbiAgLy8gaWYgbm90LCB0aGVuIHdyYXAgaXQgd2l0aCByZXR1cm4gYW5kICc7JyB0byBtYWtlIGEgZnVuY3Rpb25cclxuICBpZiAoZXhwcmVzc2lvbi5pbmRleE9mKCdyZXR1cm4nKSA+PSAwKSB7XHJcbiAgICBmdW5jdGlvbkJvZHkgPSBleHByZXNzaW9uXHJcbiAgfSBlbHNlIHtcclxuICAgIGZ1bmN0aW9uQm9keSA9ICdyZXR1cm4gJyArIGV4cHJlc3Npb24gKyAnOydcclxuICB9XHJcblxyXG4gIGNvbnN0IHRoZUZ1bmN0aW9uID0gbmV3IEZ1bmN0aW9uKFxyXG4gICAgJ3gsIGN0eCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCB2YWx1ZSwgbm9kZSwgZGF0YSwgY29sRGVmLCByb3dJbmRleCwgYXBpLCBjb2x1bW5BcGksIGdldFZhbHVlLCBjb2x1bW4sIGNvbHVtbkdyb3VwJyxcclxuICAgIGZ1bmN0aW9uQm9keVxyXG4gIClcclxuXHJcbiAgLy8gc3RvcmUgaW4gY2FjaGVcclxuICBnd19jb21waWxlRXhwcmVzc2lvbi5leHByZXNzaW9uQ2FjaGVbZXhwcmVzc2lvbl0gPSB0aGVGdW5jdGlvblxyXG5cclxuICByZXR1cm4gdGhlRnVuY3Rpb25cclxufVxyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGFuZCBleGVjdXRlZCBhbiBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBwYXJhbXNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV4cHJlc3Npb25cclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xyXG4gKlxyXG4gKiBAcmV0dXJuIG1peGVkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZXhlY3V0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcGFyYW1zKSB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IGphdmFTY3JpcHRGdW5jdGlvbiA9IGd3X2NvbXBpbGVFeHByZXNzaW9uKGV4cHJlc3Npb24pXHJcbiAgICAvLyB0aGUgcGFyYW1zIGRvbid0IGhhdmUgYWxsIHRoZXNlIHZhbHVlcywgcmF0aGVyIHdlIGFkZCBldmVyeSBwb3NzaWJsZVxyXG4gICAgLy8gdmFsdWUgYSBwYXJhbXMgY2FuIGhhdmUsIHdoaWNoIG1ha2VzIHdoYXRldmVyIGlzIGluIHRoZSBwYXJhbXMgYXZhaWxhYmxlLlxyXG4gICAgY29uc3QgcmVzdWx0ID0gamF2YVNjcmlwdEZ1bmN0aW9uKFxyXG4gICAgICBwYXJhbXMudmFsdWUsXHJcbiAgICAgIHBhcmFtcy5jb250ZXh0LFxyXG4gICAgICBwYXJhbXMub2xkVmFsdWUsXHJcbiAgICAgIHBhcmFtcy5uZXdWYWx1ZSxcclxuICAgICAgcGFyYW1zLnZhbHVlLFxyXG4gICAgICBwYXJhbXMubm9kZSxcclxuICAgICAgcGFyYW1zLmRhdGEsXHJcbiAgICAgIHBhcmFtcy5jb2xEZWYsXHJcbiAgICAgIHBhcmFtcy5yb3dJbmRleCxcclxuICAgICAgcGFyYW1zLmFwaSxcclxuICAgICAgcGFyYW1zLmNvbHVtbkFwaSxcclxuICAgICAgcGFyYW1zLmdldFZhbHVlLFxyXG4gICAgICBwYXJhbXMuY29sdW1uLFxyXG4gICAgICBwYXJhbXMuY29sdW1uR3JvdXBcclxuICAgIClcclxuICAgIHJldHVybiByZXN1bHRcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICAvLyB0aGUgZXhwcmVzc2lvbiBmYWlsZWQsIHdoaWNoIGNhbiBoYXBwZW4sIGFzIGl0J3MgdGhlIGNsaWVudCB0aGF0XHJcbiAgICAvLyBwcm92aWRlcyB0aGUgZXhwcmVzc2lvbi4gc28gcHJpbnQgYSBuaWNlIG1lc3NhZ2VcclxuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIG9mIHRoZSBleHByZXNzaW9uIGZhaWxlZCcpXHJcbiAgICBjb25zb2xlLmxvZygnRXhwcmVzc2lvbiA9ICcgKyBleHByZXNzaW9uKVxyXG4gICAgY29uc29sZS5sb2coJ1BhcmFtcyA9JywgcGFyYW1zKVxyXG4gICAgY29uc29sZS5sb2coJ0V4Y2VwdGlvbiA9ICcgKyBlKVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCwgZ3dfdXVpZCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X3BhcnNlQWRkQ2VsbFJhbmdlIH0gZnJvbSAnYXBpL2NlbGxzJ1xyXG5cclxuY29uc3QgeyBkZWVwUGFyc2VKc29uIH0gPSByZXF1aXJlKCdkZWVwLXBhcnNlLWpzb24nKVxyXG5cclxuLyoqXHJcbiAqIFRoZSBhcnJheSBjb250YWlucyByZWZlcmVuY2VzIHRvIGNyZWF0ZWQgY2hhcnRzIGZyb20gQkJqLlxyXG4gKiBFdmVyeSByZWZlcmVuY2UgaXMgYSBDaGFydFJlZiBvYmplY3Qgd2hpY2ggcHJvdmlkZXMgdGhlIGFwcGxpY2F0aW9uIHdpdGggdGhlXHJcbiAqIGRlc3Ryb3lDaGFydCgpIG1ldGhvZCB0aGF0IGlzIHJlcXVpcmVkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHdhbnRzIHRvIGRpc3Bvc2UgdGhlIGNoYXJ0LlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGNoYXJ0IHRvb2xiYXIgaXRlbXMgZGVmaW5lZCBpbiB0aGUgZ3JpZCdzIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFycmF5IG9mIHN1cHBvcnRlZCBjaGFydCBpdGVtc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldENoYXJ0VG9vbGJhckl0ZW1zKHBhcmFtcykge1xyXG4gIHJldHVybiAoXHJcbiAgICBwYXJhbXMuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0LmNoYXJ0VG9vbGJhckl0ZW1zIHx8IFtdXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogQWRkIG5ldyBjaGFydCByYW5nZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByYW5nZSAgYm91bmRlZCBvciB1bmJvdW5kZWQgcmFuZ2UgbW9kZWxcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGdlbmVyYXRlIGNoYXJ0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYWRkQ2hhcnRSYW5nZShpZCwgcmFuZ2UpIHtcclxuICBjb25zdCBncmlkID0gZ3dfZ2V0R3JpZChpZClcclxuICBjb25zdCBvcHRpb25zID0gZ3JpZC5vcHRpb25zXHJcbiAgY29uc3QgcHIgPSBkZWVwUGFyc2VKc29uKEpTT04uc3RyaW5naWZ5KHJhbmdlKSlcclxuXHJcbiAgcHIuY2VsbFJhbmdlID0gZ3dfcGFyc2VBZGRDZWxsUmFuZ2Uob3B0aW9ucywgcHIuY2VsbFJhbmdlKVxyXG5cclxuICBjb25zdCByZWYgPSBvcHRpb25zLmFwaS5jcmVhdGVSYW5nZUNoYXJ0KHByKVxyXG4gIGNvbnN0IHV1aWQgPSBnd191dWlkKClcclxuXHJcbiAgZ3JpZC5jcmVhdGVkX2NoYXJ0cyA9IGdyaWQuY3JlYXRlZF9jaGFydHMgfHwge31cclxuICBncmlkLmNyZWF0ZWRfY2hhcnRzW3V1aWRdID0gcmVmXHJcblxyXG4gIHJldHVybiB1dWlkXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXN0cm95IGNyZWF0ZWQgY2hhcnRzXHJcbiAqXHJcbiAqIERlc3Ryb3kgYWxyZWFkeSBjcmVhdGVkIGNoYXJ0IGJ5IGlkIG9yIGFsbCBjcmVhdGVkIGNoYXJ0c1xyXG4gKiB3aGVuIHRoZSBgdXVpZGAgaXMgb21pdHRlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXVpZCBUaGUgY2hhcnQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Rlc3Ryb3lDaGFydChpZCwgdXVpZCkge1xyXG4gIGNvbnN0IGdyaWQgPSBnd19nZXRHcmlkKGlkKVxyXG5cclxuICBpZiAodXVpZCkge1xyXG4gICAgaWYgKFxyXG4gICAgICBncmlkLmhhc093blByb3BlcnR5KCdjcmVhdGVkX2NoYXJ0cycpICYmXHJcbiAgICAgIGdyaWQuY3JlYXRlZF9jaGFydHMuaGFzT3duUHJvcGVydHkodXVpZClcclxuICAgICkge1xyXG4gICAgICBncmlkLmNyZWF0ZWRfY2hhcnRzW3V1aWRdLmRlc3Ryb3lDaGFydCgpXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChncmlkLmhhc093blByb3BlcnR5KCdjcmVhdGVkX2NoYXJ0cycpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgaSBpbiBncmlkLmNyZWF0ZWRfY2hhcnRzKSB7XHJcbiAgICAgICAgaWYgKGdyaWQuY3JlYXRlZF9jaGFydHMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgIGNvbnN0IGNoYXJ0ID0gZ3JpZC5jcmVhdGVkX2NoYXJ0c1tpXVxyXG4gICAgICAgICAgY2hhcnQuZGVzdHJveUNoYXJ0KClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X3BhcnNlTm9kZSB9IGZyb20gJ2V2ZW50cy91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X2dldFJvd3MgfSBmcm9tICcuL3Jvd3MnXHJcblxyXG5jb25zdCB7IGRlZXBQYXJzZUpzb24gfSA9IHJlcXVpcmUoJ2RlZXAtcGFyc2UtanNvbicpXHJcblxyXG4vKipcclxuICogU3RhcnQgY2VsbCBlZGl0aW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfG51bWJlcn0gcm93IFRoZSByb3cgaW5kZXggb3Iga2V5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xLZXkgVGhlIGNvbHVtbidzIGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGtleVByZXNzICBLZXkgcHJlc3NcclxuICogQHBhcmFtIHtTdHJpbmd9IGNoYXJQcmVzc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gcm93UGlubmVkIFNldCB0byAndG9wJyBvciAnYm90dG9tJyB0byBzdGFydGVkIGVkaXRpbmcgYSBwaW5uZWQgcm93XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc3RhcnRFZGl0aW5nQ2VsbChcclxuICBpZCxcclxuICByb3csXHJcbiAgY29sS2V5LFxyXG4gIGtleVByZXNzLFxyXG4gIGNoYXJQcmVzcyxcclxuICByb3dQaW5uZWRcclxuKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBhcGkgPSBvcHRpb25zLmFwaVxyXG4gIGNvbnN0IG5vZGUgPSBhcGkuZ2V0Um93Tm9kZShyb3cpIHx8IGFwaS5nZXREaXNwbGF5ZWRSb3dBdEluZGV4KHJvdylcclxuXHJcbiAgb3B0aW9ucy5hcGkuc3RhcnRFZGl0aW5nQ2VsbCh7XHJcbiAgICByb3dJbmRleDogbm9kZS5yb3dJbmRleCxcclxuICAgIGtleVByZXNzOiBOdW1iZXIoa2V5UHJlc3MpLFxyXG4gICAgY29sS2V5LFxyXG4gICAgY2hhclByZXNzLFxyXG4gICAgcm93UGlubmVkLFxyXG4gIH0pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTdG9wIGNlbGwgZWRpdGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhbmNlbCB3aGVuIHRydWUgY2FuY2VsIGVkaXRzICwgc2F2ZSBlZGl0cyBvdGhlcndpc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zdG9wRWRpdGluZyhpZCwgY2FuY2VsKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc3RvcEVkaXRpbmcoY2FuY2VsKVxyXG59XHJcblxyXG4vKipcclxuICogTmF2aWdhdGVzIHRoZSBncmlkIGZvY3VzIHRvIHRoZSBuZXh0IGNlbGwsIGFzIGlmIHRhYmJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgdGhlIGdyaWQgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd190YWJUb05leHRDZWxsKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkudGFiVG9OZXh0Q2VsbCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOYXZpZ2F0ZXMgdGhlIGdyaWQgZm9jdXMgdG8gdGhlIHByZXZpb3VzIGNlbGwsIGFzIGlmIHNoaWZ0LXRhYmJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgdGhlIGdyaWQgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd190YWJUb1ByZXZpb3VzQ2VsbChpZCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnRhYlRvUHJldmlvdXNDZWxsKClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBGb2N1cyBvbiB0aGUgZ2l2ZW4gcm93IGFuZCBjb2x1bW5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSByb3cgVGhlIHJvdydzIGluZGV4L2lkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW4gVGhlIGNvbHVtbiBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxvYXRpbmcgbnVsbCwgJ3RvcCcsIG9yICdib3R0b20nLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldEZvY3VzZWRDZWxsKGlkLCByb3csIGNvbHVtbiwgZmxvYXRpbmcgPSBudWxsKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBncmlkID0gZ3dfZ2V0R3JpZChpZClcclxuXHJcbiAgLy8gaWdub3JlIGZvY3VzIGNhbGxzIGlmIGVkaXRpbmdcclxuICBpZiAob3B0aW9ucy5hcGkuZ2V0RWRpdGluZ0NlbGxzKCkubGVuZ3RoID4gMCkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICBpZiAoIUpTT04ucGFyc2UoZ3dfZ2V0Um93cyhpZCwgJ2ZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXJBbmRTb3J0JywgJycpKS5sZW5ndGgpIHtcclxuICAgIGdyaWQuY29udGFpbmVyLmZvY3VzKClcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgbGV0IHIsIGMsIGZcclxuICBpZiAocm93ID09IC0xKSB7XHJcbiAgICAvLyB0cnkgdG8gcmV0YWluIHRoZSBmb2N1c1xyXG4gICAgY29uc3QgbGFzdEZvY3VzZWRDZWxsID0gb3B0aW9ucy5hcGkuZ2V0Rm9jdXNlZENlbGwoKVxyXG5cclxuICAgIGlmIChsYXN0Rm9jdXNlZENlbGwpIHtcclxuICAgICAgciA9IGxhc3RGb2N1c2VkQ2VsbC5yb3dJbmRleFxyXG4gICAgICBjID0gbGFzdEZvY3VzZWRDZWxsLmNvbHVtbi5jb2xJZFxyXG4gICAgICBmID0gbGFzdEZvY3VzZWRDZWxsLnJvd1Bpbm5lZFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IDBcclxuICAgICAgYyA9IG9wdGlvbnMuY29sdW1uQXBpLmdldEFsbEdyaWRDb2x1bW5zKClbMF0uY29sSWRcclxuICAgICAgZiA9IGZsb2F0aW5nXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSAhcm93XHJcbiAgICAgID8gMFxyXG4gICAgICA6IE51bWJlci5pc0ludGVnZXIoK3JvdylcclxuICAgICAgPyArcm93XHJcbiAgICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShyb3cpLnJvd0luZGV4XHJcbiAgICBjID0gY29sdW1uID8gY29sdW1uIDogb3B0aW9ucy5jb2x1bW5BcGkuZ2V0QWxsR3JpZENvbHVtbnMoKVswXS5jb2xJZFxyXG4gICAgZiA9IGZsb2F0aW5nXHJcbiAgfVxyXG5cclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zZXRGb2N1c2VkQ2VsbChyLCBjLCBmKVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IFJhbmdlIFNlbGVjdGlvbnNcclxuICpcclxuICogVGhlIG1ldGhvZCB3aWxsIGNyZWF0ZSBhIHJhbmdlIGpzb24gbW9kZWwgZm9yIGVhY2ggcmFuZ2Ugd2hpY2ggY2FuIGJlIHBhcnNlZCBpbiBCQmogc2lkZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzZWxlY3RlZCByYW5nZXMgYXMgSlNPTlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFJhbmdlU2VsZWN0aW9ucyhpZCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dFxyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcbiAgY29uc3QgcmFuZ2VzID0gYXBpLmdldENlbGxSYW5nZXMoKVxyXG4gIGNvbnN0IG1vZGVsID0gYXBpLmdldE1vZGVsKClcclxuICBsZXQgcmVzdWx0ID0gW11cclxuXHJcbiAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgLy8gY29uc3Qgc3RhcnQgPSBnd19wYXJzZU5vZGUobW9kZWwuZ2V0Um93KHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4KSwgb3B0aW9ucy5jb250ZXh0KTtcclxuICAgIC8vIGNvbnN0IGVuZCA9IGd3X3BhcnNlTm9kZShtb2RlbC5nZXRSb3cocmFuZ2UuZW5kUm93LnJvd0luZGV4KSwgb3B0aW9ucy5jb250ZXh0KTtcclxuXHJcbiAgICAvL2lmIChzdGFydCAhPT0gZmFsc2UgJiYgZW5kICE9PSBmYWxzZSkge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IHJhbmdlLmNvbHVtbnNcclxuICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICBpZiAoJ2FnLUdyaWQtQXV0b0NvbHVtbicgIT09IGN1cnJlbnQuY29sSWQpIHtcclxuICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY3VycmVudC5jb2xJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvclxyXG4gICAgICB9LCBbXSlcclxuICAgICAgLmZpbHRlcihCb29sZWFuKVxyXG5cclxuICAgIGNvbnN0IHN0YXJJbmRleCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4LCByYW5nZS5lbmRSb3cucm93SW5kZXgpXHJcbiAgICBjb25zdCBlbmRJbmRleCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4LCByYW5nZS5lbmRSb3cucm93SW5kZXgpXHJcbiAgICBjb25zdCByb3dzID0gW11cclxuXHJcbiAgICBmb3IgKGxldCByb3dJbmRleCA9IHN0YXJJbmRleDsgcm93SW5kZXggPD0gZW5kSW5kZXg7IHJvd0luZGV4KyspIHtcclxuICAgICAgY29uc3Qgbm9kZSA9IG1vZGVsLmdldFJvdyhyb3dJbmRleClcclxuICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWROb2RlID0gZ3dfcGFyc2VOb2RlKG5vZGUsIGNvbnRleHQpXHJcbiAgICAgICAgaWYgKHBhcnNlZE5vZGUpIHtcclxuICAgICAgICAgIHJvd3MucHVzaChwYXJzZWROb2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyb3dzLmxlbmd0aCAmJiBjb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICByZXN1bHQucHVzaCh7IHI6IHJvd3MsIGM6IGNvbHVtbnMgfSlcclxuICAgIH1cclxuICAgIC8vfVxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB0aGUgY2VsbHMgcmFuZ2UgaW4gYSBmb3JtYXQgdGhlIGdyaWQgY2FuIHVuZGVyc3RhbmQgd2hlbiBpdCBpcyBwYXNzZWRcclxuICogdG8gYGFwaS5hZGRDZWxsUmFuZ2VgXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBncmlkJ3Mgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgIGJvdW5kZWQgb3IgdW5ib3VuZGVkIHJhbmdlIG1vZGVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcGFyc2VBZGRDZWxsUmFuZ2Uob3B0aW9ucywgcmFuZ2UpIHtcclxuICBjb25zdCBwciA9IGRlZXBQYXJzZUpzb24oSlNPTi5zdHJpbmdpZnkocmFuZ2UpKVxyXG4gIGNvbnN0IHN0YXJ0ID0gIShwci5zdGFydCB8fCBudWxsKVxyXG4gICAgPyAwXHJcbiAgICA6IE51bWJlci5pc0ludGVnZXIoK3ByLnN0YXJ0KVxyXG4gICAgPyArcHIuc3RhcnRcclxuICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShwci5zdGFydCkucm93SW5kZXhcclxuICBjb25zdCBlbmQgPSAhKHByLmVuZCB8fCBudWxsKVxyXG4gICAgPyBvcHRpb25zLnJvd0RhdGEubGVuZ3RoIC0gMVxyXG4gICAgOiBOdW1iZXIuaXNJbnRlZ2VyKCtwci5lbmQpXHJcbiAgICA/ICtwci5lbmRcclxuICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShwci5lbmQpLnJvd0luZGV4XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByb3dTdGFydEluZGV4OiBNYXRoLmFicyhzdGFydCksXHJcbiAgICByb3dFbmRJbmRleDogTWF0aC5hYnMoZW5kKSxcclxuICAgIGNvbHVtbnM6IHByLmNvbHVtbnMsXHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgbmV3IGNlbGwgcmFuZ2VcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgIGJvdW5kZWQgb3IgdW5ib3VuZGVkIHJhbmdlIG1vZGVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYWRkQ2VsbFJhbmdlKGlkLCByYW5nZSkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgb3B0aW9ucy5hcGkuYWRkQ2VsbFJhbmdlKGd3X3BhcnNlQWRkQ2VsbFJhbmdlKG9wdGlvbnMsIHJhbmdlKSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgc2VsZWN0ZWQgcmFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBncmlkJ3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19jbGVhclJhbmdlU2VsZWN0aW9uKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuY2xlYXJSYW5nZVNlbGVjdGlvbigpXHJcbn1cclxuIiwiaW1wb3J0IGFzc2lnbkluV2l0aCBmcm9tICcuL2Fzc2lnbkluV2l0aC5qcyc7XG5pbXBvcnQgYXR0ZW1wdCBmcm9tICcuL2F0dGVtcHQuanMnO1xuaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiBmcm9tICcuL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzJztcbmltcG9ydCBlc2NhcGVTdHJpbmdDaGFyIGZyb20gJy4vX2VzY2FwZVN0cmluZ0NoYXIuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVTZXR0aW5ncyBmcm9tICcuL3RlbXBsYXRlU2V0dGluZ3MuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCA9ICdJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYCc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byB2YWxpZGF0ZSB0aGUgYHZhbGlkYXRlYCBvcHRpb24gaW4gYF8udGVtcGxhdGVgIHZhcmlhYmxlLlxuICpcbiAqIEZvcmJpZHMgY2hhcmFjdGVycyB3aGljaCBjb3VsZCBwb3RlbnRpYWxseSBjaGFuZ2UgdGhlIG1lYW5pbmcgb2YgdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IGRlZmluaXRpb246XG4gKiAtIFwiKCksXCIgKG1vZGlmaWNhdGlvbiBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAqIC0gXCJbXXt9XCIgKGRlc3RydWN0dXJpbmcgb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAqIC0gXCIvXCIgKGJlZ2lubmluZyBvZiBhIGNvbW1lbnQpXG4gKiAtIHdoaXRlc3BhY2VcbiAqL1xudmFyIHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzID0gL1soKT0se31cXFtcXF1cXC9cXHNdLztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpICtcbiAgICAgICAnXFxuJylcbiAgICA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBUaHJvdyBhbiBlcnJvciBpZiBhIGZvcmJpZGRlbiBjaGFyYWN0ZXIgd2FzIGZvdW5kIGluIGB2YXJpYWJsZWAsIHRvIHByZXZlbnRcbiAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gIGVsc2UgaWYgKHJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzLnRlc3QodmFyaWFibGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQpO1xuICB9XG5cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGU7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0l0ZXJhdGVlQ2FsbDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Vycm9yKEVycm9yKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRXJyb3I7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlSW50ZXJwb2xhdGU7XG4iLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCAnZXhwb3NlLWxvYWRlcj9CQmouTWFza3MhYmJqLW1hc2tzL2Rpc3QvYmJqLW1hc2tzLmpzJ1xyXG5pbXBvcnQgJ2V4cG9zZS1sb2FkZXI/QmFzaXMuSW5wdXRNYXNraW5nIWJhc2lzLWlucHV0LW1hc2tpbmcvZGlzdC9iYXNpcy1pbnB1dC1tYXNraW5nLmpzJ1xyXG5pbXBvcnQgJ2V4cG9zZS1sb2FkZXI/ZmxhdHBpY2tyIWZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5qcydcclxuaW1wb3J0ICdleHBvc2UtbG9hZGVyP0Jhc2lzLkFnR3JpZENvbXBvbmVudHMhYmFzaXMtYWdncmlkLWNvbXBvbmVudHMvZGlzdC9iYXNpcy1hZ2dyaWQtY29tcG9uZW50cy5qcydcclxuXHJcbnJlcXVpcmUoJ2ZsYXRwaWNrci9kaXN0L2ZsYXRwaWNrci5jc3MnKVxyXG5yZXF1aXJlKCcuL3N0eWxlL2NsYXNzZXMuY3NzJylcclxucmVxdWlyZSgnLi9zdHlsZS9zdWdnZXN0aW9uLWVkaXRvci5jc3MnKVxyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9wb2x5ZmlsbHMuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vYXBpJ1xyXG4iLCJpZighZ2xvYmFsW1wiQkJqXCJdKSBnbG9iYWxbXCJCQmpcIl0gPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiQkJqXCJdW1wiTWFza3NcIl0gPSByZXF1aXJlKFwiLSFEOlxcXFxHaXRodWJcXFxcQkJqR3JpZEV4V2lkZ2V0XFxcXGNsaWVudFxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz8/cmVmLS00IS5cXFxcYmJqLW1hc2tzLmpzXCIpOyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIk1hc2tzXCJdID0gZmFjdG9yeSgpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJCQmpcIl0gPSByb290W1wiQkJqXCJdIHx8IHt9LCByb290W1wiQkJqXCJdW1wiTWFza3NcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcclxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcclxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxyXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcclxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxyXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xyXG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcclxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXHJcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XHJcbi8qKioqKiovIFx0XHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcclxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XHJcbi8qKioqKiovIFx0fVxyXG4vKioqKioqL1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XHJcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XHJcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXHJcbi8qKioqKiovIFx0XHRcdH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xyXG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNSk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gdG9JbnRlZ2VyO1xyXG5mdW5jdGlvbiB0b0ludGVnZXIoZGlydHlOdW1iZXIpIHtcclxuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XHJcbiAgICByZXR1cm4gTmFOO1xyXG4gIH1cclxuXHJcbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XHJcblxyXG4gIGlmIChpc05hTihudW1iZXIpKSB7XHJcbiAgICByZXR1cm4gbnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX051bWJlck1hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX051bWJlck1hc2tfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJlXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImdcIl07IH0pO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fW1wiaFwiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJhXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImJcIl07IH0pO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fW1wiZFwiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJmXCJdOyB9KTtcclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY1wiXSA9IChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJjXCIgLyogZGVmYXVsdCAqL10pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gdHpQYXJzZVRpbWV6b25lO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190elRva2VuaXplRGF0ZV9pbmRleF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuXHJcblxyXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwXHJcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDBcclxuXHJcbnZhciBwYXR0ZXJucyA9IHtcclxuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxyXG4gIHRpbWV6b25lWjogL14oWikkLyxcclxuICB0aW1lem9uZUhIOiAvXihbKy1dKShcXGR7Mn0pJC8sXHJcbiAgdGltZXpvbmVISE1NOiAvXihbKy1dKShcXGR7Mn0pOj8oXFxkezJ9KSQvLFxyXG4gIHRpbWV6b25lSUFOQTogLyhVVEN8KD86W2EtekEtWl0rXFwvW2EtekEtWl9dKyg/OlxcL1thLXpBLVpfXSspPykpJC9cclxufVxyXG5cclxuLy8gUGFyc2UgdmFyaW91cyB0aW1lIHpvbmUgb2Zmc2V0IGZvcm1hdHMgdG8gYW4gb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xyXG5mdW5jdGlvbiB0elBhcnNlVGltZXpvbmUodGltZXpvbmVTdHJpbmcsIGRhdGUpIHtcclxuICB2YXIgdG9rZW5cclxuICB2YXIgYWJzb2x1dGVPZmZzZXRcclxuXHJcbiAgLy8gWlxyXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVaLmV4ZWModGltZXpvbmVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICByZXR1cm4gMFxyXG4gIH1cclxuXHJcbiAgdmFyIGhvdXJzXHJcblxyXG4gIC8vIMKxaGhcclxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSEguZXhlYyh0aW1lem9uZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycykpIHtcclxuICAgICAgcmV0dXJuIE5hTlxyXG4gICAgfVxyXG5cclxuICAgIGFic29sdXRlT2Zmc2V0ID0gaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUlxyXG4gICAgcmV0dXJuIHRva2VuWzFdID09PSAnKycgPyAtYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldFxyXG4gIH1cclxuXHJcbiAgLy8gwrFoaDptbSBvciDCsWhobW1cclxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSEhNTS5leGVjKHRpbWV6b25lU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXHJcbiAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KHRva2VuWzNdLCAxMClcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlVGltZXpvbmUoaG91cnMsIG1pbnV0ZXMpKSB7XHJcbiAgICAgIHJldHVybiBOYU5cclxuICAgIH1cclxuXHJcbiAgICBhYnNvbHV0ZU9mZnNldCA9XHJcbiAgICAgIGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxyXG4gICAgcmV0dXJuIHRva2VuWzFdID09PSAnKycgPyAtYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldFxyXG4gIH1cclxuXHJcbiAgLy8gSUFOQSB0aW1lIHpvbmVcclxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSUFOQS5leGVjKHRpbWV6b25lU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgLy8gdmFyIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSB0elRva2VuaXplRGF0ZShkYXRlLCB0aW1lem9uZVN0cmluZylcclxuICAgIHZhciB0b2tlbnMgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX190elRva2VuaXplRGF0ZV9pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkYXRlLCB0aW1lem9uZVN0cmluZylcclxuICAgIHZhciBhc1VUQyA9IERhdGUuVVRDKFxyXG4gICAgICB0b2tlbnNbMF0sXHJcbiAgICAgIHRva2Vuc1sxXSAtIDEsXHJcbiAgICAgIHRva2Vuc1syXSxcclxuICAgICAgdG9rZW5zWzNdLFxyXG4gICAgICB0b2tlbnNbNF0sXHJcbiAgICAgIHRva2Vuc1s1XVxyXG4gICAgKVxyXG4gICAgdmFyIHRpbWVzdGFtcFdpdGhNc1plcm9lZCA9IGRhdGUuZ2V0VGltZSgpIC0gKGRhdGUuZ2V0VGltZSgpICUgMTAwMClcclxuICAgIHJldHVybiAtKGFzVVRDIC0gdGltZXN0YW1wV2l0aE1zWmVyb2VkKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIDBcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykge1xyXG4gIGlmIChtaW51dGVzICE9IG51bGwgJiYgKG1pbnV0ZXMgPCAwIHx8IG1pbnV0ZXMgPiA1OSkpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19TdHJpbmdNYXNrX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fU3RyaW5nTWFza19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJVdGlsc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFV0aWxzOyB9KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1N0cmluZ01hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1R5cGVzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiVHlwZXNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1R5cGVzX19bXCJhXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiTnVtYmVyTWFza1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fW1wiYVwiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkRhdGVNYXNrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fW1wiY1wiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlN0cmluZ01hc2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1N0cmluZ01hc2tfX1tcImFcIl07IH0pO1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcblxyXG5cclxuXHJcbnZhciBVdGlscyA9IHtcclxuICBEYXRlczoge1xyXG4gICAgZ2V0RGF5T2ZZZWFyOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJlXCIgLyogZ2V0RGF5T2ZZZWFyICovXSxcclxuICAgIGdldFdlZWtOdW1iZXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImdcIiAvKiBnZXRXZWVrTnVtYmVyICovXSxcclxuICAgIGdldFdlZWtTdGFydEJ5TG9jYWxlOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJoXCIgLyogZ2V0V2Vla1N0YXJ0QnlMb2NhbGUgKi9dLFxyXG4gICAgSVNfREFURV9SRUdFWDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fW1wiYVwiIC8qIElTX0RBVEVfUkVHRVggKi9dLFxyXG4gICAgSVNfVElNRV9SRUdFWDogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fW1wiYlwiIC8qIElTX1RJTUVfUkVHRVggKi9dLFxyXG4gICAgZml4U2hvcnRJU086IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImRcIiAvKiBmaXhTaG9ydElTTyAqL10sXHJcbiAgICBnZXRUaW1lem9uZU9yT2Zmc2V0OiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJmXCIgLyogZ2V0VGltZXpvbmVPck9mZnNldCAqL11cclxuICB9XHJcbn07XHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19UeXBlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcblxyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBOdW1iZXJNYXNrXHJcbiAqXHJcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBmb3IgQkJqIG51bWJlcnMgbWFza2luZ1xyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxyXG4gKi9cclxudmFyIE51bWJlck1hc2sgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBOdW1iZXJNYXNrKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlck1hc2spO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKE51bWJlck1hc2ssIG51bGwsIFt7XHJcbiAgICBrZXk6IFwibWFza1wiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFzayB0aGUgZ2l2ZW4gbnVtYmVyIHdpdGggdGhlIGdpdmVuIG1hc2sgYWNjb3JkaW5nIHRvIEJCaiBydWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgdGhlIG51bWJlciB0byBmb3JtYXRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrIHRoZSBtYXNrIHRvIHVzZSBmb3IgZm9ybWF0dGluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtncm91cGluZ1NlcGFyYXRvcj0sXSAtIGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBncm91cGluZyBzZXBhcmF0b3JcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVjaW1hbFNlcGFyYXRvcj0uXSAgLSBhIGNoYXIgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlVHJhaWxpbmdaZXJvcz1mYWxzZV0gLSBBZmZlY3RzIHRoZSBvdXRwdXQgYnkgc3dpdGNoaW5nIHRoZSB3YXkgYSBtYXNrIHdpdGggXCIjXCIgY2hhcmFjdGVycyBpbiB0aGUgdHJhaWxpbmcgcG9zaXRpb25zIGlzIGZpbGxlZC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCB0aGUgZnVuY3Rpb24gYE51bWJlck1hc2subWFzayguMTA6XCIjLiMjXCIpYCByZXR1cm5zIGAgLjEwYCBpbnN0ZWFkIG9mIGAgLjEgYFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9dHJ1ZV0gd2hlbiB0cnVlICwgZXJyb3JzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCB3aWxsIHRyeSBhdCBhcHBseSB0aGUgbWFza1xyXG4gICAgICogICAgICAgICAgICAgICAgYW55d2F5ICwgb3RoZXJ3aXNlIGl0IHdpbGwgc3RvcCBhdCBmaXJzdCBlcnJvciBhbmQgdGhyb3cgaXQuXHJcbiAgICAgKiBcclxuICAgICAqIEB0aHJvd3Mge01hc2tFcnJvcn0gb25seSBpZiBsb29zZSBpcyBkaXNhYmxlZFxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgbWFza2VkIG51bWJlclxyXG4gICAgICovXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFzayhudW1iZXIsIF9tYXNrKSB7XHJcbiAgICAgIHZhciBncm91cGluZ1NlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJywnO1xyXG4gICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJy4nO1xyXG4gICAgICB2YXIgZm9yY2VUcmFpbGluZ1plcm9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcclxuICAgICAgdmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xyXG4gICAgICB2YXIgbWFza0xlbiA9IF9tYXNrLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmICgwID09PSBtYXNrTGVuKSB7XHJcbiAgICAgICAgaWYgKGxvb3NlKSByZXR1cm4gc3RyOyAvLyBmcmllbmRseSBzaWxlbnQgZmFpbFxyXG4gICAgICAgIGVsc2UgdGhyb3cge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFza0Vycm9yJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogXCJNYXNrRXJyb3I6IE1hc2sgaXMgZW1wdHlcIlxyXG4gICAgICAgICAgfTtcclxuICAgICAgfSAvLyBHZXQgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTUFTS1xyXG5cclxuXHJcbiAgICAgIHZhciBtYXNrQmVmb3JlRGVjaW1hbCA9IDA7XHJcbiAgICAgIHZhciBtYXNrQWZ0ZXJEZWNpbWFsID0gMDtcclxuICAgICAgdmFyIGZvdW5kRGVjaW1hbCA9IGZhbHNlO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrTGVuOyArK2kpIHtcclxuICAgICAgICB2YXIgbSA9IF9tYXNrLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgaWYgKG0gPT0gJzAnIHx8IG0gPT0gJyMnKSB7XHJcbiAgICAgICAgICBpZiAoZm91bmREZWNpbWFsKSArK21hc2tBZnRlckRlY2ltYWw7ZWxzZSArK21hc2tCZWZvcmVEZWNpbWFsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobSA9PSAnLicpIGZvdW5kRGVjaW1hbCA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBudW0gPSBOdW1iZXJNYXNrLl9yb3VuZChudW1iZXIsIG1hc2tBZnRlckRlY2ltYWwpO1xyXG5cclxuICAgICAgdmFyIGJ5dGVzID0gTnVtYmVyTWFzay5fdG9DaGFyQXJyYXkobnVtKTsgLy8gR2V0IG1hZ25pdHVkZSBhbmQgcHJlY2lzaW9uIG9mIE5VTUJFUlxyXG5cclxuXHJcbiAgICAgIHZhciBpbkxlbiA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgdmFyIG51bUJlZm9yZURlY2ltYWwgPSAwO1xyXG4gICAgICB2YXIgbnVtQWZ0ZXJEZWNpbWFsID0gMDtcclxuICAgICAgZm91bmREZWNpbWFsID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5MZW47ICsrX2kpIHtcclxuICAgICAgICBpZiAoYnl0ZXNbX2ldID09ICcuJykgZm91bmREZWNpbWFsID0gdHJ1ZTtlbHNlIHtcclxuICAgICAgICAgIGlmIChmb3VuZERlY2ltYWwpICsrbnVtQWZ0ZXJEZWNpbWFsO2Vsc2UgKytudW1CZWZvcmVEZWNpbWFsO1xyXG4gICAgICAgIH1cclxuICAgICAgfSAvLyBhbHdheXMgaWdub3JlIG1hc2sgb3ZlcmZsb3dcclxuXHJcblxyXG4gICAgICBpZiAobnVtQmVmb3JlRGVjaW1hbCA+IG1hc2tCZWZvcmVEZWNpbWFsKSB7XHJcbiAgICAgICAgaWYgKGxvb3NlKSByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCk7IC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgICAgZWxzZSB0aHJvdyB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYXNrRXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk1hc2tFcnJvcjogTnVtYmVyIGlzIHRvbyBsYXJnZSBmb3IgbWFza1wiXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9IC8vIHJvdW5kIGlmIG1hc2sgaXMgZm9yIGEgbG93ZXIgcHJlY2lzaW9uIG51bWJlclxyXG5cclxuXHJcbiAgICAgIGlmIChudW1BZnRlckRlY2ltYWwgPiBtYXNrQWZ0ZXJEZWNpbWFsKSB7XHJcbiAgICAgICAgbnVtID0gTnVtYmVyTWFzay5fcm91bmQobnVtLCBtYXNrQWZ0ZXJEZWNpbWFsKTtcclxuICAgICAgICBieXRlcyA9IE51bWJlck1hc2suX3RvQ2hhckFycmF5KG51bSk7XHJcbiAgICAgICAgaW5MZW4gPSBieXRlcy5sZW5ndGg7IC8vIEdldCBuZXcgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTlVNQkVSXHJcblxyXG4gICAgICAgIG51bUJlZm9yZURlY2ltYWwgPSAwO1xyXG4gICAgICAgIG51bUFmdGVyRGVjaW1hbCA9IDA7XHJcbiAgICAgICAgZm91bmREZWNpbWFsID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluTGVuOyArK19pMikge1xyXG4gICAgICAgICAgaWYgKGJ5dGVzW19pMl0gPT0gJy4nKSBmb3VuZERlY2ltYWwgPSB0cnVlO2Vsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZm91bmREZWNpbWFsKSArK251bUFmdGVyRGVjaW1hbDtlbHNlICsrbnVtQmVmb3JlRGVjaW1hbDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IC8vIGFsd2F5cyBpZ25vcmUgbWFzayBvdmVyZmxvd1xyXG5cclxuXHJcbiAgICAgICAgaWYgKG51bUJlZm9yZURlY2ltYWwgPiBtYXNrQmVmb3JlRGVjaW1hbCkge1xyXG4gICAgICAgICAgaWYgKGxvb3NlKSByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCk7IC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgICAgICBlbHNlIHRocm93IHtcclxuICAgICAgICAgICAgICBuYW1lOiAnTWFza0Vycm9yJyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiBcIk1hc2tFcnJvcjogTnVtYmVyIGlzIHRvbyBsYXJnZSBmb3IgbWFza1wiXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZmlsbEJ5dGUgPSAnICcsXHJcbiAgICAgICAgICBmbG9hdEJ5dGUgPSAnICc7XHJcbiAgICAgIHZhciBpblBvcyA9IDAsXHJcbiAgICAgICAgICBvdXRQb3MgPSAwLFxyXG4gICAgICAgICAgZmxvYXRQb3MgPSAwO1xyXG4gICAgICBpZiAoX21hc2suY2hhckF0KDApID09ICcqJykgZmlsbEJ5dGUgPSAnKic7XHJcbiAgICAgIHZhciBmaWxsSW5pdCA9IGZpbGxCeXRlO1xyXG4gICAgICB2YXIgaXNOZWdhdGl2ZSA9IE51bWJlck1hc2suX2dldFNpZ24obnVtKSA8IDA7XHJcbiAgICAgIHZhciBlbWl0RGVjaW1hbCA9IGluTGVuID4gMCB8fCBfbWFzay5pbmRleE9mKCcwJykgPj0gMDtcclxuICAgICAgdmFyIGZvdW5kWmVybyA9IGZhbHNlO1xyXG4gICAgICB2YXIgZm91bmREaWdpdCA9IGZhbHNlO1xyXG4gICAgICB2YXIgY3VycmVuY3kgPSBmYWxzZTtcclxuICAgICAgZm91bmREZWNpbWFsID0gZmFsc2U7XHJcbiAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFza0xlbik7XHJcblxyXG4gICAgICBmb3IgKHZhciBtYXNrUG9zID0gMDsgbWFza1BvcyA8IG1hc2tMZW47ICsrbWFza1Bvcykge1xyXG4gICAgICAgIHZhciBfbSA9IF9tYXNrLmNoYXJBdChtYXNrUG9zKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChfbSkge1xyXG4gICAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICAgIC0tbWFza0JlZm9yZURlY2ltYWw7XHJcblxyXG4gICAgICAgICAgICBpZiAobWFza0JlZm9yZURlY2ltYWwgPCBudW1CZWZvcmVEZWNpbWFsICYmIGluUG9zIDwgaW5MZW4pIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGJ5dGVzW2luUG9zXTtcclxuICAgICAgICAgICAgICArK2luUG9zO1xyXG4gICAgICAgICAgICAgIGZvdW5kRGlnaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJzAnO1xyXG4gICAgICAgICAgICAgIGZvdW5kWmVybyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICcjJzpcclxuICAgICAgICAgICAgLS1tYXNrQmVmb3JlRGVjaW1hbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXNrQmVmb3JlRGVjaW1hbCA8IG51bUJlZm9yZURlY2ltYWwgJiYgaW5Qb3MgPCBpbkxlbikge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gYnl0ZXNbaW5Qb3NdO1xyXG4gICAgICAgICAgICAgICsraW5Qb3M7XHJcbiAgICAgICAgICAgICAgZm91bmREaWdpdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBmb3VuZERlY2ltYWwgJiYgZm9yY2VUcmFpbGluZ1plcm9zICYmIE51bWJlck1hc2suX2dldFNpZ24obnVtKSAhPSAwID8gJzAnIDogZmlsbEJ5dGU7XHJcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZERlY2ltYWwpIGZsb2F0UG9zID0gbWFza1BvcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgICAgICBpZiAoZm91bmRaZXJvIHx8IGluUG9zID4gMCkgcmV0W291dFBvc10gPSBncm91cGluZ1NlcGFyYXRvcjtlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIGlmICghZm91bmREZWNpbWFsKSBmbG9hdFBvcyA9IG1hc2tQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSBmbG9hdEJ5dGUgPSAnLSc7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZTtcclxuICAgICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1BvcztcclxuICAgICAgICAgICAgfSBlbHNlIHJldFtvdXRQb3NdID0gaXNOZWdhdGl2ZSA/ICctJyA6IGZpbGxCeXRlO1xyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgICAgIGZsb2F0Qnl0ZSA9IGlzTmVnYXRpdmUgPyAnLScgOiAnKyc7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZTtcclxuICAgICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1BvcztcclxuICAgICAgICAgICAgfSBlbHNlIHJldFtvdXRQb3NdID0gaXNOZWdhdGl2ZSA/ICctJyA6ICcrJztcclxuXHJcbiAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICckJzpcclxuICAgICAgICAgICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAgICAgICBmbG9hdEJ5dGUgPSAnJCc7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZTtcclxuICAgICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1BvcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICckJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgLy8gY2FzZSAnJic6XHJcbiAgICAgICAgICAvLyAgIGN1cnJlbmN5ID0gdHJ1ZVxyXG4gICAgICAgICAgLy8gICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgLy8gICAgIGZsb2F0Qnl0ZSA9ICcmJ1xyXG4gICAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgIC8vICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gJyYnXHJcbiAgICAgICAgICAvLyAgIH1cclxuICAgICAgICAgIC8vICAgKytvdXRQb3NcclxuICAgICAgICAgIC8vICAgYnJlYWtcclxuICAgICAgICAgIC8vIGNhc2UgJ0AnOlxyXG4gICAgICAgICAgLy8gICBjdXJyZW5jeSA9IHRydWVcclxuICAgICAgICAgIC8vICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAgIC8vICAgICBmbG9hdEJ5dGUgPSAnQCdcclxuICAgICAgICAgIC8vICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlXHJcbiAgICAgICAgICAvLyAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3NcclxuICAgICAgICAgIC8vICAgfSBlbHNlIHtcclxuICAgICAgICAgIC8vICAgICByZXRbb3V0UG9zXSA9ICdAJ1xyXG4gICAgICAgICAgLy8gICB9XHJcbiAgICAgICAgICAvLyAgICsrb3V0UG9zXHJcbiAgICAgICAgICAvLyAgIGJyZWFrXHJcblxyXG4gICAgICAgICAgY2FzZSAnKCc6XHJcbiAgICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIGZsb2F0Qnl0ZSA9ICcoJztcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcoJztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBmb3VuZERlY2ltYWwgPyAnICcgOiBmaWxsQnl0ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICcpJzpcclxuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcpJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZvdW5kRGVjaW1hbCA/ICcgJyA6IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICAgIGlmIChtYXNrUG9zIDwgbWFza0xlbiAtIDEgJiYgX21hc2suY2hhckF0KG1hc2tQb3MgKyAxKSA9PSAnUicpIHtcclxuICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnQyc7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnUic7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvcyArIDFdID0gJyAnO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgb3V0UG9zICs9IDI7XHJcbiAgICAgICAgICAgICAgKyttYXNrUG9zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0MnO1xyXG4gICAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgICAgaWYgKG1hc2tQb3MgPCBtYXNrTGVuIC0gMSAmJiBfbWFzay5jaGFyQXQobWFza1BvcyArIDEpID09ICdSJykge1xyXG4gICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdDJztcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3MgKyAxXSA9ICdSJztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnRCc7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnUic7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBvdXRQb3MgKz0gMjtcclxuICAgICAgICAgICAgICArK21hc2tQb3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnRCc7XHJcbiAgICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJyonOlxyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcqJztcclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGVtaXREZWNpbWFsID8gZGVjaW1hbFNlcGFyYXRvciA6IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICBmaWxsQnl0ZSA9ICcgJztcclxuICAgICAgICAgICAgZm91bmREZWNpbWFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgKytpblBvcztcclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0InOlxyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcgJztcclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gX207XHJcbiAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChmbG9hdEJ5dGUgIT0gJyAnKSB7XHJcbiAgICAgICAgaWYgKGZsb2F0UG9zIDwgMCkgZmxvYXRQb3MgPSBvdXRQb3M7XHJcblxyXG4gICAgICAgIHdoaWxlIChmbG9hdFBvcyA+PSBtYXNrTGVuKSB7XHJcbiAgICAgICAgICAtLWZsb2F0UG9zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJldFtmbG9hdFBvc10gPT0gZmlsbEluaXQpIHJldFtmbG9hdFBvc10gPSBmbG9hdEJ5dGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9zaGlmdFwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdChudW1iZXIsIHByZWNpc2lvbiwgcmV2ZXJzZVNoaWZ0KSB7XHJcbiAgICAgIGlmIChyZXZlcnNlU2hpZnQpIHByZWNpc2lvbiA9IC1wcmVjaXNpb247XHJcbiAgICAgIHZhciBudW1BcnJheSA9ICgnJyArIG51bWJlcikuc3BsaXQoJ2UnKTtcclxuICAgICAgcmV0dXJuICsobnVtQXJyYXlbMF0gKyAnZScgKyAobnVtQXJyYXlbMV0gPyArbnVtQXJyYXlbMV0gKyBwcmVjaXNpb24gOiBwcmVjaXNpb24pKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX3JvdW5kXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JvdW5kKG51bWJlciwgcHJlY2lzaW9uKSB7XHJcbiAgICAgIHJldHVybiBOdW1iZXJNYXNrLl9zaGlmdChNYXRoLnJvdW5kKE51bWJlck1hc2suX3NoaWZ0KG51bWJlciwgcHJlY2lzaW9uLCBmYWxzZSkpLCBwcmVjaXNpb24sIHRydWUpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfdG9DaGFyQXJyYXlcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9DaGFyQXJyYXkobnVtYmVyKSB7XHJcbiAgICAgIHZhciBzaWdudW0gPSBOdW1iZXJNYXNrLl9nZXRTaWduKG51bWJlcik7XHJcblxyXG4gICAgICB2YXIgY2hhcnMgPSBbXTtcclxuXHJcbiAgICAgIGlmIChzaWdudW0gIT09IDApIHtcclxuICAgICAgICB2YXIgc3RyaW5nID0gc2lnbnVtIDwgMCA/IFwiXCIuY29uY2F0KC0xICogbnVtYmVyLnRvU3RyaW5nKCkpIDogbnVtYmVyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJzAnKSBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKDEpOyAvLyBUaGUgc3RyaW5nIGNvbnRhaW5zIG9ubHkgWzAtOV0gYW5kICcuJ1xyXG5cclxuICAgICAgICBjaGFycyA9IHN0cmluZy5zcGxpdCgnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjaGFycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IG51bWJlclxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBvciBuZWdhdGl2ZSB6ZXJvLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gMSwgLTEsIDAgb3IgLTAgcmVzcGVjdGl2ZWx5LlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9nZXRTaWduXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNpZ24oeCkge1xyXG4gICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gTnVtYmVyTWFzaztcclxufSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChOdW1iZXJNYXNrKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIElTX1RJTUVfUkVHRVg7IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIElTX0RBVEVfUkVHRVg7IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdlZWtTdGFydEJ5TG9jYWxlOyB9KTtcclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImVcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREYXlPZlllYXI7IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZpeFNob3J0SVNPOyB9KTtcclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImZcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRUaW1lem9uZU9yT2Zmc2V0OyB9KTtcclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXZWVrTnVtYmVyOyB9KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kYXRlX2Zuc190el91dGNUb1pvbmVkVGltZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV93ZWVrc3RhcnRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuXHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuXHJcbnZhciBJU19USU1FX1JFR0VYID0gL14oMlswLTNdfFswMV1bMC05XSk6PyhbMC01XVswLTldKTo/KFswLTVdWzAtOV0pKFp8WystXSg/OjJbMC0zXXxbMDFdWzAtOV0pKD86Oj8oPzpbMC01XVswLTldKSk/KSQvO1xyXG52YXIgSVNfREFURV9SRUdFWCA9IC9eKChbMTJdXFxkezN9KS0oMFsxLTldfDFbMC0yXSktKDBbMS05XXxbMTJdXFxkfDNbMDFdKShafFsrLV0oPzoyWzAtM118WzAxXVswLTldKSg/Ojo/KD86WzAtNV1bMC05XSkpPykpJC87XHJcbi8qKlxyXG4gKiBGaW5kIG91dCB3aGVuIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIHBhc3NlZCBsb2NhbGVcclxuICpcclxuICogQHBhcmFtIHtsb2NhbGV9IGxvY2FsZVxyXG4gKlxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGEgbnVtYmVyIDAgPSBzdW5kYXkgLCAxID0gbW9uZGF5ICwgLi4uLlxyXG4gKi9cclxuXHJcbnZhciBnZXRXZWVrU3RhcnRCeUxvY2FsZSA9IGZ1bmN0aW9uIGdldFdlZWtTdGFydEJ5TG9jYWxlKGxvY2FsZSkge1xyXG4gIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3dlZWtzdGFydF9fW1wiYVwiIC8qIGdldFdlZWtTdGFydEJ5TG9jYWxlICovXSkobG9jYWxlKTtcclxufTtcclxuLyoqXHJcbiAqICBHZXQgZGF5IG51bWJlciBpbiB0aGUgeWVhciBvZiB0aGUgcGFzc2VkIGRhdGVcclxuICpcclxuICogQHBhcmFtIHtEYXRlfSBkYXRlXHJcbiAqXHJcbiAqIEByZXR1cm4ge051bWJlcn0gZGF5IG51bWJlclxyXG4gKi9cclxuXHJcbnZhciBnZXREYXlPZlllYXIgPSBmdW5jdGlvbiBnZXREYXlPZlllYXIoZGF0ZSkge1xyXG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMCk7XHJcbiAgdmFyIGRpZmYgPSBkYXRlIC0gc3RhcnQgKyAoc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiA2MCAqIDEwMDA7XHJcbiAgdmFyIG9uZURheSA9IDEwMDAgKiA2MCAqIDYwICogMjQ7XHJcbiAgdmFyIGRheSA9IE1hdGguZmxvb3IoZGlmZiAvIG9uZURheSk7XHJcbiAgcmV0dXJuIGRheTtcclxufTtcclxuLyoqXHJcbiAqIFRha2VzIGluY29tcGxldGUgaXNvIHN0cmluZyBhbmQgcmV0dXJuIGEgY29tcGxldGUgb25lXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIGluY29tcGxldGUgaXNvIHN0cmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNvbXBsZXRlIGlzbyBzdHJpbmdcclxuICovXHJcblxyXG52YXIgZml4U2hvcnRJU08gPSBmdW5jdGlvbiBmaXhTaG9ydElTTyhkYXRlKSB7XHJcbiAgdmFyIHZhbHVlID0gZGF0ZTtcclxuICB2YXIgb2Zmc2V0ID0gKHZhbHVlLm1hdGNoKC96JHxbK1xcLV1cXGRcXGQ6XFxkXFxkJC9pKSB8fCBbXSlbMF07XHJcblxyXG4gIGlmICghb2Zmc2V0KSB7XHJcbiAgICBvZmZzZXQgPSAnWic7XHJcbiAgICB2YWx1ZSArPSBvZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBpZiAoSVNfVElNRV9SRUdFWC50ZXN0KHZhbHVlKSkge1xyXG4gICAgdmFsdWUgPSBcIjE5NzAtMDEtMDFUXCIuY29uY2F0KHZhbHVlKTtcclxuICB9IGVsc2UgaWYgKElTX0RBVEVfUkVHRVgudGVzdCh2YWx1ZSkpIHtcclxuICAgIHZhbHVlID0gXCJcIi5jb25jYXQodmFsdWUuc3BsaXQob2Zmc2V0KVswXSwgXCJUMDA6MDA6MDBcIikuY29uY2F0KG9mZnNldCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsdWU7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIGJyb3dzZXIgdGltZXpvbmUgbmFtZSAsIGlmIG5vdCBzdXBwb3J0ZWQgdGhlbiB0aGUgYnJvd3NlclxyXG4gKiB0aW1lem9uZSBvZmZzZXQgZm9ybWF0dGVkXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gdGltZXpvbmUgb2Ygb2Zmc2V0XHJcbiAqL1xyXG5cclxudmFyIGdldFRpbWV6b25lT3JPZmZzZXQgPSBmdW5jdGlvbiBnZXRUaW1lem9uZU9yT2Zmc2V0KCkge1xyXG4gIHZhciB0aW1lem9uZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcclxuXHJcbiAgaWYgKCF0aW1lem9uZSkge1xyXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChudW1iZXIsIGxlbmd0aCkge1xyXG4gICAgICB2YXIgc3RyID0gJycgKyBudW1iZXI7XHJcblxyXG4gICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xyXG4gICAgICAgIHN0ciA9ICcwJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcclxuICAgIG9mZnNldCA9IChvZmZzZXQgPCAwID8gJysnIDogJy0nKSArIC8vIE5vdGUgdGhlIHJldmVyc2VkIHNpZ24hXHJcbiAgICBwYWQocGFyc2VJbnQoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSwgMikgKyBwYWQoTWF0aC5hYnMob2Zmc2V0ICUgNjApLCAyKTtcclxuICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGltZXpvbmU7XHJcbn07XHJcbi8qKlxyXG4gKiBHZXQgdGhlIFdlZWsgTnVtYmVyIGluIHRoZSBwYXNzZWQgZGF0ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGUgLSBEYXRlIG9iamVjdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2Vla1N0YXJ0IEEgbnVtYmVyIHdoaWNoIGRlZmluZXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAgPSBzdW5kYXkgLCAxID0gbW9uZGF5ICwgLi4uKVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgd2VlayBudW1iZXJcclxuICovXHJcblxyXG52YXIgZ2V0V2Vla051bWJlciA9IGZ1bmN0aW9uIGdldFdlZWtOdW1iZXIoZGF0ZSwgd2Vla1N0YXJ0KSB7XHJcbiAgdmFyIGQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpKTtcclxuICB2YXIgZGF5TnVtID0gZC5nZXRVVENEYXkoKSAtICh3ZWVrU3RhcnQgLSAxKSB8fCA3O1xyXG4gIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIDQgLSBkYXlOdW0pO1xyXG4gIHZhciB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKTtcclxuICByZXR1cm4gTWF0aC5jZWlsKCgoZCAtIHllYXJTdGFydCkgLyA4NjQwMDAwMCArIDEpIC8gNyk7XHJcbn07XHJcbi8qKlxyXG4gKiBEYXRlTWFza1xyXG4gKlxyXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gZm9yIEJCaiBkYXRlcyBtYXNraW5nXHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG5cclxudmFyIERhdGVNYXNrID1cclxuLyojX19QVVJFX18qL1xyXG5mdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gRGF0ZU1hc2soKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0ZU1hc2spO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKERhdGVNYXNrLCBudWxsLCBbe1xyXG4gICAga2V5OiBcIm1hc2tcIixcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hc2sgZGF0ZVxyXG4gICAgICpcclxuICAgICAqIE1hc2sgdGhlIHBhc3NlZCBkYXRlIHdpdGggdGhlIHBhc3NlZCBtYXNrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGUgZGF0ZSBhcyBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgbWFzayBhcyBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtsb2NhbGU9QnJvd3NlcidzIGxvY2FsZV0gdGhlIGxhbmd1YWdlIHRvIHVzZSBleChlbi1VUykuIGRlZmF1bHQgaXMgdG8gdGhlIHN5c3RlbSBsYW5ndWFnZVxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt0aW1lem9uZT1TeXN0ZW0gdGltZXpvbmVdIHRoZSB0aW1lIHpvbmUgZGVzY3JpcHRvciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKS4gZGVmYXVsdCB0byB0aGUgc3lzdGVtXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGEgZGF0ZSBtYXNrZWQgd2l0aCB0aGUgZ2l2ZW4gbWFza1xyXG4gICAgICovXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFzayhkYXRlLCBfbWFzaywgbG9jYWxlLCB0aW1lem9uZSkge1xyXG4gICAgICBpZiAoIWRhdGUpIHJldHVybiAnJztcclxuICAgICAgaWYgKCFfbWFzaykgcmV0dXJuIGRhdGU7XHJcbiAgICAgIHRpbWV6b25lID0gdGltZXpvbmUgfHwgZ2V0VGltZXpvbmVPck9mZnNldCgpO1xyXG4gICAgICBsb2NhbGUgPSBsb2NhbGUgfHwgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZSB8fCAnZW4tVVMnOyAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhIGNvbXBsZXRlIGlzbyBzdHJpbmdcclxuXHJcbiAgICAgIGRhdGUgPSBkYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGUgOiBmaXhTaG9ydElTTyhkYXRlKTtcclxuICAgICAgdmFyIGRhdGVPYmplY3QgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2RhdGVfZm5zX3R6X3V0Y1RvWm9uZWRUaW1lX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRhdGUsIHRpbWV6b25lKTtcclxuXHJcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IERhdGVNYXNrLl9idWlsZFRyYW5zbGF0aW9uKHtcclxuICAgICAgICB5ZWFyOiBkYXRlT2JqZWN0LmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgbW9udGg6IGRhdGVPYmplY3QuZ2V0TW9udGgoKSArIDEsXHJcbiAgICAgICAgbW9udGhTaG9ydDogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW2xvY2FsZV0sIHtcclxuICAgICAgICAgIG1vbnRoOiAnc2hvcnQnXHJcbiAgICAgICAgfSkuZm9ybWF0KGRhdGVPYmplY3QpLFxyXG4gICAgICAgIG1vbnRoTG9uZzogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW2xvY2FsZV0sIHtcclxuICAgICAgICAgIG1vbnRoOiAnbG9uZydcclxuICAgICAgICB9KS5mb3JtYXQoZGF0ZU9iamVjdCksXHJcbiAgICAgICAgZGF5OiBkYXRlT2JqZWN0LmdldERhdGUoKSxcclxuICAgICAgICBkYXlTaG9ydDogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW2xvY2FsZV0sIHtcclxuICAgICAgICAgIHdlZWtkYXk6ICdzaG9ydCdcclxuICAgICAgICB9KS5mb3JtYXQoZGF0ZU9iamVjdCksXHJcbiAgICAgICAgZGF5TG9uZzogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoW2xvY2FsZV0sIHtcclxuICAgICAgICAgIHdlZWtkYXk6ICdsb25nJ1xyXG4gICAgICAgIH0pLmZvcm1hdChkYXRlT2JqZWN0KSxcclxuICAgICAgICBtaW51dGVzOiBkYXRlT2JqZWN0LmdldE1pbnV0ZXMoKSxcclxuICAgICAgICBzZWNvbmRzOiBkYXRlT2JqZWN0LmdldFNlY29uZHMoKSxcclxuXHJcbiAgICAgICAgZ2V0IGhvdXJzMjQoKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0ZU9iamVjdC5nZXRIb3VycygpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCBob3VyczEyKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMyNCAlIDEyIHx8IDEyO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRheU9mWWVhcjogZ2V0RGF5T2ZZZWFyKGRhdGVPYmplY3QpLFxyXG4gICAgICAgIGRheU9mV2VlazogZGF0ZU9iamVjdC5nZXREYXkoKSArIDEsXHJcbiAgICAgICAgLy8gU3VuZGF5ID0gMSBpbiBCQmogYnV0IFN1bmRheSA9IDAgaW4gSlNcclxuICAgICAgICB3ZWVrTnVtYmVyOiBnZXRXZWVrTnVtYmVyKGRhdGVPYmplY3QsIGdldFdlZWtTdGFydEJ5TG9jYWxlKGxvY2FsZSkpLFxyXG4gICAgICAgIGxvY2FsZTogbG9jYWxlLFxyXG4gICAgICAgIHRpbWV6b25lOiB0aW1lem9uZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBfbWFzaztcclxuXHJcbiAgICAgIGZvciAodmFyIGsgaW4gdHJhbnNsYXRpb24pIHtcclxuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShuZXcgUmVnRXhwKCcoJScgKyBrICsgJyknLCAnZycpLCB0cmFuc2xhdGlvbltrXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG1hcCBvYmplY3Qgd2hpY2ggY29udGFpbnMgYWxsIHBvc3NpYmxlIGZvcm1zIG9mIG1hc2tzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGVEZXRhaWxzIGRhdGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGZvcm1zIG1hc2tzXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl9idWlsZFRyYW5zbGF0aW9uXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkVHJhbnNsYXRpb24oZGF0ZURldGFpbHMpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAvLyB5ZWFyXHJcbiAgICAgICAgWXo6IGRhdGVEZXRhaWxzLnllYXIudG9TdHJpbmcoKS5zdWJzdHIoLTIpLFxyXG4gICAgICAgIFlzOiBkYXRlRGV0YWlscy55ZWFyLFxyXG4gICAgICAgIFlsOiBkYXRlRGV0YWlscy55ZWFyLFxyXG4gICAgICAgIFlwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLnllYXIpLFxyXG4gICAgICAgIFlkOiBkYXRlRGV0YWlscy55ZWFyLFxyXG4gICAgICAgIFk6IGRhdGVEZXRhaWxzLnllYXIsXHJcbiAgICAgICAgLy8gbW9udGhcclxuICAgICAgICBNejogU3RyaW5nKGRhdGVEZXRhaWxzLm1vbnRoKS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLm1vbnRoIDogZGF0ZURldGFpbHMubW9udGgsXHJcbiAgICAgICAgTXM6IGRhdGVEZXRhaWxzLm1vbnRoU2hvcnQsXHJcbiAgICAgICAgTWw6IGRhdGVEZXRhaWxzLm1vbnRoTG9uZyxcclxuICAgICAgICBNcDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRlRGV0YWlscy5tb250aCksXHJcbiAgICAgICAgTWQ6IGRhdGVEZXRhaWxzLm1vbnRoLFxyXG4gICAgICAgIE06IGRhdGVEZXRhaWxzLm1vbnRoLFxyXG4gICAgICAgIC8vIGRheVxyXG4gICAgICAgIER6OiBTdHJpbmcoZGF0ZURldGFpbHMuZGF5KS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLmRheSA6IGRhdGVEZXRhaWxzLmRheSxcclxuICAgICAgICBEczogZGF0ZURldGFpbHMuZGF5U2hvcnQsXHJcbiAgICAgICAgRGw6IGRhdGVEZXRhaWxzLmRheUxvbmcsXHJcbiAgICAgICAgRHA6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMuZGF5KSxcclxuICAgICAgICBEZDogZGF0ZURldGFpbHMuZGF5LFxyXG4gICAgICAgIEQ6IGRhdGVEZXRhaWxzLmRheSxcclxuICAgICAgICAvLyBob3VyIDI0XHJcbiAgICAgICAgSHo6IFN0cmluZyhkYXRlRGV0YWlscy5ob3VyczI0KS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLmhvdXJzMjQgOiBkYXRlRGV0YWlscy5ob3VyczI0LFxyXG4gICAgICAgIEhzOiBkYXRlRGV0YWlscy5ob3VyczI0LFxyXG4gICAgICAgIEhsOiBkYXRlRGV0YWlscy5ob3VyczI0LFxyXG4gICAgICAgIEhwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLmhvdXJzMjQpLFxyXG4gICAgICAgIEhkOiBkYXRlRGV0YWlscy5ob3VyczI0LFxyXG4gICAgICAgIEg6IGRhdGVEZXRhaWxzLmhvdXJzMjQsXHJcbiAgICAgICAgLy8gaG91ciAxMlxyXG4gICAgICAgIGh6OiBTdHJpbmcoZGF0ZURldGFpbHMuaG91cnMxMikubGVuZ3RoID09IDEgPyAnMCcgKyBkYXRlRGV0YWlscy5ob3VyczEyIDogZGF0ZURldGFpbHMuaG91cnMxMixcclxuICAgICAgICBoczogZGF0ZURldGFpbHMuaG91cnMxMixcclxuICAgICAgICBobDogZGF0ZURldGFpbHMuaG91cnMxMixcclxuICAgICAgICBocDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRlRGV0YWlscy5ob3VyczEyKSxcclxuICAgICAgICBoZDogZGF0ZURldGFpbHMuaG91cnMxMixcclxuICAgICAgICBoOiBkYXRlRGV0YWlscy5ob3VyczEyLFxyXG4gICAgICAgIC8vIG1pbnV0ZXNcclxuICAgICAgICBtejogU3RyaW5nKGRhdGVEZXRhaWxzLm1pbnV0ZXMpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMubWludXRlcyA6IGRhdGVEZXRhaWxzLm1pbnV0ZXMsXHJcbiAgICAgICAgbXM6IGRhdGVEZXRhaWxzLm1pbnV0ZXMsXHJcbiAgICAgICAgbWw6IGRhdGVEZXRhaWxzLm1pbnV0ZXMsXHJcbiAgICAgICAgbXA6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMubWludXRlcyksXHJcbiAgICAgICAgbWQ6IGRhdGVEZXRhaWxzLm1pbnV0ZXMsXHJcbiAgICAgICAgbTogZGF0ZURldGFpbHMubWludXRlcyxcclxuICAgICAgICAvLyBzZWNvbmRzXHJcbiAgICAgICAgc3o6IFN0cmluZyhkYXRlRGV0YWlscy5zZWNvbmRzKS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLnNlY29uZHMgOiBkYXRlRGV0YWlscy5zZWNvbmRzLFxyXG4gICAgICAgIHNzOiBkYXRlRGV0YWlscy5zZWNvbmRzLFxyXG4gICAgICAgIHNsOiBkYXRlRGV0YWlscy5zZWNvbmRzLFxyXG4gICAgICAgIHNwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLnNlY29uZHMpLFxyXG4gICAgICAgIHNkOiBkYXRlRGV0YWlscy5zZWNvbmRzLFxyXG4gICAgICAgIHM6IGRhdGVEZXRhaWxzLnNlY29uZHMsXHJcbiAgICAgICAgLy8gQU0gLCBQTVxyXG4gICAgICAgIFBQOiBkYXRlRGV0YWlscy5ob3VyczI0ID4gMTIgPyAnUE0nIDogJ1BNJyxcclxuICAgICAgICBQOiBkYXRlRGV0YWlscy5ob3VyczI0ID4gMTIgPyAnUE0nIDogJ0FNJyxcclxuICAgICAgICBwcDogZGF0ZURldGFpbHMuaG91cnMyNCA+IDEyID8gJ3BtJyA6ICdhbScsXHJcbiAgICAgICAgcDogZGF0ZURldGFpbHMuaG91cnMyNCA+IDEyID8gJ3BtJyA6ICdhbScsXHJcbiAgICAgICAgLy8gRGF5IG9mIFllYXJcclxuICAgICAgICBKejogU3RyaW5nKGRhdGVEZXRhaWxzLmRheU9mWWVhcikubGVuZ3RoID09IDEgPyAnMCcgKyBkYXRlRGV0YWlscy5kYXlPZlllYXIgOiBkYXRlRGV0YWlscy5kYXlPZlllYXIsXHJcbiAgICAgICAgSnM6IGRhdGVEZXRhaWxzLmRheU9mWWVhcixcclxuICAgICAgICBKbDogZGF0ZURldGFpbHMuZGF5T2ZZZWFyLFxyXG4gICAgICAgIEpkOiBkYXRlRGV0YWlscy5kYXlPZlllYXIsXHJcbiAgICAgICAgSjogZGF0ZURldGFpbHMuZGF5T2ZZZWFyLFxyXG4gICAgICAgIC8vIERheSBPZiBXZWVrXHJcbiAgICAgICAgV3o6IFN0cmluZyhkYXRlRGV0YWlscy5kYXlPZldlZWspLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMuZGF5T2ZXZWVrIDogZGF0ZURldGFpbHMuZGF5T2ZXZWVrLFxyXG4gICAgICAgIFdzOiBkYXRlRGV0YWlscy5kYXlPZldlZWssXHJcbiAgICAgICAgV2w6IGRhdGVEZXRhaWxzLmRheU9mV2VlayxcclxuICAgICAgICBXcDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRlRGV0YWlscy5kYXlPZldlZWspLFxyXG4gICAgICAgIFdkOiBkYXRlRGV0YWlscy5kYXlPZldlZWssXHJcbiAgICAgICAgVzogZGF0ZURldGFpbHMuZGF5T2ZXZWVrLFxyXG4gICAgICAgIC8vIHdlZWsgbnVtYmVyXHJcbiAgICAgICAgd3o6IFN0cmluZyhkYXRlRGV0YWlscy53ZWVrTnVtYmVyKS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLndlZWtOdW1iZXIgOiBkYXRlRGV0YWlscy53ZWVrTnVtYmVyLFxyXG4gICAgICAgIHdzOiBkYXRlRGV0YWlscy53ZWVrTnVtYmVyLFxyXG4gICAgICAgIHdsOiBkYXRlRGV0YWlscy53ZWVrTnVtYmVyLFxyXG4gICAgICAgIHdwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLndlZWtOdW1iZXIpLFxyXG4gICAgICAgIHdkOiBkYXRlRGV0YWlscy53ZWVrTnVtYmVyLFxyXG4gICAgICAgIHc6IGRhdGVEZXRhaWxzLndlZWtOdW1iZXJcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBEYXRlTWFzaztcclxufSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiY1wiXSA9IChEYXRlTWFzayk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSB1dGNUb1pvbmVkVGltZTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbGliX3R6UGFyc2VUaW1lem9uZV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fc3ViTWlsbGlzZWNvbmRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdG9EYXRlX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSB1dGNUb1pvbmVkVGltZVxyXG4gKiBAY2F0ZWdvcnkgVGltZSBab25lIEhlbHBlcnNcclxuICogQHN1bW1hcnkgR2V0IGEgZGF0ZS90aW1lIHJlcHJlc2VudGluZyBsb2NhbCB0aW1lIGluIGEgZ2l2ZW4gdGltZSB6b25lIGZyb20gdGhlIFVUQyBkYXRlXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBSZXR1cm5zIGEgZGF0ZSBpbnN0YW5jZSB3aXRoIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIGxvY2FsIHRpbWUgaW4gdGhlIHRpbWUgem9uZVxyXG4gKiBzcGVjaWZpZWQgb2YgdGhlIFVUQyB0aW1lIGZyb20gdGhlIGRhdGUgcHJvdmlkZWQuIEluIG90aGVyIHdvcmRzLCB3aGVuIHRoZSBuZXcgZGF0ZVxyXG4gKiBpcyBmb3JtYXR0ZWQgaXQgd2lsbCBzaG93IHRoZSBlcXVpdmFsZW50IGhvdXJzIGluIHRoZSB0YXJnZXQgdGltZSB6b25lIHJlZ2FyZGxlc3NcclxuICogb2YgdGhlIGN1cnJlbnQgc3lzdGVtIHRpbWUgem9uZS5cclxuICpcclxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB3aXRoIHRoZSByZWxldmFudCBVVEMgdGltZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdGltZVpvbmUgLSB0aGUgdGltZSB6b25lIHRvIGdldCBsb2NhbCB0aW1lIGZvciwgY2FuIGJlIGFuIG9mZnNldCBvciBJQU5BIHRpbWUgem9uZVxyXG4gKiBAcGFyYW0ge09wdGlvbnNXaXRoVFp9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cclxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxyXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIGVxdWl2YWxlbnQgdGltZSBpbiB0aGUgdGltZSB6b25lXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gSW4gSnVuZSAxMGFtIFVUQyBpcyA2YW0gaW4gTmV3IFlvcmsgKC0wNDowMClcclxuICogY29uc3QgcmVzdWx0ID0gdXRjVG9ab25lZFRpbWUoJzIwMTQtMDYtMjVUMTA6MDA6MDAuMDAwWicsICdBbWVyaWNhL05ld19Zb3JrJylcclxuICogLy89PiBKdW4gMjUgMjAxNCAwNjowMDowMFxyXG4gKi9cclxuZnVuY3Rpb24gdXRjVG9ab25lZFRpbWUoZGlydHlEYXRlLCB0aW1lWm9uZSwgb3B0aW9ucykge1xyXG4gIHZhciBkYXRlID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fdG9EYXRlX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRpcnR5RGF0ZSwgb3B0aW9ucylcclxuXHJcbiAgLy8gVGhpcyBkYXRlIGhhcyB0aGUgVVRDIHRpbWUgdmFsdWVzIG9mIHRoZSBpbnB1dCBkYXRlIGF0IHRoZSBzeXN0ZW0gdGltZSB6b25lXHJcbiAgdmFyIHV0Y0RhdGUgPSBuZXcgRGF0ZShcclxuICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcclxuICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcclxuICAgIGRhdGUuZ2V0VVRDRGF0ZSgpLFxyXG4gICAgZGF0ZS5nZXRVVENIb3VycygpLFxyXG4gICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXHJcbiAgICBkYXRlLmdldFVUQ1NlY29uZHMoKSxcclxuICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKClcclxuICApXHJcbiAgLy8gV2UganVzdCBuZWVkIHRvIGFwcGx5IHRoZSBvZmZzZXQgaW5kaWNhdGVkIGJ5IHRoZSB0aW1lIHpvbmUgdG8gdGhpcyBsb2NhbGl6ZWQgZGF0ZVxyXG4gIHZhciBvZmZzZXRNaWxsaXNlY29uZHMgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdHpQYXJzZVRpbWV6b25lX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHRpbWVab25lLCBkYXRlKVxyXG5cclxuICByZXR1cm4gb2Zmc2V0TWlsbGlzZWNvbmRzXHJcbiAgICA/IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZGF0ZV9mbnNfZXNtX3N1Yk1pbGxpc2Vjb25kc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSh1dGNEYXRlLCBvZmZzZXRNaWxsaXNlY29uZHMpXHJcbiAgICA6IHV0Y0RhdGVcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHR6VG9rZW5pemVEYXRlO1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kc10gdG9rZW5zIG9mIHRoZSBwcm92aWRlZFxyXG4gKiBgZGF0ZWAgYXMgaXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgYHRpbWVab25lYC5cclxuICovXHJcbmZ1bmN0aW9uIHR6VG9rZW5pemVEYXRlKGRhdGUsIHRpbWVab25lKSB7XHJcbiAgdmFyIGR0ZiA9IGdldERhdGVUaW1lRm9ybWF0KHRpbWVab25lKVxyXG4gIHJldHVybiBkdGYuZm9ybWF0VG9QYXJ0cyA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpXHJcbn1cclxuXHJcbnZhciB0eXBlVG9Qb3MgPSB7XHJcbiAgeWVhcjogMCxcclxuICBtb250aDogMSxcclxuICBkYXk6IDIsXHJcbiAgaG91cjogMyxcclxuICBtaW51dGU6IDQsXHJcbiAgc2Vjb25kOiA1XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xyXG4gIHZhciBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0VG9QYXJ0cyhkYXRlKVxyXG4gIHZhciBmaWxsZWQgPSBbXVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgcG9zID0gdHlwZVRvUG9zW2Zvcm1hdHRlZFtpXS50eXBlXVxyXG5cclxuICAgIGlmIChwb3MgPj0gMCkge1xyXG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KGZvcm1hdHRlZFtpXS52YWx1ZSwgMTApXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBmaWxsZWRcclxufVxyXG5cclxuZnVuY3Rpb24gaGFja3lPZmZzZXQoZHRmLCBkYXRlKSB7XHJcbiAgdmFyIGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCAnJylcclxuICB2YXIgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZClcclxuICAvLyB2YXIgWywgZk1vbnRoLCBmRGF5LCBmWWVhciwgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdID0gcGFyc2VkXHJcbiAgLy8gcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF1cclxuICByZXR1cm4gW3BhcnNlZFszXSwgcGFyc2VkWzFdLCBwYXJzZWRbMl0sIHBhcnNlZFs0XSwgcGFyc2VkWzVdLCBwYXJzZWRbNl1dXHJcbn1cclxuXHJcbi8vIEdldCBhIGNhY2hlZCBJbnRsLkRhdGVUaW1lRm9ybWF0IGluc3RhbmNlIGZvciB0aGUgSUFOQSBgdGltZVpvbmVgLiBUaGlzIGNhbiBiZSB1c2VkXHJcbi8vIHRvIGdldCBkZXRlcm1pbmlzdGljIGxvY2FsIGRhdGUvdGltZSBvdXRwdXQgYWNjb3JkaW5nIHRvIHRoZSBgZW4tVVNgIGxvY2FsZSB3aGljaFxyXG4vLyBjYW4gYmUgdXNlZCB0byBleHRyYWN0IGxvY2FsIHRpbWUgcGFydHMgYXMgbmVjZXNzYXJ5LlxyXG52YXIgZHRmQ2FjaGUgPSB7fVxyXG5mdW5jdGlvbiBnZXREYXRlVGltZUZvcm1hdCh0aW1lWm9uZSkge1xyXG4gIGlmICghZHRmQ2FjaGVbdGltZVpvbmVdKSB7XHJcbiAgICAvLyBOZXcgYnJvd3NlcnMgdXNlIGBob3VyQ3ljbGVgLCBJRSBhbmQgQ2hyb21lIDw3MyBkb2VzIG5vdCBzdXBwb3J0IGl0IGFuZCB1c2VzIGBob3VyMTJgXHJcbiAgICB2YXIgdGVzdERhdGVGb3JtYXR0ZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICAgIGhvdXIxMjogZmFsc2UsXHJcbiAgICAgIHRpbWVab25lOiAnQW1lcmljYS9OZXdfWW9yaycsXHJcbiAgICAgIHllYXI6ICdudW1lcmljJyxcclxuICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcclxuICAgICAgZGF5OiAnMi1kaWdpdCcsXHJcbiAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcclxuICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgIHNlY29uZDogJzItZGlnaXQnXHJcbiAgICB9KS5mb3JtYXQobmV3IERhdGUoJzIwMTQtMDYtMjVUMDQ6MDA6MDAuMTIzWicpKVxyXG4gICAgdmFyIGhvdXJDeWNsZVN1cHBvcnRlZCA9XHJcbiAgICAgIHRlc3REYXRlRm9ybWF0dGVkID09PSAnMDYvMjUvMjAxNCwgMDA6MDA6MDAnIHx8XHJcbiAgICAgIHRlc3REYXRlRm9ybWF0dGVkID09PSAn4oCOMDbigI4v4oCOMjXigI4v4oCOMjAxNOKAjiDigI4wMOKAjjrigI4wMOKAjjrigI4wMCdcclxuXHJcbiAgICBkdGZDYWNoZVt0aW1lWm9uZV0gPSBob3VyQ3ljbGVTdXBwb3J0ZWRcclxuICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICAgICAgICBob3VyMTI6IGZhbHNlLFxyXG4gICAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxyXG4gICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxyXG4gICAgICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgIGRheTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xyXG4gICAgICAgIH0pXHJcbiAgICAgIDogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xyXG4gICAgICAgICAgaG91ckN5Y2xlOiAnaDIzJyxcclxuICAgICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcclxuICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcclxuICAgICAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgc2Vjb25kOiAnMi1kaWdpdCdcclxuICAgICAgICB9KVxyXG4gIH1cclxuICByZXR1cm4gZHRmQ2FjaGVbdGltZVpvbmVdXHJcbn1cclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gc3ViTWlsbGlzZWNvbmRzO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdG9JbnRlZ2VyX2luZGV4X2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19hZGRNaWxsaXNlY29uZHNfaW5kZXhfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBzdWJNaWxsaXNlY29uZHNcclxuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcclxuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cclxuICpcclxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxyXG4gKlxyXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBzdWJ0cmFjdGVkXHJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIHN1YnRyYWN0ZWRcclxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBTdWJ0cmFjdCA3NTAgbWlsbGlzZWNvbmRzIGZyb20gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcclxuICogdmFyIHJlc3VsdCA9IHN1Yk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcclxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MjkuMjUwXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc3ViTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIGFtb3VudCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2xpYl90b0ludGVnZXJfaW5kZXhfanNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZGlydHlBbW91bnQpO1xyXG4gIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19hZGRNaWxsaXNlY29uZHNfaW5kZXhfanNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZGlydHlEYXRlLCAtYW1vdW50KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDExICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGFkZE1pbGxpc2Vjb25kcztcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdG9EYXRlX2luZGV4X2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuXHJcblxyXG4vKipcclxuICogQG5hbWUgYWRkTWlsbGlzZWNvbmRzXHJcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXHJcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxyXG4gKlxyXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XHJcbiAqXHJcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cclxuICpcclxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIGFkZGVkXHJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gQWRkIDc1MCBtaWxsaXNlY29uZHMgdG8gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcclxuICogdmFyIHJlc3VsdCA9IGFkZE1pbGxpc2Vjb25kcyhuZXcgRGF0ZSgyMDE0LCA2LCAxMCwgMTIsIDQ1LCAzMCwgMCksIDc1MClcclxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MzAuNzUwXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzIgYXJndW1lbnRzIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCcpO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRpbWVzdGFtcCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX3RvRGF0ZV9pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkaXJ0eURhdGUpLmdldFRpbWUoKTtcclxuICB2YXIgYW1vdW50ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkaXJ0eUFtb3VudCk7XHJcbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIGFtb3VudCk7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSB0b0RhdGU7XHJcbi8qKlxyXG4gKiBAbmFtZSB0b0RhdGVcclxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXHJcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxyXG4gKlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxyXG4gKlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXHJcbiAqXHJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxyXG4gKlxyXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cclxuICpcclxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxyXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcclxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIENsb25lIHRoZSBkYXRlOlxyXG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxyXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcclxuICogY29uc3QgcmVzdWx0ID0gdG9EYXRlKDEzOTIwOTg0MzAwMDApXHJcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIgYXJnU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KTsgLy8gQ2xvbmUgdGhlIGRhdGVcclxuXHJcbiAgaWYgKGFyZ3VtZW50IGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2YgYXJndW1lbnQgPT09ICdvYmplY3QnICYmIGFyZ1N0ciA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XHJcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcclxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50ID09PSAnbnVtYmVyJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IE51bWJlcl0nKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoKHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHwgYXJnU3RyID09PSAnW29iamVjdCBTdHJpbmddJykgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGFyZ3VtZW50cy4gUGxlYXNlIHVzZSBgcGFyc2VJU09gIHRvIHBhcnNlIHN0cmluZ3MuIFNlZTogaHR0cHM6Ly9naXQuaW8vZmp1bGVcIik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcblxyXG4gICAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKCkuc3RhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xyXG4gIH1cclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHRvRGF0ZTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kYXRlX2Zuc19lc21fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fbGliX2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHNfaW5kZXhfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19saWJfdHpQYXJzZVRpbWV6b25lX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuXHJcblxyXG5cclxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMFxyXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwXHJcbnZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMlxyXG5cclxudmFyIHBhdHRlcm5zID0ge1xyXG4gIGRhdGVUaW1lRGVsaW1ldGVyOiAvW1QgXS8sXHJcbiAgcGxhaW5UaW1lOiAvOi8sXHJcbiAgdGltZVpvbmVEZWxpbWV0ZXI6IC9bWiBdL2ksXHJcblxyXG4gIC8vIHllYXIgdG9rZW5zXHJcbiAgWVk6IC9eKFxcZHsyfSkkLyxcclxuICBZWVk6IFtcclxuICAgIC9eKFsrLV1cXGR7Mn0pJC8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcclxuICAgIC9eKFsrLV1cXGR7M30pJC8sIC8vIDEgYWRkaXRpb25hbCBkaWdpdFxyXG4gICAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXHJcbiAgXSxcclxuICBZWVlZOiAvXihcXGR7NH0pLyxcclxuICBZWVlZWTogW1xyXG4gICAgL14oWystXVxcZHs0fSkvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXHJcbiAgICAvXihbKy1dXFxkezV9KS8sIC8vIDEgYWRkaXRpb25hbCBkaWdpdFxyXG4gICAgL14oWystXVxcZHs2fSkvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcclxuICBdLFxyXG5cclxuICAvLyBkYXRlIHRva2Vuc1xyXG4gIE1NOiAvXi0oXFxkezJ9KSQvLFxyXG4gIERERDogL14tPyhcXGR7M30pJC8sXHJcbiAgTU1ERDogL14tPyhcXGR7Mn0pLT8oXFxkezJ9KSQvLFxyXG4gIFd3dzogL14tP1coXFxkezJ9KSQvLFxyXG4gIFd3d0Q6IC9eLT9XKFxcZHsyfSktPyhcXGR7MX0pJC8sXHJcblxyXG4gIEhIOiAvXihcXGR7Mn0oWy4sXVxcZCopPykkLyxcclxuICBISE1NOiAvXihcXGR7Mn0pOj8oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXHJcbiAgSEhNTVNTOiAvXihcXGR7Mn0pOj8oXFxkezJ9KTo/KFxcZHsyfShbLixdXFxkKik/KSQvLFxyXG5cclxuICAvLyB0aW1lem9uZSB0b2tlbnMgKHRvIGlkZW50aWZ5IHRoZSBwcmVzZW5jZSBvZiBhIHR6KVxyXG4gIHRpbWV6b25lOiAvKFtaKy1dLip8IFVUQ3woPzpbYS16QS1aXStcXC9bYS16QS1aX10rKD86XFwvW2EtekEtWl9dKyk/KSkkL1xyXG59XHJcblxyXG4vKipcclxuICogQG5hbWUgdG9EYXRlXHJcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xyXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cclxuICpcclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cclxuICpcclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxyXG4gKlxyXG4gKiBJZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGl0LlxyXG4gKiBGdW5jdGlvbiBhY2NlcHRzIGNvbXBsZXRlIElTTyA4NjAxIGZvcm1hdHMgYXMgd2VsbCBhcyBwYXJ0aWFsIGltcGxlbWVudGF0aW9ucy5cclxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcclxuICogSWYgdGhlIGZ1bmN0aW9uIGNhbm5vdCBwYXJzZSB0aGUgc3RyaW5nIG9yIHRoZSB2YWx1ZXMgYXJlIGludmFsaWQsIGl0IHJldHVybnMgSW52YWxpZCBEYXRlLlxyXG4gKlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cclxuICpcclxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXHJcbiAqIEFsbCAqZGF0ZS1mbnMqIGZ1bmN0aW9ucyB3aWxsIHRocm93IGBSYW5nZUVycm9yYCBpZiBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBpcyBub3QgMCwgMSwgMiBvciB1bmRlZmluZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XHJcbiAqIEBwYXJhbSB7T3B0aW9uc1dpdGhUWn0gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxyXG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcclxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWVab25lPScnXSAtIHVzZWQgdG8gc3BlY2lmeSB0aGUgSUFOQSB0aW1lIHpvbmUgb2Zmc2V0IG9mIGEgZGF0ZSBTdHJpbmcuXHJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XHJcbiAqIHZhciByZXN1bHQgPSB0b0RhdGUoJzIwMTQtMDItMTFUMTE6MzA6MzAnKVxyXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxyXG4gKiAvLyBpZiB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdCBpcyAxOlxyXG4gKiB2YXIgcmVzdWx0ID0gdG9EYXRlKCcrMDIwMTQxMDEnLCB7YWRkaXRpb25hbERpZ2l0czogMX0pXHJcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQsIGRpcnR5T3B0aW9ucykge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50J1xyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gIH1cclxuXHJcbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge31cclxuXHJcbiAgdmFyIGFkZGl0aW9uYWxEaWdpdHMgPVxyXG4gICAgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGxcclxuICAgICAgPyBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTXHJcbiAgICAgIDogT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9kYXRlX2Zuc19lc21fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHMpXHJcbiAgaWYgKFxyXG4gICAgYWRkaXRpb25hbERpZ2l0cyAhPT0gMiAmJlxyXG4gICAgYWRkaXRpb25hbERpZ2l0cyAhPT0gMSAmJlxyXG4gICAgYWRkaXRpb25hbERpZ2l0cyAhPT0gMFxyXG4gICkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2FkZGl0aW9uYWxEaWdpdHMgbXVzdCBiZSAwLCAxIG9yIDInKVxyXG4gIH1cclxuXHJcbiAgLy8gQ2xvbmUgdGhlIGRhdGVcclxuICBpZiAoXHJcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHxcclxuICAgICh0eXBlb2YgYXJndW1lbnQgPT09ICdvYmplY3QnICYmXHJcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IERhdGVdJylcclxuICApIHtcclxuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50LmdldFRpbWUoKSlcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgdHlwZW9mIGFyZ3VtZW50ID09PSAnbnVtYmVyJyB8fFxyXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcclxuICApIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudClcclxuICB9IGVsc2UgaWYgKFxyXG4gICAgIShcclxuICAgICAgdHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBTdHJpbmddJ1xyXG4gICAgKVxyXG4gICkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICB9XHJcblxyXG4gIHZhciBkYXRlU3RyaW5ncyA9IHNwbGl0RGF0ZVN0cmluZyhhcmd1bWVudClcclxuXHJcbiAgdmFyIHBhcnNlWWVhclJlc3VsdCA9IHBhcnNlWWVhcihkYXRlU3RyaW5ncy5kYXRlLCBhZGRpdGlvbmFsRGlnaXRzKVxyXG4gIHZhciB5ZWFyID0gcGFyc2VZZWFyUmVzdWx0LnllYXJcclxuICB2YXIgcmVzdERhdGVTdHJpbmcgPSBwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmdcclxuXHJcbiAgdmFyIGRhdGUgPSBwYXJzZURhdGUocmVzdERhdGVTdHJpbmcsIHllYXIpXHJcblxyXG4gIGlmIChpc05hTihkYXRlKSkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICB9XHJcblxyXG4gIGlmIChkYXRlKSB7XHJcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKClcclxuICAgIHZhciB0aW1lID0gMFxyXG4gICAgdmFyIG9mZnNldFxyXG5cclxuICAgIGlmIChkYXRlU3RyaW5ncy50aW1lKSB7XHJcbiAgICAgIHRpbWUgPSBwYXJzZVRpbWUoZGF0ZVN0cmluZ3MudGltZSlcclxuXHJcbiAgICAgIGlmIChpc05hTih0aW1lKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZXpvbmUgfHwgb3B0aW9ucy50aW1lWm9uZSkge1xyXG4gICAgICBvZmZzZXQgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19saWJfdHpQYXJzZVRpbWV6b25lX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKFxyXG4gICAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lIHx8IG9wdGlvbnMudGltZVpvbmUsXHJcbiAgICAgICAgbmV3IERhdGUodGltZXN0YW1wICsgdGltZSlcclxuICAgICAgKVxyXG4gICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGdldCBvZmZzZXQgYWNjdXJhdGUgdG8gaG91ciBpbiB0aW1lem9uZXMgdGhhdCBjaGFuZ2Ugb2Zmc2V0XHJcbiAgICAgIG9mZnNldCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZGF0ZV9mbnNfZXNtX2xpYl9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUpKVxyXG4gICAgICBvZmZzZXQgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2RhdGVfZm5zX2VzbV9saWJfZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kc19pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcclxuICAgICAgICBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lICsgb2Zmc2V0KVxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xyXG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9XHJcbiAgdmFyIGFycmF5ID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy5kYXRlVGltZURlbGltZXRlcilcclxuICB2YXIgdGltZVN0cmluZ1xyXG5cclxuICBpZiAocGF0dGVybnMucGxhaW5UaW1lLnRlc3QoYXJyYXlbMF0pKSB7XHJcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gbnVsbFxyXG4gICAgdGltZVN0cmluZyA9IGFycmF5WzBdXHJcbiAgfSBlbHNlIHtcclxuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXVxyXG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdXHJcbiAgICBkYXRlU3RyaW5ncy50aW1lem9uZSA9IGFycmF5WzJdXHJcbiAgICBpZiAocGF0dGVybnMudGltZVpvbmVEZWxpbWV0ZXIudGVzdChkYXRlU3RyaW5ncy5kYXRlKSkge1xyXG4gICAgICBkYXRlU3RyaW5ncy5kYXRlID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy50aW1lWm9uZURlbGltZXRlcilbMF1cclxuICAgICAgdGltZVN0cmluZyA9IGRhdGVTdHJpbmcuc3Vic3RyKGRhdGVTdHJpbmdzLmRhdGUubGVuZ3RoLCBkYXRlU3RyaW5nLmxlbmd0aClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0aW1lU3RyaW5nKSB7XHJcbiAgICB2YXIgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpXHJcbiAgICBpZiAodG9rZW4pIHtcclxuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpXHJcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZGF0ZVN0cmluZ3NcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VZZWFyKGRhdGVTdHJpbmcsIGFkZGl0aW9uYWxEaWdpdHMpIHtcclxuICB2YXIgcGF0dGVybllZWSA9IHBhdHRlcm5zLllZWVthZGRpdGlvbmFsRGlnaXRzXVxyXG4gIHZhciBwYXR0ZXJuWVlZWVkgPSBwYXR0ZXJucy5ZWVlZWVthZGRpdGlvbmFsRGlnaXRzXVxyXG5cclxuICB2YXIgdG9rZW5cclxuXHJcbiAgLy8gWVlZWSBvciDCsVlZWVlZXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5ZWVlZLmV4ZWMoZGF0ZVN0cmluZykgfHwgcGF0dGVybllZWVlZLmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIHZhciB5ZWFyU3RyaW5nID0gdG9rZW5bMV1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcclxuICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoeWVhclN0cmluZy5sZW5ndGgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBZWSBvciDCsVlZWVxyXG4gIHRva2VuID0gcGF0dGVybnMuWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZLmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIHZhciBjZW50dXJ5U3RyaW5nID0gdG9rZW5bMV1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHllYXI6IHBhcnNlSW50KGNlbnR1cnlTdHJpbmcsIDEwKSAqIDEwMCxcclxuICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoY2VudHVyeVN0cmluZy5sZW5ndGgpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxyXG4gIHJldHVybiB7XHJcbiAgICB5ZWFyOiBudWxsXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgeWVhcikge1xyXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXHJcbiAgaWYgKHllYXIgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG5cclxuICB2YXIgdG9rZW5cclxuICB2YXIgZGF0ZVxyXG4gIHZhciBtb250aFxyXG4gIHZhciB3ZWVrXHJcblxyXG4gIC8vIFlZWVlcclxuICBpZiAoZGF0ZVN0cmluZy5sZW5ndGggPT09IDApIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxyXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyKVxyXG4gICAgcmV0dXJuIGRhdGVcclxuICB9XHJcblxyXG4gIC8vIFlZWVktTU1cclxuICB0b2tlbiA9IHBhdHRlcm5zLk1NLmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxyXG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoKSkge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gICAgfVxyXG5cclxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgpXHJcbiAgICByZXR1cm4gZGF0ZVxyXG4gIH1cclxuXHJcbiAgLy8gWVlZWS1EREQgb3IgWVlZWURERFxyXG4gIHRva2VuID0gcGF0dGVybnMuRERELmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxyXG4gICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgICB9XHJcblxyXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBkYXlPZlllYXIpXHJcbiAgICByZXR1cm4gZGF0ZVxyXG4gIH1cclxuXHJcbiAgLy8geXl5eS1NTS1kZCBvciBZWVlZTU1ERFxyXG4gIHRva2VuID0gcGF0dGVybnMuTU1ERC5leGVjKGRhdGVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICBkYXRlID0gbmV3IERhdGUoMClcclxuICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcclxuICAgIHZhciBkYXkgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRheSkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICAgIH1cclxuXHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkpXHJcbiAgICByZXR1cm4gZGF0ZVxyXG4gIH1cclxuXHJcbiAgLy8gWVlZWS1Xd3cgb3IgWVlZWVd3d1xyXG4gIHRva2VuID0gcGF0dGVybnMuV3d3LmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrKSkge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWspXHJcbiAgfVxyXG5cclxuICAvLyBZWVlZLVd3dy1EIG9yIFlZWVlXd3dEXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5Xd3dELmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxyXG4gICAgdmFyIGRheU9mV2VlayA9IHBhcnNlSW50KHRva2VuWzJdLCAxMCkgLSAxXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWssIGRheU9mV2VlaykpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGF5T2ZJU09XZWVrWWVhcih5ZWFyLCB3ZWVrLCBkYXlPZldlZWspXHJcbiAgfVxyXG5cclxuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgZGF0ZVxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVGltZSh0aW1lU3RyaW5nKSB7XHJcbiAgdmFyIHRva2VuXHJcbiAgdmFyIGhvdXJzXHJcbiAgdmFyIG1pbnV0ZXNcclxuXHJcbiAgLy8gaGhcclxuICB0b2tlbiA9IHBhdHRlcm5zLkhILmV4ZWModGltZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGhvdXJzID0gcGFyc2VGbG9hdCh0b2tlblsxXS5yZXBsYWNlKCcsJywgJy4nKSlcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlVGltZShob3VycykpIHtcclxuICAgICAgcmV0dXJuIE5hTlxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUlxyXG4gIH1cclxuXHJcbiAgLy8gaGg6bW0gb3IgaGhtbVxyXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTS5leGVjKHRpbWVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcclxuICAgIG1pbnV0ZXMgPSBwYXJzZUZsb2F0KHRva2VuWzJdLnJlcGxhY2UoJywnLCAnLicpKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzKSkge1xyXG4gICAgICByZXR1cm4gTmFOXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgLy8gaGg6bW06c3Mgb3IgaGhtbXNzXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5ISE1NU1MuZXhlYyh0aW1lU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsxXSwgMTApXHJcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKVxyXG4gICAgdmFyIHNlY29uZHMgPSBwYXJzZUZsb2F0KHRva2VuWzNdLnJlcGxhY2UoJywnLCAnLicpKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSkge1xyXG4gICAgICByZXR1cm4gTmFOXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgK1xyXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArXHJcbiAgICAgIHNlY29uZHMgKiAxMDAwXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgdGltZVxyXG4gIHJldHVybiBudWxsXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIoaXNvV2Vla1llYXIsIHdlZWssIGRheSkge1xyXG4gIHdlZWsgPSB3ZWVrIHx8IDBcclxuICBkYXkgPSBkYXkgfHwgMFxyXG4gIHZhciBkYXRlID0gbmV3IERhdGUoMClcclxuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KVxyXG4gIHZhciBmb3VydGhPZkphbnVhcnlEYXkgPSBkYXRlLmdldFVUQ0RheSgpIHx8IDdcclxuICB2YXIgZGlmZiA9IHdlZWsgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheVxyXG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpXHJcbiAgcmV0dXJuIGRhdGVcclxufVxyXG5cclxuLy8gVmFsaWRhdGlvbiBmdW5jdGlvbnNcclxuXHJcbnZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXHJcbnZhciBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiA9IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxyXG5cclxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4KHllYXIpIHtcclxuICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMClcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXRlKSB7XHJcbiAgaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIGlmIChkYXRlICE9IG51bGwpIHtcclxuICAgIGlmIChkYXRlIDwgMSkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKVxyXG4gICAgaWYgKGlzTGVhcFllYXIgJiYgZGF0ZSA+IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIGlmICghaXNMZWFwWWVhciAmJiBkYXRlID4gREFZU19JTl9NT05USFttb250aF0pIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSB7XHJcbiAgaWYgKGRheU9mWWVhciA8IDEpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgdmFyIGlzTGVhcFllYXIgPSBpc0xlYXBZZWFySW5kZXgoeWVhcilcclxuICBpZiAoaXNMZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjYpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuICBpZiAoIWlzTGVhcFllYXIgJiYgZGF5T2ZZZWFyID4gMzY1KSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5KSB7XHJcbiAgaWYgKHdlZWsgPCAwIHx8IHdlZWsgPiA1Mikge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICBpZiAoZGF5ICE9IG51bGwgJiYgKGRheSA8IDAgfHwgZGF5ID4gNikpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XHJcbiAgaWYgKGhvdXJzICE9IG51bGwgJiYgKGhvdXJzIDwgMCB8fCBob3VycyA+PSAyNSkpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgaWYgKG1pbnV0ZXMgIT0gbnVsbCAmJiAobWludXRlcyA8IDAgfHwgbWludXRlcyA+PSA2MCkpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgaWYgKHNlY29uZHMgIT0gbnVsbCAmJiAoc2Vjb25kcyA8IDAgfHwgc2Vjb25kcyA+PSA2MCkpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzO1xyXG52YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwO1xyXG4vKipcclxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxyXG4gKiBUaGV5IHVzdWFsbHkgYXBwZWFyIGZvciBkYXRlcyB0aGF0IGRlbm90ZSB0aW1lIGJlZm9yZSB0aGUgdGltZXpvbmVzIHdlcmUgaW50cm9kdWNlZFxyXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxyXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcclxuICpcclxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcclxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhkaXJ0eURhdGUpIHtcclxuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRpcnR5RGF0ZS5nZXRUaW1lKCkpO1xyXG4gIHZhciBiYXNlVGltZXpvbmVPZmZzZXQgPSBNYXRoLmNlaWwoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKTtcclxuICBkYXRlLnNldFNlY29uZHMoMCwgMCk7XHJcbiAgdmFyIG1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lKCkgJSBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFO1xyXG4gIHJldHVybiBiYXNlVGltZXpvbmVPZmZzZXQgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICsgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQ7XHJcbn1cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogdW51c2VkIGhhcm1vbnkgZXhwb3J0IGdldFdlZWtTdGFydEJ5UmVnaW9uICovXHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2Vla1N0YXJ0QnlMb2NhbGUkMTsgfSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2FwaV9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2xhbmdSZWdpb25NYXBfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19yZWdpb25EYXlNYXBfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0QnlSZWdpb24kMShyZWdpb25Db2RlKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYXBpX2pzX19bXCJiXCIgLyogZ2V0V2Vla1N0YXJ0QnlSZWdpb24gKi9dKShyZWdpb25Db2RlLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3JlZ2lvbkRheU1hcF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0QnlMb2NhbGUkMShsb2NhbGUpIHtcclxuICAgIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19hcGlfanNfX1tcImFcIiAvKiBnZXRXZWVrU3RhcnRCeUxvY2FsZSAqL10pKGxvY2FsZSwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19sYW5nUmVnaW9uTWFwX2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10sIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fcmVnaW9uRGF5TWFwX2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xyXG59XHJcblxyXG5cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTYgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2Vla1N0YXJ0QnlSZWdpb247IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdlZWtTdGFydEJ5TG9jYWxlOyB9KTtcclxuZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0QnlSZWdpb24ocmVnaW9uQ29kZSwgcmVnaW9uRGF5TWFwKSB7XHJcbiAgICB2YXIgY29kZSA9IHJlZ2lvbkRheU1hcFt0eXBlb2YgcmVnaW9uQ29kZSA9PT0gJ3N0cmluZycgPyByZWdpb25Db2RlLnRvVXBwZXJDYXNlKCkgOiByZWdpb25Db2RlXTtcclxuICAgIHJldHVybiB0eXBlb2YgY29kZSA9PT0gJ251bWJlcicgPyBjb2RlIDogMTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0QnlMb2NhbGUobG9jYWxlLCBsYW5nUmVnaW9uTWFwLCByZWdpb25EYXlNYXApIHtcclxuICAgIGlmIChsb2NhbGUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IGxvY2FsZS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9bLV9dLyk7XHJcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gZGF0YVswXTtcclxuICAgICAgICB2YXIgY291bnRyeTtcclxuICAgICAgICBpZiAoZGF0YVsxXSAmJiBkYXRhWzFdLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICBsYW5ndWFnZSArPSBcIl9cIiArIChkYXRhWzFdKTtcclxuICAgICAgICAgICAgY291bnRyeSA9IGRhdGFbMl07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY291bnRyeSA9IGRhdGFbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY291bnRyeSkge1xyXG4gICAgICAgICAgICBjb3VudHJ5ID0gbGFuZ1JlZ2lvbk1hcFtsYW5ndWFnZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3VudHJ5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXRXZWVrU3RhcnRCeVJlZ2lvbihjb3VudHJ5Lm1hdGNoKC9eXFxkKyQvKSA/IE51bWJlcihjb3VudHJ5KSA6IGNvdW50cnksIHJlZ2lvbkRheU1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDE7XHJcbn1cclxuXHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwXHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG52YXIgbGFuZ1JlZ2lvbk1hcCA9IHtcclxuICAgIGVuOiAnVVMnLFxyXG4gICAgemg6ICdDTicsXHJcbiAgICB6aF9oYW5zOiAnQ04nLFxyXG4gICAgaGFuczogJ0NOJyxcclxuICAgIHd1dTogJ0NOJyxcclxuICAgIGhzbjogJ0NOJyxcclxuICAgIGhhazogJ0NOJyxcclxuICAgIG5hbjogJ0NOJyxcclxuICAgIGdhbjogJ0NOJyxcclxuICAgIGhpOiAnSU4nLFxyXG4gICAgdGU6ICdJTicsXHJcbiAgICBtcjogJ0lOJyxcclxuICAgIHRhOiAnSU4nLFxyXG4gICAgZ3U6ICdJTicsXHJcbiAgICBrbjogJ0lOJyxcclxuICAgIG9yOiAnSU4nLFxyXG4gICAgbWw6ICdJTicsXHJcbiAgICBwYV9ndXJ1OiAnSU4nLFxyXG4gICAgYmhvOiAnSU4nLFxyXG4gICAgYXdhOiAnSU4nLFxyXG4gICAgYXM6ICdJTicsXHJcbiAgICBtd3I6ICdJTicsXHJcbiAgICBtYWk6ICdJTicsXHJcbiAgICBtYWc6ICdJTicsXHJcbiAgICBiZ2M6ICdJTicsXHJcbiAgICBobmU6ICdJTicsXHJcbiAgICBkY2M6ICdJTicsXHJcbiAgICBkejogJ0JUJyxcclxuICAgIHRuOiAnQlcnLFxyXG4gICAgYW06ICdFVCcsXHJcbiAgICBvbTogJ0VUJyxcclxuICAgIHF1YzogJ0dUJyxcclxuICAgIGlkOiAnSUQnLFxyXG4gICAganY6ICdJRCcsXHJcbiAgICBzdTogJ0lEJyxcclxuICAgIG1hZDogJ0lEJyxcclxuICAgIG1zX2FyYWI6ICdJRCcsXHJcbiAgICBnYTogJ0lFJyxcclxuICAgIGhlOiAnSUwnLFxyXG4gICAgamFtOiAnSk0nLFxyXG4gICAgamE6ICdKUCcsXHJcbiAgICBrbTogJ0tIJyxcclxuICAgIGtvOiAnS1InLFxyXG4gICAgbG86ICdMQScsXHJcbiAgICBtaDogJ01IJyxcclxuICAgIG15OiAnTU0nLFxyXG4gICAgbXQ6ICdNVCcsXHJcbiAgICBuZTogJ05QJyxcclxuICAgIGZpbDogJ1BIJyxcclxuICAgIGNlYjogJ1BIJyxcclxuICAgIGlsbzogJ1BIJyxcclxuICAgIHVyOiAnUEsnLFxyXG4gICAgcGE6ICdQSycsXHJcbiAgICBwYV9hcmFiOiAnUEsnLFxyXG4gICAgYXJhYjogJ1BLJyxcclxuICAgIGxhaDogJ1BLJyxcclxuICAgIHBzOiAnUEsnLFxyXG4gICAgc2Q6ICdQSycsXHJcbiAgICBzZF9hcmFiOiAnUEsnLFxyXG4gICAgc2tyOiAnUEsnLFxyXG4gICAgZ246ICdQWScsXHJcbiAgICB0aDogJ1RIJyxcclxuICAgIHR0czogJ1RIJyxcclxuICAgIGFlYjogJ1ROJyxcclxuICAgIHpoX2hhbnQ6ICdUVycsXHJcbiAgICBoYW50OiAnVFcnLFxyXG4gICAgc206ICdXUycsXHJcbiAgICB6dTogJ1pBJyxcclxuICAgIHNuOiAnWlcnLFxyXG4gICAgYXJxOiAnRFonLFxyXG4gICAgYXI6ICdFRycsXHJcbiAgICBhcno6ICdFRycsXHJcbiAgICBmYTogJ0lSJyxcclxuICAgIGF6X2FyYWI6ICdJUicsXHJcbiAgICBhcnk6ICdNQScsXHJcbiAgICBibjogJ0JEJyxcclxuICAgIHJrdDogJ0JEJyxcclxuICAgIGR2OiAnTVYnXHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGxhbmdSZWdpb25NYXApO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nUmVnaW9uTWFwLmpzLm1hcFxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxudmFyIHJlZ2lvbkRheU1hcCA9IHtcclxuICAgIEFHOiAwLFxyXG4gICAgQVRHOiAwLFxyXG4gICAgMjg6IDAsXHJcbiAgICBBUjogMCxcclxuICAgIEFSRzogMCxcclxuICAgIDMyOiAwLFxyXG4gICAgQVM6IDAsXHJcbiAgICBBU006IDAsXHJcbiAgICAxNjogMCxcclxuICAgIEFVOiAwLFxyXG4gICAgQVVTOiAwLFxyXG4gICAgMzY6IDAsXHJcbiAgICBCUjogMCxcclxuICAgIEJSQTogMCxcclxuICAgIDc2OiAwLFxyXG4gICAgQlM6IDAsXHJcbiAgICBCSFM6IDAsXHJcbiAgICA0NDogMCxcclxuICAgIEJUOiAwLFxyXG4gICAgQlROOiAwLFxyXG4gICAgNjQ6IDAsXHJcbiAgICBCVzogMCxcclxuICAgIEJXQTogMCxcclxuICAgIDcyOiAwLFxyXG4gICAgQlo6IDAsXHJcbiAgICBCTFo6IDAsXHJcbiAgICA4NDogMCxcclxuICAgIENBOiAwLFxyXG4gICAgQ0FOOiAwLFxyXG4gICAgMTI0OiAwLFxyXG4gICAgQ046IDAsXHJcbiAgICBDSE46IDAsXHJcbiAgICAxNTY6IDAsXHJcbiAgICBDTzogMCxcclxuICAgIENPTDogMCxcclxuICAgIDE3MDogMCxcclxuICAgIERNOiAwLFxyXG4gICAgRE1BOiAwLFxyXG4gICAgMjEyOiAwLFxyXG4gICAgRE86IDAsXHJcbiAgICBET006IDAsXHJcbiAgICAyMTQ6IDAsXHJcbiAgICBFVDogMCxcclxuICAgIEVUSDogMCxcclxuICAgIDIzMTogMCxcclxuICAgIEdUOiAwLFxyXG4gICAgR1RNOiAwLFxyXG4gICAgMzIwOiAwLFxyXG4gICAgR1U6IDAsXHJcbiAgICBHVU06IDAsXHJcbiAgICAzMTY6IDAsXHJcbiAgICBISzogMCxcclxuICAgIEhLRzogMCxcclxuICAgIDM0NDogMCxcclxuICAgIEhOOiAwLFxyXG4gICAgSE5EOiAwLFxyXG4gICAgMzQwOiAwLFxyXG4gICAgSUQ6IDAsXHJcbiAgICBJRE46IDAsXHJcbiAgICAzNjA6IDAsXHJcbiAgICBJRTogMCxcclxuICAgIElSTDogMCxcclxuICAgIDM3MjogMCxcclxuICAgIElMOiAwLFxyXG4gICAgSVNSOiAwLFxyXG4gICAgMzc2OiAwLFxyXG4gICAgSU46IDAsXHJcbiAgICBJTkQ6IDAsXHJcbiAgICAzNTY6IDAsXHJcbiAgICBKTTogMCxcclxuICAgIEpBTTogMCxcclxuICAgIDM4ODogMCxcclxuICAgIEpQOiAwLFxyXG4gICAgSlBOOiAwLFxyXG4gICAgMzkyOiAwLFxyXG4gICAgS0U6IDAsXHJcbiAgICBLRU46IDAsXHJcbiAgICA0MDQ6IDAsXHJcbiAgICBLSDogMCxcclxuICAgIEtITTogMCxcclxuICAgIDExNjogMCxcclxuICAgIEtSOiAwLFxyXG4gICAgS09SOiAwLFxyXG4gICAgNDEwOiAwLFxyXG4gICAgTEE6IDAsXHJcbiAgICBMQTA6IDAsXHJcbiAgICA0MTg6IDAsXHJcbiAgICBNSDogMCxcclxuICAgIE1ITDogMCxcclxuICAgIDU4NDogMCxcclxuICAgIE1NOiAwLFxyXG4gICAgTU1SOiAwLFxyXG4gICAgMTA0OiAwLFxyXG4gICAgTU86IDAsXHJcbiAgICBNQUM6IDAsXHJcbiAgICA0NDY6IDAsXHJcbiAgICBNVDogMCxcclxuICAgIE1MVDogMCxcclxuICAgIDQ3MDogMCxcclxuICAgIE1YOiAwLFxyXG4gICAgTUVYOiAwLFxyXG4gICAgNDg0OiAwLFxyXG4gICAgTVo6IDAsXHJcbiAgICBNT1o6IDAsXHJcbiAgICA1MDg6IDAsXHJcbiAgICBOSTogMCxcclxuICAgIE5JQzogMCxcclxuICAgIDU1ODogMCxcclxuICAgIE5QOiAwLFxyXG4gICAgTlBMOiAwLFxyXG4gICAgNTI0OiAwLFxyXG4gICAgTlo6IDAsXHJcbiAgICBOWkw6IDAsXHJcbiAgICA1NTQ6IDAsXHJcbiAgICBQQTogMCxcclxuICAgIFBBTjogMCxcclxuICAgIDU5MTogMCxcclxuICAgIFBFOiAwLFxyXG4gICAgUEVSOiAwLFxyXG4gICAgNjA0OiAwLFxyXG4gICAgUEg6IDAsXHJcbiAgICBQSEw6IDAsXHJcbiAgICA2MDg6IDAsXHJcbiAgICBQSzogMCxcclxuICAgIFBBSzogMCxcclxuICAgIDU4NjogMCxcclxuICAgIFBSOiAwLFxyXG4gICAgUFJJOiAwLFxyXG4gICAgNjMwOiAwLFxyXG4gICAgUFk6IDAsXHJcbiAgICBQUlk6IDAsXHJcbiAgICA2MDA6IDAsXHJcbiAgICBTQTogMCxcclxuICAgIFNBVTogMCxcclxuICAgIDY4MjogMCxcclxuICAgIFNHOiAwLFxyXG4gICAgU0dQOiAwLFxyXG4gICAgNzAyOiAwLFxyXG4gICAgU1Y6IDAsXHJcbiAgICBTTFY6IDAsXHJcbiAgICAyMjI6IDAsXHJcbiAgICBUSDogMCxcclxuICAgIFRIQTogMCxcclxuICAgIDc2NDogMCxcclxuICAgIFROOiAwLFxyXG4gICAgVFVOOiAwLFxyXG4gICAgNzg4OiAwLFxyXG4gICAgVFQ6IDAsXHJcbiAgICBUVE86IDAsXHJcbiAgICA3ODA6IDAsXHJcbiAgICBUVzogMCxcclxuICAgIFRXTjogMCxcclxuICAgIDE1ODogMCxcclxuICAgIFVNOiAwLFxyXG4gICAgVU1JOiAwLFxyXG4gICAgNTgxOiAwLFxyXG4gICAgVVM6IDAsXHJcbiAgICBVU0E6IDAsXHJcbiAgICA4NDA6IDAsXHJcbiAgICBWRTogMCxcclxuICAgIFZFTjogMCxcclxuICAgIDg2MjogMCxcclxuICAgIFZJOiAwLFxyXG4gICAgVklSOiAwLFxyXG4gICAgODUwOiAwLFxyXG4gICAgV1M6IDAsXHJcbiAgICBXU006IDAsXHJcbiAgICA4ODI6IDAsXHJcbiAgICBZRTogMCxcclxuICAgIFlFTTogMCxcclxuICAgIDg4NzogMCxcclxuICAgIFpBOiAwLFxyXG4gICAgWkFGOiAwLFxyXG4gICAgNzEwOiAwLFxyXG4gICAgWlc6IDAsXHJcbiAgICBaV0U6IDAsXHJcbiAgICA3MTY6IDAsXHJcbiAgICBBRTogNixcclxuICAgIEFSRTogNixcclxuICAgIDc4NDogNixcclxuICAgIEFGOiA2LFxyXG4gICAgQUZHOiA2LFxyXG4gICAgNDogNixcclxuICAgIEJIOiA2LFxyXG4gICAgQkhSOiA2LFxyXG4gICAgNDg6IDYsXHJcbiAgICBESjogNixcclxuICAgIERKSTogNixcclxuICAgIDI2MjogNixcclxuICAgIERaOiA2LFxyXG4gICAgRFpBOiA2LFxyXG4gICAgMTI6IDYsXHJcbiAgICBFRzogNixcclxuICAgIEVHWTogNixcclxuICAgIDgxODogNixcclxuICAgIElROiA2LFxyXG4gICAgSVJROiA2LFxyXG4gICAgMzY4OiA2LFxyXG4gICAgSVI6IDYsXHJcbiAgICBJUk46IDYsXHJcbiAgICAzNjQ6IDYsXHJcbiAgICBKTzogNixcclxuICAgIEpPUjogNixcclxuICAgIDQwMDogNixcclxuICAgIEtXOiA2LFxyXG4gICAgS1dUOiA2LFxyXG4gICAgNDE0OiA2LFxyXG4gICAgTFk6IDYsXHJcbiAgICBMQlk6IDYsXHJcbiAgICA0MzQ6IDYsXHJcbiAgICBNQTogNixcclxuICAgIE1BUjogNixcclxuICAgIDUwNDogNixcclxuICAgIE9NOiA2LFxyXG4gICAgT01OOiA2LFxyXG4gICAgNTEyOiA2LFxyXG4gICAgUUE6IDYsXHJcbiAgICBRQVQ6IDYsXHJcbiAgICA2MzQ6IDYsXHJcbiAgICBTRDogNixcclxuICAgIFNETjogNixcclxuICAgIDcyOTogNixcclxuICAgIFNZOiA2LFxyXG4gICAgU1lSOiA2LFxyXG4gICAgNzYwOiA2LFxyXG4gICAgQkQ6IDUsXHJcbiAgICBCR0Q6IDUsXHJcbiAgICA1MDogNSxcclxuICAgIE1WOiA1LFxyXG4gICAgTURWOiA1LFxyXG4gICAgNDYyOiA1XHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKHJlZ2lvbkRheU1hcCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lvbkRheU1hcC5qcy5tYXBcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcbnZhciBpc051bWJlclJlZ2V4ID0gL15cXGQrJC87XHJcbnZhciBpc1doaXRlc3BhY2VSZWdleCA9IC9cXHMvO1xyXG52YXIgcHVuY3R1YXRpb25MaXN0ID0gJyFcIiMkJSZcXCcoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4nO1xyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBpbiBsb3dlciBjYXNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICovXHJcblxyXG52YXIgaXNMb3dlckNhc2UgPSBmdW5jdGlvbiBpc0xvd2VyQ2FzZShzdHIpIHtcclxuICByZXR1cm4gc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIHN0ciAhPSBzdHIudG9VcHBlckNhc2UoKTtcclxufTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgaW4gdXBwZXIgY2FzZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqL1xyXG5cclxuXHJcbnZhciBpc1VwcGVyQ2FzZSA9IGZ1bmN0aW9uIGlzVXBwZXJDYXNlKHN0cikge1xyXG4gIHJldHVybiBzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgc3RyICE9IHN0ci50b0xvd2VyQ2FzZSgpO1xyXG59O1xyXG5cclxudmFyIHBhc3NPclRocm93RXJyb3IgPSBmdW5jdGlvbiBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cikge1xyXG4gIGlmICghbG9vc2UpIHtcclxuICAgIHZhciBfY2hhciA9IHN0ci5jaGFyQXQoaSk7XHJcblxyXG4gICAgdmFyIHBvcyA9IGkgKyAxO1xyXG4gICAgdGhyb3cge1xyXG4gICAgICBuYW1lOiAnU3RyaW5nTWFza0Vycm9yJyxcclxuICAgICAgbWVzc2FnZTogXCJTdHJpbmdNYXNrRXJyb3I6IGVycm9yIGFwcGx5aW5nIG1hc2sgYXQgcG9zaXRpb24gXFxcIlwiLmNvbmNhdChwb3MsIFwiXFxcIiAsIGNoYXIgXFxcIlwiKS5jb25jYXQoX2NoYXIsIFwiXFxcIlwiKSxcclxuICAgICAgcG9zOiBwb3MsXHJcbiAgICAgIFwiY2hhclwiOiBfY2hhclxyXG4gICAgfTtcclxuICB9IGVsc2UgcmV0W2ldID0gJyAnO1xyXG59O1xyXG4vKipcclxuICogTnVtYmVyTWFza1xyXG4gKlxyXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gZm9yIEJCaiBudW1iZXJzIG1hc2tpbmdcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcblxyXG5cclxudmFyIFN0cmluZ01hc2sgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBTdHJpbmdNYXNrKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0cmluZ01hc2spO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKFN0cmluZ01hc2ssIG51bGwsIFt7XHJcbiAgICBrZXk6IFwibWFza1wiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFzayB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggdGhlIGdpdmVuIG1hc2sgYWNjb3JkaW5nIHRvIEJCaiBydWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBtYXNrXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayB0aGUgbWFzayB0byB1c2UgZm9yIGZvcm1hdHRpbmdcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3NlPXRydWVdIHdoZW4gdHJ1ZSAsIGVycm9ycyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBtZXRob2Qgd2lsbCB0cnkgYXQgYXBwbHkgdGhlIG1hc2tcclxuICAgICAqICAgICAgICAgICAgICAgIGFueXdheSAsIG90aGVyd2lzZSBpdCB3aWxsIHN0b3AgYXQgZmlyc3QgZXJyb3IgYW5kIHRocm93IGl0LlxyXG4gICAgICogXHJcbiAgICAgKiBAdGhyb3dzIHtNYXNrSXNUb29TaG9ydEVycm9yfVxyXG4gICAgICogQHRocm93cyB7U3RyaW5nTWFza0Vycm9yfVxyXG4gICAgICogQHRocm93cyB7TWFza0Vycm9yfVxyXG4gICAgICogXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgbWFza2VkIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFzayhzdHIsIF9tYXNrKSB7XHJcbiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcclxuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XHJcbiAgICAgIF9tYXNrID0gU3RyaW5nKF9tYXNrKTtcclxuICAgICAgdmFyIG1hc2tMZW4gPSBfbWFzay5sZW5ndGg7XHJcbiAgICAgIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKHN0ckxlbiA+IG1hc2tMZW4pIHtcclxuICAgICAgICBpZiAobG9vc2UpIHJldHVybiBzdHI7IC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgICAgZWxzZSB0aHJvdyB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYXNrSXNUb29TaG9ydEVycm9yJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogXCJNYXNrSXNUb29TaG9ydEVycm9yOiBNYXNrIGlzIHNob3J0ZXIgdGhhbiB0aGUgcGFzc2VkIHN0cmluZ1wiXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgcmV0ID0gbmV3IEFycmF5KG1hc2tMZW4pO1xyXG4gICAgICB2YXIgcG9zID0gMDsgLy8gdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgc3RyXHJcblxyXG4gICAgICB2YXIgbWFza0J5dGUgPSAnJztcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XHJcbiAgICAgICAgbWFza0J5dGUgPSBfbWFzay5jaGFyQXQoaSk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAobWFza0J5dGUpIHtcclxuICAgICAgICAgIGNhc2UgJ1gnOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBhbnkgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIHJldFtpXSA9IHBvcyA8IHN0ckxlbiA/IHN0ci5jaGFyQXQocG9zKSA6ICcgJztcclxuICAgICAgICAgICAgKytwb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBsZXR0ZXI7IGZvcmNlIHVwcGVyIGNhc2VcclxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgIHZhciBfYnl0ZSA9IHN0ci5jaGFyQXQocG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKF9ieXRlKSkgcmV0W2ldID0gX2J5dGU7ZWxzZSBpZiAoaXNMb3dlckNhc2UoX2J5dGUpKSByZXRbaV0gPSBfYnl0ZS50b1VwcGVyQ2FzZSgpO2Vsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnO1xyXG5cclxuICAgICAgICAgICAgKytwb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBsZXR0ZXJcclxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgIHZhciBfYnl0ZTIgPSBzdHIuY2hhckF0KHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChpc1VwcGVyQ2FzZShfYnl0ZTIpIHx8IGlzTG93ZXJDYXNlKF9ieXRlMikpIHJldFtpXSA9IF9ieXRlMjtlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJztcclxuXHJcbiAgICAgICAgICAgICsrcG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgLy8gbWF0Y2ggZGlnaXRcclxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgIHZhciBfYnl0ZTMgPSBzdHIuY2hhckF0KHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChpc051bWJlclJlZ2V4LnRlc3QoX2J5dGUzKSkgcmV0W2ldID0gX2J5dGUzO2Vsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnO1xyXG5cclxuICAgICAgICAgICAgKytwb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1onOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBsZXR0ZXIgb3IgZGlnaXQ7IGZvcmNlIHVwcGVyIGNhc2VcclxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgIHZhciBfYnl0ZTQgPSBzdHIuY2hhckF0KHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChpc1VwcGVyQ2FzZShfYnl0ZTQpIHx8IGlzTnVtYmVyUmVnZXgudGVzdChfYnl0ZTQpKSByZXRbaV0gPSBfYnl0ZTQ7ZWxzZSBpZiAoaXNMb3dlckNhc2UoX2J5dGU0KSkgcmV0W2ldID0gX2J5dGU0LnRvVXBwZXJDYXNlKCk7ZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcblxyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGxldHRlciBvciBkaWdpdFxyXG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9ieXRlNSA9IHN0ci5jaGFyQXQocG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKF9ieXRlNSkgfHwgaXNMb3dlckNhc2UoX2J5dGU1KSB8fCBpc051bWJlclJlZ2V4LnRlc3QoX2J5dGU1KSkgcmV0W2ldID0gX2J5dGU1O2Vsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnO1xyXG5cclxuICAgICAgICAgICAgKytwb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdVJzpcclxuICAgICAgICAgICAgLy8gbWF0Y2ggbGV0dGVyIChmb3JjZSB1cHBlciBjYXNlKSwgZGlnaXQsIHdoaXRlc3BhY2Ugb3IgcHVuY3R1YXRpb24uXHJcbiAgICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgICB2YXIgX2J5dGU2ID0gc3RyLmNoYXJBdChwb3MpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaXNMb3dlckNhc2UoX2J5dGU2KSkgcmV0W2ldID0gX2J5dGU2LnRvVXBwZXJDYXNlKCk7ZWxzZSBpZiAoaXNVcHBlckNhc2UoX2J5dGU2KSB8fCBpc051bWJlclJlZ2V4LnRlc3QoX2J5dGU2KSB8fCBpc1doaXRlc3BhY2VSZWdleC50ZXN0KF9ieXRlNikgfHwgcHVuY3R1YXRpb25MaXN0LmluZGV4T2YoX2J5dGU2KSA+IC0xKSByZXRbaV0gPSBfYnl0ZTY7ZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcblxyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0W2ldID0gbWFza0J5dGU7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgIGlmICghbG9vc2UpIHtcclxuICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgbmFtZTogJ01hc2tFcnJvcicsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNYXNrIGNhbm5vdCBiZSBhcHBsaWVkJ1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgfV0pO1xyXG5cclxuICByZXR1cm4gU3RyaW5nTWFzaztcclxufSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChTdHJpbmdNYXNrKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fVHlwZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19UeXBlc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1N0cmluZ01hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlc1xyXG4gKlxyXG4gKiBCQmogbWFza3MgZmFjdG9yeVxyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxyXG4gKi9cclxuXHJcbnZhciBUeXBlcyA9XHJcbi8qI19fUFVSRV9fKi9cclxuZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFR5cGVzKCkge1xyXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVzKTtcclxuICB9XHJcblxyXG4gIF9jcmVhdGVDbGFzcyhUeXBlcywgbnVsbCwgW3tcclxuICAgIGtleTogXCJudW1iZXJcIixcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1hc2sgdGhlIGdpdmVuIG51bWJlciB3aXRoIHRoZSBnaXZlbiBtYXNrIGFjY29yZGluZyB0byBCQmogcnVsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIHRoZSBudW1iZXIgdG8gZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayB0aGUgbWFzayB0byB1c2UgZm9yIGZvcm1hdHRpbmdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZ3JvdXBpbmdTZXBhcmF0b3I9LF0gLSBhIGNoYXIgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgZ3JvdXBpbmcgc2VwYXJhdG9yXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlY2ltYWxTZXBhcmF0b3I9Ll0gIC0gYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVRyYWlsaW5nWmVyb3M9ZmFsc2VdIC0gQWZmZWN0cyB0aGUgb3V0cHV0IGJ5IHN3aXRjaGluZyB0aGUgd2F5IGEgbWFzayB3aXRoIFwiI1wiIGNoYXJhY3RlcnMgaW4gdGhlIHRyYWlsaW5nIHBvc2l0aW9ucyBpcyBmaWxsZWQuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgdGhlIGZ1bmN0aW9uIGBOdW1iZXJNYXNrLm1hc2soLjEwOlwiIy4jI1wiKWAgcmV0dXJucyBgIC4xMGAgaW5zdGVhZCBvZiBgIC4xIGBcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3NlPXRydWVdIHdoZW4gdHJ1ZSAsIGVycm9ycyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBtZXRob2Qgd2lsbCB0cnkgYXQgYXBwbHkgdGhlIG1hc2tcclxuICAgICAqICAgICAgICAgICAgICAgIGFueXdheSAsIG90aGVyd2lzZSBpdCB3aWxsIHN0b3AgYXQgZmlyc3QgZXJyb3IgYW5kIHRocm93IGl0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1iZXIoX251bWJlciwgbWFzaykge1xyXG4gICAgICB2YXIgZ3JvdXBpbmdTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICcsJztcclxuICAgICAgdmFyIGRlY2ltYWxTZXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcuJztcclxuICAgICAgdmFyIGZvcmNlVHJhaWxpbmdaZXJvcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XHJcbiAgICAgIHZhciBsb29zZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcclxuICAgICAgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1hc2soX251bWJlciwgbWFzaywgZ3JvdXBpbmdTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IsIGZvcmNlVHJhaWxpbmdaZXJvcywgbG9vc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXNrIGEgZGF0ZSBhY2NvcmRpbmcgdG8gYmJqIG1hc2tpbmcgcnVsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0ZSBkYXRlIGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayBtYXNrIGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2xvY2FsZT1Ccm93c2VyJ3MgbG9jYWxlXSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGV4KGVuLVVTKS4gZGVmYXVsdCBpcyB0byB0aGUgc3lzdGVtIGxhbmd1YWdlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3RpbWV6b25lPVN5c3RlbSB0aW1lem9uZV0gdGhlIHRpbWUgem9uZSBkZXNjcmlwdG9yIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpLiBkZWZhdWx0IHRvIHRoZSBzeXN0ZW1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gbnVtYmVyIG1hc2tlZCB3aXRoIHRoZSBnaXZlbiBtYXNrXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcImRhdGVcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlKF9kYXRlLCBtYXNrLCBsb2NhbGUsIHRpbWV6b25lKSB7XHJcbiAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJjXCIgLyogZGVmYXVsdCAqL10ubWFzayhfZGF0ZSwgbWFzaywgbG9jYWxlLCB0aW1lem9uZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1hc2sgdGhlIGdpdmVuIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBtYXNrIGFjY29yZGluZyB0byBCQmogcnVsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gbWFza1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgdGhlIG1hc2sgdG8gdXNlIGZvciBmb3JtYXR0aW5nXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29zZT10cnVlXSB3aGVuIHRydWUgLCBlcnJvcnMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgbWV0aG9kIHdpbGwgdHJ5IGF0IGFwcGx5IHRoZSBtYXNrXHJcbiAgICAgKiAgICAgICAgICAgICAgICBhbnl3YXkgLCBvdGhlcndpc2UgaXQgd2lsbCBzdG9wIGF0IGZpcnN0IGVycm9yIGFuZCB0aHJvdyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIHtNYXNrSXNUb29TaG9ydEVycm9yfVxyXG4gICAgICogQHRocm93cyB7U3RyaW5nTWFza0Vycm9yfVxyXG4gICAgICogQHRocm93cyB7TWFza0Vycm9yfVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgc3RyaW5nXHJcbiAgICAgKi9cclxuXHJcbiAgfSwge1xyXG4gICAga2V5OiBcInN0cmluZ1wiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZyhzdHIsIG1hc2spIHtcclxuICAgICAgdmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19TdHJpbmdNYXNrX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubWFzayhzdHIsIG1hc2ssIGxvb3NlKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBUeXBlcztcclxufSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChUeXBlcyk7XHJcblxyXG4vKioqLyB9KVxyXG4vKioqKioqLyBdKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJiai1tYXNrcy5qcy5tYXAiLCJpZighZ2xvYmFsW1wiQmFzaXNcIl0pIGdsb2JhbFtcIkJhc2lzXCJdID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcIkJhc2lzXCJdW1wiSW5wdXRNYXNraW5nXCJdID0gcmVxdWlyZShcIi0hRDpcXFxcR2l0aHViXFxcXEJCakdyaWRFeFdpZGdldFxcXFxjbGllbnRcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3JlZi0tNCEuXFxcXGJhc2lzLWlucHV0LW1hc2tpbmcuanNcIik7IiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQWdHcmlkQ29tcG9uZW50c1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJCYXNpc1wiXSA9IHJvb3RbXCJCYXNpc1wiXSB8fCB7fSwgcm9vdFtcIkJhc2lzXCJdW1wiQWdHcmlkQ29tcG9uZW50c1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZmQ3ZjYwNDIxOTJlMTIzMmNmNjUiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJiYmotbWFza3Mvc3JjL1N0cmluZ01hc2tcIixcImNvbW1vbmpzMlwiOlwiYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrXCIsXCJhbWRcIjpcImJiai1tYXNrcy9zcmMvU3RyaW5nTWFza1wiLFwicm9vdFwiOltcIkJCalwiLFwiTWFza3NcIixcIlN0cmluZ01hc2tcIl19XG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtaW5wdXQtbWFza2luZyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFRleHRJbnB1dCBmcm9tICcuL1RleHRJbnB1dCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRJbnB1dFxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGV4dElucHV0L2luZGV4LmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtaW5wdXQtbWFza2luZyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0cmluZ01hc2sgZnJvbSAnYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrJ1xyXG5pbXBvcnQge1xyXG4gIG1hc2tJZk5vdE1hc2tlZCxcclxuICB1bm1hc2ssXHJcbiAgZmluZENhcmV0UG9zaXRpb24sXHJcbiAgZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2ssXHJcbn0gZnJvbSAnLi90b29scy5qcydcclxuXHJcbi8qKlxyXG4gKiBUaGUgYFRleHRJbnB1dGAgd2lsbCB3cmFwIHRleHQgaW5wdXRzIGFuZCBhcHBseSB0aGUgZ2l2ZW4gW2JiaiBzdHJpbmcgbWFza10oaHR0cHM6Ly9naXRodWIuY29tL0Jhc2lzSHViL2Jiai1tYXNrcyNzdHJpbmctbWFza3MpXHJcbiAqXHJcbiAqICoqT3B0aW9ucyoqXHJcbiAqXHJcbiAqIF9PcHRpb25zIGNhbiBiZSBwYXNzZWQgdmlhIGRhdGEgYXR0cmlidXRlcyAuIEZvciBkYXRhIGF0dHJpYnV0ZXMsIGFwcGVuZCB0aGUgb3B0aW9uIG5hbWUgdG8gZGF0YS0sIGFzIGluIGRhdGEtbWFza19cclxuICpcclxuICogfCBPcHRpb24gICAgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqIHwtLS0tLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gKiB8IG1hc2sgfCAgICAgICAgIHwgVGhlIGJiaiBzdHJpbmcgbWFzayBAc2VlIFtCQmogU3RyaW5nIE1hc2tzXShodHRwczovL2dpdGh1Yi5jb20vQmFzaXNIdWIvYmJqLW1hc2tzI3N0cmluZy1tYXNrcykgfFxyXG4gKlxyXG4gKiAgPGJyPlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUgOioqXHJcbiAqIGBgYGh0bWxcclxuICogIDxpbnB1dCBjbGFzcz1cImJiai10ZXh0LW1hc2tlZFwiIG5hbWU9XCJ0ZXN0XCIgaWQ9XCJ0ZXN0XCIgdmFsdWU9XCJlZDIzXCIgZGF0YS1tYXNrPVwiQUEtMDBcIj5cclxuICpcclxuICogIDxzY3JpcHQ+XHJcbiAqICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoZSkge1xyXG4gKiAgICAgIG5ldyBCYXNpcy5JbnB1dE1hc2tpbmcuVGV4dElucHV0KHtcclxuICogICAgICAgICBvblVwZGF0ZTogKG1hc2tlZFZhbHVlICwgcmF3VmFsdWUgLCBpbnB1dCkgPT4ge1xyXG4gKiAgICAgICAgICAgIC8vIGRvIHNvbWV0aGluZ1xyXG4gKiAgICAgICAgIH0sXHJcbiAqICAgICAgICAgb25JbnZhbGlkOiAoZXJyICwgaW5wdXQpID0+IHtcclxuICogICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICogICAgICAgICB9XHJcbiAqICAgICAgfSlcclxuICogICAgfSlcclxuICogIDwvc2NyaXB0PlxyXG4gKiBgYGBcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcbmNsYXNzIFRleHRJbnB1dCB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IG5ldyBUZXh0SW5wdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7P09iamVjdH0gb3B0aW9ucyAtIFRoZSBpbnB1dCBvcHRpb25zLlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBbb3B0aW9ucy5lbGVtZW50cz1cIi5iYmotdGV4dC1tYXNrZWRcIl0gLSBUaGUgY2xhc3MgbmFtZSBvciB0aGUgbm9kZSB0byB1c2VcclxuICAgKiBAcGFyYW0ge0hUTUxEb2N1bWVudH0gW29wdGlvbnMuZG9jdW1lbnQ9ZG9jdW1lbnRdIC0gRG9jdW1lbnQgaW5zdGFuY2UgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNzc0NsYXNzRXJyb3I9XCJiYmotbWFzay1lcnJvclwiXSAtIEEgY3NzIGNsYXNzIHRvIGF0dGFjaCB0byB0aGUgaW5wdXQgd2hlbiBpdCBpcyBpbnZhbGlkXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNzc0NsYXNzU3VjY2Vzcz1cImJiai1tYXNrLXN1Y2Nlc3NcIl0gLSBBIGNzcyBjbGFzcyB0byBhdHRhY2ggdG8gdGhlIGlucHV0IHdoZW4gaXQgaXMgdmFsaWQgYWZ0ZXIgdGhlIHVzZXIgaW50ZXJhY3Rpb25cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblVwZGF0ZT1udWxsXSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIHRoZSBuZXcgbWFza2VkIHZhbHVlIGlzIHNldFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uSW52YWxpZD1udWxsXSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIHRoZSBpbnB1dCBvciB0aGUgbWFzayBpcyBpbnZhbGlkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7XHJcbiAgICAgIC4uLntcclxuICAgICAgICBlbGVtZW50czogJy5iYmotdGV4dC1tYXNrZWQnLFxyXG4gICAgICAgIGRvYzogZG9jdW1lbnQsXHJcbiAgICAgICAgY3NzQ2xhc3NFcnJvcjogJ2Jiai1tYXNrLWVycm9yJyxcclxuICAgICAgICBjc3NDbGFzc1N1Y2Nlc3M6ICdiYmotbWFzay1zdWNjZXNzJyxcclxuICAgICAgICBvblVwZGF0ZTogbnVsbCxcclxuICAgICAgICBvbkludmFsaWQ6IG51bGwsXHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9XHJcbiAgICB0aGlzLl9vbktleXN0cm9rZSA9IHRoaXMuX29uS2V5c3Ryb2tlLmJpbmQodGhpcylcclxuICAgIHRoaXMuX29uRm9jdXMgPSB0aGlzLl9vbkZvY3VzLmJpbmQodGhpcylcclxuICAgIHRoaXMucmVmcmVzaCgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBjb21wb25lbnQgYW5kIHdyYXAgdGhlIGlucHV0IGVsZW1lbnRzIGZvciBtYXNraW5nIGluIGNhc2VcclxuICAgKiB0aGV5IGFyZSBub3Qgd3JhcHBlZCB5ZXRcclxuICAgKi9cclxuICByZWZyZXNoKCkge1xyXG4gICAgY29uc3QgZWxlbWVudHMgPVxyXG4gICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmVsZW1lbnRzID09PSAnc3RyaW5nJ1xyXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmRvYy5xdWVyeVNlbGVjdG9yQWxsKHRoaXMub3B0aW9ucy5lbGVtZW50cylcclxuICAgICAgICA6IHRoaXMub3B0aW9ucy5lbGVtZW50c1xyXG4gICAgbGV0IGlucHV0LCBwYXJlbnRDbGFzc1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaW5wdXQgPSBlbGVtZW50c1tpXVxyXG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgcGFyZW50Q2xhc3MgPSBpbnB1dC5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxyXG5cclxuICAgICAgICBpZiAoIWlucHV0LmdldEF0dHJpYnV0ZSgnaWQnKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgQkJqTWFza2luZzogSW5wdXQgaGFzIG5vIElELiBXaXRob3V0IGFuIElEIHRoZSBpbnB1dCBjYW5ub3QgYmUgbWFza2VkYCxcclxuICAgICAgICAgICAgaW5wdXRcclxuICAgICAgICAgIClcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZSBkb24ndCBpbml0aWFsaXplIHRoZSBpbnB1dCdzIHdyYXAgdHdpY2VcclxuICAgICAgICBjb25zdCBpc1dyYXBwZWQgPVxyXG4gICAgICAgICAgcGFyZW50Q2xhc3MgJiYgcGFyZW50Q2xhc3MuaW5kZXhPZigndGV4dElucHV0TWFza19fd3JhcCcpID4gLTFcclxuICAgICAgICB0aGlzLl93cmFwKGlucHV0LCBpc1dyYXBwZWQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYEJCak1hc2tpbmc6IEludmFsaWQgaW5wdXQgZWxlbWVudC4gVGhlIGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkYCxcclxuICAgICAgICAgIGlucHV0XHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIGlucHV0IGVsZW1lbnRzIGFuZCByZW1vdmUgYXR0YWNoZWQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnRzID1cclxuICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5lbGVtZW50cyA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZWxlbWVudHMpXHJcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuZWxlbWVudHNcclxuXHJcbiAgICBsZXQgaW5wdXQsIHBhcmVudCwgcGFyZW50Q2xhc3NcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlucHV0ID0gZWxlbWVudHNbaV1cclxuICAgICAgcGFyZW50ID0gaW5wdXQucGFyZW50Tm9kZVxyXG4gICAgICBwYXJlbnRDbGFzcyA9IHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcclxuXHJcbiAgICAgIGlmIChwYXJlbnRDbGFzcyAmJiBwYXJlbnRDbGFzcy5pbmRleE9mKCd0ZXh0SW5wdXRNYXNrX193cmFwJykgPiAtMSkge1xyXG4gICAgICAgIHRoaXMuX3Vud3JhcChwYXJlbnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgdGV4dCBtYXNraW5nIGlucHV0IHdyYXBwZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgdGhlIGlucHV0IGVsZW1lbnRcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzV3JhcHBlZCB3aGVuIHRydWUgdGhlIGlucHV0IGlzIGFscmVhZHkgd3JhcHBlZCBhbmQgd2UgbmVlZCB0byBhZGQgd2hhdCBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3Npbmcgb25seVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0hUTUxTcGFuRWxlbWVudH0gdGhlIHdyYXAgZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF93cmFwKGlucHV0LCBpc1dyYXBwZWQpIHtcclxuICAgIGNvbnN0IGlucHV0SWQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJyksXHJcbiAgICAgIGlucHV0TmFtZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgnbmFtZScpLFxyXG4gICAgICBtYXNrID0gaW5wdXQuZGF0YXNldC5tYXNrIHx8ICcnLFxyXG4gICAgICBvcmlnaW5hbFBhdHRlcm4gPSBpbnB1dC5wYXR0ZXJuLFxyXG4gICAgICBkZWZhdWx0UGF0dGVybiA9IGdlbmVyYXRlUGF0dGVybkZyb21NYXNrKG1hc2spLFxyXG4gICAgICBwYXR0ZXJuID0gb3JpZ2luYWxQYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuXHJcblxyXG4gICAgbGV0IHdyYXAgPSBudWxsLFxyXG4gICAgICB1bm1hc2tJbnB1dCA9IG51bGxcclxuXHJcbiAgICBpZiAoIWlzV3JhcHBlZCkge1xyXG4gICAgICB3cmFwID0gdGhpcy5vcHRpb25zLmRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJylcclxuICAgICAgdW5tYXNrSW5wdXQgPSB0aGlzLm9wdGlvbnMuZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JykgLy8gaGlkZGVuIGlucHV0IHdpdGggdGhlIHVubWFza2VkIHZhbHVlcyBmb3IgZm9ybXNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdyYXAgPSBpbnB1dC5wYXJlbnROb2RlXHJcbiAgICAgIHVubWFza0lucHV0ID0gd3JhcC5xdWVyeVNlbGVjdG9yKCcudGV4dElucHV0TWFza19fdW5tYXNrZWRJbnB1dCcpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uZmlndXJlIHRoZSBhY3R1YWwgaW5wdXRcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBpbnB1dC52YWx1ZSA9IG1hc2tJZk5vdE1hc2tlZChpbnB1dC52YWx1ZSwgbWFzaylcclxuICAgIGlucHV0LnBhdHRlcm4gPSBwYXR0ZXJuXHJcbiAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCd0ZXh0SW5wdXRNYXNrX190ZXh0SW5wdXQnKVxyXG4gICAgaW5wdXQuZGF0YXNldC5tYXNrID0gbWFza1xyXG4gICAgaW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkID0gdW5tYXNrKGlucHV0LnZhbHVlLCBtYXNrKVxyXG4gICAgaWYgKG9yaWdpbmFsUGF0dGVybiAmJiBvcmlnaW5hbFBhdHRlcm4gIT09IGRlZmF1bHRQYXR0ZXJuKSB7XHJcbiAgICAgIGlucHV0LmRhdGFzZXQuaXNDdXN0b21QYXR0ZXJuID0gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNXcmFwcGVkKSB7XHJcbiAgICAgIGlmICghKGlucHV0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSB8fCBpbnB1dC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUnKSkpIHtcclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5c3Ryb2tlKVxyXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5fb25LZXlzdHJva2UpXHJcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCB0aGlzLl9vbktleXN0cm9rZSlcclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fb25Gb2N1cylcclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uRm9jdXMpXHJcbiAgICAgIH1cclxuICAgICAgaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcCwgaW5wdXQpIC8vIG1vdmUgdGhlIGlucHV0IG91dHNpZGUgdGhlIHdyYXBwZXJcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fdmFsaWRhdGVJbnB1dChpbnB1dCkpIHtcclxuICAgICAgdGhpcy5fX2ZpcmVPblVwZGF0ZShpbnB1dC52YWx1ZSwgaW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkLCBpbnB1dClcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25maWd1cmUgdGhlIHVubWFza2VkIGlucHV0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB1bm1hc2tJbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxyXG4gICAgdW5tYXNrSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2hpZGRlbicpXHJcbiAgICB1bm1hc2tJbnB1dC5jbGFzc0xpc3QuYWRkKCd0ZXh0SW5wdXRNYXNrX191bm1hc2tlZElucHV0JylcclxuICAgIHVubWFza0lucHV0LnZhbHVlID0gaW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkXHJcbiAgICBpZiAoaW5wdXRJZCkgdW5tYXNrSW5wdXQuc2V0QXR0cmlidXRlKCdpZCcsIGAke2lucHV0SWR9LXVubWFza2VkYClcclxuICAgIGlmIChpbnB1dE5hbWUpIHVubWFza0lucHV0LnNldEF0dHJpYnV0ZSgnbmFtZScsIGAke2lucHV0TmFtZX0tdW5tYXNrZWRgKVxyXG5cclxuICAgIGlmICghaXNXcmFwcGVkKSB7XHJcbiAgICAgIC8vIGNvbmZpZ3VyZSB0aGUgd3JhcHBlclxyXG4gICAgICB3cmFwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGV4dElucHV0TWFza19fd3JhcCcpXHJcbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQodW5tYXNrSW5wdXQpXHJcbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoaW5wdXQpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdyYXBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbWFza2VkIGlucHV0IGFuZCByZW1vdmUgdGhlIHZhbHVlIGNoYW5nZWQgbGlzdGVuZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTFNwYW5FbGVtZW50fSB0ZXh0SW5wdXQgdGhlIHdyYXBwZXIgc3BhbiBpbnN0YW5jZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF91bndyYXAodGV4dElucHV0KSB7XHJcbiAgICB0ZXh0SW5wdXQucmVtb3ZlQ2hpbGQoXHJcbiAgICAgIHRleHRJbnB1dC5xdWVyeVNlbGVjdG9yKCcudGV4dElucHV0TWFza19fdW5tYXNrZWRJbnB1dCcpXHJcbiAgICApXHJcblxyXG4gICAgY29uc3QgaW5wdXQgPSB0ZXh0SW5wdXQucXVlcnlTZWxlY3RvcignLnRleHRJbnB1dE1hc2tfX3RleHRJbnB1dCcpXHJcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5c3Ryb2tlKVxyXG4gICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9vbktleXN0cm9rZSlcclxuICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5fb25LZXlzdHJva2UpXHJcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fb25Gb2N1cylcclxuICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Gb2N1cylcclxuICAgIGRlbGV0ZSBpbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWRcclxuICAgIGlmICghaW5wdXQuZGF0YXNldC5pc0N1c3RvbVBhdHRlcm4pIHtcclxuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdwYXR0ZXJuJylcclxuICAgICAgZGVsZXRlIGlucHV0LmRhdGFzZXQuaXNDdXN0b21QYXR0ZXJuXHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuXHJcbiAgICB0ZXh0SW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXQsIHRleHRJbnB1dClcclxuICAgIHRleHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRJbnB1dClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBldmVyeSBrZXlzdHJva2Ugb24gdGhlIGlucHV0IGFuZCB1cGRhdGUgdGhlIG1hc2tlZCBhbmQgdGhlIHVubWFza2VkIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX29uS2V5c3Ryb2tlKGUpIHtcclxuICAgIGlmIChlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpIHJldHVyblxyXG4gICAgaWYoZS5rZXlDb2RlICE9PSAxMykgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBcclxuICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXQsXHJcbiAgICAgIG1hc2sgPSBpbnB1dC5kYXRhc2V0Lm1hc2sgfHwgdGhpcy5vcHRpb25zLm1hc2ssXHJcbiAgICAgIGV2ZW50VHlwZSA9IGUudHlwZVxyXG5cclxuICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICBpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSgnJyk7XHJcblxyXG4gICAgbGV0IHZhbHVlID0gaW5wdXQudmFsdWUsXHJcbiAgICAgIGtleUNvZGUgPSBlLmtleUNvZGUsXHJcbiAgICAgIGtleUNvbnRlbnQgPSBlLmtleSB8fCBlLmNvZGUucmVwbGFjZSgvW14wLTldL2csICcnKSxcclxuICAgICAga2V5ID0ga2V5Q29udGVudCA/IChrZXlDb250ZW50Lmxlbmd0aCA+IDEgPyAnJyA6IGtleUNvbnRlbnQpIDogJycsXHJcbiAgICAgIGluc2VydFBvc2l0aW9uID0gZmluZENhcmV0UG9zaXRpb24odmFsdWUsIG1hc2spLFxyXG4gICAgICBuZXdWYWx1ZSxcclxuICAgICAgdW5tYXNrZWRWYWx1ZSxcclxuICAgICAgbWFza0Vycm9yID0gZmFsc2VcclxuXHJcbiAgICBzd2l0Y2ggKGV2ZW50VHlwZSkge1xyXG4gICAgICBjYXNlICdwYXN0ZSc6XHJcbiAgICAgICAgbmV3VmFsdWUgPSBtYXNrSWZOb3RNYXNrZWQoXHJcbiAgICAgICAgICAoZS5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhKS5nZXREYXRhKCdUZXh0JyksXHJcbiAgICAgICAgICBtYXNrXHJcbiAgICAgICAgKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ2tleXVwJzpcclxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgY2FzZSAna2V5cHJlc3MnOlxyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gaW5wdXQuc2VsZWN0aW9uU3RhcnRcclxuICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgIT09IGluc2VydFBvc2l0aW9uKSBpbnNlcnRQb3NpdGlvbiA9IHNlbGVjdGlvblN0YXJ0XHJcblxyXG4gICAgICAgIG5ld1ZhbHVlID1cclxuICAgICAgICAgIHZhbHVlLnN1YnN0cigwLCBpbnNlcnRQb3NpdGlvbikgKyBrZXkgKyB2YWx1ZS5zdWJzdHIoaW5zZXJ0UG9zaXRpb24pXHJcbiAgICAgICAgYnJlYWtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBicmVha1xyXG4gICAgfVxyXG5cclxuICAgIHVubWFza2VkVmFsdWUgPSB1bm1hc2sobmV3VmFsdWUsIG1hc2spXHJcblxyXG4gICAgaWYgKFszNSwgMzYsIDM3LCAzOCwgMzksIDQwXS5pbmRleE9mKGtleUNvZGUpID09PSAtMSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGlucHV0LnZhbHVlID0gU3RyaW5nTWFzay5tYXNrKHVubWFza2VkVmFsdWUsIG1hc2ssIGZhbHNlKVxyXG4gICAgICAgIGlmKHRoaXMuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XHJcbiAgICAgICAgICBpbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWQgPSB1bm1hc2tlZFZhbHVlXHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3IoXHJcbiAgICAgICAgICAgIGAjJHtpbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJyl9LXVubWFza2VkYFxyXG4gICAgICAgICAgKS52YWx1ZSA9IHVubWFza2VkVmFsdWVcclxuICAgICAgICAgIHRoaXMuX19hcHBseUNzc0NsYXNzU3RhdGUoaW5wdXQsICdzdWNjZXNzJylcclxuICAgICAgICAgIHRoaXMuX19maXJlT25VcGRhdGUoaW5wdXQudmFsdWUsIGlucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCwgaW5wdXQpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hc2tFcnJvciA9IGZhbHNlXHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZShpbnB1dCwgJ2Vycm9yJylcclxuICAgICAgICB0aGlzLl9fZmlyZU9uSW52YWxpZChlcnJvciwgaW5wdXQpXHJcbiAgICAgICAgbWFza0Vycm9yID0gdHJ1ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl91cGRhdGVDYXJldFBvc2l0aW9uKGlucHV0LCBtYXNrKVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghbWFza0Vycm9yKSB0aGlzLl92YWxpZGF0ZUlucHV0KGlucHV0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRvIGZvY3VzIGV2ZW50cyBvbiB0aGUgaW5wdXQgYW5kIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb25cclxuICAgKiB3aGVyZSB0aGUgbmV4dCBjaGFyIHNob3VsZCBiZSBpbnNlcnRlZCBhY2NvcmRpbmcgdG8gdGhlIG1hc2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF9vbkZvY3VzKGUpIHtcclxuICAgIGNvbnN0IGlucHV0ID0gZS50YXJnZXRcclxuICAgIGNvbnN0IG1hc2sgPSBpbnB1dC5kYXRhc2V0Lm1hc2sgfHwgdGhpcy5vcHRpb25zLm1hc2tcclxuICAgIHRoaXMuX3VwZGF0ZUNhcmV0UG9zaXRpb24oaW5wdXQsIG1hc2spXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uIG9uIHRoZSBpbnB1dCBiYXNlZCBvbiB0aGUgZ2l2ZW4gbWFza1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrICBiYmogc3RyaW5nXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3VwZGF0ZUNhcmV0UG9zaXRpb24oaW5wdXQsIG1hc2spIHtcclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGZpbmRDYXJldFBvc2l0aW9uKGlucHV0LnZhbHVlLCBtYXNrKVxyXG4gICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShwb3NpdGlvbiwgcG9zaXRpb24pXHJcbiAgICB9LCAwKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBgY2hlY2tWYWxpZGl0eWAgb24gdGhlIGlucHV0XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHZhbGlkICwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcclxuICAgIGNvbnN0IGlzVmFsaWQgPSBpbnB1dC5jaGVja1ZhbGlkaXR5KClcclxuXHJcbiAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKGlucHV0LCAnc3VjY2VzcycpXHJcbiAgICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KCcnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZShpbnB1dCwgJ2Vycm9yJylcclxuICAgICAgdGhpcy5fX2ZpcmVPbkludmFsaWQoaW5wdXQudmFsaWRhdGlvbk1lc3NhZ2UsIGlucHV0KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc1ZhbGlkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fZmlyZU9uVXBkYXRlKHZhbHVlTWFza2VkLCB2YWx1ZVVubWFza2VkLCBpbnB1dCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vblVwZGF0ZSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUodmFsdWVNYXNrZWQsIHZhbHVlVW5tYXNrZWQsIGlucHV0KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2ZpcmVPbkludmFsaWQoZXJyb3IsIGlucHV0KSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW52YWxpZCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMub25JbnZhbGlkKGVycm9yLCBpbnB1dClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19hcHBseUNzc0NsYXNzU3RhdGUoaW5wdXQsIHN0YXRlKSB7XHJcbiAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpIHx8IGlucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xyXG4gICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoc3RhdGUgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dElucHV0XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZXh0SW5wdXQvVGV4dElucHV0LmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtaW5wdXQtbWFza2luZyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0cmluZ01hc2sgZnJvbSAnYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrJ1xyXG5cclxuY29uc3QgU1VQUE9SVEVEX01BU0tTID0gWydYJywgJ2EnLCAnQScsICcwJywgJ3onLCAnWicsICdVJ11cclxuLyoqXHJcbiAqIFdoZW4gdHJ1ZSAsIHRoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgVW5pY29kZSBQcm9wZXJ0eSBFc2NhcGVzXHJcbiAqIG90aGVyd2lzZSBpdCBpcyBmYWxzZSBcclxuICogXHJcbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1yZWdleHAtdW5pY29kZS1wcm9wZXJ0eS1lc2NhcGVzfVxyXG4gKi9cclxubGV0IElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEID0gZmFsc2VcclxudHJ5IHtcclxuICBldmFsKCcvXFxcXHB7TH0vdScpXHJcbiAgSVNfVU5JQ09ERV9QUk9QRVJUWV9TVVBQT1JURUQgPSB0cnVlXHJcbn0gY2F0Y2ggKGVycikge1xyXG4gIElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEID0gZmFsc2VcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBtYXNrZWQgd2l0aCB0aGUgZ2l2ZW4gbWFzayBvciBub3RcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIG1hc2tlZCBvciB1bm1hc2tlZCB2YWx1ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFzayAgYSBiYmogbWFza1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gdGhlIHZhbHVlIGlzIG1hc2tlZCB3aXRoIGdpdmVuIG1hc2sgLCBmYWxzZSBvdGhlcndpc2VcclxuICovXHJcbmNvbnN0IGlzTWFza2VkVmFsdWUgPSAodmFsdWUsIG1hc2spID0+IHtcclxuICBpZiAodHlwZW9mIGlzTWFza2VkVmFsdWUuX19DQUNIRV9fID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgaXNNYXNrZWRWYWx1ZS5fX0NBQ0hFX18gPSB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHt2YWx1ZX0tJHttYXNrfWBcclxuXHJcbiAgaWYgKCFpc01hc2tlZFZhbHVlLl9fQ0FDSEVfX1tjYWNoZUtleV0pIHtcclxuICAgIGNvbnN0IHVubWFza2VkVmFsdWUgPSB1bm1hc2sodmFsdWUsIG1hc2spXHJcbiAgICBpc01hc2tlZFZhbHVlLl9fQ0FDSEVfX1tjYWNoZUtleV0gPVxyXG4gICAgICB2YWx1ZSA9PT0gU3RyaW5nTWFzay5tYXNrKHVubWFza2VkVmFsdWUsIG1hc2spXHJcbiAgfVxyXG5cclxuICByZXR1cm4gaXNNYXNrZWRWYWx1ZS5fX0NBQ0hFX19bY2FjaGVLZXldXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXNrIHRoZSBnaXZlbiB2YWx1ZSB3aXRoIHRoZSBnaXZlbiBtYXNrIGluIGNhc2UgdGhlIHZhbHVlIGlzIG5vdCBhbHJlYWR5IG1hc2tlZCB3aXRoIHRoZVxyXG4gKiBnaXZlbiBtYXNrXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBtYXNrZWQgb3IgdW5tYXNrZWQgdmFsdWVcclxuICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgIGEgYmJqIG1hc2tcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSBhIG1hc2tlZCB2YWx1ZVxyXG4gKi9cclxuY29uc3QgbWFza0lmTm90TWFza2VkID0gKHZhbHVlLCBtYXNrKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBtYXNrSWZOb3RNYXNrZWQuX19DQUNIRV9fID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfXyA9IHt9XHJcbiAgfVxyXG5cclxuICBjb25zdCBjYWNoZUtleSA9IGAke3ZhbHVlfS0ke21hc2t9YFxyXG5cclxuICBpZiAoIW1hc2tJZk5vdE1hc2tlZC5fX0NBQ0hFX19bY2FjaGVLZXldKSB7XHJcbiAgICBpZiAoaXNNYXNrZWRWYWx1ZSh2YWx1ZSwgbWFzaykpIHtcclxuICAgICAgbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfX1tjYWNoZUtleV0gPSB2YWx1ZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBtYXNrSWZOb3RNYXNrZWQuX19DQUNIRV9fW2NhY2hlS2V5XSA9IFN0cmluZ01hc2subWFzayhcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgbWFzayxcclxuICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgKVxyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfX1tjYWNoZUtleV0gPSBTdHJpbmdNYXNrLm1hc2soJycsIG1hc2spXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBtYXNrSWZOb3RNYXNrZWQuX19DQUNIRV9fW2NhY2hlS2V5XVxyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSByZWdleCBwYXR0ZXIgYmFzZWQgb24gdGhlIGdpdmUgdGFza1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFzayAgYmJqIHN0cmluZyBtYXNrXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gcmVnZXggZm9yIHRoZSBnaXZlIG1hc2tcclxuICovXHJcbmNvbnN0IGdlbmVyYXRlUGF0dGVybkZyb21NYXNrID0gbWFzayA9PiB7XHJcbiAgaWYgKHR5cGVvZiBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzay5fX0NBQ0hFX18gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzay5fX0NBQ0hFX18gPSB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FjaGVLZXkgPSBtYXNrXHJcblxyXG4gIGlmICghZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2suX19DQUNIRV9fW2NhY2hlS2V5XSkge1xyXG4gICAgY29uc3QgbWFza0FzQXJyeSA9IG1hc2suc3BsaXQoJycpXHJcbiAgICBsZXQgcmVnZXggPSAnJ1xyXG4gICAgbWFza0FzQXJyeS5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICBzd2l0Y2ggKGMpIHtcclxuICAgICAgICBjYXNlICdYJzpcclxuICAgICAgICAgIHJlZ2V4ICs9ICcoW14gLX5dKSdcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAvLyBodHRwczovL21vdGhlcmVmZi5pbi9yZWdleHB1I2lucHV0PXZhcityZWdleCslM0QrLyU1Q3AlN0JMJTdEL3UlM0ImdW5pY29kZVByb3BlcnR5RXNjYXBlPTFcclxuICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1MDAzMy9yZWd1bGFyLWV4cHJlc3Npb24tdG8tbWF0Y2gtbm9uLWFzY2lpLWNoYXJhY3RlcnMjYW5zd2VyLTQ4OTAyNzY1XHJcbiAgICAgICAgICByZWdleCArPSBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRFxyXG4gICAgICAgICAgICA/ICdcXFxccHtMfSdcclxuICAgICAgICAgICAgOiAnKCg/OltBLVphLXpcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVEMC1cXHUwNUVBXFx1MDVFRi1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2QVxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MDlGQ1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODYtXFx1MEU4QVxcdTBFOEMtXFx1MEVBM1xcdTBFQTVcXHUwRUE3LVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc4XFx1MTg4MC1cXHUxODg0XFx1MTg4Ny1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDOTAtXFx1MUNCQVxcdTFDQkQtXFx1MUNCRlxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGM1xcdTFDRjVcXHUxQ0Y2XFx1MUNGQVxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTgzXFx1MjE4NFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDVcXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzQlxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkZcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGRUZcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFNVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdCRlxcdUE3QzItXFx1QTdDNlxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QThGRVxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjdcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjJELVxcdURGNDBcXHVERjQyLVxcdURGNDlcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENCMC1cXHVEQ0QzXFx1RENEOC1cXHVEQ0ZCXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzNVxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJcXHVERDAwLVxcdUREMjNcXHVERjAwLVxcdURGMUNcXHVERjI3XFx1REYzMC1cXHVERjQ1XFx1REZFMC1cXHVERkY2XXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENDRcXHVERDUwLVxcdURENzJcXHVERDc2XFx1REQ4My1cXHVEREIyXFx1RERDMS1cXHVEREM0XFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMkJcXHVERTgwLVxcdURFODZcXHVERTg4XFx1REU4QS1cXHVERThEXFx1REU4Ri1cXHVERTlEXFx1REU5Ri1cXHVERUE4XFx1REVCMC1cXHVERURFXFx1REYwNS1cXHVERjBDXFx1REYwRlxcdURGMTBcXHVERjEzLVxcdURGMjhcXHVERjJBLVxcdURGMzBcXHVERjMyXFx1REYzM1xcdURGMzUtXFx1REYzOVxcdURGM0RcXHVERjUwXFx1REY1RC1cXHVERjYxXXxcXHVEODA1W1xcdURDMDAtXFx1REMzNFxcdURDNDctXFx1REM0QVxcdURDNUZcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REVCOFxcdURGMDAtXFx1REYxQV18XFx1RDgwNltcXHVEQzAwLVxcdURDMkJcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1RERBMC1cXHVEREE3XFx1RERBQS1cXHVEREQwXFx1RERFMVxcdURERTNcXHVERTAwXFx1REUwQi1cXHVERTMyXFx1REUzQVxcdURFNTBcXHVERTVDLVxcdURFODlcXHVERTlEXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZcXHVERDAwLVxcdUREMDZcXHVERDA4XFx1REQwOVxcdUREMEItXFx1REQzMFxcdURENDZcXHVERDYwLVxcdURENjVcXHVERDY3XFx1REQ2OFxcdURENkEtXFx1REQ4OVxcdUREOThcXHVERUUwLVxcdURFRjJdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJcXHVEODc0LVxcdUQ4NzldW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERTQwLVxcdURFN0ZcXHVERjAwLVxcdURGNEFcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMFxcdURGRTFcXHVERkUzXXxcXHVEODIxW1xcdURDMDAtXFx1REZGN118XFx1RDgyMltcXHVEQzAwLVxcdURFRjJdfFxcdUQ4MkNbXFx1REMwMC1cXHVERDFFXFx1REQ1MC1cXHVERDUyXFx1REQ2NC1cXHVERDY3XFx1REQ3MC1cXHVERUZCXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODM4W1xcdUREMDAtXFx1REQyQ1xcdUREMzctXFx1REQzRFxcdURENEVcXHVERUMwLVxcdURFRUJdfFxcdUQ4M0FbXFx1REMwMC1cXHVEQ0M0XFx1REQwMC1cXHVERDQzXFx1REQ0Ql18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMVxcdURFQjAtXFx1REZGRl18XFx1RDg3QVtcXHVEQzAwLVxcdURGRTBdfFxcdUQ4N0VbXFx1REMwMC1cXHVERTFEXSkpJ1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgIHJlZ2V4ICs9ICcoWzAtOV0pJ1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICd6JzpcclxuICAgICAgICBjYXNlICdaJzpcclxuICAgICAgICAgIHJlZ2V4ICs9IElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEXHJcbiAgICAgICAgICAgID8gJyhbMC05XXxcXFxccHtMfSknXHJcbiAgICAgICAgICAgIDogJyhbMC05XXwoPzpbQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1RDAtXFx1MDVFQVxcdTA1RUYtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkVGXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QkZcXHVBN0MyLVxcdUE3QzZcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE4RkVcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY3XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzVcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXFx1REQwMC1cXHVERDIzXFx1REYwMC1cXHVERjFDXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDQ0XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzVGXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERjAwLVxcdURGMUFdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1REVFMC1cXHVERUYyXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REU0MC1cXHVERTdGXFx1REYwMC1cXHVERjRBXFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBcXHVERkUxXFx1REZFM118XFx1RDgyMVtcXHVEQzAwLVxcdURGRjddfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENTAtXFx1REQ1MlxcdURENjQtXFx1REQ2N1xcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDRFXFx1REVDMC1cXHVERUVCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M1xcdURENEJdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0pKSdcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnVSc6XHJcbiAgICAgICAgICByZWdleCArPSBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRFxyXG4gICAgICAgICAgICA/ICcoKFswLTldKXwoXFxcXHMpfChbLiwvIyEkJV4mKjs6e309LV9gfigpXSl8KFxcXFxwe0x9KSknXHJcbiAgICAgICAgICAgIDogJygoWzAtOV0pfChcXFxccyl8KFsuLC8jISQlXiYqOzp7fT0tX2B+KCldKXwoPzpbQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1RDAtXFx1MDVFQVxcdTA1RUYtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkVGXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QkZcXHVBN0MyLVxcdUE3QzZcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE4RkVcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY3XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzVcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXFx1REQwMC1cXHVERDIzXFx1REYwMC1cXHVERjFDXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDQ0XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzVGXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERjAwLVxcdURGMUFdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1REVFMC1cXHVERUYyXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REU0MC1cXHVERTdGXFx1REYwMC1cXHVERjRBXFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBcXHVERkUxXFx1REZFM118XFx1RDgyMVtcXHVEQzAwLVxcdURGRjddfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENTAtXFx1REQ1MlxcdURENjQtXFx1REQ2N1xcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDRFXFx1REVDMC1cXHVERUVCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M1xcdURENEJdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0pKSdcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJlZ2V4ICs9IGMucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzay5fX0NBQ0hFX19bY2FjaGVLZXldID0gcmVnZXhcclxuICB9XHJcblxyXG4gIHJldHVybiBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzay5fX0NBQ0hFX19bY2FjaGVLZXldXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVbm1hc2sgdGhlIGdpdmVuIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrZWRWYWx1ZSBtYXNrZWQgc3RyaW5nXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrICB0aGUgdXNlZCBtYXNrIHRvIHByb2R1Y2UgdGhlIG1hc2tlZCBzdHJpbmdcclxuICovXHJcbmNvbnN0IHVubWFzayA9IChtYXNrZWRWYWx1ZSwgbWFzaykgPT4ge1xyXG4gIGlmICh0eXBlb2YgdW5tYXNrLl9fQ0FDSEVfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHVubWFzay5fX0NBQ0hFX18gPSB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHttYXNrZWRWYWx1ZX0tJHttYXNrfWBcclxuXHJcbiAgaWYgKCF1bm1hc2suX19DQUNIRV9fW2NhY2hlS2V5XSkge1xyXG4gICAgY29uc3QgbWFza0FzQXJyYXkgPSBtYXNrLnNwbGl0KCcnKVxyXG4gICAgY29uc3QgbWFza2VkVmFsdWVBc0FycmF5ID0gbWFza2VkVmFsdWUuc3BsaXQoJycpXHJcblxyXG4gICAgbGV0IHVubWFza2VkID0gJydcclxuXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWFza2VkVmFsdWVBc0FycmF5Lmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjb25zdCBlbCA9IG1hc2tlZFZhbHVlQXNBcnJheVtpbmRleF1cclxuICAgICAgY29uc3QgbWFzayA9IG1hc2tBc0FycmF5W2luZGV4XVxyXG4gICAgICBjb25zdCBlbEhhc01hc2sgPSBTVVBQT1JURURfTUFTS1MuaW5kZXhPZihtYXNrKSA+IC0xXHJcbiAgICAgIGlmIChlbEhhc01hc2spIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgIGdlbmVyYXRlUGF0dGVybkZyb21NYXNrKG1hc2spLFxyXG4gICAgICAgICAgSVNfVU5JQ09ERV9QUk9QRVJUWV9TVVBQT1JURUQgPyAndScgOiAnJ1xyXG4gICAgICAgIClcclxuICAgICAgICBpZiAocGF0dGVybi50ZXN0KGVsKSkgdW5tYXNrZWQgKz0gZWxcclxuICAgICAgICBlbHNlIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1bm1hc2suX19DQUNIRV9fW2NhY2hlS2V5XSA9IHVubWFza2VkLnRvTG9jYWxlTG93ZXJDYXNlKClcclxuICB9XHJcblxyXG4gIHJldHVybiB1bm1hc2suX19DQUNIRV9fW2NhY2hlS2V5XVxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIG1hc2tlZCBzdHJpbmcgLCBmaW5kIHRoZSBuZXh0IGNhcmV0IHBvc2l0aW9uIGRlcGVuZGluZyBvblxyXG4gKiB3aGF0IGlzIG1pc3NpbmcgdG8gY29tcGxldGUgdGhlIG1hc2tcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1hc2tlZFZhbHVlIG1hc2tlZCBzdHJpbmdcclxuICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgIHRoZSB1c2VkIG1hc2sgdG8gcHJvZHVjZSB0aGUgbWFza2VkIHN0cmluZ1xyXG4gKi9cclxuY29uc3QgZmluZENhcmV0UG9zaXRpb24gPSAobWFza2VkVmFsdWUsIG1hc2spID0+IHtcclxuICBpZiAodHlwZW9mIGZpbmRDYXJldFBvc2l0aW9uLl9fQ0FDSEVfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGZpbmRDYXJldFBvc2l0aW9uLl9fQ0FDSEVfXyA9IHt9XHJcbiAgfVxyXG5cclxuICBjb25zdCBjYWNoZUtleSA9IGAke21hc2tlZFZhbHVlfS0ke21hc2t9YFxyXG4gIGlmICghZmluZENhcmV0UG9zaXRpb24uX19DQUNIRV9fW2NhY2hlS2V5XSkge1xyXG4gICAgY29uc3QgbWFza0FzQXJyYXkgPSBtYXNrLnNwbGl0KCcnKVxyXG4gICAgbGV0IG1hc2tlZFZhbHVlQXNBcnJheSA9IG1hc2tlZFZhbHVlLnNwbGl0KCcnKVxyXG4gICAgaWYgKG1hc2tlZFZhbHVlQXNBcnJheS5sZW5ndGggPCBtYXNrQXNBcnJheS5sZW5ndGgpIHtcclxuICAgICAgbWFza2VkVmFsdWVBc0FycmF5ID0gbWFza2VkVmFsdWVBc0FycmF5LmNvbmNhdChcclxuICAgICAgICBuZXcgQXJyYXkobWFza0FzQXJyYXkubGVuZ3RoIC0gbWFza2VkVmFsdWVBc0FycmF5Lmxlbmd0aCkuam9pbignICcpLnNwbGl0KCcnKVxyXG4gICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHBvc2l0aW9uID0gLTFcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtYXNrQXNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgY29uc3QgZWwgPSBtYXNrQXNBcnJheVtpbmRleF1cclxuICAgICAgaWYgKGVsICE9PSBtYXNrZWRWYWx1ZUFzQXJyYXlbaW5kZXhdKSB7XHJcbiAgICAgICAgLy8gaWYgKG1hc2tlZFZhbHVlQXNBcnJheVtpbmRleF0gPT09ICcgJykgcmV0dXJuIGluZGV4XHJcbiAgICAgICAgaWYgKFNVUFBPUlRFRF9NQVNLUy5pbmRleE9mKGVsKSA+IC0xKSB7XHJcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2soZWwpLFxyXG4gICAgICAgICAgICBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRCA/ICd1JyA6ICcnXHJcbiAgICAgICAgICApXHJcblxyXG4gICAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QobWFza2VkVmFsdWVBc0FycmF5W2luZGV4XSkpIHtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBpbmRleFxyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZpbmRDYXJldFBvc2l0aW9uLl9fQ0FDSEVfX1tjYWNoZUtleV0gPVxyXG4gICAgICBwb3NpdGlvbiA8IDAgPyBtYXNrZWRWYWx1ZUFzQXJyYXkubGVuZ3RoIDogcG9zaXRpb25cclxuICB9XHJcblxyXG4gIHJldHVybiBmaW5kQ2FyZXRQb3NpdGlvbi5fX0NBQ0hFX19bY2FjaGVLZXldXHJcbn1cclxuXHJcbmV4cG9ydCB7XHJcbiAgaXNNYXNrZWRWYWx1ZSxcclxuICBtYXNrSWZOb3RNYXNrZWQsXHJcbiAgdW5tYXNrLFxyXG4gIGZpbmRDYXJldFBvc2l0aW9uLFxyXG4gIGdlbmVyYXRlUGF0dGVybkZyb21NYXNrLFxyXG4gIElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVELFxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZXh0SW5wdXQvdG9vbHMuanMiLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1pbnB1dC1tYXNraW5nIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgTnVtYmVySW5wdXQgZnJvbSAnLi9OdW1iZXJJbnB1dCdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE51bWJlcklucHV0XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9OdW1iZXJJbnB1dC9pbmRleC5qcyIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWlucHV0LW1hc2tpbmcgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBOdW1iZXJNYXNrIGZyb20gJ2Jiai1tYXNrcy9zcmMvTnVtYmVyTWFzaydcclxuXHJcbmNvbnN0IGNvdW50RGVjaW1hbHMgPSB2YWx1ZSA9PiB7XHJcbiAgaWYgKHZhbHVlICUgMSAhPSAwKSB7XHJcbiAgICBjb25zdCBzcGxpdCA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVxyXG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMikgcmV0dXJuIHNwbGl0WzFdLmxlbmd0aFxyXG4gIH1cclxuICByZXR1cm4gMFxyXG59XHJcblxyXG4vKipcclxuICogVGhlIGBOdW1iZXJJbnB1dGAgd2lsbCB3cmFwIHRleHQgaW5wdXRzIGFuZCBhcHBseSB0aGUgZ2l2ZW4gW2JiaiBOdW1iZXIgbWFza10oaHR0cHM6Ly9naXRodWIuY29tL0Jhc2lzSHViL2Jiai1tYXNrcyNudW1iZXItbWFza3MpXHJcbiAqXHJcbiAqICoqT3B0aW9ucyoqXHJcbiAqXHJcbiAqIF9PcHRpb25zIGNhbiBiZSBwYXNzZWQgdmlhIGRhdGEgYXR0cmlidXRlcyAuIEZvciBkYXRhIGF0dHJpYnV0ZXMsIGFwcGVuZCB0aGUgb3B0aW9uIG5hbWUgdG8gZGF0YS0sIGFzIGluIGRhdGEtbWFza19cclxuICpcclxuICogfCBPcHRpb24gICAgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqIHwtLS0tLS0tLS0tLXwtLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxyXG4gKiB8IG1hc2sgfCAgICAgICAgIHwgVGhlIGJiaiBudW1iZXIgbWFzayBAc2VlIFtCQmogTnVtYmVyIE1hc2tzXShodHRwczovL2dpdGh1Yi5jb20vQmFzaXNIdWIvYmJqLW1hc2tzI251bWJlci1tYXNrcykgfFxyXG4gKiB8IG1pbiB8ICAgICAgICAgfCBUaGUgbWF4aW11bSB2YWx1ZSB0byBhY2NlcHQgZm9yIHRoaXMgaW5wdXR8XHJcbiAqIHwgbWF4IHwgICAgICAgICB8IFRoZSBtaW5pbXVtIHZhbHVlIHRvIGFjY2VwdCBmb3IgdGhpcyBpbnB1dHxcclxuICogfCBzdGVwIHwgICAgICAgICB8IEEgc3RlcHBpbmcgaW50ZXJ2YWwgdG8gdXNlIHdoZW4gdXNpbmcgdXAgYW5kIGRvd24gYXJyb3dzIHRvIGFkanVzdCB0aGUgdmFsdWUsIGFzIHdlbGwgYXMgZm9yIHZhbGlkYXRpb258XHJcbiAqIHxncm91cGluZy1zZXBhcmF0b3IgfCAsIHwgYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGdyb3VwaW5nIHNlcGFyYXRvciB8XHJcbiAqIHxkZWNpbWFsLXNlcGFyYXRvciB8IC4gfCBhIGNoYXIgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgZGVjaW1hbCBzZXBhcmF0b3IgfFxyXG4gKiB8Zm9yY2UtdHJhaWxpbmctemVyb3MgfCBmYWxzZSB8IEFmZmVjdHMgdGhlIG91dHB1dCBieSBzd2l0Y2hpbmcgdGhlIHdheSBhIG1hc2sgd2l0aCBcIiNcIiBjaGFyYWN0ZXJzIGluIHRoZSB0cmFpbGluZyBwb3NpdGlvbnMgaXMgZmlsbGVkLiBmb3IgZXhhbXBsZSwgdGhlIGZ1bmN0aW9uIE51bWJlck1hc2subWFzayguMTA6XCIjLiMjXCIpIHJldHVybnMgLjEwIGluc3RlYWQgb2YgLjF8XHJcbiAqXHJcbiAqICA8YnI+XHJcbiAqXHJcbiAqICoqRXhhbXBsZSA6KipcclxuICogYGBgaHRtbFxyXG4gKiAgPGlucHV0IGNsYXNzPVwiYmJqLW51bWJlci1tYXNrZWRcIiBuYW1lPVwidGVzdFwiIGlkPVwidGVzdFwiIHZhbHVlPVwiMTIzNFwiIGRhdGEtbWFzaz1cIiMjLCMjMFwiPlxyXG4gKlxyXG4gKiAgPHNjcmlwdD5cclxuICogICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIChlKSB7XHJcbiAqICAgICAgbmV3IEJhc2lzLklucHV0TWFza2luZy5OdW1iZXJJbnB1dCh7XHJcbiAqXHJcbiAqICAgICAgICAgLy8gQHBhcmFtIHtTdHJpbmd9IHZhbHVlTWFza2VkICBtYXNrZWQgdmFsdWVcclxuICogICAgICAgICAvLyBAcGFyYW0ge051bWJlcn0gdmFsdWVVbm1hc2tlZCAgb3JpZ2luYWwgdmFsdWVcclxuICogICAgICAgICAvLyBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0IHRoZSBhY3R1YWwgaW5wdXQgaW5zdGFuY2VcclxuICogICAgICAgICBvblVwZGF0ZTogKHZhbHVlTWFza2VkLCB2YWx1ZVVubWFza2VkLCBpbnB1dCwgaXNBcHBsaWVkLCBpc0luaXRpYWwpID0+IHtcclxuICogICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICogICAgICAgICB9LFxyXG4gKlxyXG4gKiAgICAgICAgIC8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXJyb3IgbGFzdCBvY2N1cnJlZCBlcnJvci4gY291bGQgYmUgbWFzayBlcnJvciBvciB2YWxpZGF0aW9uIGVycm9yXHJcbiAqICAgICAgICAgLy8gQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCB0aGUgYWN0dWFsIGlucHV0IGluc3RhbmNlXHJcbiAqICAgICAgICAgb25JbnZhbGlkOiAoZXJyICwgaW5wdXQpID0+IHtcclxuICogICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICogICAgICAgICB9XHJcbiAqICAgICAgfSlcclxuICogICAgfSlcclxuICogIDwvc2NyaXB0PlxyXG4gKiBgYGBcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcbmNsYXNzIE51bWJlcklucHV0IHtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgbmV3IE51bWJlcklucHV0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnMgLSBUaGUgaW5wdXQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gW29wdGlvbnMuZWxlbWVudHM9XCIuYmJqLW51bWJlci1tYXNrZWRcIl0gLSBUaGUgY2xhc3MgbmFtZSBvciB0aGUgbm9kZSB0byB1c2VcclxuICAgKiBAcGFyYW0ge0hUTUxEb2N1bWVudH0gW29wdGlvbnMuZG9jdW1lbnQ9ZG9jdW1lbnRdIC0gRG9jdW1lbnQgaW5zdGFuY2UgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNzc0NsYXNzRXJyb3I9XCJiYmotbWFzay1lcnJvclwiXSAtIEEgY3NzIGNsYXNzIHRvIGF0dGFjaCB0byB0aGUgaW5wdXQgd2hlbiBpdCBpcyBpbnZhbGlkXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNzc0NsYXNzU3VjY2Vzcz1cImJiai1tYXNrLXN1Y2Nlc3NcIl0gLSBBIGNzcyBjbGFzcyB0byBhdHRhY2ggdG8gdGhlIGlucHV0IHdoZW4gaXQgaXMgdmFsaWQgYWZ0ZXIgdGhlIHVzZXIgaW50ZXJhY3Rpb25cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vblVwZGF0ZT1udWxsXSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIHRoZSBuZXcgbWFza2VkIHZhbHVlIGlzIHNldFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uSW52YWxpZD1udWxsXSAtIEEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIHRoZSBpbnB1dCBvciB0aGUgbWFzayBpcyBpbnZhbGlkXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLm9wdGlvbnMgPSB7XHJcbiAgICAgIC4uLntcclxuICAgICAgICBlbGVtZW50czogJy5iYmotbnVtYmVyLW1hc2tlZCcsXHJcbiAgICAgICAgZG9jOiBkb2N1bWVudCxcclxuICAgICAgICBjc3NDbGFzc0Vycm9yOiAnYmJqLW1hc2stZXJyb3InLFxyXG4gICAgICAgIGNzc0NsYXNzU3VjY2VzczogJ2Jiai1tYXNrLXN1Y2Nlc3MnLFxyXG4gICAgICAgIG9uVXBkYXRlOiBudWxsLFxyXG4gICAgICAgIG9uSW52YWxpZDogbnVsbCxcclxuICAgICAgfSxcclxuICAgICAgLi4ub3B0aW9ucyxcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIgPSB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIuYmluZCh0aGlzKVxyXG4gICAgdGhpcy5fdW5tYXNrZWRJbnB1dEhhbmRsZXIgPSB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlci5iaW5kKHRoaXMpXHJcbiAgICB0aGlzLnJlZnJlc2goKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGFuZCB3cmFwIHRoZSBpbnB1dCBlbGVtZW50cyBmb3IgbWFza2luZyBpbiBjYXNlXHJcbiAgICogdGhleSBhcmUgbm90IHdyYXBwZWQgeWV0XHJcbiAgICovXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnRzID1cclxuICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5lbGVtZW50cyA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZWxlbWVudHMpXHJcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuZWxlbWVudHNcclxuICAgIGxldCBpbnB1dCwgcGFyZW50Q2xhc3NcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlucHV0ID0gZWxlbWVudHNbaV1cclxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudENsYXNzID0gaW5wdXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcclxuXHJcbiAgICAgICAgaWYgKCFpbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgYEJCak1hc2tpbmc6IElucHV0IGhhcyBubyBJRC4gV2l0aG91dCBhbiBJRCB0aGUgaW5wdXQgY2Fubm90IGJlIG1hc2tlZGAsXHJcbiAgICAgICAgICAgIGlucHV0XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgaW5pdGlhbGl6ZSB0aGUgaW5wdXQncyB3cmFwIHR3aWNlXHJcbiAgICAgICAgY29uc3QgaXNXcmFwcGVkID1cclxuICAgICAgICAgIHBhcmVudENsYXNzICYmIHBhcmVudENsYXNzLmluZGV4T2YoJ251bWJlcklucHV0TWFza19fd3JhcCcpID4gLTFcclxuICAgICAgICB0aGlzLl93cmFwKGlucHV0LCBpc1dyYXBwZWQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYEJCak1hc2tpbmc6IEludmFsaWQgaW5wdXQgZWxlbWVudC4gVGhlIGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkYCxcclxuICAgICAgICAgIGlucHV0XHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIGlucHV0IGVsZW1lbnRzIGFuZCByZW1vdmUgYXR0YWNoZWQgbGlzdGVuZXJzXHJcbiAgICovXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnRzID1cclxuICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5lbGVtZW50cyA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZWxlbWVudHMpXHJcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuZWxlbWVudHNcclxuXHJcbiAgICBsZXQgaW5wdXQsIHBhcmVudCwgcGFyZW50Q2xhc3NcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlucHV0ID0gZWxlbWVudHNbaV1cclxuICAgICAgcGFyZW50ID0gaW5wdXQucGFyZW50Tm9kZVxyXG4gICAgICBwYXJlbnRDbGFzcyA9IHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcclxuXHJcbiAgICAgIGlmIChwYXJlbnRDbGFzcyAmJiBwYXJlbnRDbGFzcy5pbmRleE9mKCdudW1iZXJJbnB1dE1hc2tfX3dyYXAnKSA+IC0xKSB7XHJcbiAgICAgICAgdGhpcy5fdW53cmFwKHBhcmVudClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBudW1iZXIgbWFza2luZyBpbnB1dCB3cmFwcGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGFjdHVhbElucHV0IHRoZSBpbnB1dCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1dyYXBwZWQgd2hlbiB0cnVlIHRoZSBpbnB1dCBpcyBhbHJlYWR5IHdyYXBwZWQgYW5kIHdlIG5lZWQgdG8gYWRkIHdoYXQgaXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nIG9ubHlcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtIVE1MU3BhbkVsZW1lbnR9IHdyYXBwZXIgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfd3JhcChhY3R1YWxJbnB1dCwgaXNXcmFwcGVkKSB7XHJcbiAgICBjb25zdCBhY3R1YWxJbnB1dElkID0gYWN0dWFsSW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpLFxyXG4gICAgICBhY3R1YWxJbnB1dE5hbWUgPSBhY3R1YWxJbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcclxuICAgICAgYWN0dWFsSW5wdXRTdGVwID0gYWN0dWFsSW5wdXQuZGF0YXNldC5zdGVwIHx8IG51bGwsXHJcbiAgICAgIGFjdHVhbElucHV0TWF4ID0gYWN0dWFsSW5wdXQuZGF0YXNldC5tYXggfHwgbnVsbCxcclxuICAgICAgYWN0dWFsSW5wdXRNaW4gPSBhY3R1YWxJbnB1dC5kYXRhc2V0Lm1pbiB8fCBudWxsLFxyXG4gICAgICBhY3R1YWxJbnB1dEdyb3VwaW5nU2VwYXJhdG9yID1cclxuICAgICAgICBhY3R1YWxJbnB1dC5kYXRhc2V0Lmdyb3VwaW5nU2VwYXJhdG9yIHx8ICcsJyxcclxuICAgICAgYWN0dWFsSW5wdXREZWNpbWFsU2VwYXJhdG9yID0gYWN0dWFsSW5wdXQuZGF0YXNldC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcuJyxcclxuICAgICAgYWN0dWFsSW5wdXRGb3JjZVRyYWlsaW5nWmVyb3MgPVxyXG4gICAgICAgIGFjdHVhbElucHV0LmRhdGFzZXQuZm9yY2VUcmFpbGluZ1plcm9zIHx8IG51bGwsXHJcbiAgICAgIGFjdHVhbElucHV0TWFzayA9IGFjdHVhbElucHV0LmRhdGFzZXQubWFzayB8fCAnJyxcclxuICAgICAgYWN0dWFsSW5wdXRDbGFzc2VzID0gYWN0dWFsSW5wdXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxyXG4gICAgICBhY3R1YWxJbnB1dFJlcXVpcmVkID0gYWN0dWFsSW5wdXQuZ2V0QXR0cmlidXRlKCdyZXF1aXJlZCcpIHx8IG51bGxcclxuXHJcbiAgICBsZXQgd3JhcCA9IG51bGwsXHJcbiAgICAgIHVubWFza2VkSW5wdXQgPSBudWxsXHJcblxyXG4gICAgaWYgKCFpc1dyYXBwZWQpIHtcclxuICAgICAgd3JhcCA9IHRoaXMub3B0aW9ucy5kb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpXHJcbiAgICAgIHVubWFza2VkSW5wdXQgPSB0aGlzLm9wdGlvbnMuZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JykgLy8gaGlkZGVuIGlucHV0IHdpdGggdGhlIHVubWFza2VkIHZhbHVlcyBmb3IgZm9ybXNcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdyYXAgPSBhY3R1YWxJbnB1dC5wYXJlbnROb2RlXHJcbiAgICAgIHVubWFza2VkSW5wdXQgPSB3cmFwLnF1ZXJ5U2VsZWN0b3IoJy5udW1iZXJJbnB1dE1hc2tfX3VubWFza2VkSW5wdXQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbmZpZ3VyZSB0aGUgYWN0dWFsIGlucHV0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgaWYgKCFpc1dyYXBwZWQpIHtcclxuICAgICAgYWN0dWFsSW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcCwgYWN0dWFsSW5wdXQpIC8vIG1vdmUgdGhlIGlucHV0IG91dHNpZGUgdGhlIHdyYXBwZXJcclxuICAgICAgaWYgKFxyXG4gICAgICAgICEoXHJcbiAgICAgICAgICBhY3R1YWxJbnB1dC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHxcclxuICAgICAgICAgIGFjdHVhbElucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKVxyXG4gICAgICAgIClcclxuICAgICAgKSB7XHJcbiAgICAgICAgYWN0dWFsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIpXHJcbiAgICAgICAgYWN0dWFsSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX2FjdHVhbElucHV0SGFuZGxlcilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCA9IGFjdHVhbElucHV0LnZhbHVlIHx8IDBcclxuICAgIGFjdHVhbElucHV0LmRhdGFzZXQuZ3JvdXBpbmdTZXBhcmF0b3IgPSBhY3R1YWxJbnB1dEdyb3VwaW5nU2VwYXJhdG9yXHJcbiAgICBhY3R1YWxJbnB1dC5kYXRhc2V0LmRlY2ltYWxTZXBhcmF0b3IgPSBhY3R1YWxJbnB1dERlY2ltYWxTZXBhcmF0b3JcclxuICAgIGFjdHVhbElucHV0LmRhdGFzZXQuZm9yY2VUcmFpbGluZ1plcm9zID0gYWN0dWFsSW5wdXRGb3JjZVRyYWlsaW5nWmVyb3NcclxuICAgIGFjdHVhbElucHV0LnZhbHVlID0gTnVtYmVyTWFzay5tYXNrKFxyXG4gICAgICBhY3R1YWxJbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWQsXHJcbiAgICAgIGFjdHVhbElucHV0TWFzayxcclxuICAgICAgYWN0dWFsSW5wdXRHcm91cGluZ1NlcGFyYXRvcixcclxuICAgICAgYWN0dWFsSW5wdXREZWNpbWFsU2VwYXJhdG9yLFxyXG4gICAgICBhY3R1YWxJbnB1dEZvcmNlVHJhaWxpbmdaZXJvc1xyXG4gICAgKS50cmltKClcclxuICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5hZGQoXHJcbiAgICAgICdudW1iZXJJbnB1dE1hc2tfX3RleHRJbnB1dCcsXHJcbiAgICAgIHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3NcclxuICAgIClcclxuXHJcbiAgICAvLyBjb25maWd1cmUgdGhlIHVubWFza2VkIGlucHV0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICB1bm1hc2tlZElucHV0LnZhbHVlID0gYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkXHJcbiAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpXHJcbiAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdoaWRkZW4nKVxyXG4gICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYWN0dWFsSW5wdXRDbGFzc2VzKVxyXG4gICAgaWYgKGFjdHVhbElucHV0SWQpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCdpZCcsIGAke2FjdHVhbElucHV0SWR9LXVubWFza2VkYClcclxuICAgIGlmIChhY3R1YWxJbnB1dE5hbWUpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCduYW1lJywgYCR7YWN0dWFsSW5wdXROYW1lfS11bm1hc2tlZGApXHJcbiAgICBpZiAoYWN0dWFsSW5wdXRSZXF1aXJlZCkgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJywgJ3JlcXVpcmVkJylcclxuXHJcbiAgICBpZiAoYWN0dWFsSW5wdXRTdGVwKSB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnc3RlcCcsIGFjdHVhbElucHV0U3RlcClcclxuICAgIGVsc2Uge1xyXG4gICAgICBjb25zdCBkZWNpbWFscyA9IGNvdW50RGVjaW1hbHModW5tYXNrZWRJbnB1dC52YWx1ZSlcclxuICAgICAgbGV0IHN0ZXAgPSAnMSdcclxuICAgICAgaWYgKGRlY2ltYWxzID4gMCkge1xyXG4gICAgICAgIHN0ZXAgPSBgLiR7QXJyYXkoZGVjaW1hbHMpLmpvaW4oJzAnKX0xYFxyXG4gICAgICB9XHJcblxyXG4gICAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnc3RlcCcsIHN0ZXApXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFjdHVhbElucHV0TWluKSB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnbWluJywgYWN0dWFsSW5wdXRNaW4pXHJcbiAgICBpZiAoYWN0dWFsSW5wdXRNYXgpIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCdtYXgnLCBhY3R1YWxJbnB1dE1heClcclxuICAgIHVubWFza2VkSW5wdXQuZGF0YXNldC5pbnB1dElkID0gYWN0dWFsSW5wdXRJZFxyXG4gICAgdW5tYXNrZWRJbnB1dC5kYXRhc2V0Lm1hc2sgPSBhY3R1YWxJbnB1dE1hc2tcclxuICAgIHVubWFza2VkSW5wdXQuZGF0YXNldC5ncm91cGluZ1NlcGFyYXRvciA9IGFjdHVhbElucHV0R3JvdXBpbmdTZXBhcmF0b3JcclxuICAgIHVubWFza2VkSW5wdXQuZGF0YXNldC5kZWNpbWFsU2VwYXJhdG9yID0gYWN0dWFsSW5wdXREZWNpbWFsU2VwYXJhdG9yXHJcbiAgICBpZiAoYWN0dWFsSW5wdXRGb3JjZVRyYWlsaW5nWmVyb3MpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuZGF0YXNldC5mb3JjZVRyYWlsaW5nWmVyb3MgPSBhY3R1YWxJbnB1dEZvcmNlVHJhaWxpbmdaZXJvc1xyXG5cclxuICAgIGlmICghaXNXcmFwcGVkKSB7XHJcbiAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LmFkZCgnbnVtYmVySW5wdXRNYXNrX191bm1hc2tlZElucHV0JylcclxuICAgICAgdW5tYXNrZWRJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fdW5tYXNrZWRJbnB1dEhhbmRsZXIpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlcilcclxuICAgICAgdW5tYXNrZWRJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyKVxyXG5cclxuICAgICAgLy8gY29uZmlndXJlIHRoZSB3cmFwcGVyXHJcbiAgICAgIHdyYXAuc2V0QXR0cmlidXRlKCdjbGFzcycsICdudW1iZXJJbnB1dE1hc2tfX3dyYXAnKVxyXG4gICAgICB3cmFwLmFwcGVuZENoaWxkKHVubWFza2VkSW5wdXQpXHJcbiAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoYWN0dWFsSW5wdXQpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc05hTihOdW1iZXIoYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkKSkpIHtcclxuICAgICAgaWYgKHRoaXMuX3ZhbGlkYXRlSW5wdXQodW5tYXNrZWRJbnB1dCwgYWN0dWFsSW5wdXQpKSB7XHJcbiAgICAgICAgdGhpcy5fX2ZpcmVPblVwZGF0ZShcclxuICAgICAgICAgIGFjdHVhbElucHV0LnZhbHVlLFxyXG4gICAgICAgICAgYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkLFxyXG4gICAgICAgICAgYWN0dWFsSW5wdXRcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdyYXBcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbWFza2VkIGlucHV0IGFuZCByZW1vdmUgdGhlIHZhbHVlIGNoYW5nZWQgbGlzdGVuZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTFNwYW5FbGVtZW50fSB3cmFwcGVyIHRoZSB3cmFwcGVyIHNwYW4gaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfdW53cmFwKHdyYXBwZXIpIHtcclxuICAgIGNvbnN0IGFjdHVhbElucHV0ID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKCcubnVtYmVySW5wdXRNYXNrX190ZXh0SW5wdXQnKSxcclxuICAgICAgYWN0dWFsSW5wdXRJZCA9IGFjdHVhbElucHV0LmlkLFxyXG4gICAgICB1bm1hc2tlZElucHV0ID0gd3JhcHBlci5xdWVyeVNlbGVjdG9yKGAjJHthY3R1YWxJbnB1dElkfS11bm1hc2tlZGApXHJcblxyXG4gICAgdW5tYXNrZWRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyKVxyXG4gICAgdW5tYXNrZWRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyKVxyXG4gICAgdW5tYXNrZWRJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyKVxyXG5cclxuICAgIHdyYXBwZXIucmVtb3ZlQ2hpbGQodW5tYXNrZWRJbnB1dClcclxuXHJcbiAgICBhY3R1YWxJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2FjdHVhbElucHV0SGFuZGxlcilcclxuICAgIGFjdHVhbElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIpXHJcbiAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdudW1iZXJJbnB1dE1hc2tfX3RleHRJbnB1dCcpXHJcbiAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgZGVsZXRlIGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZFxyXG5cclxuICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYWN0dWFsSW5wdXQsIHdyYXBwZXIpXHJcbiAgICB3cmFwcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod3JhcHBlcilcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBjbGljayBhbmQgZm9jdXNpbiBldmVudCBvbiB0aGUgYWN0dWFsIGlucHV0IGFuZCB0b2dnbGUgdGhlIG51bWJlciBpbnB1dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF9hY3R1YWxJbnB1dEhhbmRsZXIoZSkge1xyXG4gICAgY29uc3QgYWN0dWFsSW5wdXQgPSBlLnRhcmdldCxcclxuICAgICAgYWN0dWFsSW5wdXRJZCA9IGFjdHVhbElucHV0LmlkLFxyXG4gICAgICB1bm1hc2tlZElucHV0ID0gdGhpcy5vcHRpb25zLmRvYy5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICAgIGAjJHthY3R1YWxJbnB1dElkfS11bm1hc2tlZGBcclxuICAgICAgKVxyXG5cclxuICAgIGFjdHVhbElucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpXHJcbiAgICBhY3R1YWxJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaGlkZGVuJylcclxuXHJcbiAgICB1bm1hc2tlZElucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxyXG4gICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbnVtYmVyJylcclxuICAgIHRoaXMuX3ZhbGlkYXRlSW5wdXQodW5tYXNrZWRJbnB1dCwgYWN0dWFsSW5wdXQpXHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgdW5tYXNrZWRJbnB1dC5mb2N1cygpXHJcbiAgICAgIGNvbnN0IGxlbmd0aCA9IFN0cmluZyh1bm1hc2tlZElucHV0LnZhbHVlKS5sZW5ndGhcclxuICAgICAgdW5tYXNrZWRJbnB1dC50eXBlID0gJ3RleHQnXHJcbiAgICAgIHVubWFza2VkSW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpXHJcbiAgICAgIHVubWFza2VkSW5wdXQudHlwZSA9ICdudW1iZXInXHJcbiAgICB9LCAwKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRvIHRoZSB1bm1hc2tlZCBpbnB1dCBrZXlkb3duIGFuZCBmb2N1c291dCBldmVudHMgYW5kIGNoZWNrXHJcbiAgICogaWYgdGhlIGlucHV0IHZhbHVlIGNhbiBiZSBtYXNrZWQgb3Igbm90XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3VubWFza2VkSW5wdXRIYW5kbGVyKGUpIHtcclxuICAgIGNvbnN0IHVubWFza2VkSW5wdXQgPSBlLnRhcmdldCxcclxuICAgICAga2V5Q29kZSA9IGUua2V5Q29kZSxcclxuICAgICAgbWFzayA9IHVubWFza2VkSW5wdXQuZGF0YXNldC5tYXNrLFxyXG4gICAgICBncm91cGluZ1NlcGFyYXRvciA9IHVubWFza2VkSW5wdXQuZGF0YXNldC5ncm91cGluZ1NlcGFyYXRvcixcclxuICAgICAgZGVjaW1hbFNlcGFyYXRvciA9IHVubWFza2VkSW5wdXQuZGF0YXNldC5kZWNpbWFsU2VwYXJhdG9yLFxyXG4gICAgICBmb3JjZVRyYWlsaW5nWmVyb3MgPSB1bm1hc2tlZElucHV0LmRhdGFzZXQuZm9yY2VUcmFpbGluZ1plcm9zLFxyXG4gICAgICBhY3R1YWxJbnB1dElkID0gdW5tYXNrZWRJbnB1dC5kYXRhc2V0LmlucHV0SWQsXHJcbiAgICAgIGFjdHVhbElucHV0ID0gdGhpcy5vcHRpb25zLmRvYy5xdWVyeVNlbGVjdG9yKGAjJHthY3R1YWxJbnB1dElkfWApXHJcblxyXG4gICAgbGV0IHJlc3RvcmUgPSBmYWxzZSxcclxuICAgICAgYXBwbHkgPSBmYWxzZSxcclxuICAgICAgbWFza2VkVmFsdWUgPSBmYWxzZSxcclxuICAgICAgaXNWYWxpZCA9IHRoaXMuX3ZhbGlkYXRlSW5wdXQodW5tYXNrZWRJbnB1dCwgYWN0dWFsSW5wdXQpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgbWFza2VkVmFsdWUgPSBOdW1iZXJNYXNrLm1hc2soXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC52YWx1ZSB8fCAwLFxyXG4gICAgICAgIG1hc2ssXHJcbiAgICAgICAgZ3JvdXBpbmdTZXBhcmF0b3IsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcixcclxuICAgICAgICBmb3JjZVRyYWlsaW5nWmVyb3MsXHJcbiAgICAgICAgZmFsc2VcclxuICAgICAgKS50cmltKClcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgbWFza2VkVmFsdWUgPSBmYWxzZVxyXG4gICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0LCAnZXJyb3InKVxyXG4gICAgICB0aGlzLl9fZmlyZU9uSW52YWxpZChlLCBhY3R1YWxJbnB1dClcclxuICAgIH1cclxuXHJcbiAgICByZXN0b3JlID0gWzEzLCAyN10uaW5kZXhPZihrZXlDb2RlKSA+IC0xIHx8IGUudHlwZSA9PT0gJ2ZvY3Vzb3V0J1xyXG4gICAgYXBwbHkgPSBtYXNrZWRWYWx1ZSAmJiBpc1ZhbGlkXHJcblxyXG4gICAgaWYgKHJlc3RvcmUpIHtcclxuICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICB1bm1hc2tlZElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuXHJcbiAgICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJylcclxuICAgICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaGlkZGVuJylcclxuXHJcbiAgICAgIGFjdHVhbElucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxyXG4gICAgICBhY3R1YWxJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpXHJcblxyXG4gICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcblxyXG4gICAgICBpZiAoYXBwbHkpIHtcclxuICAgICAgICBhY3R1YWxJbnB1dC52YWx1ZSA9IG1hc2tlZFZhbHVlXHJcbiAgICAgICAgYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkID0gdW5tYXNrZWRJbnB1dC52YWx1ZVxyXG4gICAgICAgIHRoaXMuX19maXJlT25VcGRhdGUobWFza2VkVmFsdWUsIHVubWFza2VkSW5wdXQudmFsdWUsIGFjdHVhbElucHV0KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVubWFza2VkSW5wdXQudmFsdWUgPSBhY3R1YWxJbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWRcclxuICAgICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0LCAnc3VjY2VzcycpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgYGNoZWNrVmFsaWRpdHlgIG9uIHRoZSBpbnB1dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSB1bm1hc2tlZElucHV0XHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBhY3R1YWxJbnB1dFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUlucHV0KHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0KSB7XHJcbiAgICBsZXQgaXNWYWxpZCA9IHRydWVcclxuICAgIGNvbnN0IHZhbHVlID0gTnVtYmVyKHVubWFza2VkSW5wdXQudmFsdWUpXHJcbiAgICBpZiAodW5tYXNrZWRJbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgIWlzTmFOKHZhbHVlKSkge1xyXG4gICAgICBjb25zdCBtYXggPSB1bm1hc2tlZElucHV0LmdldEF0dHJpYnV0ZSgnbWF4JylcclxuICAgICAgY29uc3QgbWluID0gdW5tYXNrZWRJbnB1dC5nZXRBdHRyaWJ1dGUoJ21pbicpXHJcbiAgICAgIGNvbnN0IHN0ZXAgPSB1bm1hc2tlZElucHV0LmdldEF0dHJpYnV0ZSgnc3RlcCcpXHJcblxyXG4gICAgICBpZiAobWluKSBpc1ZhbGlkID0gaXNWYWxpZCAmJiB2YWx1ZSA+PSBOdW1iZXIobWluKVxyXG4gICAgICBpZiAobWF4KSBpc1ZhbGlkID0gaXNWYWxpZCAmJiB2YWx1ZSA8PSBOdW1iZXIobWF4KVxyXG5cclxuICAgICAgaWYgKHN0ZXApXHJcbiAgICAgICAgaXNWYWxpZCA9XHJcbiAgICAgICAgICBpc1ZhbGlkICYmIGNvdW50RGVjaW1hbHMoc3RlcCkgPT09IGNvdW50RGVjaW1hbHModW5tYXNrZWRJbnB1dC52YWx1ZSlcclxuICAgIH0gZWxzZSBpc1ZhbGlkID0gdW5tYXNrZWRJbnB1dC5jaGVja1ZhbGlkaXR5KClcclxuXHJcbiAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0LCAnc3VjY2VzcycpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0LCAnZXJyb3InKVxyXG4gICAgICB0aGlzLl9fZmlyZU9uSW52YWxpZChcclxuICAgICAgICB1bm1hc2tlZElucHV0LnZhbGlkYXRpb25NZXNzYWdlIHx8ICdWYWxpZGl0eSBjaGVjayBmYWlscycsXHJcbiAgICAgICAgYWN0dWFsSW5wdXRcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc1ZhbGlkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVNYXNrZWQgIG1hc2tlZCB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVVubWFza2VkICBvcmlnaW5hbCB2YWx1ZVxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgdGhlIGFjdHVhbCBpbnB1dCBpbnN0YW5jZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2ZpcmVPblVwZGF0ZSh2YWx1ZU1hc2tlZCwgdmFsdWVVbm1hc2tlZCwgaW5wdXQpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMub25VcGRhdGUpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKHZhbHVlTWFza2VkLCB2YWx1ZVVubWFza2VkLCBpbnB1dClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXJyb3IgbGFzdCBvY2N1cnJlZCBlcnJvci4gY291bGQgYmUgbWFzayBlcnJvciBvciB2YWxpZGF0aW9uIGVycm9yXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCB0aGUgYWN0dWFsIGlucHV0IGluc3RhbmNlXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fZmlyZU9uSW52YWxpZChlcnJvciwgaW5wdXQpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMub25JbnZhbGlkKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5vbkludmFsaWQoZXJyb3IsIGlucHV0KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2FwcGx5Q3NzQ2xhc3NTdGF0ZSh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCwgc3RhdGUpIHtcclxuICAgIGlmIChcclxuICAgICAgYWN0dWFsSW5wdXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpIHx8XHJcbiAgICAgIGFjdHVhbElucHV0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKVxyXG4gICAgKSB7XHJcbiAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuXHJcbiAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoc3RhdGUgPT09ICdzdWNjZXNzJykge1xyXG4gICAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG5cclxuICAgICAgICB1bm1hc2tlZElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yJykge1xyXG4gICAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG5cclxuICAgICAgICB1bm1hc2tlZElucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE51bWJlcklucHV0XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9OdW1iZXJJbnB1dC9OdW1iZXJJbnB1dC5qcyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImJiai1tYXNrcy9zcmMvTnVtYmVyTWFza1wiLFwiY29tbW9uanMyXCI6XCJiYmotbWFza3Mvc3JjL051bWJlck1hc2tcIixcImFtZFwiOlwiYmJqLW1hc2tzL3NyYy9OdW1iZXJNYXNrXCIsXCJyb290XCI6W1wiQkJqXCIsXCJNYXNrc1wiLFwiTnVtYmVyTWFza1wiXX1cbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmNvbnN0IGlzTnVtYmVyUmVnZXggPSAvXlxcZCskL1xyXG5jb25zdCBpc1doaXRlc3BhY2VSZWdleCA9IC9cXHMvXHJcbmNvbnN0IHB1bmN0dWF0aW9uTGlzdCA9ICchXCIjJCUmXFwnKCkqKywtLi86Ozw9Pj9AW11eX2B7fH1+J1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgaW4gbG93ZXIgY2FzZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqL1xyXG5jb25zdCBpc0xvd2VyQ2FzZSA9IHN0ciA9PiB7XHJcbiAgcmV0dXJuIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiBzdHIgIT0gc3RyLnRvVXBwZXJDYXNlKClcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdHJpbmcgaXMgaW4gdXBwZXIgY2FzZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqL1xyXG5jb25zdCBpc1VwcGVyQ2FzZSA9IHN0ciA9PiB7XHJcbiAgcmV0dXJuIHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiBzdHIgIT0gc3RyLnRvTG93ZXJDYXNlKClcclxufVxyXG5cclxuY29uc3QgcGFzc09yVGhyb3dFcnJvciA9IChsb29zZSwgcmV0LCBpLCBzdHIpID0+IHtcclxuICBpZiAoIWxvb3NlKSB7XHJcbiAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJBdChpKVxyXG4gICAgY29uc3QgcG9zID0gaSArIDFcclxuICAgIHRocm93IHtcclxuICAgICAgbmFtZTogJ1N0cmluZ01hc2tFcnJvcicsXHJcbiAgICAgIG1lc3NhZ2U6IGBTdHJpbmdNYXNrRXJyb3I6IGVycm9yIGFwcGx5aW5nIG1hc2sgYXQgcG9zaXRpb24gXCIke3Bvc31cIiAsIGNoYXIgXCIke2NoYXJ9XCJgLFxyXG4gICAgICBwb3MsXHJcbiAgICAgIGNoYXJcclxuICAgIH1cclxuICB9IGVsc2UgcmV0W2ldID0gJyAnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBOdW1iZXJNYXNrXHJcbiAqXHJcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBmb3IgQkJqIG51bWJlcnMgbWFza2luZ1xyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxyXG4gKi9cclxuY2xhc3MgU3RyaW5nTWFzayB7XHJcbiAgLyoqXHJcbiAgICogTWFzayB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggdGhlIGdpdmVuIG1hc2sgYWNjb3JkaW5nIHRvIEJCaiBydWxlc1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIG1hc2tcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayB0aGUgbWFzayB0byB1c2UgZm9yIGZvcm1hdHRpbmdcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29zZT10cnVlXSB3aGVuIHRydWUgLCBlcnJvcnMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgbWV0aG9kIHdpbGwgdHJ5IGF0IGFwcGx5IHRoZSBtYXNrXHJcbiAgICogICAgICAgICAgICAgICAgYW55d2F5ICwgb3RoZXJ3aXNlIGl0IHdpbGwgc3RvcCBhdCBmaXJzdCBlcnJvciBhbmQgdGhyb3cgaXQuXHJcbiAgICogXHJcbiAgICogQHRocm93cyB7TWFza0lzVG9vU2hvcnRFcnJvcn1cclxuICAgKiBAdGhyb3dzIHtTdHJpbmdNYXNrRXJyb3J9XHJcbiAgICogQHRocm93cyB7TWFza0Vycm9yfVxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgc3RyaW5nXHJcbiAgICovXHJcbiAgc3RhdGljIG1hc2soc3RyLCBtYXNrLCBsb29zZSA9IHRydWUpIHtcclxuICAgIHN0ciA9IFN0cmluZyhzdHIpXHJcbiAgICBtYXNrID0gU3RyaW5nKG1hc2spXHJcbiAgICBjb25zdCBtYXNrTGVuID0gbWFzay5sZW5ndGhcclxuICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGhcclxuXHJcbiAgICBpZiAoc3RyTGVuID4gbWFza0xlbikge1xyXG4gICAgICBpZiAobG9vc2UpIHJldHVybiBzdHJcclxuICAgICAgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRocm93IHtcclxuICAgICAgICAgIG5hbWU6ICdNYXNrSXNUb29TaG9ydEVycm9yJyxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBNYXNrSXNUb29TaG9ydEVycm9yOiBNYXNrIGlzIHNob3J0ZXIgdGhhbiB0aGUgcGFzc2VkIHN0cmluZ2BcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmV0ID0gbmV3IEFycmF5KG1hc2tMZW4pXHJcbiAgICBsZXQgcG9zID0gMCAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdHJcclxuICAgIGxldCBtYXNrQnl0ZSA9ICcnXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrTGVuOyBpKyspIHtcclxuICAgICAgbWFza0J5dGUgPSBtYXNrLmNoYXJBdChpKVxyXG4gICAgICBzd2l0Y2ggKG1hc2tCeXRlKSB7XHJcbiAgICAgICAgY2FzZSAnWCc6IC8vIG1hdGNoIGFueSBjaGFyYWN0ZXJcclxuICAgICAgICAgIHJldFtpXSA9IHBvcyA8IHN0ckxlbiA/IHN0ci5jaGFyQXQocG9zKSA6ICcgJ1xyXG4gICAgICAgICAgKytwb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJ0EnOiAvLyBtYXRjaCBsZXR0ZXI7IGZvcmNlIHVwcGVyIGNhc2VcclxuICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHN0ci5jaGFyQXQocG9zKVxyXG4gICAgICAgICAgICBpZiAoaXNVcHBlckNhc2UoYnl0ZSkpIHJldFtpXSA9IGJ5dGVcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNMb3dlckNhc2UoYnl0ZSkpIHJldFtpXSA9IGJ5dGUudG9VcHBlckNhc2UoKVxyXG4gICAgICAgICAgICBlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKVxyXG4gICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJ1xyXG4gICAgICAgICAgKytwb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJ2EnOiAvLyBtYXRjaCBsZXR0ZXJcclxuICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHN0ci5jaGFyQXQocG9zKVxyXG4gICAgICAgICAgICBpZiAoaXNVcHBlckNhc2UoYnl0ZSkgfHwgaXNMb3dlckNhc2UoYnl0ZSkpIHJldFtpXSA9IGJ5dGVcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJzAnOiAvLyBtYXRjaCBkaWdpdFxyXG4gICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlID0gc3RyLmNoYXJBdChwb3MpXHJcbiAgICAgICAgICAgIGlmIChpc051bWJlclJlZ2V4LnRlc3QoYnl0ZSkpIHJldFtpXSA9IGJ5dGVcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ1onOiAvLyBtYXRjaCBsZXR0ZXIgb3IgZGlnaXQ7IGZvcmNlIHVwcGVyIGNhc2VcclxuICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHN0ci5jaGFyQXQocG9zKVxyXG4gICAgICAgICAgICBpZiAoaXNVcHBlckNhc2UoYnl0ZSkgfHwgaXNOdW1iZXJSZWdleC50ZXN0KGJ5dGUpKSByZXRbaV0gPSBieXRlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTG93ZXJDYXNlKGJ5dGUpKSByZXRbaV0gPSBieXRlLnRvVXBwZXJDYXNlKClcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ3onOiAvLyBtYXRjaCBsZXR0ZXIgb3IgZGlnaXRcclxuICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHN0ci5jaGFyQXQocG9zKVxyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgaXNVcHBlckNhc2UoYnl0ZSkgfHxcclxuICAgICAgICAgICAgICBpc0xvd2VyQ2FzZShieXRlKSB8fFxyXG4gICAgICAgICAgICAgIGlzTnVtYmVyUmVnZXgudGVzdChieXRlKVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgcmV0W2ldID0gYnl0ZVxyXG4gICAgICAgICAgICBlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKVxyXG4gICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJ1xyXG4gICAgICAgICAgKytwb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICdVJzogLy8gbWF0Y2ggbGV0dGVyIChmb3JjZSB1cHBlciBjYXNlKSwgZGlnaXQsIHdoaXRlc3BhY2Ugb3IgcHVuY3R1YXRpb24uXHJcbiAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBzdHIuY2hhckF0KHBvcylcclxuICAgICAgICAgICAgaWYgKGlzTG93ZXJDYXNlKGJ5dGUpKSByZXRbaV0gPSBieXRlLnRvVXBwZXJDYXNlKClcclxuICAgICAgICAgICAgZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgaXNVcHBlckNhc2UoYnl0ZSkgfHxcclxuICAgICAgICAgICAgICBpc051bWJlclJlZ2V4LnRlc3QoYnl0ZSkgfHxcclxuICAgICAgICAgICAgICBpc1doaXRlc3BhY2VSZWdleC50ZXN0KGJ5dGUpIHx8XHJcbiAgICAgICAgICAgICAgcHVuY3R1YXRpb25MaXN0LmluZGV4T2YoYnl0ZSkgPiAtMVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgcmV0W2ldID0gYnl0ZVxyXG4gICAgICAgICAgICBlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKVxyXG4gICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJ1xyXG4gICAgICAgICAgKytwb3NcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldFtpXSA9IG1hc2tCeXRlXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICBpZiAoIWxvb3NlKSB7XHJcbiAgICAgICAgdGhyb3cgeyBuYW1lOiAnTWFza0Vycm9yJywgbWVzc2FnZTogJ01hc2sgY2Fubm90IGJlIGFwcGxpZWQnIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQuam9pbignJylcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFN0cmluZ01hc2tcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vKipcclxuICogTnVtYmVyTWFza1xyXG4gKlxyXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gZm9yIEJCaiBudW1iZXJzIG1hc2tpbmdcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcbmNsYXNzIE51bWJlck1hc2sge1xyXG4gIC8qKlxyXG4gICAqIE1hc2sgdGhlIGdpdmVuIG51bWJlciB3aXRoIHRoZSBnaXZlbiBtYXNrIGFjY29yZGluZyB0byBCQmogcnVsZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgdGhlIG51bWJlciB0byBmb3JtYXRcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayB0aGUgbWFzayB0byB1c2UgZm9yIGZvcm1hdHRpbmdcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwaW5nU2VwYXJhdG9yPSxdIC0gYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGdyb3VwaW5nIHNlcGFyYXRvclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVjaW1hbFNlcGFyYXRvcj0uXSAgLSBhIGNoYXIgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVRyYWlsaW5nWmVyb3M9ZmFsc2VdIC0gQWZmZWN0cyB0aGUgb3V0cHV0IGJ5IHN3aXRjaGluZyB0aGUgd2F5IGEgbWFzayB3aXRoIFwiI1wiIGNoYXJhY3RlcnMgaW4gdGhlIHRyYWlsaW5nIHBvc2l0aW9ucyBpcyBmaWxsZWQuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsIHRoZSBmdW5jdGlvbiBgTnVtYmVyTWFzay5tYXNrKC4xMDpcIiMuIyNcIilgIHJldHVybnMgYCAuMTBgIGluc3RlYWQgb2YgYCAuMSBgXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9dHJ1ZV0gd2hlbiB0cnVlICwgZXJyb3JzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCB3aWxsIHRyeSBhdCBhcHBseSB0aGUgbWFza1xyXG4gICAqICAgICAgICAgICAgICAgIGFueXdheSAsIG90aGVyd2lzZSBpdCB3aWxsIHN0b3AgYXQgZmlyc3QgZXJyb3IgYW5kIHRocm93IGl0LlxyXG4gICAqIFxyXG4gICAqIEB0aHJvd3Mge01hc2tFcnJvcn0gb25seSBpZiBsb29zZSBpcyBkaXNhYmxlZFxyXG4gICAqIFxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgbnVtYmVyXHJcbiAgICovXHJcbiAgc3RhdGljIG1hc2soXHJcbiAgICBudW1iZXIsXHJcbiAgICBtYXNrLFxyXG4gICAgZ3JvdXBpbmdTZXBhcmF0b3IgPSAnLCcsXHJcbiAgICBkZWNpbWFsU2VwYXJhdG9yID0gJy4nLFxyXG4gICAgZm9yY2VUcmFpbGluZ1plcm9zID0gZmFsc2UsXHJcbiAgICBsb29zZSA9IHRydWVcclxuICApIHtcclxuICAgIGNvbnN0IG1hc2tMZW4gPSBtYXNrLmxlbmd0aFxyXG4gICAgaWYgKDAgPT09IG1hc2tMZW4pIHtcclxuICAgICAgaWYgKGxvb3NlKSByZXR1cm4gc3RyXHJcbiAgICAgIC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICBuYW1lOiAnTWFza0Vycm9yJyxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBNYXNrRXJyb3I6IE1hc2sgaXMgZW1wdHlgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldCBtYWduaXR1ZGUgYW5kIHByZWNpc2lvbiBvZiBNQVNLXHJcbiAgICBsZXQgbWFza0JlZm9yZURlY2ltYWwgPSAwXHJcbiAgICBsZXQgbWFza0FmdGVyRGVjaW1hbCA9IDBcclxuICAgIGxldCBmb3VuZERlY2ltYWwgPSBmYWxzZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXNrTGVuOyArK2kpIHtcclxuICAgICAgY29uc3QgbSA9IG1hc2suY2hhckF0KGkpXHJcbiAgICAgIGlmIChtID09ICcwJyB8fCBtID09ICcjJykge1xyXG4gICAgICAgIGlmIChmb3VuZERlY2ltYWwpICsrbWFza0FmdGVyRGVjaW1hbFxyXG4gICAgICAgIGVsc2UgKyttYXNrQmVmb3JlRGVjaW1hbFxyXG4gICAgICB9IGVsc2UgaWYgKG0gPT0gJy4nKSBmb3VuZERlY2ltYWwgPSB0cnVlXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG51bSA9IE51bWJlck1hc2suX3JvdW5kKG51bWJlciwgbWFza0FmdGVyRGVjaW1hbClcclxuICAgIGxldCBieXRlcyA9IE51bWJlck1hc2suX3RvQ2hhckFycmF5KG51bSlcclxuXHJcbiAgICAvLyBHZXQgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTlVNQkVSXHJcbiAgICBsZXQgaW5MZW4gPSBieXRlcy5sZW5ndGhcclxuICAgIGxldCBudW1CZWZvcmVEZWNpbWFsID0gMFxyXG4gICAgbGV0IG51bUFmdGVyRGVjaW1hbCA9IDBcclxuICAgIGZvdW5kRGVjaW1hbCA9IGZhbHNlXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluTGVuOyArK2kpIHtcclxuICAgICAgaWYgKGJ5dGVzW2ldID09ICcuJykgZm91bmREZWNpbWFsID0gdHJ1ZVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm91bmREZWNpbWFsKSArK251bUFmdGVyRGVjaW1hbFxyXG4gICAgICAgIGVsc2UgKytudW1CZWZvcmVEZWNpbWFsXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhbHdheXMgaWdub3JlIG1hc2sgb3ZlcmZsb3dcclxuICAgIGlmIChudW1CZWZvcmVEZWNpbWFsID4gbWFza0JlZm9yZURlY2ltYWwpIHtcclxuICAgICAgaWYgKGxvb3NlKSByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKClcclxuICAgICAgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRocm93IHtcclxuICAgICAgICAgIG5hbWU6ICdNYXNrRXJyb3InLFxyXG4gICAgICAgICAgbWVzc2FnZTogYE1hc2tFcnJvcjogTnVtYmVyIGlzIHRvbyBsYXJnZSBmb3IgbWFza2BcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gcm91bmQgaWYgbWFzayBpcyBmb3IgYSBsb3dlciBwcmVjaXNpb24gbnVtYmVyXHJcbiAgICBpZiAobnVtQWZ0ZXJEZWNpbWFsID4gbWFza0FmdGVyRGVjaW1hbCkge1xyXG4gICAgICBudW0gPSBOdW1iZXJNYXNrLl9yb3VuZChudW0sIG1hc2tBZnRlckRlY2ltYWwpXHJcbiAgICAgIGJ5dGVzID0gTnVtYmVyTWFzay5fdG9DaGFyQXJyYXkobnVtKVxyXG4gICAgICBpbkxlbiA9IGJ5dGVzLmxlbmd0aFxyXG5cclxuICAgICAgLy8gR2V0IG5ldyBtYWduaXR1ZGUgYW5kIHByZWNpc2lvbiBvZiBOVU1CRVJcclxuICAgICAgbnVtQmVmb3JlRGVjaW1hbCA9IDBcclxuICAgICAgbnVtQWZ0ZXJEZWNpbWFsID0gMFxyXG4gICAgICBmb3VuZERlY2ltYWwgPSBmYWxzZVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluTGVuOyArK2kpIHtcclxuICAgICAgICBpZiAoYnl0ZXNbaV0gPT0gJy4nKSBmb3VuZERlY2ltYWwgPSB0cnVlXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpZiAoZm91bmREZWNpbWFsKSArK251bUFmdGVyRGVjaW1hbFxyXG4gICAgICAgICAgZWxzZSArK251bUJlZm9yZURlY2ltYWxcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFsd2F5cyBpZ25vcmUgbWFzayBvdmVyZmxvd1xyXG4gICAgICBpZiAobnVtQmVmb3JlRGVjaW1hbCA+IG1hc2tCZWZvcmVEZWNpbWFsKSB7XHJcbiAgICAgICAgaWYgKGxvb3NlKSByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKClcclxuICAgICAgICAvLyBmcmllbmRseSBzaWxlbnQgZmFpbFxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRocm93IHtcclxuICAgICAgICAgICAgbmFtZTogJ01hc2tFcnJvcicsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBNYXNrRXJyb3I6IE51bWJlciBpcyB0b28gbGFyZ2UgZm9yIG1hc2tgXHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsZXQgZmlsbEJ5dGUgPSAnICcsXHJcbiAgICAgIGZsb2F0Qnl0ZSA9ICcgJ1xyXG4gICAgbGV0IGluUG9zID0gMCxcclxuICAgICAgb3V0UG9zID0gMCxcclxuICAgICAgZmxvYXRQb3MgPSAwXHJcbiAgICBpZiAobWFzay5jaGFyQXQoMCkgPT0gJyonKSBmaWxsQnl0ZSA9ICcqJ1xyXG5cclxuICAgIGNvbnN0IGZpbGxJbml0ID0gZmlsbEJ5dGVcclxuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBOdW1iZXJNYXNrLl9nZXRTaWduKG51bSkgPCAwXHJcbiAgICBsZXQgZW1pdERlY2ltYWwgPSBpbkxlbiA+IDAgfHwgbWFzay5pbmRleE9mKCcwJykgPj0gMFxyXG4gICAgbGV0IGZvdW5kWmVybyA9IGZhbHNlXHJcbiAgICBsZXQgZm91bmREaWdpdCA9IGZhbHNlXHJcbiAgICBsZXQgY3VycmVuY3kgPSBmYWxzZVxyXG4gICAgZm91bmREZWNpbWFsID0gZmFsc2VcclxuXHJcbiAgICBsZXQgcmV0ID0gbmV3IEFycmF5KG1hc2tMZW4pXHJcblxyXG4gICAgZm9yIChsZXQgbWFza1BvcyA9IDA7IG1hc2tQb3MgPCBtYXNrTGVuOyArK21hc2tQb3MpIHtcclxuICAgICAgbGV0IG0gPSBtYXNrLmNoYXJBdChtYXNrUG9zKVxyXG4gICAgICBzd2l0Y2ggKG0pIHtcclxuICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgIC0tbWFza0JlZm9yZURlY2ltYWxcclxuICAgICAgICAgIGlmIChtYXNrQmVmb3JlRGVjaW1hbCA8IG51bUJlZm9yZURlY2ltYWwgJiYgaW5Qb3MgPCBpbkxlbikge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGJ5dGVzW2luUG9zXVxyXG4gICAgICAgICAgICArK2luUG9zXHJcbiAgICAgICAgICAgIGZvdW5kRGlnaXQgPSB0cnVlXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcwJ1xyXG4gICAgICAgICAgICBmb3VuZFplcm8gPSB0cnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnIyc6XHJcbiAgICAgICAgICAtLW1hc2tCZWZvcmVEZWNpbWFsXHJcbiAgICAgICAgICBpZiAobWFza0JlZm9yZURlY2ltYWwgPCBudW1CZWZvcmVEZWNpbWFsICYmIGluUG9zIDwgaW5MZW4pIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBieXRlc1tpblBvc11cclxuICAgICAgICAgICAgKytpblBvc1xyXG4gICAgICAgICAgICBmb3VuZERpZ2l0ID0gdHJ1ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPVxyXG4gICAgICAgICAgICAgIGZvdW5kRGVjaW1hbCAmJlxyXG4gICAgICAgICAgICAgIGZvcmNlVHJhaWxpbmdaZXJvcyAmJlxyXG4gICAgICAgICAgICAgIE51bWJlck1hc2suX2dldFNpZ24obnVtKSAhPSAwXHJcbiAgICAgICAgICAgICAgICA/ICcwJ1xyXG4gICAgICAgICAgICAgICAgOiBmaWxsQnl0ZVxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kRGVjaW1hbCkgZmxvYXRQb3MgPSBtYXNrUG9zXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICBpZiAoZm91bmRaZXJvIHx8IGluUG9zID4gMCkgcmV0W291dFBvc10gPSBncm91cGluZ1NlcGFyYXRvclxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgICAgaWYgKCFmb3VuZERlY2ltYWwpIGZsb2F0UG9zID0gbWFza1Bvc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJy0nOlxyXG4gICAgICAgICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIGZsb2F0Qnl0ZSA9ICctJ1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlXHJcbiAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zXHJcbiAgICAgICAgICB9IGVsc2UgcmV0W291dFBvc10gPSBpc05lZ2F0aXZlID8gJy0nIDogZmlsbEJ5dGVcclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgIGZsb2F0Qnl0ZSA9IGlzTmVnYXRpdmUgPyAnLScgOiAnKydcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgICAgfSBlbHNlIHJldFtvdXRQb3NdID0gaXNOZWdhdGl2ZSA/ICctJyA6ICcrJ1xyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJyQnOlxyXG4gICAgICAgICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAgICAgZmxvYXRCeXRlID0gJyQnXHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3NcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyQnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgLy8gY2FzZSAnJic6XHJcbiAgICAgICAgLy8gICBjdXJyZW5jeSA9IHRydWVcclxuICAgICAgICAvLyAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgLy8gICAgIGZsb2F0Qnl0ZSA9ICcmJ1xyXG4gICAgICAgIC8vICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlXHJcbiAgICAgICAgLy8gICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zXHJcbiAgICAgICAgLy8gICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICByZXRbb3V0UG9zXSA9ICcmJ1xyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vICAgKytvdXRQb3NcclxuICAgICAgICAvLyAgIGJyZWFrXHJcblxyXG4gICAgICAgIC8vIGNhc2UgJ0AnOlxyXG4gICAgICAgIC8vICAgY3VycmVuY3kgPSB0cnVlXHJcbiAgICAgICAgLy8gICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgIC8vICAgICBmbG9hdEJ5dGUgPSAnQCdcclxuICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgIC8vICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgIC8vICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSAnQCdcclxuICAgICAgICAvLyAgIH1cclxuICAgICAgICAvLyAgICsrb3V0UG9zXHJcbiAgICAgICAgLy8gICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICcoJzpcclxuICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSBmbG9hdEJ5dGUgPSAnKCdcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICcoJ1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZm91bmREZWNpbWFsID8gJyAnIDogZmlsbEJ5dGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJyknOlxyXG4gICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSAnKSdcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZm91bmREZWNpbWFsID8gJyAnIDogZmlsbEJ5dGVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgIGlmIChtYXNrUG9zIDwgbWFza0xlbiAtIDEgJiYgbWFzay5jaGFyQXQobWFza1BvcyArIDEpID09ICdSJykge1xyXG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0MnXHJcbiAgICAgICAgICAgICAgcmV0W291dFBvcyArIDFdID0gJ1InXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnICdcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnICdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRQb3MgKz0gMlxyXG4gICAgICAgICAgICArK21hc2tQb3NcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0MnXHJcbiAgICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgaWYgKG1hc2tQb3MgPCBtYXNrTGVuIC0gMSAmJiBtYXNrLmNoYXJBdChtYXNrUG9zICsgMSkgPT0gJ1InKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnQydcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnUidcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdEJ1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3MgKyAxXSA9ICdSJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dFBvcyArPSAyXHJcbiAgICAgICAgICAgICsrbWFza1Bvc1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSAnRCdcclxuICAgICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJyonOlxyXG4gICAgICAgICAgcmV0W291dFBvc10gPSAnKidcclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICAgIHJldFtvdXRQb3NdID0gZW1pdERlY2ltYWwgPyBkZWNpbWFsU2VwYXJhdG9yIDogZmlsbEJ5dGVcclxuICAgICAgICAgIGZpbGxCeXRlID0gJyAnXHJcbiAgICAgICAgICBmb3VuZERlY2ltYWwgPSB0cnVlXHJcbiAgICAgICAgICArK2luUG9zXHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnQic6XHJcbiAgICAgICAgICByZXRbb3V0UG9zXSA9ICcgJ1xyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXRbb3V0UG9zXSA9IG1cclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGZsb2F0Qnl0ZSAhPSAnICcpIHtcclxuICAgICAgaWYgKGZsb2F0UG9zIDwgMCkgZmxvYXRQb3MgPSBvdXRQb3NcclxuICAgICAgd2hpbGUgKGZsb2F0UG9zID49IG1hc2tMZW4pIC0tZmxvYXRQb3NcclxuICAgICAgaWYgKHJldFtmbG9hdFBvc10gPT0gZmlsbEluaXQpIHJldFtmbG9hdFBvc10gPSBmbG9hdEJ5dGVcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0LmpvaW4oJycpXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3NoaWZ0KG51bWJlciwgcHJlY2lzaW9uLCByZXZlcnNlU2hpZnQpIHtcclxuICAgIGlmIChyZXZlcnNlU2hpZnQpIHByZWNpc2lvbiA9IC1wcmVjaXNpb25cclxuICAgIHZhciBudW1BcnJheSA9ICgnJyArIG51bWJlcikuc3BsaXQoJ2UnKVxyXG4gICAgcmV0dXJuICsoXHJcbiAgICAgIG51bUFycmF5WzBdICtcclxuICAgICAgJ2UnICtcclxuICAgICAgKG51bUFycmF5WzFdID8gK251bUFycmF5WzFdICsgcHJlY2lzaW9uIDogcHJlY2lzaW9uKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9yb3VuZChudW1iZXIsIHByZWNpc2lvbikge1xyXG4gICAgcmV0dXJuIE51bWJlck1hc2suX3NoaWZ0KFxyXG4gICAgICBNYXRoLnJvdW5kKE51bWJlck1hc2suX3NoaWZ0KG51bWJlciwgcHJlY2lzaW9uLCBmYWxzZSkpLFxyXG4gICAgICBwcmVjaXNpb24sXHJcbiAgICAgIHRydWVcclxuICAgIClcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfdG9DaGFyQXJyYXkobnVtYmVyKSB7XHJcbiAgICBjb25zdCBzaWdudW0gPSBOdW1iZXJNYXNrLl9nZXRTaWduKG51bWJlcilcclxuICAgIGxldCBjaGFycyA9IFtdXHJcblxyXG4gICAgaWYgKHNpZ251bSAhPT0gMCkge1xyXG4gICAgICBsZXQgc3RyaW5nID0gc2lnbnVtIDwgMCA/IGAkey0xICogbnVtYmVyLnRvU3RyaW5nKCl9YCA6IG51bWJlci50b1N0cmluZygpXHJcblxyXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnMCcpXHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZygxKVxyXG5cclxuICAgICAgLy8gVGhlIHN0cmluZyBjb250YWlucyBvbmx5IFswLTldIGFuZCAnLidcclxuICAgICAgY2hhcnMgPSBzdHJpbmcuc3BsaXQoJycpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNoYXJzXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0geCBudW1iZXJcclxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHNpZ24gb2YgdGhlIGdpdmVuIGFyZ3VtZW50LlxyXG4gICAqICAgICAgICAgICAgICAgICAgIElmIHRoZSBhcmd1bWVudCBpcyBhIHBvc2l0aXZlIG51bWJlciwgbmVnYXRpdmUgbnVtYmVyLCBwb3NpdGl2ZSB6ZXJvXHJcbiAgICogICAgICAgICAgICAgICAgICAgb3IgbmVnYXRpdmUgemVybywgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIDEsIC0xLCAwIG9yIC0wIHJlc3BlY3RpdmVseS5cclxuICAgKiAgICAgICAgICAgICAgICAgICBPdGhlcndpc2UsIE5hTiBpcyByZXR1cm5lZC5cclxuICAgKi9cclxuICBzdGF0aWMgX2dldFNpZ24oeCkge1xyXG4gICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJNYXNrXHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiZmxhdHBpY2tyXCJdID0gcmVxdWlyZShcIi0hRDpcXFxcR2l0aHViXFxcXEJCakdyaWRFeFdpZGdldFxcXFxjbGllbnRcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3JlZi0tNCEuXFxcXGZsYXRwaWNrci5qc1wiKTsiLCIvKiBmbGF0cGlja3IgdjQuNi42LCBAbGljZW5zZSBNSVQgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuZmxhdHBpY2tyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcbiAgICBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxuICAgIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcbiAgICBSRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuICAgIEFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuICAgIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG4gICAgTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuICAgIE9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuICAgIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfVxuXG4gICAgdmFyIEhPT0tTID0gW1xuICAgICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICAgIFwib25DbG9zZVwiLFxuICAgICAgICBcIm9uRGF5Q3JlYXRlXCIsXG4gICAgICAgIFwib25EZXN0cm95XCIsXG4gICAgICAgIFwib25LZXlEb3duXCIsXG4gICAgICAgIFwib25Nb250aENoYW5nZVwiLFxuICAgICAgICBcIm9uT3BlblwiLFxuICAgICAgICBcIm9uUGFyc2VDb25maWdcIixcbiAgICAgICAgXCJvblJlYWR5XCIsXG4gICAgICAgIFwib25WYWx1ZVVwZGF0ZVwiLFxuICAgICAgICBcIm9uWWVhckNoYW5nZVwiLFxuICAgICAgICBcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiLFxuICAgIF07XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBfZGlzYWJsZTogW10sXG4gICAgICAgIF9lbmFibGU6IFtdLFxuICAgICAgICBhbGxvd0lucHV0OiBmYWxzZSxcbiAgICAgICAgYWxsb3dJbnZhbGlkUHJlbG9hZDogZmFsc2UsXG4gICAgICAgIGFsdEZvcm1hdDogXCJGIGosIFlcIixcbiAgICAgICAgYWx0SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbHRJbnB1dENsYXNzOiBcImZvcm0tY29udHJvbCBpbnB1dFwiLFxuICAgICAgICBhbmltYXRlOiB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSA9PT0gLTEsXG4gICAgICAgIGFyaWFEYXRlRm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBhdXRvRmlsbERlZmF1bHRUaW1lOiB0cnVlLFxuICAgICAgICBjbGlja09wZW5zOiB0cnVlLFxuICAgICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxuICAgICAgICBjb25qdW5jdGlvbjogXCIsIFwiLFxuICAgICAgICBkYXRlRm9ybWF0OiBcIlktbS1kXCIsXG4gICAgICAgIGRlZmF1bHRIb3VyOiAxMixcbiAgICAgICAgZGVmYXVsdE1pbnV0ZTogMCxcbiAgICAgICAgZGVmYXVsdFNlY29uZHM6IDAsXG4gICAgICAgIGRpc2FibGU6IFtdLFxuICAgICAgICBkaXNhYmxlTW9iaWxlOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlOiBbXSxcbiAgICAgICAgZW5hYmxlU2Vjb25kczogZmFsc2UsXG4gICAgICAgIGVuYWJsZVRpbWU6IGZhbHNlLFxuICAgICAgICBlcnJvckhhbmRsZXI6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2VlazogZnVuY3Rpb24gKGdpdmVuRGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShnaXZlbkRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBUaHVyc2RheSBpbiBjdXJyZW50IHdlZWsgZGVjaWRlcyB0aGUgeWVhci5cbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIDMgLSAoKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpKTtcbiAgICAgICAgICAgIC8vIEphbnVhcnkgNCBpcyBhbHdheXMgaW4gd2VlayAxLlxuICAgICAgICAgICAgdmFyIHdlZWsxID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgICAgICAgICAgIC8vIEFkanVzdCB0byBUaHVyc2RheSBpbiB3ZWVrIDEgYW5kIGNvdW50IG51bWJlciBvZiB3ZWVrcyBmcm9tIGRhdGUgdG8gd2VlazEuXG4gICAgICAgICAgICByZXR1cm4gKDEgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKChkYXRlLmdldFRpbWUoKSAtIHdlZWsxLmdldFRpbWUoKSkgLyA4NjQwMDAwMCAtXG4gICAgICAgICAgICAgICAgICAgIDMgK1xuICAgICAgICAgICAgICAgICAgICAoKHdlZWsxLmdldERheSgpICsgNikgJSA3KSkgL1xuICAgICAgICAgICAgICAgICAgICA3KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhvdXJJbmNyZW1lbnQ6IDEsXG4gICAgICAgIGlnbm9yZWRGb2N1c0VsZW1lbnRzOiBbXSxcbiAgICAgICAgaW5saW5lOiBmYWxzZSxcbiAgICAgICAgbG9jYWxlOiBcImRlZmF1bHRcIixcbiAgICAgICAgbWludXRlSW5jcmVtZW50OiA1LFxuICAgICAgICBtb2RlOiBcInNpbmdsZVwiLFxuICAgICAgICBtb250aFNlbGVjdG9yVHlwZTogXCJkcm9wZG93blwiLFxuICAgICAgICBuZXh0QXJyb3c6IFwiPHN2ZyB2ZXJzaW9uPScxLjEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHZpZXdCb3g9JzAgMCAxNyAxNyc+PGc+PC9nPjxwYXRoIGQ9J00xMy4yMDcgOC40NzJsLTcuODU0IDcuODU0LTAuNzA3LTAuNzA3IDcuMTQ2LTcuMTQ2LTcuMTQ2LTcuMTQ4IDAuNzA3LTAuNzA3IDcuODU0IDcuODU0eicgLz48L3N2Zz5cIixcbiAgICAgICAgbm9DYWxlbmRhcjogZmFsc2UsXG4gICAgICAgIG5vdzogbmV3IERhdGUoKSxcbiAgICAgICAgb25DaGFuZ2U6IFtdLFxuICAgICAgICBvbkNsb3NlOiBbXSxcbiAgICAgICAgb25EYXlDcmVhdGU6IFtdLFxuICAgICAgICBvbkRlc3Ryb3k6IFtdLFxuICAgICAgICBvbktleURvd246IFtdLFxuICAgICAgICBvbk1vbnRoQ2hhbmdlOiBbXSxcbiAgICAgICAgb25PcGVuOiBbXSxcbiAgICAgICAgb25QYXJzZUNvbmZpZzogW10sXG4gICAgICAgIG9uUmVhZHk6IFtdLFxuICAgICAgICBvblZhbHVlVXBkYXRlOiBbXSxcbiAgICAgICAgb25ZZWFyQ2hhbmdlOiBbXSxcbiAgICAgICAgb25QcmVDYWxlbmRhclBvc2l0aW9uOiBbXSxcbiAgICAgICAgcGx1Z2luczogW10sXG4gICAgICAgIHBvc2l0aW9uOiBcImF1dG9cIixcbiAgICAgICAgcG9zaXRpb25FbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHByZXZBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTUuMjA3IDguNDcxbDcuMTQ2IDcuMTQ3LTAuNzA3IDAuNzA3LTcuODUzLTcuODU0IDcuODU0LTcuODUzIDAuNzA3IDAuNzA3LTcuMTQ3IDcuMTQ2eicgLz48L3N2Zz5cIixcbiAgICAgICAgc2hvcnRoYW5kQ3VycmVudE1vbnRoOiBmYWxzZSxcbiAgICAgICAgc2hvd01vbnRoczogMSxcbiAgICAgICAgc3RhdGljOiBmYWxzZSxcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZSxcbiAgICAgICAgd2Vla051bWJlcnM6IGZhbHNlLFxuICAgICAgICB3cmFwOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgdmFyIGVuZ2xpc2ggPSB7XG4gICAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgICAgICBzaG9ydGhhbmQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJTdW5kYXlcIixcbiAgICAgICAgICAgICAgICBcIk1vbmRheVwiLFxuICAgICAgICAgICAgICAgIFwiVHVlc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUaHVyc2RheVwiLFxuICAgICAgICAgICAgICAgIFwiRnJpZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJTYXR1cmRheVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgbW9udGhzOiB7XG4gICAgICAgICAgICBzaG9ydGhhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIkphblwiLFxuICAgICAgICAgICAgICAgIFwiRmViXCIsXG4gICAgICAgICAgICAgICAgXCJNYXJcIixcbiAgICAgICAgICAgICAgICBcIkFwclwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5cIixcbiAgICAgICAgICAgICAgICBcIkp1bFwiLFxuICAgICAgICAgICAgICAgIFwiQXVnXCIsXG4gICAgICAgICAgICAgICAgXCJTZXBcIixcbiAgICAgICAgICAgICAgICBcIk9jdFwiLFxuICAgICAgICAgICAgICAgIFwiTm92XCIsXG4gICAgICAgICAgICAgICAgXCJEZWNcIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBsb25naGFuZDogW1xuICAgICAgICAgICAgICAgIFwiSmFudWFyeVwiLFxuICAgICAgICAgICAgICAgIFwiRmVicnVhcnlcIixcbiAgICAgICAgICAgICAgICBcIk1hcmNoXCIsXG4gICAgICAgICAgICAgICAgXCJBcHJpbFwiLFxuICAgICAgICAgICAgICAgIFwiTWF5XCIsXG4gICAgICAgICAgICAgICAgXCJKdW5lXCIsXG4gICAgICAgICAgICAgICAgXCJKdWx5XCIsXG4gICAgICAgICAgICAgICAgXCJBdWd1c3RcIixcbiAgICAgICAgICAgICAgICBcIlNlcHRlbWJlclwiLFxuICAgICAgICAgICAgICAgIFwiT2N0b2JlclwiLFxuICAgICAgICAgICAgICAgIFwiTm92ZW1iZXJcIixcbiAgICAgICAgICAgICAgICBcIkRlY2VtYmVyXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBkYXlzSW5Nb250aDogWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdLFxuICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG50aCkge1xuICAgICAgICAgICAgdmFyIHMgPSBudGggJSAxMDA7XG4gICAgICAgICAgICBpZiAocyA+IDMgJiYgcyA8IDIxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICBzd2l0Y2ggKHMgJSAxMCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyZFwiO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRoXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJhbmdlU2VwYXJhdG9yOiBcIiB0byBcIixcbiAgICAgICAgd2Vla0FiYnJldmlhdGlvbjogXCJXa1wiLFxuICAgICAgICBzY3JvbGxUaXRsZTogXCJTY3JvbGwgdG8gaW5jcmVtZW50XCIsXG4gICAgICAgIHRvZ2dsZVRpdGxlOiBcIkNsaWNrIHRvIHRvZ2dsZVwiLFxuICAgICAgICBhbVBNOiBbXCJBTVwiLCBcIlBNXCJdLFxuICAgICAgICB5ZWFyQXJpYUxhYmVsOiBcIlllYXJcIixcbiAgICAgICAgbW9udGhBcmlhTGFiZWw6IFwiTW9udGhcIixcbiAgICAgICAgaG91ckFyaWFMYWJlbDogXCJIb3VyXCIsXG4gICAgICAgIG1pbnV0ZUFyaWFMYWJlbDogXCJNaW51dGVcIixcbiAgICAgICAgdGltZV8yNGhyOiBmYWxzZSxcbiAgICB9O1xuXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uIChudW1iZXIsIGxlbmd0aCkge1xuICAgICAgICBpZiAobGVuZ3RoID09PSB2b2lkIDApIHsgbGVuZ3RoID0gMjsgfVxuICAgICAgICByZXR1cm4gKFwiMDAwXCIgKyBudW1iZXIpLnNsaWNlKGxlbmd0aCAqIC0xKTtcbiAgICB9O1xuICAgIHZhciBpbnQgPSBmdW5jdGlvbiAoYm9vbCkgeyByZXR1cm4gKGJvb2wgPT09IHRydWUgPyAxIDogMCk7IH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSA9PT0gdm9pZCAwKSB7IGltbWVkaWF0ZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgdGltZW91dCAhPT0gbnVsbCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKVxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgd2FpdCk7XG4gICAgICAgICAgICBpZiAoaW1tZWRpYXRlICYmICF0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhcnJheWlmeSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5ID8gb2JqIDogW29ial07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW0sIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgICAgICBpZiAoYm9vbCA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBjbGFzc05hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIGUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgICBjbGFzc05hbWUgPSBjbGFzc05hbWUgfHwgXCJcIjtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQgfHwgXCJcIjtcbiAgICAgICAgZS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XG4gICAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSwgY29uZGl0aW9uKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24obm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZpbmRQYXJlbnQobm9kZS5wYXJlbnROb2RlLCBjb25kaXRpb24pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU51bWJlcklucHV0KGlucHV0Q2xhc3NOYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcIm51bUlucHV0V3JhcHBlclwiKSwgbnVtSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgXCJudW1JbnB1dCBcIiArIGlucHV0Q2xhc3NOYW1lKSwgYXJyb3dVcCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiYXJyb3dVcFwiKSwgYXJyb3dEb3duID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd0Rvd25cIik7XG4gICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFIDkuMFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG51bUlucHV0LnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgbnVtSW5wdXQucGF0dGVybiA9IFwiXFxcXGQqXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRzKVxuICAgICAgICAgICAgICAgIG51bUlucHV0LnNldEF0dHJpYnV0ZShrZXksIG9wdHNba2V5XSk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobnVtSW5wdXQpO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93VXApO1xuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGFycm93RG93bik7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRFdmVudFRhcmdldChldmVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudC5jb21wb3NlZFBhdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkb05vdGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG4gICAgdmFyIG1vbnRoVG9TdHIgPSBmdW5jdGlvbiAobW9udGhOdW1iZXIsIHNob3J0aGFuZCwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUubW9udGhzW3Nob3J0aGFuZCA/IFwic2hvcnRoYW5kXCIgOiBcImxvbmdoYW5kXCJdW21vbnRoTnVtYmVyXTsgfTtcbiAgICB2YXIgcmV2Rm9ybWF0ID0ge1xuICAgICAgICBEOiBkb05vdGhpbmcsXG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aE5hbWUsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLmxvbmdoYW5kLmluZGV4T2YobW9udGhOYW1lKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEc6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSjogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlT2JqLCBhbVBNLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMoKGRhdGVPYmouZ2V0SG91cnMoKSAlIDEyKSArXG4gICAgICAgICAgICAgICAgMTIgKiBpbnQobmV3IFJlZ0V4cChsb2NhbGUuYW1QTVsxXSwgXCJpXCIpLnRlc3QoYW1QTSkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGVPYmosIHNob3J0TW9udGgsIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChsb2NhbGUubW9udGhzLnNob3J0aGFuZC5pbmRleE9mKHNob3J0TW9udGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgUzogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgVTogZnVuY3Rpb24gKF8sIHVuaXhTZWNvbmRzKSB7IHJldHVybiBuZXcgRGF0ZShwYXJzZUZsb2F0KHVuaXhTZWNvbmRzKSAqIDEwMDApOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZU9iaiwgd2Vla051bSwgbG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IHBhcnNlSW50KHdlZWtOdW0pO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDAsIDIgKyAod2Vla051bWJlciAtIDEpICogNywgMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkYXRlLmdldERheSgpICsgbG9jYWxlLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcihwYXJzZUZsb2F0KHllYXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgWjogZnVuY3Rpb24gKF8sIElTT0RhdGUpIHsgcmV0dXJuIG5ldyBEYXRlKElTT0RhdGUpOyB9LFxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlT2JqLCBtaW51dGVzKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1pbnV0ZXMocGFyc2VGbG9hdChtaW51dGVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBsOiBkb05vdGhpbmcsXG4gICAgICAgIG06IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZU9iaiwgbW9udGgpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TW9udGgocGFyc2VGbG9hdChtb250aCkgLSAxKTtcbiAgICAgICAgfSxcbiAgICAgICAgczogZnVuY3Rpb24gKGRhdGVPYmosIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0U2Vjb25kcyhwYXJzZUZsb2F0KHNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdTogZnVuY3Rpb24gKF8sIHVuaXhNaWxsU2Vjb25kcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peE1pbGxTZWNvbmRzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHc6IGRvTm90aGluZyxcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGVPYmosIHllYXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RnVsbFllYXIoMjAwMCArIHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgdmFyIHRva2VuUmVnZXggPSB7XG4gICAgICAgIEQ6IFwiKFxcXFx3KylcIixcbiAgICAgICAgRjogXCIoXFxcXHcrKVwiLFxuICAgICAgICBHOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBIOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBKOiBcIihcXFxcZFxcXFxkfFxcXFxkKVxcXFx3K1wiLFxuICAgICAgICBLOiBcIlwiLFxuICAgICAgICBNOiBcIihcXFxcdyspXCIsXG4gICAgICAgIFM6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFU6IFwiKC4rKVwiLFxuICAgICAgICBXOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBZOiBcIihcXFxcZHs0fSlcIixcbiAgICAgICAgWjogXCIoLispXCIsXG4gICAgICAgIGQ6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGk6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIGw6IFwiKFxcXFx3KylcIixcbiAgICAgICAgbTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbjogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgczogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgdTogXCIoLispXCIsXG4gICAgICAgIHc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIHk6IFwiKFxcXFxkezJ9KVwiLFxuICAgIH07XG4gICAgdmFyIGZvcm1hdHMgPSB7XG4gICAgICAgIC8vIGdldCB0aGUgZGF0ZSBpbiBVVENcbiAgICAgICAgWjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUudG9JU09TdHJpbmcoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBzaG9ydCwgZS5nLiBUaHVcbiAgICAgICAgRDogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5cy5zaG9ydGhhbmRbZm9ybWF0cy53KGRhdGUsIGxvY2FsZSwgb3B0aW9ucyldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBmdWxsIG1vbnRoIG5hbWUgZS5nLiBKYW51YXJ5XG4gICAgICAgIEY6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGZvcm1hdHMubihkYXRlLCBsb2NhbGUsIG9wdGlvbnMpIC0gMSwgZmFsc2UsIGxvY2FsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBob3VyIDEtMTJcbiAgICAgICAgRzogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHBhZChmb3JtYXRzLmgoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhvdXJzIHdpdGggbGVhZGluZyB6ZXJvIGUuZy4gMDNcbiAgICAgICAgSDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldEhvdXJzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgKDEtMzApIHdpdGggb3JkaW5hbCBzdWZmaXggZS5nLiAxc3QsIDJuZFxuICAgICAgICBKOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm9yZGluYWwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZGF0ZS5nZXREYXRlKCkgKyBsb2NhbGUub3JkaW5hbChkYXRlLmdldERhdGUoKSlcbiAgICAgICAgICAgICAgICA6IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBBTS9QTVxuICAgICAgICBLOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7IHJldHVybiBsb2NhbGUuYW1QTVtpbnQoZGF0ZS5nZXRIb3VycygpID4gMTEpXTsgfSxcbiAgICAgICAgLy8gc2hvcnRoYW5kIG1vbnRoIGUuZy4gSmFuLCBTZXAsIE9jdCwgZXRjXG4gICAgICAgIE06IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtb250aFRvU3RyKGRhdGUuZ2V0TW9udGgoKSwgdHJ1ZSwgbG9jYWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwMC01OVxuICAgICAgICBTOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0U2Vjb25kcygpKTsgfSxcbiAgICAgICAgLy8gdW5peCB0aW1lc3RhbXBcbiAgICAgICAgVTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpIC8gMTAwMDsgfSxcbiAgICAgICAgVzogZnVuY3Rpb24gKGRhdGUsIF8sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmdldFdlZWsoZGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZ1bGwgeWVhciBlLmcuIDIwMTYsIHBhZGRlZCAoMDAwMS05OTk5KVxuICAgICAgICBZOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0RnVsbFllYXIoKSwgNCk7IH0sXG4gICAgICAgIC8vIGRheSBpbiBtb250aCwgcGFkZGVkICgwMS0zMClcbiAgICAgICAgZDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldERhdGUoKSk7IH0sXG4gICAgICAgIC8vIGhvdXIgZnJvbSAxLTEyIChhbS9wbSlcbiAgICAgICAgaDogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlLmdldEhvdXJzKCkgJSAxMiA/IGRhdGUuZ2V0SG91cnMoKSAlIDEyIDogMTIpOyB9LFxuICAgICAgICAvLyBtaW51dGVzLCBwYWRkZWQgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwOVxuICAgICAgICBpOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TWludXRlcygpKTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoICgxLTMwKVxuICAgICAgICBqOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXRlKCk7IH0sXG4gICAgICAgIC8vIHdlZWtkYXkgbmFtZSwgZnVsbCwgZS5nLiBUaHVyc2RheVxuICAgICAgICBsOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLmxvbmdoYW5kW2RhdGUuZ2V0RGF5KCldO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwYWRkZWQgbW9udGggbnVtYmVyICgwMS0xMilcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTsgfSxcbiAgICAgICAgLy8gdGhlIG1vbnRoIG51bWJlciAoMS0xMilcbiAgICAgICAgbjogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKSArIDE7IH0sXG4gICAgICAgIC8vIHNlY29uZHMgMC01OVxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRTZWNvbmRzKCk7IH0sXG4gICAgICAgIC8vIFVuaXggTWlsbGlzZWNvbmRzXG4gICAgICAgIHU6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFRpbWUoKTsgfSxcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAgICAgICAgdzogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7IH0sXG4gICAgICAgIC8vIGxhc3QgdHdvIGRpZ2l0cyBvZiB5ZWFyIGUuZy4gMTYgZm9yIDIwMTZcbiAgICAgICAgeTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIFN0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLnN1YnN0cmluZygyKTsgfSxcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZURhdGVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX2EuY29uZmlnLCBjb25maWcgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdHMgOiBfYiwgX2MgPSBfYS5sMTBuLCBsMTBuID0gX2MgPT09IHZvaWQgMCA/IGVuZ2xpc2ggOiBfYywgX2QgPSBfYS5pc01vYmlsZSwgaXNNb2JpbGUgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlT2JqLCBmcm10LCBvdmVycmlkZUxvY2FsZSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IG92ZXJyaWRlTG9jYWxlIHx8IGwxMG47XG4gICAgICAgICAgICBpZiAoY29uZmlnLmZvcm1hdERhdGUgIT09IHVuZGVmaW5lZCAmJiAhaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZmlnLmZvcm1hdERhdGUoZGF0ZU9iaiwgZnJtdCwgbG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcm10XG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXCIpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYywgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdHNbY10gJiYgYXJyW2kgLSAxXSAhPT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2NdKGRhdGVPYmosIGxvY2FsZSwgY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICA6IGMgIT09IFwiXFxcXFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcIik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlRGF0ZVBhcnNlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIGdpdmVuRm9ybWF0LCB0aW1lbGVzcywgY3VzdG9tTG9jYWxlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSAhPT0gMCAmJiAhZGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIGxvY2FsZSA9IGN1c3RvbUxvY2FsZSB8fCBsMTBuO1xuICAgICAgICAgICAgdmFyIHBhcnNlZERhdGU7XG4gICAgICAgICAgICB2YXIgZGF0ZU9yaWcgPSBkYXRlO1xuICAgICAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0ZSAhPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGRhdGUudG9GaXhlZCAhPT0gdW5kZWZpbmVkIC8vIHRpbWVzdGFtcFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvcHlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIC8vIGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGdpdmVuRm9ybWF0IHx8IChjb25maWcgfHwgZGVmYXVsdHMpLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGVzdHIgPSBTdHJpbmcoZGF0ZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlc3RyID09PSBcInRvZGF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVsZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL1okLy50ZXN0KGRhdGVzdHIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC9HTVQkLy50ZXN0KGRhdGVzdHIpIC8vIGRhdGVzdHJpbmdzIHcvIHRpbWV6b25lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnICYmIGNvbmZpZy5wYXJzZURhdGUpXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBjb25maWcucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbmZpZyB8fCAhY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgMCwgMSwgMCwgMCwgMCwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlZCA9IHZvaWQgMCwgb3BzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBtYXRjaEluZGV4ID0gMCwgcmVnZXhTdHIgPSBcIlwiOyBpIDwgZm9ybWF0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5fMSA9IGZvcm1hdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0JhY2tTbGFzaCA9IHRva2VuXzEgPT09IFwiXFxcXFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVzY2FwZWQgPSBmb3JtYXRbaSAtIDFdID09PSBcIlxcXFxcIiB8fCBpc0JhY2tTbGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlblJlZ2V4W3Rva2VuXzFdICYmICFlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXhTdHIgKz0gdG9rZW5SZWdleFt0b2tlbl8xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKS5leGVjKGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAobWF0Y2hlZCA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wc1t0b2tlbl8xICE9PSBcIllcIiA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiByZXZGb3JtYXRbdG9rZW5fMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6IG1hdGNoWysrbWF0Y2hJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0JhY2tTbGFzaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSBcIi5cIjsgLy8gZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IF9hLmZuLCB2YWwgPSBfYS52YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwYXJzZWREYXRlID0gZm4ocGFyc2VkRGF0ZSwgdmFsLCBsb2NhbGUpIHx8IHBhcnNlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG1hdGNoZWQgPyBwYXJzZWREYXRlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIShwYXJzZWREYXRlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocGFyc2VkRGF0ZS5nZXRUaW1lKCkpKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHByb3ZpZGVkOiBcIiArIGRhdGVPcmlnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICBwYXJzZWREYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZERhdGU7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBkaWZmZXJlbmNlIGluIGRhdGVzLCBtZWFzdXJlZCBpbiBtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVEYXRlcyhkYXRlMSwgZGF0ZTIsIHRpbWVsZXNzKSB7XG4gICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICBpZiAodGltZWxlc3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gKG5ldyBEYXRlKGRhdGUxLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkgLVxuICAgICAgICAgICAgICAgIG5ldyBEYXRlKGRhdGUyLmdldFRpbWUoKSkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHZhciBpc0JldHdlZW4gPSBmdW5jdGlvbiAodHMsIHRzMSwgdHMyKSB7XG4gICAgICAgIHJldHVybiB0cyA+IE1hdGgubWluKHRzMSwgdHMyKSAmJiB0cyA8IE1hdGgubWF4KHRzMSwgdHMyKTtcbiAgICB9O1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgREFZOiA4NjQwMDAwMCxcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIF9hID0gMCwgYXJnc18xID0gYXJnczsgX2EgPCBhcmdzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NfMVtfYV07XG4gICAgICAgICAgICAgICAgX2xvb3BfMShzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgREVCT1VOQ0VEX0NIQU5HRV9NUyA9IDMwMDtcbiAgICBmdW5jdGlvbiBGbGF0cGlja3JJbnN0YW5jZShlbGVtZW50LCBpbnN0YW5jZUNvbmZpZykge1xuICAgICAgICB2YXIgc2VsZiA9IHtcbiAgICAgICAgICAgIGNvbmZpZzogX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRzKSwgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcpLFxuICAgICAgICAgICAgbDEwbjogZW5nbGlzaCxcbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICBzZWxmLnBsdWdpbkVsZW1lbnRzID0gW107XG4gICAgICAgIHNlbGYubG9hZGVkUGx1Z2lucyA9IFtdO1xuICAgICAgICBzZWxmLl9iaW5kID0gYmluZDtcbiAgICAgICAgc2VsZi5fc2V0SG91cnNGcm9tRGF0ZSA9IHNldEhvdXJzRnJvbURhdGU7XG4gICAgICAgIHNlbGYuX3Bvc2l0aW9uQ2FsZW5kYXIgPSBwb3NpdGlvbkNhbGVuZGFyO1xuICAgICAgICBzZWxmLmNoYW5nZU1vbnRoID0gY2hhbmdlTW9udGg7XG4gICAgICAgIHNlbGYuY2hhbmdlWWVhciA9IGNoYW5nZVllYXI7XG4gICAgICAgIHNlbGYuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgc2VsZi5jbG9zZSA9IGNsb3NlO1xuICAgICAgICBzZWxmLl9jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbiAgICAgICAgc2VsZi5kZXN0cm95ID0gZGVzdHJveTtcbiAgICAgICAgc2VsZi5pc0VuYWJsZWQgPSBpc0VuYWJsZWQ7XG4gICAgICAgIHNlbGYuanVtcFRvRGF0ZSA9IGp1bXBUb0RhdGU7XG4gICAgICAgIHNlbGYub3BlbiA9IG9wZW47XG4gICAgICAgIHNlbGYucmVkcmF3ID0gcmVkcmF3O1xuICAgICAgICBzZWxmLnNldCA9IHNldDtcbiAgICAgICAgc2VsZi5zZXREYXRlID0gc2V0RGF0ZTtcbiAgICAgICAgc2VsZi50b2dnbGUgPSB0b2dnbGU7XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwSGVscGVyRnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgc2VsZi51dGlscyA9IHtcbiAgICAgICAgICAgICAgICBnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKG1vbnRoLCB5cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IHZvaWQgMCkgeyBtb250aCA9IHNlbGYuY3VycmVudE1vbnRoOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ciA9PT0gdm9pZCAwKSB7IHlyID0gc2VsZi5jdXJyZW50WWVhcjsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9udGggPT09IDEgJiYgKCh5ciAlIDQgPT09IDAgJiYgeXIgJSAxMDAgIT09IDApIHx8IHlyICUgNDAwID09PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubDEwbi5kYXlzSW5Nb250aFttb250aF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgICAgIHNlbGYuZWxlbWVudCA9IHNlbGYuaW5wdXQgPSBlbGVtZW50O1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcnNlQ29uZmlnKCk7XG4gICAgICAgICAgICBzZXR1cExvY2FsZSgpO1xuICAgICAgICAgICAgc2V0dXBJbnB1dHMoKTtcbiAgICAgICAgICAgIHNldHVwRGF0ZXMoKTtcbiAgICAgICAgICAgIHNldHVwSGVscGVyRnVuY3Rpb25zKCk7XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgYnVpbGQoKTtcbiAgICAgICAgICAgIGJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIHx8IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21EYXRlKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHwgc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDYWxlbmRhcldpZHRoKCk7XG4gICAgICAgICAgICB2YXIgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAgICAgLyogVE9ETzogaW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyXG4gICAgICAgIFxuICAgICAgICAgICAgICBDdXJyZW50bHksIHRoZXJlIGlzIHdlaXJkIHBvc2l0aW9uaW5nIGJlaGF2aW9yIGluIHNhZmFyaSBjYXVzaW5nIHBhZ2VzXG4gICAgICAgICAgICAgIHRvIHNjcm9sbCB1cC4gaHR0cHM6Ly9naXRodWIuY29tL2NobWxuL2ZsYXRwaWNrci9pc3N1ZXMvNTYzXG4gICAgICAgIFxuICAgICAgICAgICAgICBIb3dldmVyLCBtb3N0IGJyb3dzZXJzIGFyZSBub3QgU2FmYXJpIGFuZCBwb3NpdGlvbmluZyBpcyBleHBlbnNpdmUgd2hlbiB1c2VkXG4gICAgICAgICAgICAgIGluIHNjYWxlLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy8xMDk2XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlICYmIGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25SZWFkeVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiaW5kVG9JbnN0YW5jZShmbikge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmJpbmQoc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2FsZW5kYXJXaWR0aCgpIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBzZWxmLmNvbmZpZztcbiAgICAgICAgICAgIGlmIChjb25maWcud2Vla051bWJlcnMgPT09IGZhbHNlICYmIGNvbmZpZy5zaG93TW9udGhzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLm5vQ2FsZW5kYXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXlzV2lkdGggPSAoc2VsZi5kYXlzLm9mZnNldFdpZHRoICsgMSkgKiBjb25maWcuc2hvd01vbnRocztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGRheXNXaWR0aCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUud2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheXNXaWR0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWxmLndlZWtXcmFwcGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi53ZWVrV3JhcHBlci5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ2aXNpYmlsaXR5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhhbmRsZXIgZm9yIGFsbCBldmVudHMgdGFyZ2V0aW5nIHRoZSB0aW1lIGlucHV0c1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGltZShlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0RGF0ZSA9IHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZ2V0RGVmYXVsdEhvdXJzKCksIGhvdXJzID0gX2EuaG91cnMsIG1pbnV0ZXMgPSBfYS5taW51dGVzLCBzZWNvbmRzID0gX2Euc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF0ZS5zZXRIb3Vycyhob3VycywgbWludXRlcywgc2Vjb25kcywgMCk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKGRlZmF1bHREYXRlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gdW5kZWZpbmVkICYmIGUudHlwZSAhPT0gXCJibHVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aW1lV3JhcHBlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VmFsdWUgPSBzZWxmLl9pbnB1dC52YWx1ZTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC52YWx1ZSAhPT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYW1wbTJtaWxpdGFyeShob3VyLCBhbVBNKSB7XG4gICAgICAgICAgICByZXR1cm4gKGhvdXIgJSAxMikgKyAxMiAqIGludChhbVBNID09PSBzZWxmLmwxMG4uYW1QTVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWlsaXRhcnkyYW1wbShob3VyKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdXIgJSAyNCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvdXIgJSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGhlIHNlbGVjdGVkIGRhdGUgb2JqZWN0IHRpbWUgd2l0aCB1c2VyJ3MgdGltZSBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tSW5wdXRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCB8fCBzZWxmLm1pbnV0ZUVsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG91cnMgPSAocGFyc2VJbnQoc2VsZi5ob3VyRWxlbWVudC52YWx1ZS5zbGljZSgtMiksIDEwKSB8fCAwKSAlIDI0LCBtaW51dGVzID0gKHBhcnNlSW50KHNlbGYubWludXRlRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjAsIHNlY29uZHMgPSBzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gKHBhcnNlSW50KHNlbGYuc2Vjb25kRWxlbWVudC52YWx1ZSwgMTApIHx8IDApICUgNjBcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBob3VycyA9IGFtcG0ybWlsaXRhcnkoaG91cnMsIHNlbGYuYW1QTS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGltaXRNaW5Ib3VycyA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5taW5EYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgdmFyIGxpbWl0TWF4SG91cnMgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiwgc2VsZi5jb25maWcubWF4RGF0ZSwgdHJ1ZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAwKTtcbiAgICAgICAgICAgIGlmIChsaW1pdE1heEhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heFRpbWUgPSBzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhUaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhUaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4VGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5taW4obWludXRlcywgbWF4VGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtYXhUaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWluKHNlY29uZHMsIG1heFRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdE1pbkhvdXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pblRpbWUgPSBzZWxmLmNvbmZpZy5taW5UaW1lICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5UaW1lXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWF4KGhvdXJzLCBtaW5UaW1lLmdldEhvdXJzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluVGltZS5nZXRIb3VycygpKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWludXRlcywgbWluVGltZS5nZXRNaW51dGVzKCkpO1xuICAgICAgICAgICAgICAgIGlmIChtaW51dGVzID09PSBtaW5UaW1lLmdldE1pbnV0ZXMoKSlcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IE1hdGgubWF4KHNlY29uZHMsIG1pblRpbWUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3luY3MgdGltZSBpbnB1dCB2YWx1ZXMgd2l0aCBhIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaikge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBkYXRlT2JqIHx8IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqO1xuICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBzZXRIb3VycyhkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdEhvdXJzKCkge1xuICAgICAgICAgICAgdmFyIGhvdXJzID0gc2VsZi5jb25maWcuZGVmYXVsdEhvdXI7XG4gICAgICAgICAgICB2YXIgbWludXRlcyA9IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGU7XG4gICAgICAgICAgICB2YXIgc2Vjb25kcyA9IHNlbGYuY29uZmlnLmRlZmF1bHRTZWNvbmRzO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBtaW5IciA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWluTWludXRlcyA9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TWludXRlcygpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5tYXgoaG91cnMsIG1pbkhyKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1pbkhyKVxuICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gTWF0aC5tYXgobWluTWludXRlcywgbWludXRlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5IciAmJiBtaW51dGVzID09PSBtaW5NaW51dGVzKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1heEhyID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhNaW51dGVzID0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1pbihob3VycywgbWF4SHIpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4SHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1pbihtYXhNaW51dGVzLCBtaW51dGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1heEhyICYmIG1pbnV0ZXMgPT09IG1heE1pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGhvdXJzOiBob3VycywgbWludXRlczogbWludXRlcywgc2Vjb25kczogc2Vjb25kcyB9O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBob3VycywgbWludXRlcywgYW5kIG9wdGlvbmFsbHkgc2Vjb25kc1xuICAgICAgICAgKiBvZiB0aGUgbGF0ZXN0IHNlbGVjdGVkIGRhdGUgb2JqZWN0IGFuZCB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyB0aW1lIGlucHV0c1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gaG91cnMgdGhlIGhvdXIuIHdoZXRoZXIgaXRzIG1pbGl0YXJ5XG4gICAgICAgICAqICAgICAgICAgICAgICAgICBvciBhbS1wbSBnZXRzIGluZmVycmVkIGZyb20gY29uZmlnXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW51dGVzIHRoZSBtaW51dGVzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzIHRoZSBzZWNvbmRzIChvcHRpb25hbClcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLnNldEhvdXJzKGhvdXJzICUgMjQsIG1pbnV0ZXMsIHNlY29uZHMgfHwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuaG91ckVsZW1lbnQgfHwgIXNlbGYubWludXRlRWxlbWVudCB8fCBzZWxmLmlzTW9iaWxlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoIXNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgID8gKCgxMiArIGhvdXJzKSAlIDEyKSArIDEyICogaW50KGhvdXJzICUgMTIgPT09IDApXG4gICAgICAgICAgICAgICAgOiBob3Vycyk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUgPSBwYWQobWludXRlcyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1baW50KGhvdXJzID49IDEyKV07XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHRoZSB5ZWFyIGlucHV0IGFuZCBpbmNyZW1lbnRpbmcgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IHRoZSBrZXl1cCBvciBpbmNyZW1lbnQgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG9uWWVhcklucHV0KGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KGV2ZW50VGFyZ2V0LnZhbHVlKSArIChldmVudC5kZWx0YSB8fCAwKTtcbiAgICAgICAgICAgIGlmICh5ZWFyIC8gMTAwMCA+IDEgfHxcbiAgICAgICAgICAgICAgICAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgJiYgIS9bXlxcZF0vLnRlc3QoeWVhci50b1N0cmluZygpKSkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHllYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFc3NlbnRpYWxseSBhZGRFdmVudExpc3RlbmVyICsgdHJhY2tpbmdcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGFkZEV2ZW50TGlzdGVuZXIgdG9cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IHRoZSBldmVudCBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmQoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldikgeyByZXR1cm4gYmluZChlbGVtZW50LCBldiwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gYmluZChlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyQ2hhbmdlKCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLndyYXApIHtcbiAgICAgICAgICAgICAgICBbXCJvcGVuXCIsIFwiY2xvc2VcIiwgXCJ0b2dnbGVcIiwgXCJjbGVhclwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzZWxmLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiICsgZXZ0ICsgXCJdXCIpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kKGVsLCBcImNsaWNrXCIsIHNlbGZbZXZ0XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUpIHtcbiAgICAgICAgICAgICAgICBzZXR1cE1vYmlsZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkZWJvdW5jZWRSZXNpemUgPSBkZWJvdW5jZShvblJlc2l6ZSwgNTApO1xuICAgICAgICAgICAgc2VsZi5fZGVib3VuY2VkQ2hhbmdlID0gZGVib3VuY2UodHJpZ2dlckNoYW5nZSwgREVCT1VOQ0VEX0NIQU5HRV9NUyk7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICYmICEvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk1vdXNlT3ZlcihnZXRFdmVudFRhcmdldChlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudC5ib2R5LCBcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuaW5saW5lICYmICFzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3csIFwicmVzaXplXCIsIGRlYm91bmNlZFJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcInRvdWNoc3RhcnRcIiwgZG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwiY2xpY2tcIiwgZG9jdW1lbnRDbGljayk7XG4gICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJmb2N1c1wiLCBkb2N1bWVudENsaWNrLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY2xpY2tPcGVucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwiZm9jdXNcIiwgc2VsZi5vcGVuKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuX2lucHV0LCBcImNsaWNrXCIsIHNlbGYub3Blbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFwiY2xpY2tcIiwgb25Nb250aE5hdkNsaWNrKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYubW9udGhOYXYsIFtcImtleXVwXCIsIFwiaW5jcmVtZW50XCJdLCBvblllYXJJbnB1dCk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLmRheXNDb250YWluZXIsIFwiY2xpY2tcIiwgc2VsZWN0RGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi50aW1lQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxUZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV2ZW50VGFyZ2V0KGUpLnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFtcImluY3JlbWVudFwiXSwgdXBkYXRlVGltZSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFwiYmx1clwiLCB1cGRhdGVUaW1lLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLnRpbWVDb250YWluZXIsIFwiY2xpY2tcIiwgdGltZUluY3JlbWVudCk7XG4gICAgICAgICAgICAgICAgYmluZChbc2VsZi5ob3VyRWxlbWVudCwgc2VsZi5taW51dGVFbGVtZW50XSwgW1wiZm9jdXNcIiwgXCJjbGlja1wiXSwgc2VsVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuc2Vjb25kRWxlbWVudCwgXCJmb2N1c1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLnNlY29uZEVsZW1lbnQgJiYgc2VsZi5zZWNvbmRFbGVtZW50LnNlbGVjdCgpOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZChzZWxmLmFtUE0sIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbGxvd0lucHV0KVxuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwiYmx1clwiLCBvbkJsdXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGhlIGNhbGVuZGFyIHZpZXcgdG8gYSBwYXJ0aWN1bGFyIGRhdGUuXG4gICAgICAgICAqIEBwYXJhbSB7RGF0ZX0ganVtcERhdGUgdGhlIGRhdGUgdG8gc2V0IHRoZSB2aWV3IHRvXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpZ2dlckNoYW5nZSBpZiBjaGFuZ2UgZXZlbnRzIHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGp1bXBUb0RhdGUoanVtcERhdGUsIHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBqdW1wVG8gPSBqdW1wRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBzZWxmLnBhcnNlRGF0ZShqdW1wRGF0ZSlcbiAgICAgICAgICAgICAgICA6IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqIHx8XG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIHNlbGYuY29uZmlnLm1pbkRhdGUgPiBzZWxmLm5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1heERhdGUgJiYgc2VsZi5jb25maWcubWF4RGF0ZSA8IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdyk7XG4gICAgICAgICAgICB2YXIgb2xkWWVhciA9IHNlbGYuY3VycmVudFllYXI7XG4gICAgICAgICAgICB2YXIgb2xkTW9udGggPSBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBUbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBqdW1wVG8uZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBqdW1wVG8uZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlID0gXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsganVtcFRvO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlICYmIHNlbGYuY3VycmVudFllYXIgIT09IG9sZFllYXIpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgJiZcbiAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciAhPT0gb2xkWWVhciB8fCBzZWxmLmN1cnJlbnRNb250aCAhPT0gb2xkTW9udGgpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1cC9kb3duIGFycm93IGhhbmRsZXIgZm9yIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0aW1lSW5jcmVtZW50KGUpIHtcbiAgICAgICAgICAgIHZhciBldmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgaWYgKH5ldmVudFRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcImFycm93XCIpKVxuICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KGUsIGV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikgPyAxIDogLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNyZW1lbnRzL2RlY3JlbWVudHMgdGhlIHZhbHVlIG9mIGlucHV0IGFzc29jaS1cbiAgICAgICAgICogYXRlZCB3aXRoIHRoZSB1cC9kb3duIGFycm93IGJ5IGRpc3BhdGNoaW5nIGFuXG4gICAgICAgICAqIFwiaW5jcmVtZW50XCIgZXZlbnQgb24gdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIHRoZSBjbGljayBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGEgdGhlIGRpZmYgKHVzdWFsbHkgMSBvciAtMSlcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBpbnB1dEVsZW0gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudE51bUlucHV0KGUsIGRlbHRhLCBpbnB1dEVsZW0pIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlICYmIGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRFbGVtIHx8XG4gICAgICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQucGFyZW50Tm9kZSAmJiB0YXJnZXQucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUV2ZW50KFwiaW5jcmVtZW50XCIpO1xuICAgICAgICAgICAgZXZlbnQuZGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIGlucHV0ICYmIGlucHV0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWNhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRNb250aE5hdigpKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1pbm5lckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud2Vla051bWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gYnVpbGRXZWVrcygpLCB3ZWVrV3JhcHBlciA9IF9hLndlZWtXcmFwcGVyLCB3ZWVrTnVtYmVycyA9IF9hLndlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHdlZWtXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycyA9IHdlZWtOdW1iZXJzO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtXcmFwcGVyID0gd2Vla1dyYXBwZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItckNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoYnVpbGRXZWVrZGF5cygpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWRheXNcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlubmVyQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc2VsZi5pbm5lckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGJ1aWxkVGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmFuZ2VNb2RlXCIsIHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFuaW1hdGVcIiwgc2VsZi5jb25maWcuYW5pbWF0ZSA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcIm11bHRpTW9udGhcIiwgc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tQXBwZW5kID0gc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLm5vZGVUeXBlICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lIHx8IHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChzZWxmLmNvbmZpZy5pbmxpbmUgPyBcImlubGluZVwiIDogXCJzdGF0aWNcIik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1c3RvbUFwcGVuZCAmJiBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBzZWxmLl9pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5hcHBlbmRUby5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd3JhcHBlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIHNlbGYuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLmFwcGVuZFRvICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hcHBlbmRUb1xuICAgICAgICAgICAgICAgICAgICA6IHdpbmRvdy5kb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEYXkoY2xhc3NOYW1lLCBkYXRlLCBkYXlOdW1iZXIsIGkpIHtcbiAgICAgICAgICAgIHZhciBkYXRlSXNFbmFibGVkID0gaXNFbmFibGVkKGRhdGUsIHRydWUpLCBkYXlFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItZGF5IFwiICsgY2xhc3NOYW1lLCBkYXRlLmdldERhdGUoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuZGF0ZU9iaiA9IGRhdGU7XG4gICAgICAgICAgICBkYXlFbGVtZW50LiRpID0gaTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmZvcm1hdERhdGUoZGF0ZSwgc2VsZi5jb25maWcuYXJpYURhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5ub3cpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi50b2RheURhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJ0b2RheVwiKTtcbiAgICAgICAgICAgICAgICBkYXlFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiLCBcImRhdGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUlzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IGRheUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwic3RhcnRSYW5nZVwiLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhkYXlFbGVtZW50LCBcImVuZFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09IFwibmV4dE1vbnRoRGF5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlSW5SYW5nZShkYXRlKSAmJiAhaXNEYXRlU2VsZWN0ZWQoZGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImluUmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgIT09IFwicHJldk1vbnRoRGF5XCIgJiZcbiAgICAgICAgICAgICAgICBkYXlOdW1iZXIgJSA3ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrTnVtYmVycy5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgXCI8c3BhbiBjbGFzcz0nZmxhdHBpY2tyLWRheSc+XCIgKyBzZWxmLmNvbmZpZy5nZXRXZWVrKGRhdGUpICsgXCI8L3NwYW4+XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25EYXlDcmVhdGVcIiwgZGF5RWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZGF5RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c09uRGF5RWxlbSh0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldEZpcnN0QXZhaWxhYmxlRGF5KGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRNb250aCA9IGRlbHRhID4gMCA/IDAgOiBzZWxmLmNvbmZpZy5zaG93TW9udGhzIC0gMTtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzdGFydE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZGVsdGEgPiAwID8gMCA6IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gZGVsdGEgPiAwID8gbW9udGguY2hpbGRyZW4ubGVuZ3RoIDogLTE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgIT0gZW5kSW5kZXg7IGkgKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBtb250aC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuY2xhc3NOYW1lLmluZGV4T2YoXCJoaWRkZW5cIikgPT09IC0xICYmIGlzRW5hYmxlZChjLmRhdGVPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0QXZhaWxhYmxlRGF5KGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZ2l2ZW5Nb250aCA9IGN1cnJlbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJNb250aFwiKSA9PT0gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnQuZGF0ZU9iai5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRNb250aDtcbiAgICAgICAgICAgIHZhciBlbmRNb250aCA9IGRlbHRhID4gMCA/IHNlbGYuY29uZmlnLnNob3dNb250aHMgOiAtMTtcbiAgICAgICAgICAgIHZhciBsb29wRGVsdGEgPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoOyBtICE9IGVuZE1vbnRoOyBtICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IGdpdmVuTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCA9PT0gbVxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQuJGkgKyBkZWx0YVxuICAgICAgICAgICAgICAgICAgICA6IGRlbHRhIDwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgdmFyIG51bU1vbnRoRGF5cyA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA+PSAwICYmIGkgPCBudW1Nb250aERheXMgJiYgaSAhPSAoZGVsdGEgPiAwID8gbnVtTW9udGhEYXlzIDogLTEpOyBpICs9IGxvb3BEZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRW5hYmxlZChjLmRhdGVPYmopICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhjdXJyZW50LiRpIC0gaSkgPj0gTWF0aC5hYnMoZGVsdGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzT25EYXlFbGVtKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgobG9vcERlbHRhKTtcbiAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkobG9vcERlbHRhKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXkoY3VycmVudCwgb2Zmc2V0KSB7XG4gICAgICAgICAgICB2YXIgZGF5Rm9jdXNlZCA9IGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICB2YXIgc3RhcnRFbGVtID0gY3VycmVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBjdXJyZW50XG4gICAgICAgICAgICAgICAgOiBkYXlGb2N1c2VkXG4gICAgICAgICAgICAgICAgICAgID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYuc2VsZWN0ZWREYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYudG9kYXlEYXRlRWxlbSAhPT0gdW5kZWZpbmVkICYmIGlzSW5WaWV3KHNlbGYudG9kYXlEYXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYudG9kYXlEYXRlRWxlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZ2V0Rmlyc3RBdmFpbGFibGVEYXkob2Zmc2V0ID4gMCA/IDEgOiAtMSk7XG4gICAgICAgICAgICBpZiAoc3RhcnRFbGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWRheUZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBmb2N1c09uRGF5RWxlbShzdGFydEVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0TmV4dEF2YWlsYWJsZURheShzdGFydEVsZW0sIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aERheXMoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdE9mTW9udGggPSAobmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpIC0gc2VsZi5sMTBuLmZpcnN0RGF5T2ZXZWVrICsgNykgJSA3O1xuICAgICAgICAgICAgdmFyIHByZXZNb250aERheXMgPSBzZWxmLnV0aWxzLmdldERheXNJbk1vbnRoKChtb250aCAtIDEgKyAxMikgJSAxMiwgeWVhcik7XG4gICAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBzZWxmLnV0aWxzLmdldERheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSwgZGF5cyA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksIGlzTXVsdGlNb250aCA9IHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxLCBwcmV2TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwicHJldk1vbnRoRGF5IGhpZGRlblwiIDogXCJwcmV2TW9udGhEYXlcIiwgbmV4dE1vbnRoRGF5Q2xhc3MgPSBpc011bHRpTW9udGggPyBcIm5leHRNb250aERheSBoaWRkZW5cIiA6IFwibmV4dE1vbnRoRGF5XCI7XG4gICAgICAgICAgICB2YXIgZGF5TnVtYmVyID0gcHJldk1vbnRoRGF5cyArIDEgLSBmaXJzdE9mTW9udGgsIGRheUluZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIHByZXBlbmQgZGF5cyBmcm9tIHRoZSBlbmRpbmcgb2YgcHJldmlvdXMgbW9udGhcbiAgICAgICAgICAgIGZvciAoOyBkYXlOdW1iZXIgPD0gcHJldk1vbnRoRGF5czsgZGF5TnVtYmVyKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShwcmV2TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGFydCBhdCAxIHNpbmNlIHRoZXJlIGlzIG5vIDB0aCBkYXlcbiAgICAgICAgICAgIGZvciAoZGF5TnVtYmVyID0gMTsgZGF5TnVtYmVyIDw9IGRheXNJbk1vbnRoOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KFwiXCIsIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXlOdW1iZXIpLCBkYXlOdW1iZXIsIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhcHBlbmQgZGF5cyBmcm9tIHRoZSBuZXh0IG1vbnRoXG4gICAgICAgICAgICBmb3IgKHZhciBkYXlOdW0gPSBkYXlzSW5Nb250aCArIDE7IGRheU51bSA8PSA0MiAtIGZpcnN0T2ZNb250aCAmJlxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxIHx8IGRheUluZGV4ICUgNyAhPT0gMCk7IGRheU51bSsrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkobmV4dE1vbnRoRGF5Q2xhc3MsIG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgZGF5TnVtICUgZGF5c0luTW9udGgpLCBkYXlOdW0sIGRheUluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIHZhciBkYXlDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZGF5Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgZGF5Q29udGFpbmVyLmFwcGVuZENoaWxkKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRheUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZERheXMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhck5vZGUoc2VsZi5kYXlzQ29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHdlZWsgbnVtYmVycyBmb3IgZWFjaCBtb250aFxuICAgICAgICAgICAgaWYgKHNlbGYud2Vla051bWJlcnMpXG4gICAgICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYud2Vla051bWJlcnMpO1xuICAgICAgICAgICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGJ1aWxkTW9udGhEYXlzKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZyk7XG4gICAgICAgICAgICBzZWxmLmRheXMgPSBzZWxmLmRheXNDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiYgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aFN3aXRjaCgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93TW9udGhzID4gMSB8fFxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vbnRoU2VsZWN0b3JUeXBlICE9PSBcImRyb3Bkb3duXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHNob3VsZEJ1aWxkTW9udGggPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhKHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkQnVpbGRNb250aChpKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gY3JlYXRlRWxlbWVudChcIm9wdGlvblwiLCBcImZsYXRwaWNrci1tb250aERyb3Bkb3duLW1vbnRoXCIpO1xuICAgICAgICAgICAgICAgIG1vbnRoLnZhbHVlID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgaSkuZ2V0TW9udGgoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG1vbnRoLnRleHRDb250ZW50ID0gbW9udGhUb1N0cihpLCBzZWxmLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsIHNlbGYubDEwbik7XG4gICAgICAgICAgICAgICAgbW9udGgudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jdXJyZW50TW9udGggPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGguc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItbW9udGhcIik7XG4gICAgICAgICAgICB2YXIgbW9udGhOYXZGcmFnbWVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICB2YXIgbW9udGhFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxIHx8XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9udGhTZWxlY3RvclR5cGUgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICBtb250aEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImN1ci1tb250aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIFwiZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmwxMG4ubW9udGhBcmlhTGFiZWwpO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lciwgXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRNb250aCA9IHBhcnNlSW50KHRhcmdldC52YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZU1vbnRoKHNlbGVjdGVkTW9udGggLSBzZWxmLmN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgICAgIG1vbnRoRWxlbWVudCA9IHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeWVhcklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJjdXIteWVhclwiLCB7IHRhYmluZGV4OiBcIi0xXCIgfSk7XG4gICAgICAgICAgICB2YXIgeWVhckVsZW1lbnQgPSB5ZWFySW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgc2VsZi5sMTBuLnllYXJBcmlhTGFiZWwpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LmRpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50TW9udGggPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWN1cnJlbnQtbW9udGhcIik7XG4gICAgICAgICAgICBjdXJyZW50TW9udGguYXBwZW5kQ2hpbGQobW9udGhFbGVtZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZCh5ZWFySW5wdXQpO1xuICAgICAgICAgICAgbW9udGhOYXZGcmFnbWVudC5hcHBlbmRDaGlsZChjdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1vbnRoTmF2RnJhZ21lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudDogeWVhckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50OiBtb250aEVsZW1lbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhzKCkge1xuICAgICAgICAgICAgY2xlYXJOb2RlKHNlbGYubW9udGhOYXYpO1xuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLnByZXZNb250aE5hdik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocykge1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgbS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IGJ1aWxkTW9udGgoKTtcbiAgICAgICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5wdXNoKG1vbnRoLnllYXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMucHVzaChtb250aC5tb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQobW9udGguY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYuYXBwZW5kQ2hpbGQoc2VsZi5uZXh0TW9udGhOYXYpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGhOYXYoKSB7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aHNcIik7XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXByZXYtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLnByZXZNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5wcmV2QXJyb3c7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdiA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLW5leHQtbW9udGhcIik7XG4gICAgICAgICAgICBzZWxmLm5leHRNb250aE5hdi5pbm5lckhUTUwgPSBzZWxmLmNvbmZpZy5uZXh0QXJyb3c7XG4gICAgICAgICAgICBidWlsZE1vbnRocygpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZVByZXZNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYucHJldk1vbnRoTmF2LCBcImZsYXRwaWNrci1kaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLl9faGlkZU5leHRNb250aEFycm93OyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgIT09IGJvb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYubmV4dE1vbnRoTmF2LCBcImZsYXRwaWNrci1kaXNhYmxlZFwiLCBib29sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3cgPSBib29sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQgPSBzZWxmLnllYXJFbGVtZW50c1swXTtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLm1vbnRoTmF2O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkVGltZSgpIHtcbiAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1RpbWVcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhcilcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub0NhbGVuZGFyXCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci10aW1lXCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpO1xuICAgICAgICAgICAgdmFyIGhvdXJJbnB1dCA9IGNyZWF0ZU51bWJlcklucHV0KFwiZmxhdHBpY2tyLWhvdXJcIiwge1xuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBzZWxmLmwxMG4uaG91ckFyaWFMYWJlbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCA9IGhvdXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgdmFyIG1pbnV0ZUlucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItbWludXRlXCIsIHtcbiAgICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogc2VsZi5sMTBuLm1pbnV0ZUFyaWFMYWJlbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50ID0gbWludXRlSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudGFiSW5kZXggPSBzZWxmLm1pbnV0ZUVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldEhvdXJzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLnRpbWVfMjRoclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyXG4gICAgICAgICAgICAgICAgICAgIDogbWlsaXRhcnkyYW1wbShzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRNaW51dGVzKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRlZmF1bHRNaW51dGUpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLmhvdXJJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3RlcFwiLCBzZWxmLmNvbmZpZy5taW51dGVJbmNyZW1lbnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPyBcIjBcIiA6IFwiMVwiKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMjNcIiA6IFwiMTJcIik7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChob3VySW5wdXQpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQobWludXRlSW5wdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnRpbWVfMjRocilcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRpbWUyNGhyXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc1NlY29uZHNcIik7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZElucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3Itc2Vjb25kXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCA9IHNlY29uZElucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlID0gcGFkKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0U2Vjb25kcygpXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHMpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYubWludXRlRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWF4XCIsIFwiNTlcIik7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yXCIsIFwiOlwiKSk7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlY29uZElucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcudGltZV8yNGhyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIHNlbGYuYW1QTSBpZiBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgICAgIHNlbGYuYW1QTSA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiZmxhdHBpY2tyLWFtLXBtXCIsIHNlbGYubDEwbi5hbVBNW2ludCgoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmhvdXJFbGVtZW50LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdEhvdXIpID4gMTEpXSk7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRpdGxlID0gc2VsZi5sMTBuLnRvZ2dsZVRpdGxlO1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmFtUE0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGYudGltZUNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpXG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5c1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrZGF5Q29udGFpbmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVdlZWtkYXlzKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi53ZWVrZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdlZWtkYXlzKCkge1xuICAgICAgICAgICAgaWYgKCFzZWxmLndlZWtkYXlDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3REYXlPZldlZWsgPSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWs7XG4gICAgICAgICAgICB2YXIgd2Vla2RheXMgPSBfX3NwcmVhZEFycmF5cyhzZWxmLmwxMG4ud2Vla2RheXMuc2hvcnRoYW5kKTtcbiAgICAgICAgICAgIGlmIChmaXJzdERheU9mV2VlayA+IDAgJiYgZmlyc3REYXlPZldlZWsgPCB3ZWVrZGF5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5cyA9IF9fc3ByZWFkQXJyYXlzKHdlZWtkYXlzLnNwbGljZShmaXJzdERheU9mV2Vlaywgd2Vla2RheXMubGVuZ3RoKSwgd2Vla2RheXMuc3BsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5jb25maWcuc2hvd01vbnRoczsgaS0tOykge1xuICAgICAgICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lci5jaGlsZHJlbltpXS5pbm5lckhUTUwgPSBcIlxcbiAgICAgIDxzcGFuIGNsYXNzPSdmbGF0cGlja3Itd2Vla2RheSc+XFxuICAgICAgICBcIiArIHdlZWtkYXlzLmpvaW4oXCI8L3NwYW4+PHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cIikgKyBcIlxcbiAgICAgIDwvc3Bhbj5cXG4gICAgICBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBidWlsZFdlZWtzKCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzV2Vla3NcIik7XG4gICAgICAgICAgICB2YXIgd2Vla1dyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWt3cmFwcGVyXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3Itd2Vla2RheVwiLCBzZWxmLmwxMG4ud2Vla0FiYnJldmlhdGlvbikpO1xuICAgICAgICAgICAgdmFyIHdlZWtOdW1iZXJzID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrc1wiKTtcbiAgICAgICAgICAgIHdlZWtXcmFwcGVyLmFwcGVuZENoaWxkKHdlZWtOdW1iZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2Vla1dyYXBwZXI6IHdlZWtXcmFwcGVyLFxuICAgICAgICAgICAgICAgIHdlZWtOdW1iZXJzOiB3ZWVrTnVtYmVycyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlTW9udGgodmFsdWUsIGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXQgPT09IHZvaWQgMCkgeyBpc09mZnNldCA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGlzT2Zmc2V0ID8gdmFsdWUgOiB2YWx1ZSAtIHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgaWYgKChkZWx0YSA8IDAgJiYgc2VsZi5faGlkZVByZXZNb250aEFycm93ID09PSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIChkZWx0YSA+IDAgJiYgc2VsZi5faGlkZU5leHRNb250aEFycm93ID09PSB0cnVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCArPSBkZWx0YTtcbiAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRNb250aCA8IDAgfHwgc2VsZi5jdXJyZW50TW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgKz0gc2VsZi5jdXJyZW50TW9udGggPiAxMSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IChzZWxmLmN1cnJlbnRNb250aCArIDEyKSAlIDEyO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uTW9udGhDaGFuZ2VcIik7XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXIodHJpZ2dlckNoYW5nZUV2ZW50LCB0b0luaXRpYWwpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQgPT09IHZvaWQgMCkgeyB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAodG9Jbml0aWFsID09PSB2b2lkIDApIHsgdG9Jbml0aWFsID0gdHJ1ZTsgfVxuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodG9Jbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGYuX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0SG91cnMoKSwgaG91cnMgPSBfYS5ob3VycywgbWludXRlcyA9IF9hLm1pbnV0ZXMsIHNlY29uZHMgPSBfYS5zZWNvbmRzO1xuICAgICAgICAgICAgICAgIHNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KVxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJDaGFuZ2VFdmVudCBpcyB0cnVlIChkZWZhdWx0KSBvciBhbiBFdmVudFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNhbGVuZGFyQ29udGFpbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwib3BlblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc2VsZi5faGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIGggPSBzZWxmLl9oYW5kbGVyc1tpXTtcbiAgICAgICAgICAgICAgICBoLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihoLmV2ZW50LCBoLmhhbmRsZXIsIGgub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9oYW5kbGVycyA9IFtdO1xuICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5tb2JpbGVJbnB1dCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgJiYgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYyAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIubGFzdENoaWxkICYmIHdyYXBwZXIucmVtb3ZlQ2hpbGQod3JhcHBlci5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod3JhcHBlci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAod3JhcHBlci5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlci5maXJzdENoaWxkLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLmNhbGVuZGFyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuYWx0SW5wdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmFsdElucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBzZWxmLmlucHV0Ll90eXBlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LnJlbW92ZShcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiX3Nob3dUaW1lSW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImxhdGVzdFNlbGVjdGVkRGF0ZU9ialwiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX2hpZGVQcmV2TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlTmV4dE1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcIl9faGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJpc01vYmlsZVwiLFxuICAgICAgICAgICAgICAgIFwiaXNPcGVuXCIsXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZERhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJtaW5EYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibWF4RGF0ZUhhc1RpbWVcIixcbiAgICAgICAgICAgICAgICBcImRheXNcIixcbiAgICAgICAgICAgICAgICBcImRheXNDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIl9pbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwiX3Bvc2l0aW9uRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwiaW5uZXJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcInJDb250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJ0b2RheURhdGVFbGVtXCIsXG4gICAgICAgICAgICAgICAgXCJjYWxlbmRhckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwid2Vla2RheUNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwicHJldk1vbnRoTmF2XCIsXG4gICAgICAgICAgICAgICAgXCJuZXh0TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcIm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50TW9udGhFbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJjdXJyZW50WWVhckVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcIm5hdmlnYXRpb25DdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJFbGVtKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hcHBlbmRUbyAmJiBzZWxmLmNvbmZpZy5hcHBlbmRUby5jb250YWlucyhlbGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRvY3VtZW50Q2xpY2soZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXRfMSA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc0NhbGVuZGFyRWxlbWVudCA9IGlzQ2FsZW5kYXJFbGVtKGV2ZW50VGFyZ2V0XzEpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lucHV0ID0gZXZlbnRUYXJnZXRfMSA9PT0gc2VsZi5pbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldF8xID09PSBzZWxmLmFsdElucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudC5jb250YWlucyhldmVudFRhcmdldF8xKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZWIgY29tcG9uZW50c1xuICAgICAgICAgICAgICAgICAgICAvLyBlLnBhdGggaXMgbm90IHByZXNlbnQgaW4gYWxsIGJyb3dzZXJzLiBjaXJjdW12ZW50aW5nIHR5cGVjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgKGUucGF0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wYXRoLmluZGV4T2YgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICh+ZS5wYXRoLmluZGV4T2Yoc2VsZi5pbnB1dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB+ZS5wYXRoLmluZGV4T2Yoc2VsZi5hbHRJbnB1dCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgbG9zdEZvY3VzID0gZS50eXBlID09PSBcImJsdXJcIlxuICAgICAgICAgICAgICAgICAgICA/IGlzSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzQ2FsZW5kYXJFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaXNJZ25vcmVkID0gIXNlbGYuY29uZmlnLmlnbm9yZWRGb2N1c0VsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29udGFpbnMoZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc3RGb2N1cyAmJiBpc0lnbm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudGltZUNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlICE9PSBcIlwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlWWVhcihuZXdZZWFyKSB7XG4gICAgICAgICAgICBpZiAoIW5ld1llYXIgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZSAmJiBuZXdZZWFyIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKSB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmIG5ld1llYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuZXdZZWFyTnVtID0gbmV3WWVhciwgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gbmV3WWVhck51bTtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBuZXdZZWFyTnVtIHx8IHNlbGYuY3VycmVudFllYXI7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gTWF0aC5taW4oc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpLCBzZWxmLmN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1heChzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05ld1llYXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNFbmFibGVkKGRhdGUsIHRpbWVsZXNzKSB7XG4gICAgICAgICAgICBpZiAodGltZWxlc3MgPT09IHZvaWQgMCkgeyB0aW1lbGVzcyA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciBkYXRlVG9DaGVjayA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHVuZGVmaW5lZCwgdGltZWxlc3MpOyAvLyB0aW1lbGVzc1xuICAgICAgICAgICAgaWYgKChzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1pbkRhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1pbkRhdGVIYXNUaW1lKSA8IDApIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2sgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGVUb0NoZWNrLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0aW1lbGVzcyAhPT0gdW5kZWZpbmVkID8gdGltZWxlc3MgOiAhc2VsZi5tYXhEYXRlSGFzVGltZSkgPiAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA9PT0gMCAmJiBzZWxmLmNvbmZpZy5kaXNhYmxlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChkYXRlVG9DaGVjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBib29sID0gc2VsZi5jb25maWcuZW5hYmxlLmxlbmd0aCA+IDAsIGFycmF5ID0gYm9vbCA/IHNlbGYuY29uZmlnLmVuYWJsZSA6IHNlbGYuY29uZmlnLmRpc2FibGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZCA9IHZvaWQgMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZCA9IGFycmF5W2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICAgICAgICAgIGQoZGF0ZVRvQ2hlY2spIC8vIGRpc2FibGVkIGJ5IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkIGluc3RhbmNlb2YgRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09IFwic3RyaW5nXCIgJiYgZGF0ZVRvQ2hlY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSBkYXRlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkID0gc2VsZi5wYXJzZURhdGUoZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQuZ2V0VGltZSgpID09PSBkYXRlVG9DaGVjay5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYm9vbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiAhYm9vbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgcmFuZ2VcbiAgICAgICAgICAgICAgICB0eXBlb2YgZCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIGQuZnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICBkLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA+PSBkLmZyb20uZ2V0VGltZSgpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrLmdldFRpbWUoKSA8PSBkLnRvLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIWJvb2w7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJblZpZXcoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAoZWxlbS5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUuaW5kZXhPZihcImZsYXRwaWNrci1kaXNhYmxlZFwiKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGVsZW0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkJsdXIoZSkge1xuICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBlLnRhcmdldCA9PT0gc2VsZi5faW5wdXQ7XG4gICAgICAgICAgICBpZiAoaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICEoZS5yZWxhdGVkVGFyZ2V0ICYmIGlzQ2FsZW5kYXJFbGVtKGUucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBlLnRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmFsdEZvcm1hdFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgICAgICAgICAvLyBlLmtleSAgICAgICAgICAgICAgICAgICAgICBlLmtleUNvZGVcbiAgICAgICAgICAgIC8vIFwiQmFja3NwYWNlXCIgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAvLyBcIlRhYlwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOVxuICAgICAgICAgICAgLy8gXCJFbnRlclwiICAgICAgICAgICAgICAgICAgICAgICAgICAgMTNcbiAgICAgICAgICAgIC8vIFwiRXNjYXBlXCIgICAgIChJRSBcIkVzY1wiKSAgICAgICAgICAgMjdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dMZWZ0XCIgIChJRSBcIkxlZnRcIikgICAgICAgICAgMzdcbiAgICAgICAgICAgIC8vIFwiQXJyb3dVcFwiICAgIChJRSBcIlVwXCIpICAgICAgICAgICAgMzhcbiAgICAgICAgICAgIC8vIFwiQXJyb3dSaWdodFwiIChJRSBcIlJpZ2h0XCIpICAgICAgICAgMzlcbiAgICAgICAgICAgIC8vIFwiQXJyb3dEb3duXCIgIChJRSBcIkRvd25cIikgICAgICAgICAgNDBcbiAgICAgICAgICAgIC8vIFwiRGVsZXRlXCIgICAgIChJRSBcIkRlbFwiKSAgICAgICAgICAgNDZcbiAgICAgICAgICAgIHZhciBldmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBzZWxmLmNvbmZpZy53cmFwXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KVxuICAgICAgICAgICAgICAgIDogZXZlbnRUYXJnZXQgPT09IHNlbGYuX2lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93SW5wdXQgPSBzZWxmLmNvbmZpZy5hbGxvd0lucHV0O1xuICAgICAgICAgICAgdmFyIGFsbG93S2V5ZG93biA9IHNlbGYuaXNPcGVuICYmICghYWxsb3dJbnB1dCB8fCAhaXNJbnB1dCk7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbmxpbmVLZXlkb3duID0gc2VsZi5jb25maWcuaW5saW5lICYmIGlzSW5wdXQgJiYgIWFsbG93SW5wdXQ7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMyAmJiBpc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKHNlbGYuX2lucHV0LnZhbHVlLCB0cnVlLCBldmVudFRhcmdldCA9PT0gc2VsZi5hbHRJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5hbHRGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudFRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NhbGVuZGFyRWxlbShldmVudFRhcmdldCkgfHxcbiAgICAgICAgICAgICAgICBhbGxvd0tleWRvd24gfHxcbiAgICAgICAgICAgICAgICBhbGxvd0lubGluZUtleWRvd24pIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNUaW1lT2JqID0gISFzZWxmLnRpbWVDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZU9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdERhdGUoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQgJiYgIXNlbGYuY29uZmlnLmFsbG93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaiAmJiAhaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93SW5wdXQgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiBpc0luVmlldyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YV8xID0gZS5rZXlDb2RlID09PSAzOSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmN0cmxLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGRlbHRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gZS5rZXlDb2RlID09PSA0MCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoc2VsZi5kYXlzQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuJGkgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldCA9PT0gc2VsZi5pbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0ID09PSBzZWxmLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSBkZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkoZ2V0Rmlyc3RBdmFpbGFibGVEYXkoMSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNUaW1lT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KHVuZGVmaW5lZCwgZGVsdGEgKiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0ID09PSBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVGltZU9iaiAmJiBzZWxmLmhvdXJFbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChzZWxmLnBsdWdpbkVsZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IGVsZW1zLmluZGV4T2YoZXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbXNbaSArIChlLnNoaWZ0S2V5ID8gLTEgOiAxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRhcmdldCB8fCBzZWxmLl9pbnB1dCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2VsZi5jb25maWcubm9DYWxlbmRhciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5jb250YWlucyhldmVudFRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZXZlbnRUYXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMF0uY2hhckF0KDApLnRvTG93ZXJDYXNlKCk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbUlucHV0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzFdLmNoYXJBdCgwKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVsxXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5wdXQgfHwgaXNDYWxlbmRhckVsZW0oZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25LZXlEb3duXCIsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW91c2VPdmVyKGVsZW0pIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoICE9PSAxIHx8XG4gICAgICAgICAgICAgICAgKGVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kYXlcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRpc2FibGVkXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvdmVyRGF0ZSA9IGVsZW1cbiAgICAgICAgICAgICAgICA/IGVsZW0uZGF0ZU9iai5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuZGF5cy5maXJzdEVsZW1lbnRDaGlsZC5kYXRlT2JqLmdldFRpbWUoKSwgaW5pdGlhbERhdGUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHVuZGVmaW5lZCwgdHJ1ZSkuZ2V0VGltZSgpLCByYW5nZVN0YXJ0RGF0ZSA9IE1hdGgubWluKGhvdmVyRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSksIHJhbmdlRW5kRGF0ZSA9IE1hdGgubWF4KGhvdmVyRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLmdldFRpbWUoKSk7XG4gICAgICAgICAgICB2YXIgY29udGFpbnNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG1pblJhbmdlID0gMCwgbWF4UmFuZ2UgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgdCA9IHJhbmdlU3RhcnREYXRlOyB0IDwgcmFuZ2VFbmREYXRlOyB0ICs9IGR1cmF0aW9uLkRBWSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbmFibGVkKG5ldyBEYXRlKHQpLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluc0Rpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zRGlzYWJsZWQgfHwgKHQgPiByYW5nZVN0YXJ0RGF0ZSAmJiB0IDwgcmFuZ2VFbmREYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPCBpbml0aWFsRGF0ZSAmJiAoIW1pblJhbmdlIHx8IHQgPiBtaW5SYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5SYW5nZSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHQgPiBpbml0aWFsRGF0ZSAmJiAoIW1heFJhbmdlIHx8IHQgPCBtYXhSYW5nZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhSYW5nZSA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbV07XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSwgbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF5RWxlbSA9IG1vbnRoLmNoaWxkcmVuW2ldLCBkYXRlID0gZGF5RWxlbS5kYXRlT2JqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRPZlJhbmdlID0gKG1pblJhbmdlID4gMCAmJiB0aW1lc3RhbXAgPCBtaW5SYW5nZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChtYXhSYW5nZSA+IDAgJiYgdGltZXN0YW1wID4gbWF4UmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0T2ZSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtcImluUmFuZ2VcIiwgXCJzdGFydFJhbmdlXCIsIFwiZW5kUmFuZ2VcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LnJlbW92ZShjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWluc0Rpc2FibGVkICYmICFvdXRPZlJhbmdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICAgICAgW1wic3RhcnRSYW5nZVwiLCBcImluUmFuZ2VcIiwgXCJlbmRSYW5nZVwiLCBcIm5vdEFsbG93ZWRcIl0uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuYWRkKGhvdmVyRGF0ZSA8PSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcInN0YXJ0UmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJlbmRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRGF0ZSA8IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcInN0YXJ0UmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbml0aWFsRGF0ZSA+IGhvdmVyRGF0ZSAmJiB0aW1lc3RhbXAgPT09IGluaXRpYWxEYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRheUVsZW0uY2xhc3NMaXN0LmFkZChcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCA+PSBtaW5SYW5nZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXhSYW5nZSA9PT0gMCB8fCB0aW1lc3RhbXAgPD0gbWF4UmFuZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNCZXR3ZWVuKHRpbWVzdGFtcCwgaW5pdGlhbERhdGUsIGhvdmVyRGF0ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBtb250aC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2xvb3BfMShpLCBsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLnN0YXRpYyAmJiAhc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FsZW5kYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcGVuKGUsIHBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uRWxlbWVudCA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uRWxlbWVudCA9IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDsgfVxuICAgICAgICAgICAgaWYgKHNlbGYuaXNNb2JpbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGUpO1xuICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldCAmJiBldmVudFRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uT3BlblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5faW5wdXQuZGlzYWJsZWQgfHwgc2VsZi5jb25maWcuaW5saW5lKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB3YXNPcGVuID0gc2VsZi5pc09wZW47XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXdhc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25PcGVuXCIpO1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uQ2FsZW5kYXIocG9zaXRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lID09PSB0cnVlICYmIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuYWxsb3dJbnB1dCA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNlbGYudGltZUNvbnRhaW5lci5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuaG91ckVsZW1lbnQuc2VsZWN0KCk7IH0sIDUwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWluTWF4RGF0ZVNldHRlcih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZU9iaiA9IChzZWxmLmNvbmZpZ1tcIl9cIiArIHR5cGUgKyBcIkRhdGVcIl0gPSBzZWxmLnBhcnNlRGF0ZShkYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGludmVyc2VEYXRlT2JqID0gc2VsZi5jb25maWdbXCJfXCIgKyAodHlwZSA9PT0gXCJtaW5cIiA/IFwibWF4XCIgOiBcIm1pblwiKSArIFwiRGF0ZVwiXTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZbdHlwZSA9PT0gXCJtaW5cIiA/IFwibWluRGF0ZUhhc1RpbWVcIiA6IFwibWF4RGF0ZUhhc1RpbWVcIl0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmouZ2V0U2Vjb25kcygpID4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBzZWxmLnNlbGVjdGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBpc0VuYWJsZWQoZCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggJiYgdHlwZSA9PT0gXCJtaW5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoZGF0ZU9iaik7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudFt0eXBlXSA9IGRhdGVPYmouZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50LmRpc2FibGVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICEhaW52ZXJzZURhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZlcnNlRGF0ZU9iai5nZXRGdWxsWWVhcigpID09PSBkYXRlT2JqLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZUNvbmZpZygpIHtcbiAgICAgICAgICAgIHZhciBib29sT3B0cyA9IFtcbiAgICAgICAgICAgICAgICBcIndyYXBcIixcbiAgICAgICAgICAgICAgICBcIndlZWtOdW1iZXJzXCIsXG4gICAgICAgICAgICAgICAgXCJhbGxvd0lucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJhbGxvd0ludmFsaWRQcmVsb2FkXCIsXG4gICAgICAgICAgICAgICAgXCJjbGlja09wZW5zXCIsXG4gICAgICAgICAgICAgICAgXCJ0aW1lXzI0aHJcIixcbiAgICAgICAgICAgICAgICBcImVuYWJsZVRpbWVcIixcbiAgICAgICAgICAgICAgICBcIm5vQ2FsZW5kYXJcIixcbiAgICAgICAgICAgICAgICBcImFsdElucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJzaG9ydGhhbmRDdXJyZW50TW9udGhcIixcbiAgICAgICAgICAgICAgICBcImlubGluZVwiLFxuICAgICAgICAgICAgICAgIFwic3RhdGljXCIsXG4gICAgICAgICAgICAgICAgXCJlbmFibGVTZWNvbmRzXCIsXG4gICAgICAgICAgICAgICAgXCJkaXNhYmxlTW9iaWxlXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIHVzZXJDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50LmRhdGFzZXQgfHwge30pKSksIGluc3RhbmNlQ29uZmlnKTtcbiAgICAgICAgICAgIHZhciBmb3JtYXRzID0ge307XG4gICAgICAgICAgICBzZWxmLmNvbmZpZy5wYXJzZURhdGUgPSB1c2VyQ29uZmlnLnBhcnNlRGF0ZTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLmZvcm1hdERhdGUgPSB1c2VyQ29uZmlnLmZvcm1hdERhdGU7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZW5hYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9lbmFibGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGF0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuX2VuYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwiZGlzYWJsZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fZGlzYWJsZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5fZGlzYWJsZSA9IHBhcnNlRGF0ZVJ1bGVzKGRhdGVzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdGltZU1vZGUgPSB1c2VyQ29uZmlnLm1vZGUgPT09IFwidGltZVwiO1xuICAgICAgICAgICAgaWYgKCF1c2VyQ29uZmlnLmRhdGVGb3JtYXQgJiYgKHVzZXJDb25maWcuZW5hYmxlVGltZSB8fCB0aW1lTW9kZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdERhdGVGb3JtYXQgPSBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy5kYXRlRm9ybWF0IHx8IGRlZmF1bHRzLmRhdGVGb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5kYXRlRm9ybWF0ID1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5ub0NhbGVuZGFyIHx8IHRpbWVNb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiSDppXCIgKyAodXNlckNvbmZpZy5lbmFibGVTZWNvbmRzID8gXCI6U1wiIDogXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdERhdGVGb3JtYXQgKyBcIiBIOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLmFsdElucHV0ICYmXG4gICAgICAgICAgICAgICAgKHVzZXJDb25maWcuZW5hYmxlVGltZSB8fCB0aW1lTW9kZSkgJiZcbiAgICAgICAgICAgICAgICAhdXNlckNvbmZpZy5hbHRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdEFsdEZvcm1hdCA9IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmFsdEZvcm1hdCB8fCBkZWZhdWx0cy5hbHRGb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0cy5hbHRGb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLm5vQ2FsZW5kYXIgfHwgdGltZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJoOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTIEtcIiA6IFwiIEtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGVmYXVsdEFsdEZvcm1hdCArIChcIiBoOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKSArIFwiIEtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWluRGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWluRGF0ZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heERhdGVTZXR0ZXIoXCJtaW5cIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtYXhEYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9tYXhEYXRlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1heFwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG1pbk1heFRpbWVTZXR0ZXIgPSBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW3R5cGUgPT09IFwibWluXCIgPyBcIl9taW5UaW1lXCIgOiBcIl9tYXhUaW1lXCJdID0gc2VsZi5wYXJzZURhdGUodmFsLCBcIkg6aTpTXCIpO1xuICAgICAgICAgICAgfTsgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5UaW1lXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9taW5UaW1lOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4VGltZVNldHRlcihcIm1pblwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heFRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heFRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWF4XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5tb2RlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZWxmLmNvbmZpZywgZm9ybWF0cywgdXNlckNvbmZpZyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2xPcHRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE2NjNcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tib29sT3B0c1tpXV0gPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgICAgICBIT09LUy5maWx0ZXIoZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIHNlbGYuY29uZmlnW2hvb2tdICE9PSB1bmRlZmluZWQ7IH0pLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tob29rXSA9IGFycmF5aWZ5KHNlbGYuY29uZmlnW2hvb2tdIHx8IFtdKS5tYXAoYmluZFRvSW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmlzTW9iaWxlID1cbiAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZU1vYmlsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuaW5saW5lICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy53ZWVrTnVtYmVycyAmJlxuICAgICAgICAgICAgICAgICAgICAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuY29uZmlnLnBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2luQ29uZiA9IHNlbGYuY29uZmlnLnBsdWdpbnNbaV0oc2VsZikgfHwge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHBsdWdpbkNvbmYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhPT0tTLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gYXJyYXlpZnkocGx1Z2luQ29uZltrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYmluZFRvSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChzZWxmLmNvbmZpZ1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdXNlckNvbmZpZ1trZXldID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdba2V5XSA9IHBsdWdpbkNvbmZba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVzZXJDb25maWcuYWx0SW5wdXRDbGFzcykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3MgPVxuICAgICAgICAgICAgICAgICAgICBnZXRJbnB1dEVsZW0oKS5jbGFzc05hbWUgKyBcIiBcIiArIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblBhcnNlQ29uZmlnXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldElucHV0RWxlbSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy53cmFwXG4gICAgICAgICAgICAgICAgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1pbnB1dF1cIilcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBMb2NhbGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSAhPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBmbGF0cGlja3IubDEwbnNbc2VsZi5jb25maWcubG9jYWxlXSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiZmxhdHBpY2tyOiBpbnZhbGlkIGxvY2FsZSBcIiArIHNlbGYuY29uZmlnLmxvY2FsZSkpO1xuICAgICAgICAgICAgc2VsZi5sMTBuID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGZsYXRwaWNrci5sMTBucy5kZWZhdWx0KSwgKHR5cGVvZiBzZWxmLmNvbmZpZy5sb2NhbGUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmxvY2FsZVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubG9jYWxlICE9PSBcImRlZmF1bHRcIlxuICAgICAgICAgICAgICAgICAgICA/IGZsYXRwaWNrci5sMTBuc1tzZWxmLmNvbmZpZy5sb2NhbGVdXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB0b2tlblJlZ2V4LksgPSBcIihcIiArIHNlbGYubDEwbi5hbVBNWzBdICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVsxXSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMF0udG9Mb3dlckNhc2UoKSArIFwifFwiICsgc2VsZi5sMTBuLmFtUE1bMV0udG9Mb3dlckNhc2UoKSArIFwiKVwiO1xuICAgICAgICAgICAgdmFyIHVzZXJDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5zdGFuY2VDb25maWcpLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKTtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLnRpbWVfMjRociA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcudGltZV8yNGhyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy50aW1lXzI0aHIgPSBzZWxmLmwxMG4udGltZV8yNGhyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcihzZWxmKTtcbiAgICAgICAgICAgIHNlbGYucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7IGNvbmZpZzogc2VsZi5jb25maWcsIGwxMG46IHNlbGYubDEwbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbkNhbGVuZGFyKGN1c3RvbVBvc2l0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblByZUNhbGVuZGFyUG9zaXRpb25cIik7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25FbGVtZW50ID0gY3VzdG9tUG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX3Bvc2l0aW9uRWxlbWVudDtcbiAgICAgICAgICAgIHZhciBjYWxlbmRhckhlaWdodCA9IEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbChzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNoaWxkcmVuLCAoZnVuY3Rpb24gKGFjYywgY2hpbGQpIHsgcmV0dXJuIGFjYyArIGNoaWxkLm9mZnNldEhlaWdodDsgfSksIDApLCBjYWxlbmRhcldpZHRoID0gc2VsZi5jYWxlbmRhckNvbnRhaW5lci5vZmZzZXRXaWR0aCwgY29uZmlnUG9zID0gc2VsZi5jb25maWcucG9zaXRpb24uc3BsaXQoXCIgXCIpLCBjb25maWdQb3NWZXJ0aWNhbCA9IGNvbmZpZ1Bvc1swXSwgY29uZmlnUG9zSG9yaXpvbnRhbCA9IGNvbmZpZ1Bvcy5sZW5ndGggPiAxID8gY29uZmlnUG9zWzFdIDogbnVsbCwgaW5wdXRCb3VuZHMgPSBwb3NpdGlvbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRpc3RhbmNlRnJvbUJvdHRvbSA9IHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0Qm91bmRzLmJvdHRvbSwgc2hvd09uVG9wID0gY29uZmlnUG9zVmVydGljYWwgPT09IFwiYWJvdmVcIiB8fFxuICAgICAgICAgICAgICAgIChjb25maWdQb3NWZXJ0aWNhbCAhPT0gXCJiZWxvd1wiICYmXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlRnJvbUJvdHRvbSA8IGNhbGVuZGFySGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCA+IGNhbGVuZGFySGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgK1xuICAgICAgICAgICAgICAgIGlucHV0Qm91bmRzLnRvcCArXG4gICAgICAgICAgICAgICAgKCFzaG93T25Ub3AgPyBwb3NpdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgMiA6IC1jYWxlbmRhckhlaWdodCAtIDIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1RvcFwiLCAhc2hvd09uVG9wKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dCb3R0b21cIiwgc2hvd09uVG9wKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBpbnB1dEJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgdmFyIGlzQ2VudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1Bvc0hvcml6b250YWwgPT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICAgICAgICBsZWZ0IC09IChjYWxlbmRhcldpZHRoIC0gaW5wdXRCb3VuZHMud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBpc0NlbnRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWdQb3NIb3Jpem9udGFsID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBsZWZ0IC09IGNhbGVuZGFyV2lkdGggLSBpbnB1dEJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICBpc1JpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dMZWZ0XCIsICFpc0NlbnRlciAmJiAhaXNSaWdodCk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93Q2VudGVyXCIsIGlzQ2VudGVyKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dSaWdodFwiLCBpc1JpZ2h0KTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgICAgICAod2luZG93LnBhZ2VYT2Zmc2V0ICsgaW5wdXRCb3VuZHMucmlnaHQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TW9zdCA9IGxlZnQgKyBjYWxlbmRhcldpZHRoID4gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgY2VudGVyTW9zdCA9IHJpZ2h0ICsgY2FsZW5kYXJXaWR0aCA+IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyaWdodE1vc3RcIiwgcmlnaHRNb3N0KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zdGF0aWMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICBpZiAoIXJpZ2h0TW9zdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNlbnRlck1vc3QpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gcmlnaHQgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gZ2V0RG9jdW1lbnRTdHlsZVNoZWV0KCk7XG4gICAgICAgICAgICAgICAgLy8gc29tZSB0ZXN0aW5nIGVudmlyb25tZW50cyBkb24ndCBoYXZlIGNzcyBzdXBwb3J0XG4gICAgICAgICAgICAgICAgaWYgKGRvYyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlXaWR0aCA9IHdpbmRvdy5kb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJMZWZ0ID0gTWF0aC5tYXgoMCwgYm9keVdpZHRoIC8gMiAtIGNhbGVuZGFyV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyQmVmb3JlID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YmVmb3JlXCI7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckFmdGVyID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyLmNlbnRlck1vc3Q6YWZ0ZXJcIjtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVySW5kZXggPSBkb2MuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJTdHlsZSA9IFwie2xlZnQ6XCIgKyBpbnB1dEJvdW5kcy5sZWZ0ICsgXCJweDtyaWdodDphdXRvO31cIjtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJpZ2h0TW9zdFwiLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJjZW50ZXJNb3N0XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRvYy5pbnNlcnRSdWxlKGNlbnRlckJlZm9yZSArIFwiLFwiICsgY2VudGVyQWZ0ZXIgKyBjZW50ZXJTdHlsZSwgY2VudGVySW5kZXgpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IGNlbnRlckxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERvY3VtZW50U3R5bGVTaGVldCgpIHtcbiAgICAgICAgICAgIHZhciBlZGl0YWJsZVNoZWV0ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzaGVldC5jc3NSdWxlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWRpdGFibGVTaGVldCA9IHNoZWV0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVkaXRhYmxlU2hlZXQgIT0gbnVsbCA/IGVkaXRhYmxlU2hlZXQgOiBjcmVhdGVTdHlsZVNoZWV0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3R5bGVTaGVldCgpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLnNoZWV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyIHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNBbmRDbG9zZSgpIHtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2sgLSBidWdzIGluIHRoZSB3YXkgSUUgaGFuZGxlcyBmb2N1cyBrZWVwcyB0aGUgY2FsZW5kYXIgb3BlblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc2VsZi5jbG9zZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2VsZWN0RGF0ZShlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0YWJsZSA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF5LmNsYXNzTGlzdCAmJlxuICAgICAgICAgICAgICAgICAgICBkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRheVwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcImZsYXRwaWNrci1kaXNhYmxlZFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZGF5LmNsYXNzTGlzdC5jb250YWlucyhcIm5vdEFsbG93ZWRcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHQgPSBmaW5kUGFyZW50KGdldEV2ZW50VGFyZ2V0KGUpLCBpc1NlbGVjdGFibGUpO1xuICAgICAgICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdDtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGUgPSAoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBuZXcgRGF0ZSh0YXJnZXQuZGF0ZU9iai5nZXRUaW1lKCkpKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRDaGFuZ2VNb250aCA9IChzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA8IHNlbGYuY3VycmVudE1vbnRoIHx8XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWREYXRlLmdldE1vbnRoKCkgPlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCArIHNlbGYuY29uZmlnLnNob3dNb250aHMgLSAxKSAmJlxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIjtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiKVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtzZWxlY3RlZERhdGVdO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcubW9kZSA9PT0gXCJtdWx0aXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSBpc0RhdGVTZWxlY3RlZChzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4KVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc3BsaWNlKHBhcnNlSW50KHNlbGVjdGVkSW5kZXgpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZWN0ZWREYXRlO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5wdXNoKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIHNlbGVjdGluZyBzYW1lIGRhdGUgdHdpY2UsIHNvcnQgYXNjZW5kaW5nbHlcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZURhdGVzKHNlbGVjdGVkRGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzBdLCB0cnVlKSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2hhbmdlTW9udGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNOZXdZZWFyID0gc2VsZi5jdXJyZW50WWVhciAhPT0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGVjdGVkRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gc2VsZWN0ZWREYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmV3WWVhcikge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblllYXJDaGFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIC8vIG1haW50YWluIGZvY3VzXG4gICAgICAgICAgICBpZiAoIXNob3VsZENoYW5nZU1vbnRoICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSlcbiAgICAgICAgICAgICAgICBmb2N1c09uRGF5RWxlbSh0YXJnZXQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5zZWxlY3RlZERhdGVFbGVtICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gJiYgc2VsZi5zZWxlY3RlZERhdGVFbGVtLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBzZWxmLmhvdXJFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuY2xvc2VPblNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGUgPSBzZWxmLmNvbmZpZy5tb2RlID09PSBcInNpbmdsZVwiICYmICFzZWxmLmNvbmZpZy5lbmFibGVUaW1lO1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5lbmFibGVUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGUgfHwgcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNBbmRDbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgQ0FMTEJBQ0tTID0ge1xuICAgICAgICAgICAgbG9jYWxlOiBbc2V0dXBMb2NhbGUsIHVwZGF0ZVdlZWtkYXlzXSxcbiAgICAgICAgICAgIHNob3dNb250aHM6IFtidWlsZE1vbnRocywgc2V0Q2FsZW5kYXJXaWR0aCwgYnVpbGRXZWVrZGF5c10sXG4gICAgICAgICAgICBtaW5EYXRlOiBbanVtcFRvRGF0ZV0sXG4gICAgICAgICAgICBtYXhEYXRlOiBbanVtcFRvRGF0ZV0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHNldChvcHRpb24sIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENBTExCQUNLU1trZXldICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBDQUxMQkFDS1Nba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4KCk7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoQ0FMTEJBQ0tTW29wdGlvbl0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgQ0FMTEJBQ0tTW29wdGlvbl0uZm9yRWFjaChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCgpOyB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChIT09LUy5pbmRleE9mKG9wdGlvbikgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbb3B0aW9uXSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRTZWxlY3RlZERhdGUoaW5wdXREYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBkYXRlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZCwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbnB1dERhdGUgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBpbnB1dERhdGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBbc2VsZi5wYXJzZURhdGUoaW5wdXREYXRlLCBmb3JtYXQpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dERhdGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNlbGYuY29uZmlnLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBbc2VsZi5wYXJzZURhdGUoaW5wdXREYXRlLCBmb3JtYXQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibXVsdGlwbGVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVzID0gaW5wdXREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KHNlbGYuY29uZmlnLmNvbmp1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYW5nZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHNlbGYucGFyc2VEYXRlKGRhdGUsIGZvcm1hdCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgc3VwcGxpZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoaW5wdXREYXRlKSkpO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gKHNlbGYuY29uZmlnLmFsbG93SW52YWxpZFByZWxvYWRcbiAgICAgICAgICAgICAgICA/IGRhdGVzXG4gICAgICAgICAgICAgICAgOiBkYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQgaW5zdGFuY2VvZiBEYXRlICYmIGlzRW5hYmxlZChkLCBmYWxzZSk7IH0pKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldERhdGUoZGF0ZSwgdHJpZ2dlckNoYW5nZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gdm9pZCAwKSB7IGZvcm1hdCA9IHNlbGYuY29uZmlnLmRhdGVGb3JtYXQ7IH1cbiAgICAgICAgICAgIGlmICgoZGF0ZSAhPT0gMCAmJiAhZGF0ZSkgfHwgKGRhdGUgaW5zdGFuY2VvZiBBcnJheSAmJiBkYXRlLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2xlYXIodHJpZ2dlckNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXNbc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIGp1bXBUb0RhdGUodW5kZWZpbmVkLCB0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jbGVhcihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRGF0ZVJ1bGVzKGFycikge1xuICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgICAgICBydWxlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wYXJzZURhdGUocnVsZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocnVsZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmZyb20gJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS50bylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNlbGYucGFyc2VEYXRlKHJ1bGUuZnJvbSwgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiBzZWxmLnBhcnNlRGF0ZShydWxlLnRvLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4OyB9KTsgLy8gcmVtb3ZlIGZhbHN5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwRGF0ZXMoKSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYubm93ID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubm93KSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBJRTExIHNldHRpbmcgcGxhY2Vob2xkZXIgYXMgdGhlIGlucHV0J3MgdmFsdWVcbiAgICAgICAgICAgIHZhciBwcmVsb2FkZWREYXRlID0gc2VsZi5jb25maWcuZGVmYXVsdERhdGUgfHxcbiAgICAgICAgICAgICAgICAoKHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiSU5QVVRcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGxhY2Vob2xkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9PT0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmlucHV0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVsb2FkZWREYXRlKVxuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShwcmVsb2FkZWREYXRlLCBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgIHNlbGYuX2luaXRpYWxEYXRlID1cbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuc2VsZWN0ZWREYXRlc1swXVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0VGltZSgpID4gc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0VGltZSgpIDwgc2VsZi5ub3cuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLm5vdztcbiAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxmLl9pbml0aWFsRGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqID0gc2VsZi5zZWxlY3RlZERhdGVzWzBdO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5UaW1lID0gc2VsZi5wYXJzZURhdGUoc2VsZi5jb25maWcubWluVGltZSwgXCJIOmlcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4VGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heFRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5tYXhUaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIHNlbGYubWluRGF0ZUhhc1RpbWUgPVxuICAgICAgICAgICAgICAgICEhc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKSA+IDApO1xuICAgICAgICAgICAgc2VsZi5tYXhEYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBJbnB1dHMoKSB7XG4gICAgICAgICAgICBzZWxmLmlucHV0ID0gZ2V0SW5wdXRFbGVtKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgZWxlbWVudCBzcGVjaWZpZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhY2s6IHN0b3JlIHByZXZpb3VzIHR5cGUgdG8gcmVzdG9yZSBpdCBhZnRlciBkZXN0cm95KClcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuX3R5cGUgPSBzZWxmLmlucHV0LnR5cGU7XG4gICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQuY2xhc3NMaXN0LmFkZChcImZsYXRwaWNrci1pbnB1dFwiKTtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5pbnB1dDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbHRJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIHJlcGxpY2F0ZSBzZWxmLmVsZW1lbnRcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0ID0gY3JlYXRlRWxlbWVudChzZWxmLmlucHV0Lm5vZGVOYW1lLCBzZWxmLmNvbmZpZy5hbHRJbnB1dENsYXNzKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dCA9IHNlbGYuYWx0SW5wdXQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC5yZXF1aXJlZCA9IHNlbGYuaW5wdXQucmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50YWJJbmRleCA9IHNlbGYuaW5wdXQudGFiSW5kZXg7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmFsdElucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5jb25maWcuYWxsb3dJbnB1dClcbiAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgc2VsZi5fcG9zaXRpb25FbGVtZW50ID0gc2VsZi5jb25maWcucG9zaXRpb25FbGVtZW50IHx8IHNlbGYuX2lucHV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldHVwTW9iaWxlKCkge1xuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IHNlbGYuY29uZmlnLmVuYWJsZVRpbWVcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm5vQ2FsZW5kYXJcbiAgICAgICAgICAgICAgICAgICAgPyBcInRpbWVcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiZGF0ZXRpbWUtbG9jYWxcIlxuICAgICAgICAgICAgICAgIDogXCJkYXRlXCI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gY3JlYXRlRWxlbWVudChcImlucHV0XCIsIHNlbGYuaW5wdXQuY2xhc3NOYW1lICsgXCIgZmxhdHBpY2tyLW1vYmlsZVwiKTtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudGFiSW5kZXggPSAxO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50eXBlID0gaW5wdXRUeXBlO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kaXNhYmxlZCA9IHNlbGYuaW5wdXQuZGlzYWJsZWQ7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucGxhY2Vob2xkZXIgPSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVGb3JtYXRTdHIgPVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9PT0gXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFxcXFxUSDppOlNcIlxuICAgICAgICAgICAgICAgICAgICA6IGlucHV0VHlwZSA9PT0gXCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJZLW0tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiSDppOlNcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuZGVmYXVsdFZhbHVlID0gc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWluID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1pbkRhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0Lm1heCA9IHNlbGYuZm9ybWF0RGF0ZShzZWxmLmNvbmZpZy5tYXhEYXRlLCBcIlktbS1kXCIpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSlcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnN0ZXAgPSBTdHJpbmcoc2VsZi5pbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2VsZi5tb2JpbGVJbnB1dCwgc2VsZi5pbnB1dC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgYmluZChzZWxmLm1vYmlsZUlucHV0LCBcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShnZXRFdmVudFRhcmdldChlKS52YWx1ZSwgZmFsc2UsIHNlbGYubW9iaWxlRm9ybWF0U3RyKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNsb3NlXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9nZ2xlKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbG9zZSgpO1xuICAgICAgICAgICAgc2VsZi5vcGVuKGUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJFdmVudChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbHJlYWR5LCBhbGwgaG9va3MgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob29rcyA9IHNlbGYuY29uZmlnW2V2ZW50XTtcbiAgICAgICAgICAgIGlmIChob29rcyAhPT0gdW5kZWZpbmVkICYmIGhvb2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaG9va3NbaV0gJiYgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBob29rc1tpXShzZWxmLnNlbGVjdGVkRGF0ZXMsIHNlbGYuaW5wdXQudmFsdWUsIHNlbGYsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBcIm9uQ2hhbmdlXCIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJjaGFuZ2VcIikpO1xuICAgICAgICAgICAgICAgIC8vIG1hbnkgZnJvbnQtZW5kIGZyYW1ld29ya3MgYmluZCB0byB0aGUgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoXCJpbnB1dFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQobmFtZSkge1xuICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgICAgICAgICAgZS5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0RhdGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZi5zZWxlY3RlZERhdGVzW2ldLCBkYXRlKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZUluUmFuZ2UoZGF0ZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fCBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gKGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0pID49IDAgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZSwgc2VsZi5zZWxlY3RlZERhdGVzWzFdKSA8PSAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSB8fCAhc2VsZi5tb250aE5hdilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLnllYXJFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh5ZWFyRWxlbWVudCwgaSkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoc2VsZi5jdXJyZW50WWVhciwgc2VsZi5jdXJyZW50TW9udGgsIDEpO1xuICAgICAgICAgICAgICAgIGQuc2V0TW9udGgoc2VsZi5jdXJyZW50TW9udGggKyBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9udGhTZWxlY3RvclR5cGUgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb250aEVsZW1lbnRzW2ldLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoVG9TdHIoZC5nZXRNb250aCgpLCBzZWxmLmNvbmZpZy5zaG9ydGhhbmRDdXJyZW50TW9udGgsIHNlbGYubDEwbikgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIudmFsdWUgPSBkLmdldE1vbnRoKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQudmFsdWUgPSBkLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5faGlkZVByZXZNb250aEFycm93ID1cbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmN1cnJlbnRNb250aCA8PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jdXJyZW50WWVhciA8IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoICsgMSA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREYXRlU3RyKGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuc2VsZWN0ZWREYXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRPYmopIHsgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShkT2JqLCBmb3JtYXQpOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQsIGksIGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSB8fFxuICAgICAgICAgICAgICAgICAgICBhcnIuaW5kZXhPZihkKSA9PT0gaTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgPyBzZWxmLmNvbmZpZy5jb25qdW5jdGlvblxuICAgICAgICAgICAgICAgIDogc2VsZi5sMTBuLnJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIGlucHV0cyBhc3NvY2lhdGVkIHdpdGggdGhlIGNhbGVuZGFyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZSh0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2UgPSB0cnVlOyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkICYmIHNlbGYubW9iaWxlRm9ybWF0U3RyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5mb3JtYXREYXRlKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLm1vYmlsZUZvcm1hdFN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQudmFsdWUgPSBnZXREYXRlU3RyKHNlbGYuY29uZmlnLmFsdEZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25WYWx1ZVVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbk1vbnRoTmF2Q2xpY2soZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICB2YXIgaXNQcmV2TW9udGggPSBzZWxmLnByZXZNb250aE5hdi5jb250YWlucyhldmVudFRhcmdldCk7XG4gICAgICAgICAgICB2YXIgaXNOZXh0TW9udGggPSBzZWxmLm5leHRNb250aE5hdi5jb250YWlucyhldmVudFRhcmdldCk7XG4gICAgICAgICAgICBpZiAoaXNQcmV2TW9udGggfHwgaXNOZXh0TW9udGgpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VNb250aChpc1ByZXZNb250aCA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnllYXJFbGVtZW50cy5pbmRleE9mKGV2ZW50VGFyZ2V0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudFRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoXCJhcnJvd1VwXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93RG93blwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGltZVdyYXBwZXIoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIGlzS2V5RG93biA9IGUudHlwZSA9PT0gXCJrZXlkb3duXCIsIGV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSksIGlucHV0ID0gZXZlbnRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbVBNICE9PSB1bmRlZmluZWQgJiYgZXZlbnRUYXJnZXQgPT09IHNlbGYuYW1QTSkge1xuICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubDEwbi5hbVBNW2ludChzZWxmLmFtUE0udGV4dENvbnRlbnQgPT09IHNlbGYubDEwbi5hbVBNWzBdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluID0gcGFyc2VGbG9hdChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJtaW5cIikpLCBtYXggPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1heFwiKSksIHN0ZXAgPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpLCBjdXJWYWx1ZSA9IHBhcnNlSW50KGlucHV0LnZhbHVlLCAxMCksIGRlbHRhID0gZS5kZWx0YSB8fFxuICAgICAgICAgICAgICAgIChpc0tleURvd24gPyAoZS53aGljaCA9PT0gMzggPyAxIDogLTEpIDogMCk7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXJWYWx1ZSArIHN0ZXAgKiBkZWx0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSG91ckVsZW0gPSBpbnB1dCA9PT0gc2VsZi5ob3VyRWxlbWVudCwgaXNNaW51dGVFbGVtID0gaW5wdXQgPT09IHNlbGYubWludXRlRWxlbWVudDtcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50KCFpc0hvdXJFbGVtKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGludChpc0hvdXJFbGVtKSAmJiBpbnQoIXNlbGYuYW1QTSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNaW51dGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQodW5kZWZpbmVkLCAtMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50ID8gbmV3VmFsdWUgLSBtYXggLSBpbnQoIXNlbGYuYW1QTSkgOiBtaW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIDEsIHNlbGYuaG91ckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbVBNICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSG91ckVsZW0gJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0ZXAgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUgKyBjdXJWYWx1ZSA9PT0gMjNcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMobmV3VmFsdWUgLSBjdXJWYWx1ZSkgPiBzdGVwKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBwYWQobmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gX2ZsYXRwaWNrcihub2RlTGlzdCwgY29uZmlnKSB7XG4gICAgICAgIC8vIHN0YXRpYyBsaXN0XG4gICAgICAgIHZhciBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgLmNhbGwobm9kZUxpc3QpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7IH0pO1xuICAgICAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImRhdGEtZnAtb21pdFwiKSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX2ZsYXRwaWNrciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX2ZsYXRwaWNrciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gRmxhdHBpY2tySW5zdGFuY2Uobm9kZSwgY29uZmlnIHx8IHt9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChub2RlLl9mbGF0cGlja3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0YW5jZXMubGVuZ3RoID09PSAxID8gaW5zdGFuY2VzWzBdIDogaW5zdGFuY2VzO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIEhUTUxDb2xsZWN0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBOb2RlTGlzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBicm93c2VyIGVudlxuICAgICAgICBIVE1MQ29sbGVjdGlvbi5wcm90b3R5cGUuZmxhdHBpY2tyID0gTm9kZUxpc3QucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5mbGF0cGlja3IgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihbdGhpc10sIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdmFyIGZsYXRwaWNrciA9IGZ1bmN0aW9uIChzZWxlY3RvciwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKFtzZWxlY3Rvcl0sIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX2ZsYXRwaWNrcihzZWxlY3RvciwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyA9IHt9O1xuICAgIGZsYXRwaWNrci5sMTBucyA9IHtcbiAgICAgICAgZW46IF9fYXNzaWduKHt9LCBlbmdsaXNoKSxcbiAgICAgICAgZGVmYXVsdDogX19hc3NpZ24oe30sIGVuZ2xpc2gpLFxuICAgIH07XG4gICAgZmxhdHBpY2tyLmxvY2FsaXplID0gZnVuY3Rpb24gKGwxMG4pIHtcbiAgICAgICAgZmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQpLCBsMTBuKTtcbiAgICB9O1xuICAgIGZsYXRwaWNrci5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmRlZmF1bHRDb25maWcpLCBjb25maWcpO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoe30pO1xuICAgIGZsYXRwaWNrci5mb3JtYXREYXRlID0gY3JlYXRlRGF0ZUZvcm1hdHRlcih7fSk7XG4gICAgZmxhdHBpY2tyLmNvbXBhcmVEYXRlcyA9IGNvbXBhcmVEYXRlcztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBqUXVlcnkuZm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgalF1ZXJ5LmZuLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvY2FtZWxjYXNlXG4gICAgRGF0ZS5wcm90b3R5cGUuZnBfaW5jciA9IGZ1bmN0aW9uIChkYXlzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLmdldEZ1bGxZZWFyKCksIHRoaXMuZ2V0TW9udGgoKSwgdGhpcy5nZXREYXRlKCkgKyAodHlwZW9mIGRheXMgPT09IFwic3RyaW5nXCIgPyBwYXJzZUludChkYXlzLCAxMCkgOiBkYXlzKSk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB3aW5kb3cuZmxhdHBpY2tyID0gZmxhdHBpY2tyO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0cGlja3I7XG5cbn0pKSk7XG4iLCJpZighZ2xvYmFsW1wiQmFzaXNcIl0pIGdsb2JhbFtcIkJhc2lzXCJdID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcIkJhc2lzXCJdW1wiQWdHcmlkQ29tcG9uZW50c1wiXSA9IHJlcXVpcmUoXCItIUQ6XFxcXEdpdGh1YlxcXFxCQmpHcmlkRXhXaWRnZXRcXFxcY2xpZW50XFxcXG5vZGVfbW9kdWxlc1xcXFxiYWJlbC1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz9yZWYtLTQhLlxcXFxiYXNpcy1hZ2dyaWQtY29tcG9uZW50cy5qc1wiKTsiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0Mik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMGJhZTA1OWUyYjVmZTI2YzViMTAiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4vQ29tcG9uZW50J1xuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21wb25lbnQvaW5kZXguanMiLCJpbXBvcnQgeyBkZWNvcmF0ZSwgY3JlYXRlRGVmYXVsdFNldHRlcixcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycywgZ2V0T3duS2V5cywgYmluZCB9IGZyb20gJy4vcHJpdmF0ZS91dGlscyc7XG5jb25zdCB7IGRlZmluZVByb3BlcnR5LCBnZXRQcm90b3R5cGVPZiB9ID0gT2JqZWN0O1xuXG5sZXQgbWFwU3RvcmU7XG5cbmZ1bmN0aW9uIGdldEJvdW5kU3VwZXIob2JqLCBmbikge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFVzaW5nIEBhdXRvYmluZCBvbiAke2ZuLm5hbWV9KCkgcmVxdWlyZXMgV2Vha01hcCBzdXBwb3J0IGR1ZSB0byBpdHMgdXNlIG9mIHN1cGVyLiR7Zm4ubmFtZX0oKVxuICAgICAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXlwaGVscHMvY29yZS1kZWNvcmF0b3JzLmpzL2lzc3Vlcy8yMGBcbiAgICApO1xuICB9XG5cbiAgaWYgKCFtYXBTdG9yZSkge1xuICAgICBtYXBTdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG4gIH1cblxuICBpZiAobWFwU3RvcmUuaGFzKG9iaikgPT09IGZhbHNlKSB7XG4gICAgbWFwU3RvcmUuc2V0KG9iaiwgbmV3IFdlYWtNYXAoKSk7XG4gIH1cblxuICBjb25zdCBzdXBlclN0b3JlID0gbWFwU3RvcmUuZ2V0KG9iaik7XG5cbiAgaWYgKHN1cGVyU3RvcmUuaGFzKGZuKSA9PT0gZmFsc2UpIHtcbiAgICBzdXBlclN0b3JlLnNldChmbiwgYmluZChmbiwgb2JqKSk7XG4gIH1cblxuICByZXR1cm4gc3VwZXJTdG9yZS5nZXQoZm4pO1xufVxuXG5mdW5jdGlvbiBhdXRvYmluZENsYXNzKGtsYXNzKSB7XG4gIGNvbnN0IGRlc2NzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhrbGFzcy5wcm90b3R5cGUpO1xuICBjb25zdCBrZXlzID0gZ2V0T3duS2V5cyhkZXNjcyk7XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgZGVzYyA9IGRlc2NzW2tleV07XG5cbiAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgIT09ICdmdW5jdGlvbicgfHwga2V5ID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkZWZpbmVQcm9wZXJ0eShrbGFzcy5wcm90b3R5cGUsIGtleSwgYXV0b2JpbmRNZXRob2Qoa2xhc3MucHJvdG90eXBlLCBrZXksIGRlc2MpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdXRvYmluZE1ldGhvZCh0YXJnZXQsIGtleSwgeyB2YWx1ZTogZm4sIGNvbmZpZ3VyYWJsZSwgZW51bWVyYWJsZSB9KSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEBhdXRvYmluZCBjYW4gb25seSBiZSB1c2VkIG9uIGZ1bmN0aW9ucywgbm90OiAke2ZufWApO1xuICB9XG5cbiAgY29uc3QgeyBjb25zdHJ1Y3RvciB9ID0gdGFyZ2V0O1xuXG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGUsXG5cbiAgICBnZXQoKSB7XG4gICAgICAvLyBDbGFzcy5wcm90b3R5cGUua2V5IGxvb2t1cFxuICAgICAgLy8gU29tZW9uZSBhY2Nlc3NlcyB0aGUgcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZSBvbiB3aGljaCBpdCBpc1xuICAgICAgLy8gYWN0dWFsbHkgZGVmaW5lZCBvbiwgaS5lLiBDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KVxuICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG5cbiAgICAgIC8vIENsYXNzLnByb3RvdHlwZS5rZXkgbG9va3VwXG4gICAgICAvLyBTb21lb25lIGFjY2Vzc2VzIHRoZSBwcm9wZXJ0eSBkaXJlY3RseSBvbiBhIHByb3RvdHlwZSBidXQgaXQgd2FzIGZvdW5kXG4gICAgICAvLyB1cCB0aGUgY2hhaW4sIG5vdCBkZWZpbmVkIGRpcmVjdGx5IG9uIGl0XG4gICAgICAvLyBpLmUuIENsYXNzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShrZXkpID09IGZhbHNlICYmIGtleSBpbiBDbGFzcy5wcm90b3R5cGVcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBjb25zdHJ1Y3RvciAmJiBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvciA9PT0gY29uc3RydWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdXRvYm91bmQgbWV0aG9kIGNhbGxpbmcgc3VwZXIuc2FtZU1ldGhvZCgpIHdoaWNoIGlzIGFsc28gYXV0b2JvdW5kIGFuZCBzbyBvbi5cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBjb25zdHJ1Y3RvciAmJiBrZXkgaW4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kU3VwZXIodGhpcywgZm4pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBib3VuZEZuID0gYmluZChmbiwgdGhpcyk7XG5cbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAvLyBOT1QgZW51bWVyYWJsZSB3aGVuIGl0J3MgYSBib3VuZCBtZXRob2RcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBib3VuZEZuXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJvdW5kRm47XG4gICAgfSxcbiAgICBzZXQ6IGNyZWF0ZURlZmF1bHRTZXR0ZXIoa2V5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGUoYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYXV0b2JpbmRDbGFzcyguLi5hcmdzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXV0b2JpbmRNZXRob2QoLi4uYXJncyk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2JpbmQoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGhhbmRsZShhcmd1bWVudHMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhbmRsZShhcmdzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvYXV0b2JpbmQuanMiLCJpbXBvcnQgeyBkZWNvcmF0ZSB9IGZyb20gJy4vcHJpdmF0ZS91dGlscyc7XG5cbmNvbnN0IEdFTkVSSUNfRlVOQ1RJT05fRVJST1IgPSAne2NoaWxkfSBkb2VzIG5vdCBwcm9wZXJseSBvdmVycmlkZSB7cGFyZW50fSc7XG5jb25zdCBGVU5DVElPTl9SRUdFWFAgPSAvXmZ1bmN0aW9uIChbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKik/KFxcKFteXFwpXSpcXCkpW1xcc1xcU10rJC87XG5cbmNsYXNzIFN5bnRheEVycm9yUmVwb3J0ZXIge1xuICBwYXJlbnRLbGFzcztcbiAgY2hpbGRLbGFzcztcbiAgcGFyZW50RGVzY3JpcHRvcjtcbiAgY2hpbGREZXNjcmlwdG9yO1xuICBcbiAgZ2V0IGtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZERlc2NyaXB0b3Iua2V5OyAgXG4gIH1cbiAgXG4gIGdldCBwYXJlbnROb3RhdGlvbigpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5wYXJlbnRLbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke3RoaXMucGFyZW50UHJvcGVydHlTaWduYXR1cmV9YDtcbiAgfVxuXG4gIGdldCBjaGlsZE5vdGF0aW9uKCkge1xuICAgIHJldHVybiBgJHt0aGlzLmNoaWxkS2xhc3MuY29uc3RydWN0b3IubmFtZX0jJHt0aGlzLmNoaWxkUHJvcGVydHlTaWduYXR1cmV9YDtcbiAgfVxuICBcbiAgZ2V0IHBhcmVudFRvcGljKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRUb3BpYyh0aGlzLnBhcmVudERlc2NyaXB0b3IpO1xuICB9XG4gIFxuICBnZXQgY2hpbGRUb3BpYygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VG9waWModGhpcy5jaGlsZERlc2NyaXB0b3IpO1xuICB9XG4gIFxuICBfZ2V0VG9waWMoZGVzY3JpcHRvcikge1xuICAgIGlmIChkZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsOyAgXG4gICAgfVxuICAgIFxuICAgIGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoJ2dldCcgaW4gZGVzY3JpcHRvcikge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0O1xuICAgIH1cbiAgICBcbiAgICBpZiAoJ3NldCcgaW4gZGVzY3JpcHRvcikge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3Iuc2V0O1xuICAgIH1cbiAgfVxuICBcbiAgZ2V0IHBhcmVudFByb3BlcnR5U2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLl9leHRyYWN0VG9waWNTaWduYXR1cmUodGhpcy5wYXJlbnRUb3BpYyk7IFxuICB9XG4gIFxuICBnZXQgY2hpbGRQcm9wZXJ0eVNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdFRvcGljU2lnbmF0dXJlKHRoaXMuY2hpbGRUb3BpYyk7IFxuICB9XG4gIFxuICBfZXh0cmFjdFRvcGljU2lnbmF0dXJlKHRvcGljKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdG9waWMpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4dHJhY3RGdW5jdGlvblNpZ25hdHVyZSh0b3BpYyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICB9XG4gIFxuICBfZXh0cmFjdEZ1bmN0aW9uU2lnbmF0dXJlKGZuKSB7XG4gICAgcmV0dXJuIGZuXG4gICAgICAudG9TdHJpbmcoKVxuICAgICAgLnJlcGxhY2UoXG4gICAgICAgIEZVTkNUSU9OX1JFR0VYUCxcbiAgICAgICAgKG1hdGNoLCBuYW1lID0gdGhpcy5rZXksIHBhcmFtcykgPT4gbmFtZSArIHBhcmFtc1xuICAgICAgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBhcmVudEtsYXNzLCBjaGlsZEtsYXNzLCBwYXJlbnREZXNjcmlwdG9yLCBjaGlsZERlc2NyaXB0b3IpIHtcbiAgICB0aGlzLnBhcmVudEtsYXNzID0gcGFyZW50S2xhc3M7XG4gICAgdGhpcy5jaGlsZEtsYXNzID0gY2hpbGRLbGFzcztcbiAgICB0aGlzLnBhcmVudERlc2NyaXB0b3IgPSBwYXJlbnREZXNjcmlwdG9yO1xuICAgIHRoaXMuY2hpbGREZXNjcmlwdG9yID0gY2hpbGREZXNjcmlwdG9yO1xuICB9XG4gIFxuICBhc3NlcnQoY29uZGl0aW9uLCBtc2cgPSAnJykge1xuICAgIGlmIChjb25kaXRpb24gIT09IHRydWUpIHtcbiAgICAgIHRoaXMuZXJyb3IoR0VORVJJQ19GVU5DVElPTl9FUlJPUiArIG1zZyk7XG4gICAgfVxuICB9XG4gIFxuICBlcnJvcihtc2cpIHtcbiAgICBtc2cgPSBtc2dcbiAgICAgIC8vIFJlcGxhY2UgbGF6aWx5LCBiZWNhdXNlIHRoZXkgYWN0dWFsbHkgbWlnaHQgbm90XG4gICAgICAvLyBiZSBhdmFpbGFibGUgaW4gYWxsIGNhc2VzXG4gICAgICAucmVwbGFjZSgne3BhcmVudH0nLCBtID0+IHRoaXMucGFyZW50Tm90YXRpb24pXG4gICAgICAucmVwbGFjZSgne2NoaWxkfScsIG0gPT4gdGhpcy5jaGlsZE5vdGF0aW9uKTtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IobXNnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yKSB7XG4gIGlmIChkZXNjcmlwdG9yLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgcmV0dXJuICdkYXRhJztcbiAgfVxuXG4gIGlmIChkZXNjcmlwdG9yLmhhc093blByb3BlcnR5KCdnZXQnKSB8fCBkZXNjcmlwdG9yLmhhc093blByb3BlcnR5KCdzZXQnKSkge1xuICAgIHJldHVybiAnYWNjZXNzb3InO1xuICB9XG5cbiAgLy8gSWYgbm9uZSBvZiB0aGVtIGV4aXN0LCBicm93c2VycyB0cmVhdCBpdCBhc1xuICAvLyBhIGRhdGEgZGVzY3JpcHRvciB3aXRoIGEgdmFsdWUgb2YgYHVuZGVmaW5lZGBcbiAgcmV0dXJuICdkYXRhJztcbn1cblxuZnVuY3Rpb24gY2hlY2tGdW5jdGlvblNpZ25hdHVyZXMocGFyZW50LCBjaGlsZCwgcmVwb3J0ZXIpIHtcbiAgcmVwb3J0ZXIuYXNzZXJ0KHBhcmVudC5sZW5ndGggPT09IGNoaWxkLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGF0YURlc2NyaXB0b3JzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKSB7XG4gIGNvbnN0IHBhcmVudFZhbHVlVHlwZSA9IHR5cGVvZiBwYXJlbnQudmFsdWU7XG4gIGNvbnN0IGNoaWxkVmFsdWVUeXBlID0gdHlwZW9mIGNoaWxkLnZhbHVlO1xuICBcbiAgaWYgKHBhcmVudFZhbHVlVHlwZSA9PT0gJ3VuZGVmaW5lZCcgJiYgY2hpbGRWYWx1ZVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY2xhc3MgcHJvcGVydGllcyBjYW4gYmUgYW55IGV4cHJlc3Npb24sIHdoaWNoIGlzbid0IHJhbiB1bnRpbCB0aGVcbiAgICAvLyB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCwgc28gd2UgY2FuJ3QgcmVsaWFibHkgZ2V0IHR5cGUgaW5mb3JtYXRpb25cbiAgICAvLyBmb3IgdGhlbSB5ZXQgKHBlciBzcGVjKS4gUGVyaGFwcyB3aGVuIEJhYmVsIGluY2x1ZGVzIGZsb3ctdHlwZSBpbmZvXG4gICAgLy8gaW4gcnVudGltZT8gVHJpZWQgcmVnZXggc29sdXRpb25zLCBidXQgc3VwZXIgaGFja3kgYW5kIG9ubHkgZmVhc2libGVcbiAgICAvLyBvbiBwcmltaXRpdmVzLCB3aGljaCBpcyBjb25mdXNpbmcgZm9yIHVzYWdlLi4uXG4gICAgcmVwb3J0ZXIuZXJyb3IoYGRlc2NyaXB0b3IgdmFsdWVzIGFyZSBib3RoIHVuZGVmaW5lZC4gKGNsYXNzIHByb3BlcnRpZXMgYXJlIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCknYCk7XG4gIH1cbiAgXG4gIGlmIChwYXJlbnRWYWx1ZVR5cGUgIT09IGNoaWxkVmFsdWVUeXBlKSB7XG4gICAgY29uc3QgaXNGdW5jdGlvbk92ZXJVbmRlZmluZWQgPSAoY2hpbGRWYWx1ZVR5cGUgPT09ICdmdW5jdGlvbicgJiYgcGFyZW50VmFsdWVUeXBlID09PSB1bmRlZmluZWQpO1xuICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGRvbid0IHN1cHBvcnQgY2xhc3MgcHJvcGVydGllcywgdGhpc1xuICAgIC8vIHdpbGwgc3RpbGwgaGFuZGxlIG1vcmUgdGhhbiBqdXN0IGZ1bmN0aW9ucywganVzdCBpbiBjYXNlLlxuICAgIC8vIFNoYWRvd2luZyBhbiB1bmRlZmluZWQgdmFsdWUgaXMgYW4gZXJyb3IgaWYgdGhlIGluaGVyaXRlZFxuICAgIC8vIHZhbHVlIHdhcyB1bmRlZmluZWQgKHVzdWFsbHkgYSBjbGFzcyBwcm9wZXJ0eSwgbm90IGEgbWV0aG9kKVxuICAgIGlmIChpc0Z1bmN0aW9uT3ZlclVuZGVmaW5lZCB8fCBwYXJlbnRWYWx1ZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVwb3J0ZXIuZXJyb3IoYHZhbHVlIHR5cGVzIGRvIG5vdCBtYXRjaC4ge3BhcmVudH0gaXMgXCIke3BhcmVudFZhbHVlVHlwZX1cIiwge2NoaWxkfSBpcyBcIiR7Y2hpbGRWYWx1ZVR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFN3aXRjaCwgaW4gcHJlcGFyYXRpb24gZm9yIHN1cHBvcnRpbmcgbW9yZSB0eXBlc1xuICBzd2l0Y2ggKGNoaWxkVmFsdWVUeXBlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2hlY2tGdW5jdGlvblNpZ25hdHVyZXMocGFyZW50LnZhbHVlLCBjaGlsZC52YWx1ZSwgcmVwb3J0ZXIpO1xuICAgICAgYnJlYWs7XG4gICAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgcmVwb3J0ZXIuZXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3IuIFBsZWFzZSBmaWxlIGEgYnVnIHdpdGg6IHtwYXJlbnR9IGlzIFwiJHtwYXJlbnRWYWx1ZVR5cGV9XCIsIHtjaGlsZH0gaXMgXCIke2NoaWxkVmFsdWVUeXBlfVwiYCk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0FjY2Vzc29yRGVzY3JpcHRvcnMocGFyZW50LCBjaGlsZCwgcmVwb3J0ZXIpIHtcbiAgY29uc3QgcGFyZW50SGFzR2V0dGVyID0gdHlwZW9mIHBhcmVudC5nZXQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IGNoaWxkSGFzR2V0dGVyID0gdHlwZW9mIGNoaWxkLmdldCA9PT0gJ2Z1bmN0aW9uJztcbiAgY29uc3QgcGFyZW50SGFzU2V0dGVyID0gdHlwZW9mIHBhcmVudC5zZXQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IGNoaWxkSGFzU2V0dGVyID0gdHlwZW9mIGNoaWxkLnNldCA9PT0gJ2Z1bmN0aW9uJztcbiAgXG4gIGlmIChwYXJlbnRIYXNHZXR0ZXIgfHwgY2hpbGRIYXNHZXR0ZXIpIHtcbiAgICBpZiAoIXBhcmVudEhhc0dldHRlciAmJiBwYXJlbnRIYXNTZXR0ZXIpIHtcbiAgICAgIHJlcG9ydGVyLmVycm9yKGB7cGFyZW50fSBpcyBzZXR0ZXIgYnV0IHtjaGlsZH0gaXMgZ2V0dGVyYCk7XG4gICAgfVxuICAgIFxuICAgIGlmICghY2hpbGRIYXNHZXR0ZXIgJiYgY2hpbGRIYXNTZXR0ZXIpIHtcbiAgICAgIHJlcG9ydGVyLmVycm9yKGB7cGFyZW50fSBpcyBnZXR0ZXIgYnV0IHtjaGlsZH0gaXMgc2V0dGVyYCk7XG4gICAgfVxuICAgIFxuICAgIGNoZWNrRnVuY3Rpb25TaWduYXR1cmVzKHBhcmVudC5nZXQsIGNoaWxkLmdldCwgcmVwb3J0ZXIpO1xuICB9XG4gIFxuICBpZiAocGFyZW50SGFzU2V0dGVyIHx8IGNoaWxkSGFzU2V0dGVyKSB7XG4gICAgaWYgKCFwYXJlbnRIYXNTZXR0ZXIgJiYgcGFyZW50SGFzR2V0dGVyKSB7XG4gICAgICByZXBvcnRlci5lcnJvcihge3BhcmVudH0gaXMgZ2V0dGVyIGJ1dCB7Y2hpbGR9IGlzIHNldHRlcmApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWNoaWxkSGFzU2V0dGVyICYmIGNoaWxkSGFzR2V0dGVyKSB7XG4gICAgICByZXBvcnRlci5lcnJvcihge3BhcmVudH0gaXMgc2V0dGVyIGJ1dCB7Y2hpbGR9IGlzIGdldHRlcmApO1xuICAgIH1cbiAgICBcbiAgICBjaGVja0Z1bmN0aW9uU2lnbmF0dXJlcyhwYXJlbnQuc2V0LCBjaGlsZC5zZXQsIHJlcG9ydGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0Rlc2NyaXB0b3JzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBnZXREZXNjcmlwdG9yVHlwZShwYXJlbnQpO1xuICBjb25zdCBjaGlsZFR5cGUgPSBnZXREZXNjcmlwdG9yVHlwZShjaGlsZCk7XG5cbiAgaWYgKHBhcmVudFR5cGUgIT09IGNoaWxkVHlwZSkge1xuICAgIHJlcG9ydGVyLmVycm9yKGBkZXNjcmlwdG9yIHR5cGVzIGRvIG5vdCBtYXRjaC4ge3BhcmVudH0gaXMgXCIke3BhcmVudFR5cGV9XCIsIHtjaGlsZH0gaXMgXCIke2NoaWxkVHlwZX1cImApO1xuICB9XG5cbiAgc3dpdGNoIChjaGlsZFR5cGUpIHtcbiAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNoZWNrRGF0YURlc2NyaXB0b3JzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYWNjZXNzb3InOlxuICAgICAgY2hlY2tBY2Nlc3NvckRlc2NyaXB0b3JzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmNvbnN0IHN1Z2dlc3Rpb25UcmFuc2Zvcm1zID0gW1xuICBrZXkgPT4ga2V5LnRvTG93ZXJDYXNlKCksXG4gIGtleSA9PiBrZXkudG9VcHBlckNhc2UoKSxcbiAga2V5ID0+IGtleSArICdzJyxcbiAga2V5ID0+IGtleS5zbGljZSgwLCAtMSksXG4gIGtleSA9PiBrZXkuc2xpY2UoMSwga2V5Lmxlbmd0aCksXG5dO1xuXG5mdW5jdGlvbiBmaW5kUG9zc2libGVBbHRlcm5hdGl2ZXMoc3VwZXJLbGFzcywga2V5KSB7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gc3VnZ2VzdGlvblRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgZm4gPSBzdWdnZXN0aW9uVHJhbnNmb3Jtc1tpXTtcbiAgICBjb25zdCBzdWdnZXN0aW9uID0gZm4oa2V5KTtcblxuICAgIGlmIChzdWdnZXN0aW9uIGluIHN1cGVyS2xhc3MpIHtcbiAgICAgIHJldHVybiBzdWdnZXN0aW9uO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURlc2NyaXB0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgZGVzY3JpcHRvci5rZXkgPSBrZXk7XG4gIGNvbnN0IHN1cGVyS2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgY29uc3Qgc3VwZXJEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzdXBlcktsYXNzLCBrZXkpO1xuICBjb25zdCByZXBvcnRlciA9IG5ldyBTeW50YXhFcnJvclJlcG9ydGVyKHN1cGVyS2xhc3MsIHRhcmdldCwgc3VwZXJEZXNjcmlwdG9yLCBkZXNjcmlwdG9yKTtcbiAgXG4gIGlmIChzdXBlckRlc2NyaXB0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHN1Z2dlc3RlZEtleSA9IGZpbmRQb3NzaWJsZUFsdGVybmF0aXZlcyhzdXBlcktsYXNzLCBrZXkpO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb24gPSBzdWdnZXN0ZWRLZXkgPyBgXFxuXFxuICBEaWQgeW91IG1lYW4gXCIke3N1Z2dlc3RlZEtleX1cIj9gIDogJyc7XG4gICAgcmVwb3J0ZXIuZXJyb3IoYE5vIGRlc2NyaXB0b3IgbWF0Y2hpbmcge2NoaWxkfSB3YXMgZm91bmQgb24gdGhlIHByb3RvdHlwZSBjaGFpbi4ke3N1Z2dlc3Rpb259YCk7XG4gIH1cbiAgXG4gIGNoZWNrRGVzY3JpcHRvcnMoc3VwZXJEZXNjcmlwdG9yLCBkZXNjcmlwdG9yLCByZXBvcnRlcik7XG4gIFxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3ZlcnJpZGUoLi4uYXJncykge1xuICByZXR1cm4gZGVjb3JhdGUoaGFuZGxlRGVzY3JpcHRvciwgYXJncyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9vdmVycmlkZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsImltcG9ydCBsYXp5SW5pdGlhbGl6ZSBmcm9tICcuLi9sYXp5LWluaXRpYWxpemUnO1xuXG5jb25zdCB7IGRlZmluZVByb3BlcnR5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gICAgICAgIGdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scyB9ID0gT2JqZWN0O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXNjcmlwdG9yKGRlc2MpIHtcbiAgaWYgKCFkZXNjIHx8ICFkZXNjLmhhc093blByb3BlcnR5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qga2V5cyA9IFsndmFsdWUnLCAnaW5pdGlhbGl6ZXInLCAnZ2V0JywgJ3NldCddO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoZGVzYy5oYXNPd25Qcm9wZXJ0eShrZXlzW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb3JhdGUoaGFuZGxlRGVzY3JpcHRvciwgZW50cnlBcmdzKSB7XG4gIGlmIChpc0Rlc2NyaXB0b3IoZW50cnlBcmdzW2VudHJ5QXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICByZXR1cm4gaGFuZGxlRGVzY3JpcHRvciguLi5lbnRyeUFyZ3MsIFtdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGhhbmRsZURlc2NyaXB0b3IoLi4uQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSwgZW50cnlBcmdzKTtcbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIE1ldGEge1xuICBAbGF6eUluaXRpYWxpemVcbiAgZGVib3VuY2VUaW1lb3V0SWRzID0ge307XG5cbiAgQGxhenlJbml0aWFsaXplXG4gIHRocm90dGxlVGltZW91dElkcyA9IHt9O1xuXG4gIEBsYXp5SW5pdGlhbGl6ZVxuICB0aHJvdHRsZVByZXZpb3VzVGltZXN0YW1wcyA9IHt9O1xuXG4gIEBsYXp5SW5pdGlhbGl6ZVxuICB0aHJvdHRsZVRyYWlsaW5nQXJncyA9IG51bGw7XG5cbiAgQGxhenlJbml0aWFsaXplXG4gIHByb2ZpbGVMYXN0UmFuID0gbnVsbDtcbn1cblxuY29uc3QgTUVUQV9LRVkgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJylcbiAgPyBTeW1ib2woJ19fY29yZV9kZWNvcmF0b3JzX18nKVxuICA6ICdfX2NvcmVfZGVjb3JhdG9yc19fJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFGb3Iob2JqKSB7XG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpID09PSBmYWxzZSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgTUVUQV9LRVksIHtcbiAgICAgIC8vIERlZmF1bHRzOiBOT1QgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlLCBvciB3cml0YWJsZVxuICAgICAgdmFsdWU6IG5ldyBNZXRhKClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvYmpbTUVUQV9LRVldO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0T3duS2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9sc1xuICAgID8gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpXG4gICAgICAgICAgLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KSk7XG4gICAgICB9XG4gICAgOiBnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICBjb25zdCBkZXNjcyA9IHt9O1xuXG4gIGdldE93bktleXMob2JqKS5mb3JFYWNoKFxuICAgIGtleSA9PiAoZGVzY3Nba2V5XSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkpXG4gICk7XG5cbiAgcmV0dXJuIGRlc2NzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFNldHRlcihrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNldChuZXdWYWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgLy8gSVMgZW51bWVyYWJsZSB3aGVuIHJlYXNzaWduZWQgYnkgdGhlIG91dHNpZGUgd29yZFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBuZXdWYWx1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmluZChmbiwgY29udGV4dCkge1xuICBpZiAoZm4uYmluZCkge1xuICAgIHJldHVybiBmbi5iaW5kKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBfX2F1dG9iaW5kX18oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3YXJuID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAnb2JqZWN0JyB8fCAhY29uc29sZSB8fCB0eXBlb2YgY29uc29sZS53YXJuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICgpID0+IHt9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBiaW5kKGNvbnNvbGUud2FybiwgY29uc29sZSk7XG4gIH1cbn0pKCk7XG5cbmNvbnN0IHNlZW5EZXByZWNhdGlvbnMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbERlcHJlY2F0aW9uKG1zZykge1xuICBpZiAoc2VlbkRlcHJlY2F0aW9uc1ttc2ddICE9PSB0cnVlKSB7XG4gICAgc2VlbkRlcHJlY2F0aW9uc1ttc2ddID0gdHJ1ZTtcbiAgICB3YXJuKCdERVBSRUNBVElPTjogJyArIG1zZyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL3ByaXZhdGUvdXRpbHMuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlcTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9JbnRlZ2VyKGRpcnR5TnVtYmVyKSB7XG4gIGlmIChkaXJ0eU51bWJlciA9PT0gbnVsbCB8fCBkaXJ0eU51bWJlciA9PT0gdHJ1ZSB8fCBkaXJ0eU51bWJlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIG51bWJlciA9IE51bWJlcihkaXJ0eU51bWJlcik7XG5cbiAgaWYgKGlzTmFOKG51bWJlcikpIHtcbiAgICByZXR1cm4gbnVtYmVyO1xuICB9XG5cbiAgcmV0dXJuIG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVxdWlyZWRBcmdzKHJlcXVpcmVkLCBhcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA8IHJlcXVpcmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyZXF1aXJlZCArICcgYXJndW1lbnQnICsgKHJlcXVpcmVkID4gMSA/ICdzJyA6ICcnKSArICcgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmdzLmxlbmd0aCArICcgcHJlc2VudCcpO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBCb29sZWFuU3dpdGNoIGZyb20gJy4vQm9vbGVhblN3aXRjaCdcblxuZXhwb3J0IGRlZmF1bHQgQm9vbGVhblN3aXRjaFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5Td2l0Y2gvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgVGVtcGxhdGVSZW5kZXJlciBmcm9tICcuL1RlbXBsYXRlUmVuZGVyZXInXG5cbmV4cG9ydCBkZWZhdWx0IFRlbXBsYXRlUmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZW1wbGF0ZVJlbmRlcmVyL2luZGV4LmpzIiwiaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFzc2lnblZhbHVlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwiaW1wb3J0IGdldE5hdGl2ZSBmcm9tICcuL19nZXROYXRpdmUuanMnO1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICBmdW5jKHt9LCAnJywge30pO1xuICAgIHJldHVybiBmdW5jO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19kZWZpbmVQcm9wZXJ0eS5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuaW1wb3J0IG92ZXJSZXN0IGZyb20gJy4vX292ZXJSZXN0LmpzJztcbmltcG9ydCBzZXRUb1N0cmluZyBmcm9tICcuL19zZXRUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaWRlbnRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FwcGx5LmpzIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJdGVyYXRlZUNhbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XHJcblx0aWYoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcnJvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNFcnJvci5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVJbnRlcnBvbGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlSW50ZXJwb2xhdGUuanMiLCJpbXBvcnQgYmFzZVRvU3RyaW5nIGZyb20gJy4vX2Jhc2VUb1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvU3RyaW5nLmpzIiwiaW1wb3J0IHsgZGVjb3JhdGUgfSBmcm9tICcuL3ByaXZhdGUvdXRpbHMnO1xuXG5mdW5jdGlvbiBoYW5kbGVEZXNjcmlwdG9yKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlYWRvbmx5KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGRlY29yYXRlKGhhbmRsZURlc2NyaXB0b3IsIGFyZ3MpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvcmVhZG9ubHkuanMiLCJpbXBvcnQgdHpQYXJzZVRpbWV6b25lIGZyb20gJy4uL19saWIvdHpQYXJzZVRpbWV6b25lJ1xuaW1wb3J0IHN1Yk1pbGxpc2Vjb25kcyBmcm9tICdkYXRlLWZucy9lc20vc3ViTWlsbGlzZWNvbmRzJ1xuaW1wb3J0IHRvRGF0ZSBmcm9tICcuLi90b0RhdGUnXG5cbi8qKlxuICogQG5hbWUgdXRjVG9ab25lZFRpbWVcbiAqIEBjYXRlZ29yeSBUaW1lIFpvbmUgSGVscGVyc1xuICogQHN1bW1hcnkgR2V0IGEgZGF0ZS90aW1lIHJlcHJlc2VudGluZyBsb2NhbCB0aW1lIGluIGEgZ2l2ZW4gdGltZSB6b25lIGZyb20gdGhlIFVUQyBkYXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm5zIGEgZGF0ZSBpbnN0YW5jZSB3aXRoIHZhbHVlcyByZXByZXNlbnRpbmcgdGhlIGxvY2FsIHRpbWUgaW4gdGhlIHRpbWUgem9uZVxuICogc3BlY2lmaWVkIG9mIHRoZSBVVEMgdGltZSBmcm9tIHRoZSBkYXRlIHByb3ZpZGVkLiBJbiBvdGhlciB3b3Jkcywgd2hlbiB0aGUgbmV3IGRhdGVcbiAqIGlzIGZvcm1hdHRlZCBpdCB3aWxsIHNob3cgdGhlIGVxdWl2YWxlbnQgaG91cnMgaW4gdGhlIHRhcmdldCB0aW1lIHpvbmUgcmVnYXJkbGVzc1xuICogb2YgdGhlIGN1cnJlbnQgc3lzdGVtIHRpbWUgem9uZS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHdpdGggdGhlIHJlbGV2YW50IFVUQyB0aW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gdGltZVpvbmUgLSB0aGUgdGltZSB6b25lIHRvIGdldCBsb2NhbCB0aW1lIGZvciwgY2FuIGJlIGFuIG9mZnNldCBvciBJQU5BIHRpbWUgem9uZVxuICogQHBhcmFtIHtPcHRpb25zV2l0aFRafSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIG5ldyBkYXRlIHdpdGggdGhlIGVxdWl2YWxlbnQgdGltZSBpbiB0aGUgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJbiBKdW5lIDEwYW0gVVRDIGlzIDZhbSBpbiBOZXcgWW9yayAoLTA0OjAwKVxuICogY29uc3QgcmVzdWx0ID0gdXRjVG9ab25lZFRpbWUoJzIwMTQtMDYtMjVUMTA6MDA6MDAuMDAwWicsICdBbWVyaWNhL05ld19Zb3JrJylcbiAqIC8vPT4gSnVuIDI1IDIwMTQgMDY6MDA6MDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXRjVG9ab25lZFRpbWUoZGlydHlEYXRlLCB0aW1lWm9uZSwgb3B0aW9ucykge1xuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUsIG9wdGlvbnMpXG5cbiAgLy8gVGhpcyBkYXRlIGhhcyB0aGUgVVRDIHRpbWUgdmFsdWVzIG9mIHRoZSBpbnB1dCBkYXRlIGF0IHRoZSBzeXN0ZW0gdGltZSB6b25lXG4gIHZhciB1dGNEYXRlID0gbmV3IERhdGUoXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICBkYXRlLmdldFVUQ0hvdXJzKCksXG4gICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKVxuICApXG4gIC8vIFdlIGp1c3QgbmVlZCB0byBhcHBseSB0aGUgb2Zmc2V0IGluZGljYXRlZCBieSB0aGUgdGltZSB6b25lIHRvIHRoaXMgbG9jYWxpemVkIGRhdGVcbiAgdmFyIG9mZnNldE1pbGxpc2Vjb25kcyA9IHR6UGFyc2VUaW1lem9uZSh0aW1lWm9uZSwgdXRjRGF0ZSlcblxuICByZXR1cm4gb2Zmc2V0TWlsbGlzZWNvbmRzXG4gICAgPyBzdWJNaWxsaXNlY29uZHModXRjRGF0ZSwgb2Zmc2V0TWlsbGlzZWNvbmRzKVxuICAgIDogdXRjRGF0ZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS91dGNUb1pvbmVkVGltZS9pbmRleC5qcyIsImltcG9ydCB0elRva2VuaXplRGF0ZSBmcm9tICcuLi90elRva2VuaXplRGF0ZS9pbmRleC5qcydcblxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMFxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMFxuXG52YXIgcGF0dGVybnMgPSB7XG4gIHRpbWV6b25lOiAvKFtaKy1dLiopJC8sXG4gIHRpbWV6b25lWjogL14oWikkLyxcbiAgdGltZXpvbmVISDogL14oWystXSkoXFxkezJ9KSQvLFxuICB0aW1lem9uZUhITU06IC9eKFsrLV0pKFxcZHsyfSk6PyhcXGR7Mn0pJC8sXG4gIHRpbWV6b25lSUFOQTogLyhVVEN8KD86W2EtekEtWl0rXFwvW2EtekEtWl9dKyg/OlxcL1thLXpBLVpfXSspPykpJC9cbn1cblxuLy8gUGFyc2UgdmFyaW91cyB0aW1lIHpvbmUgb2Zmc2V0IGZvcm1hdHMgdG8gYW4gb2Zmc2V0IGluIG1pbGxpc2Vjb25kc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHpQYXJzZVRpbWV6b25lKHRpbWV6b25lU3RyaW5nLCBkYXRlKSB7XG4gIHZhciB0b2tlblxuICB2YXIgYWJzb2x1dGVPZmZzZXRcblxuICAvLyBaXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVaLmV4ZWModGltZXpvbmVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIHJldHVybiAwXG4gIH1cblxuICB2YXIgaG91cnNcblxuICAvLyDCsWhoXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISC5leGVjKHRpbWV6b25lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzJdLCAxMClcblxuICAgIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycykpIHtcbiAgICAgIHJldHVybiBOYU5cbiAgICB9XG5cbiAgICBhYnNvbHV0ZU9mZnNldCA9IGhvdXJzICogTUlMTElTRUNPTkRTX0lOX0hPVVJcbiAgICByZXR1cm4gdG9rZW5bMV0gPT09ICcrJyA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICAvLyDCsWhoOm1tIG9yIMKxaGhtbVxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSEhNTS5leGVjKHRpbWV6b25lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzJdLCAxMClcbiAgICB2YXIgbWludXRlcyA9IHBhcnNlSW50KHRva2VuWzNdLCAxMClcblxuICAgIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykpIHtcbiAgICAgIHJldHVybiBOYU5cbiAgICB9XG5cbiAgICBhYnNvbHV0ZU9mZnNldCA9XG4gICAgICBob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSICsgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEVcbiAgICByZXR1cm4gdG9rZW5bMV0gPT09ICcrJyA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XG4gIH1cblxuICAvLyBJQU5BIHRpbWUgem9uZVxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSUFOQS5leGVjKHRpbWV6b25lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICAvLyB2YXIgW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHR6VG9rZW5pemVEYXRlKGRhdGUsIHRpbWV6b25lU3RyaW5nKVxuICAgIHZhciB0b2tlbnMgPSB0elRva2VuaXplRGF0ZShkYXRlLCB0aW1lem9uZVN0cmluZylcbiAgICB2YXIgYXNVVEMgPSBEYXRlLlVUQyhcbiAgICAgIHRva2Vuc1swXSxcbiAgICAgIHRva2Vuc1sxXSAtIDEsXG4gICAgICB0b2tlbnNbMl0sXG4gICAgICB0b2tlbnNbM10sXG4gICAgICB0b2tlbnNbNF0sXG4gICAgICB0b2tlbnNbNV1cbiAgICApXG4gICAgdmFyIHRpbWVzdGFtcFdpdGhNc1plcm9lZCA9IGRhdGUuZ2V0VGltZSgpIC0gKGRhdGUuZ2V0VGltZSgpICUgMTAwMClcbiAgICByZXR1cm4gLShhc1VUQyAtIHRpbWVzdGFtcFdpdGhNc1plcm9lZClcbiAgfVxuXG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZXpvbmUoaG91cnMsIG1pbnV0ZXMpIHtcbiAgaWYgKG1pbnV0ZXMgIT0gbnVsbCAmJiAobWludXRlcyA8IDAgfHwgbWludXRlcyA+IDU5KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vX2xpYi90elBhcnNlVGltZXpvbmUvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudHNNaXhpbiwgd2l0aEV2ZW50c01peGluIH0gZnJvbSAnLi9FdmVudHNNaXhpbidcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRzTWl4aW5cbmV4cG9ydCB7IHdpdGhFdmVudHNNaXhpbiB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRXZlbnRzTWl4aW4vaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgRGF0ZVRpbWVJbnB1dCBmcm9tICcuL0RhdGVUaW1lSW5wdXQnXG5cbmV4cG9ydCBkZWZhdWx0IERhdGVUaW1lSW5wdXRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EYXRlVGltZUlucHV0L2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IEJvb2xlYW5FZGl0b3IgZnJvbSAnLi9Cb29sZWFuRWRpdG9yJ1xuaW1wb3J0IEJvb2xlYW5SZW5kZXJlciBmcm9tICcuL0Jvb2xlYW5SZW5kZXJlcidcbmltcG9ydCBCb29sZWFuRmlsdGVyIGZyb20gJy4vQm9vbGVhbkZpbHRlcidcbmltcG9ydCBOdW1iZXJFZGl0b3IgZnJvbSAnLi9OdW1iZXJFZGl0b3InXG5pbXBvcnQgVGV4dEVkaXRvciBmcm9tICcuL1RleHRFZGl0b3InXG5pbXBvcnQgVGVtcGxhdGVSZW5kZXJlciBmcm9tICcuL1RlbXBsYXRlUmVuZGVyZXInXG5pbXBvcnQgSW1hZ2VSZW5kZXJlciBmcm9tICcuL0ltYWdlUmVuZGVyZXInXG5pbXBvcnQgRGF0ZVRpbWVGaWx0ZXIgZnJvbSAnLi9EYXRlVGltZUZpbHRlcidcbmltcG9ydCBEYXRlVGltZUVkaXRvciBmcm9tICcuL0RhdGVUaW1lRWRpdG9yJ1xuXG5leHBvcnQge1xuICBCb29sZWFuRWRpdG9yLFxuICBCb29sZWFuUmVuZGVyZXIsXG4gIEJvb2xlYW5GaWx0ZXIsXG4gIE51bWJlckVkaXRvcixcbiAgVGV4dEVkaXRvcixcbiAgVGVtcGxhdGVSZW5kZXJlcixcbiAgSW1hZ2VSZW5kZXJlcixcbiAgRGF0ZVRpbWVGaWx0ZXIsXG4gIERhdGVUaW1lRWRpdG9yLFxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IEJvb2xlYW5FZGl0b3IgZnJvbSAnLi9Cb29sZWFuRWRpdG9yJ1xuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuRWRpdG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhbkVkaXRvci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IEJvb2xlYW5Td2l0Y2ggZnJvbSAnLi4vQm9vbGVhblN3aXRjaCdcblxuLyoqXG4gKiBCb29sZWFucyBFZGl0b3JcbiAqXG4gKiBIYW5kbGUgYm9vbGVhbiB2YWx1ZXMgRWRpdGluZ1xuICpcbiAqICMjIE9wdGlvbnNcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKmJvb2xlYW5Vc2VkVHJ1ZVZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IHRoZSB2YWx1ZSB0byByZXR1cm4gd2hlbiB0aGUgZWRpdG9yIGNoYW5nZXMgdGhlIGN1cnJlbnQgY2VsbCB2YWx1ZSB0byB0cnVlLiBpbiBjYXNlIGl0IGlzIHVuZGVmaW5lZCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaXRlbSBpbiAqKmJvb2xlYW5UcnVlVmFsdWVbXSoqXG4gKiB8ICoqYm9vbGVhblVzZWRGYWxzZVZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IHRoZSB2YWx1ZSB0byByZXR1cm4gd2hlbiB0aGUgZWRpdG9yIGNoYW5nZXMgdGhlIGN1cnJlbnQgY2VsbCB2YWx1ZSB0byBmYWxzZS4gaW4gY2FzZSBpdCBpcyB1bmRlZmluZWQgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGl0ZW0gaW4gKipib29sZWFuRmFsc2VWYWx1ZVtdKipcbiAqIHwgKipib29sZWFuVHJ1ZVZhbHVlW10qKiAgICAgICB8IHRydWUoYm9vbCkgIFx0fCBUaGUgb3B0aW9ucyBkZXNjcmliZXMgd2hhdCBpcyBjb25zaWRlcmVkIGB0cnVlYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8ICoqYm9vbGVhbkZhbHNlVmFsdWVbXSoqICAgICAgfCBmYWxzZShib29sKSBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgZmFsc2VgXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgQm9vbGVhbkVkaXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGluaXQocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fdmFsdWUgPSBCb29sZWFuKHBhcmFtcy5rZXlQcmVzcylcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5jaGFyUHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gQm9vbGVhbihwYXJhbXMuY2hhclByZXNzKVxuICAgIH1cblxuICAgIHRoaXMuX3RydWVWYWx1ZSA9IFtdLmNvbmNhdChcbiAgICAgIHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuVHJ1ZVZhbHVlJywgcGFyYW1zLCBbdHJ1ZV0pXG4gICAgKVxuXG4gICAgdGhpcy5fZmFsc2VWYWx1ZSA9IFtdLmNvbmNhdChcbiAgICAgIHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuRmFsc2VWYWx1ZScsIHBhcmFtcywgW2ZhbHNlXSlcbiAgICApXG5cbiAgICB0aGlzLl9yZXR1cm5UcnVlVmFsdWUgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICdib29sZWFuVXNlZFRydWVWYWx1ZScsXG4gICAgICBwYXJhbXMsXG4gICAgICB0aGlzLl90cnVlVmFsdWVbMF1cbiAgICApXG4gICAgdGhpcy5fcmV0dXJuRmFsc2VWYWx1ZSA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ2Jvb2xlYW5Vc2VkRmFsc2VWYWx1ZScsXG4gICAgICBwYXJhbXMsXG4gICAgICB0aGlzLl9mYWxzZVZhbHVlWzBdXG4gICAgKVxuXG4gICAgdGhpcy5fdHJ1ZVZhbHVlID0gdGhpcy5fdHJ1ZVZhbHVlLm1hcCh4ID0+IFN0cmluZyh4KSlcbiAgICB0aGlzLl9mYWxzZVZhbHVlID0gdGhpcy5fZmFsc2VWYWx1ZS5tYXAoeCA9PiBTdHJpbmcoeCkpXG5cbiAgICB0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHBhcmFtcy5jZWxsU3RhcnRlZEVkaXRcbiAgICBpZiAodGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIGxldCBrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlID1cbiAgICAgICAgcGFyYW1zLmtleVByZXNzID09IDMyIHx8IHBhcmFtcy5rZXlQcmVzcyA9PSA0NiAvLyBzcGFjZSAvLyBkZWxldGVcblxuICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyYW1zLmNoYXJQcmVzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2NvbnZlcnRWYWx1ZShcbiAgICAgIHRoaXMuX3ZhbHVlLFxuICAgICAgdGhpcy5fdHJ1ZVZhbHVlLFxuICAgICAgdGhpcy5fZmFsc2VWYWx1ZVxuICAgIClcblxuICAgIHRoaXMuX3N3aXRjaGVyID0gbmV3IEJvb2xlYW5Td2l0Y2godGhpcy5fdmFsdWUsIHN3aXRjaGVyID0+IHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5fY29udmVydFZhbHVlKFxuICAgICAgICBzd2l0Y2hlci5pc0NoZWNrZWQoKSxcbiAgICAgICAgdGhpcy5fdHJ1ZVZhbHVlLFxuICAgICAgICB0aGlzLl9mYWxzZVZhbHVlXG4gICAgICApXG4gICAgfSlcbiAgICB0aGlzLl9zd2l0Y2hlci5pbml0KHBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGdldEd1aSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3dpdGNoZXIuZ2V0R3VpKClcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3dpdGNoZXIuZGVzdHJveSgpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBHVUkgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICAgKiBNYWtlIHN1cmUgdGhlIGNvbnRhaW5lciBpcyBhbHdheXMgZm9jdXNlZCBhbmQgbGlzdGVuaW5nIHRvIGtleSBjaGFuZ2VzXG4gICAqL1xuICBhZnRlckd1aUF0dGFjaGVkKCkge1xuICAgIGlmICh0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xuICAgICAgdGhpcy5mb2N1c0luKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaW5hbCB2YWx1ZSB0byB0aGUgZ3JpZCwgdGhlIHJlc3VsdCBvZiB0aGUgZWRpdGluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlID8gdGhpcy5fcmV0dXJuVHJ1ZVZhbHVlIDogdGhpcy5fcmV0dXJuRmFsc2VWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgaW5pdGlhbGl6ZWQgYW5kIHJldHVybnMgZmFsc2Ugc28gdGhlIGVkaXRvciBhcHBlYXJzIGluIHRoZSBjZWxsXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGFsd2F5cyBmYWxzZVxuICAgKiovXG4gIGlzUG9wdXAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogSWYgZG9pbmcgZnVsbCByb3cgZWRpdCwgdGhlbiBnZXRzIGNhbGxlZCB3aGVuIHRhYmJpbmcgaW50byB0aGUgY2VsbC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZvY3VzSW4oKSB7XG4gICAgdGhpcy5fc3dpdGNoZXIuc2V0RGlzYWJsZWQoZmFsc2UpXG4gICAgdGhpcy5fc3dpdGNoZXIuZm9jdXMoKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogSWYgZG9pbmcgZnVsbCByb3cgZWRpdCwgdGhlbiBnZXRzIGNhbGxlZCB3aGVuIHRhYmJpbmcgb3V0IG9mIHRoZSBjZWxsLlxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgZm9jdXNPdXQoKSB7XG4gICAgdGhpcy5fc3dpdGNoZXIuc2V0RGlzYWJsZWQodHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgdGhlIGN1cnJlbnQgY2VsbCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHRydWVWYWx1ZSB0cnVlIHZhbHVlIGFsaWFzXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZmFsc2VWYWx1ZSBmYWxzZSB2YWx1ZSBhbGlhc1xuICAgKi9cbiAgX2NvbnZlcnRWYWx1ZSh2YWx1ZSwgdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IFN0cmluZyh2YWx1ZSlcblxuICAgIHJldHVybiB0cnVlVmFsdWUuaW5kZXhPZih2YWx1ZUFzU3RyaW5nKSA+IC0xXG4gICAgICA/IHRydWVcbiAgICAgIDogZmFsc2VWYWx1ZS5pbmRleE9mKHZhbHVlQXNTdHJpbmcpID4gLTFcbiAgICAgID8gZmFsc2VcbiAgICAgIDogdmFsdWVcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuRWRpdG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhbkVkaXRvci9Cb29sZWFuRWRpdG9yLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbi8qKlxuICogVGhlIGJhc2UgY29tcG9uZW50IGNsYXNzXG4gKlxuICogVGhpcyBjbGFzcyBpcyB0aGUgYWJzdHJhY3QgY2xhc3Mgd2hpY2ggYWxsIGNvbXBvbmVudHMgc2hvdWxkIHVzZVxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IGh0bWwgZWxlbWVudFxuICAgKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ3VpID0gbnVsbFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKlxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBpbml0KHBhcmFtcykge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IHRoZSBbaW5pdF0gbWV0aG9kYFxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIERPTSBlbGVtZW50IG9mIHRoZSBjb21wb25lbnQsIHRoaXMgaXMgd2hhdCB0aGUgZ3JpZCBwdXRzIGludG8gdGhlIGNlbGxcbiAgICpcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBnZXRHdWkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1aVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuIElmIHlvdXIgY3VzdG9tIGNvbXBvbmVudCBuZWVkcyB0byBkb1xuICAgKiBhbnkgcmVzb3VyY2UgY2xlYW5pbmcgdXAsIGRvIGl0IGhlcmUuXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIC8vIHBhc3NcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSByZXF1aXJlZCBvcHRpb24gdmFsdWVcbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHRyeSB0byBmaW5kIHRoZSBwYXNzZWQgb3B0aW9uJ3MgdmFsdWUgaW4gdGhlIGZvbGxvd2luZyBvcmRlclxuICAgKlxuICAgKiAgMS4gcGFyYW1zXG4gICAqICAyLiBTZWFyY2ggYHBhcmFtcy5jb2xEZWZgXG4gICAqICAzLiBTZWFyY2ggYHBhcmFtcy5jb250ZXh0LkFHcmlkQ29tcG9uZW50c01ldGFDb25maWdbQ09MVU1OX0lEXWAgb3IgYHBhcmFtcy5jb250ZXh0Lm1ldGFbQ09MVU1OX0lEXWBcbiAgICogIDQuIFNlYXJjaCBgcGFyYW1zLmNvbnRleHQuQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZ2Agb3IgYHBhcmFtcy5jb250ZXh0Lm1ldGFgXG4gICAqICA1LiBTZWFyY2ggYHBhcmFtcy5jb250ZXh0YFxuICAgKiAgNi4gSWYgbm9uZSBmb3VuZCByZXR1cm4gdGhlIGZhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBvcHRpb25cbiAgICogQHBhcmFtIHtwYXJhbXN9IHBhcmFtcyBhbiBvYmplY3QgdXNlZCB0byBzZWFyY2ggZm9yIHRoZSBvcHRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZhbGxiYWNrIGEgdmFsdWUgdG8gcmV0dXJuIGluIGNhc2UgdGhlIG9wdGlvbiBjYW4gbm90IGJlIGZvdW5kXG4gICAqL1xuICBnZXRPcHRpb24obmFtZSwgcGFyYW1zLCBmYWxsYmFjayA9IG51bGwpIHtcbiAgICBsZXQgb3B0aW9uXG5cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwYXJhbXNbbmFtZV0gIT09IG51bGwpIHtcbiAgICAgIG9wdGlvbiA9IHBhcmFtc1tuYW1lXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0cnkgdG8gZmV0Y2ggZnJvbSB0aGUgY29sdW1uIGRlZiBmaXJzdFxuICAgICAgaWYgKFxuICAgICAgICBwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2NvbERlZicpICYmXG4gICAgICAgIHBhcmFtcy5jb2xEZWYuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgcGFyYW1zLmNvbERlZltuYW1lXSAhPT0gbnVsbFxuICAgICAgKSB7XG4gICAgICAgIG9wdGlvbiA9IHBhcmFtcy5jb2xEZWZbbmFtZV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRyeSB0byBmZXRjaCBmcm9tIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWd8bWV0YSBpbiB0aGUgY29udGV4dFxuICAgICAgICBsZXQgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZyA9IG51bGxcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnY29udGV4dCcpKSB7XG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZyA9XG4gICAgICAgICAgICBwYXJhbXMuY29udGV4dC5BR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnIHx8IHBhcmFtcy5jb250ZXh0Lm1ldGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnICYmXG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZy5oYXNPd25Qcm9wZXJ0eShwYXJhbXMuY29sdW1uLmNvbElkKSAmJlxuICAgICAgICAgIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWdbcGFyYW1zLmNvbHVtbi5jb2xJZF0uaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnW3BhcmFtcy5jb2x1bW4uY29sSWRdW25hbWVdICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbiA9IEFHcmlkQ29tcG9uZW50c01ldGFDb25maWdbcGFyYW1zLmNvbHVtbi5jb2xJZF1bbmFtZV1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnICYmXG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWdbbmFtZV0gIT09IG51bGxcbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9uID0gQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZ1tuYW1lXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRyeSB0byBmZXRjaCBmcm9tIHRoZSBjb250ZXh0IG9iamVjdCBpdHNlbGZcbiAgICAgICAgICBjb25zdCBjb250ZXh0ID0gcGFyYW1zLmNvbnRleHRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb250ZXh0ICYmXG4gICAgICAgICAgICBjb250ZXh0Lmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICBjb250ZXh0W25hbWVdICE9PSBudWxsXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb24gPSBjb250ZXh0W25hbWVdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyeSB0byBjaGVjayBwYXJhbXMgaXRzZWxmIG9yIGZhbGxiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgICAgIG9wdGlvbiA9IGZhbGxiYWNrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBvcHRpb24gIT09ICd1bmRlZmluZWQnID8gb3B0aW9uIDogZmFsbGJhY2tcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgV2luZG93IEluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7cGFyYW1zfSBwYXJhbXMgYW4gb2JqZWN0IHVzZWQgdG8gc2VhcmNoIGZvciB0aGUgd2luZG93IGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge1dpbmRvd31cbiAgICovXG4gIGdldFdpbihwYXJhbXMpIHtcbiAgICBjb25zdCB3aW4gPSB0aGlzLmdldE9wdGlvbignd2luZG93JywgcGFyYW1zKSB8fCB3aW5kb3cgfHwgbnVsbFxuXG4gICAgaWYgKCF3aW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IHdpbmRvdycpXG4gICAgfVxuXG4gICAgcmV0dXJuIHdpblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBkb2N1bWVudCBJbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge3BhcmFtc30gcGFyYW1zIGFuIG9iamVjdCB1c2VkIHRvIHNlYXJjaCBmb3IgdGhlIGRvY3VtZW50IGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxEb2N1bWVudH1cbiAgICovXG4gIGdldERvYyhwYXJhbXMpIHtcbiAgICBjb25zdCBkb2MgPSB0aGlzLmdldE9wdGlvbignZG9jdW1lbnQnLCBwYXJhbXMpIHx8IGRvY3VtZW50IHx8IG51bGxcblxuICAgIGlmICghZG9jKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkb2N1bWVudCcpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0NvbXBvbmVudC9Db21wb25lbnQuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgeyBhdXRvYmluZCwgb3ZlcnJpZGUgfSBmcm9tICdjb3JlLWRlY29yYXRvcnMnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCAnLi9zdHlsZS5zY3NzJ1xuXG4vKipcbiAqIEJvb2xlYW4gUmVuZGVyZXJcbiAqXG4gKiBTaW1wbGUgdG9nZ2xlIHN3aXRjaCB0byBoYW5kbGUgYm9vbGVhbiB2YWx1ZXNcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBCb29sZWFuU3dpdGNoIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBuZXcgQm9vbGVhblN3aXRjaCBDb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaW5pdGlhbFZhbHVlID0gZmFsc2VdIHRoZSBkZWZhdWx0IHN0YXRlICwgY2hlY2tlZCBvciB1bmNoZWNrZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2xpc3RlbmVyID0gbnVsbF0gYSBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5pdGlhbFZhbHVlID0gZmFsc2UsIGxpc3RlbmVyID0gbnVsbCkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNldENoZWNrZWQoaW5pdGlhbFZhbHVlKVxuICAgIHRoaXMuc2V0TGlzdGVuZXIobGlzdGVuZXIpXG4gICAgdGhpcy5zZXREaXNhYmxlZChmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtc1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcylcbiAgICB0aGlzLl9vbktleWRvd24gPSB0aGlzLl9vbktleWRvd24uYmluZCh0aGlzKVxuXG4gICAgdGhpcy5fZ3VpID0gdGhpcy5nZXREb2MocGFyYW1zKS5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnYm9vbFN3aXRjaF9fd3JhcHBlcidcbiAgICB0aGlzLl9ndWkudGFiSW5kZXggPSAtMVxuXG4gICAgdGhpcy5yZW5kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc3dpdGNoIHNsaWRlciBhbmQgaGlkZGVuIGlucHV0LlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGRvYyA9IHRoaXMuZ2V0RG9jKHRoaXMuX3BhcmFtcylcblxuICAgIGNvbnN0IGJvb2xTd2l0Y2ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGJvb2xTd2l0Y2guY2xhc3NOYW1lID0gJ2Jvb2xTd2l0Y2gnXG5cbiAgICAvLyBpbnB1dFxuICAgIHRoaXMuX2lucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICB0aGlzLl9pbnB1dC5pZCA9IGBlbC0ke01hdGgucmFuZG9tKCl9YFxuICAgIHRoaXMuX2lucHV0Lm5hbWUgPSAnY2hlY2tib3gnXG4gICAgdGhpcy5faW5wdXQuY2xhc3NOYW1lID0gJ2Jvb2xTd2l0Y2hfX2NoZWNrYm94J1xuICAgIHRoaXMuX2lucHV0LnR5cGUgPSAnY2hlY2tib3gnXG4gICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHRoaXMuaXNDaGVja2VkKClcbiAgICB0aGlzLl9pbnB1dC5kaXNhYmxlZCA9IHRoaXMuaXNEaXNhYmxlZCgpXG4gICAgdGhpcy5faW5wdXQudGFiSW5kZXggPSAnMCdcblxuICAgIC8vIGxhYmVsXG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpXG4gICAgbGFiZWwuY2xhc3NOYW1lID0gJ2Jvb2xTd2l0Y2hfX2xhYmVsJ1xuICAgIGxhYmVsLmZvciA9IHRoaXMuX2lucHV0LmlkXG4gICAgbGFiZWwuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgICA8c3BhbiBjbGFzcz1cImJvb2xTd2l0Y2hfX2lubmVyXCI+PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJib29sU3dpdGNoX19zd2l0Y2hcIj48L3NwYW4+XG4gICAgYFxuXG4gICAgLy8gYXR0YWNoZSBpbnB1dCBhbmQgc2xpZGVyIHRvIGNvbXBvbmVudFxuICAgIGJvb2xTd2l0Y2guYXBwZW5kQ2hpbGQodGhpcy5faW5wdXQpXG4gICAgYm9vbFN3aXRjaC5hcHBlbmRDaGlsZChsYWJlbClcblxuICAgIGJvb2xTd2l0Y2guYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKVxuICAgIHRoaXMuX2d1aS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duKVxuXG4gICAgdGhpcy5fZ3VpLmFwcGVuZENoaWxkKGJvb2xTd2l0Y2gpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCBib29sU3dpdGNoID0gdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5ib29sU3dpdGNoJylcbiAgICBib29sU3dpdGNoLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaylcbiAgICB0aGlzLl9ndWkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bilcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgY29tcG9uZW50XG4gICAqL1xuICBmb2N1cygpIHtcbiAgICB0aGlzLl9ndWkuZm9jdXMoKVxuICAgIHRoaXMuX2lucHV0LmZvY3VzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBsaXN0ZW5lciB0byBiZSBjYWxsZWQgd2hlbiB0aGUgc3dpdGNoIHN0YXRlIGlzIGNoYW5nZWRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICovXG4gIHNldExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbGlzdGVuZXIgPSBsaXN0ZW5lclxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGlzdGVuZXIgaW5zdGFuY2UgLCBpZlxuICAgKlxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnxudWxsfVxuICAgKi9cbiAgZ2V0TGlzdGVuZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyXG4gIH1cblxuICAvKipcbiAgICogU2V0IGNoZWNrZWRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSB0cnVlIHRvIGNoZWNrICwgZmFsc2UgdG8gdW5jaGVja1xuICAgKi9cbiAgc2V0Q2hlY2tlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2NoZWNrZWQgPSB2YWx1ZVxuICAgIGlmICh0aGlzLl9pbnB1dCkge1xuICAgICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBpZiBzd2l0Y2ggaXMgY2hlY2tlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgdHJ1ZSB3aGVuIGNoZWNrZWQgLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tlZFxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5zZXRDaGVja2VkKCF0aGlzLmlzQ2hlY2tlZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkaXNhYmxlZFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHRydWUgdG8gZGlzYWJsZWQgLCBmYWxzZSB0byBlbmFibGVcbiAgICovXG4gIHNldERpc2FibGVkKHZhbHVlKSB7XG4gICAgdGhpcy5fZGlzYWJsZWQgPSB2YWx1ZVxuICAgIGlmICh0aGlzLl9pbnB1dCkge1xuICAgICAgdGhpcy5faW5wdXQuZGlzYWJsZWQgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3dpdGNoIGlzIGRpc2FibGVkXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBkaXNhYmxlZCAsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBjbGljayBsaXN0ZW5lciBvZiB0aGUgc3dpdGNoLiBJdCB3aWxsIHRvZ2dsZSB0aGUgc3RhdGUgYW5kIGZpcmUgYW55IHJlZ2lzdGVyZWQgbGlzdGVuZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgZXZlbnQgb2JqZWN0XG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEBhdXRvYmluZFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgX29uQ2xpY2soZSkge1xuICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy50b2dnbGUoKVxuXG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcih0aGlzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBrZXkgbGlzdGVuZXIgb2YgdGhlIHN3aXRjaC4gSXQgd2lsbCB0b2dnbGUgdGhlIHN0YXRlIHVzaW5nIGtleWJvYXJkIGtleXMgKGxlZnQgLCByaWdodCAsIHNwYWNlKVxuICAgKiBhbmQgZmlyZSBhbnkgcmVnaXN0ZXJlZCBsaXN0ZW5lclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlICB0aGUgZXZlbnQgb2JqZWN0XG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25LZXlkb3duKGUpIHtcbiAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlXG5cbiAgICAvLyBzcGFjZVxuICAgIGlmIChrZXkgPT0gMzIpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcih0aGlzKVxuICAgICAgfVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH1cbiAgICAvLyByaWdodFxuICAgIGVsc2UgaWYgKGtleSA9PSAzOSkge1xuICAgICAgdGhpcy5zZXRDaGVja2VkKHRydWUpXG4gICAgICBpZiAodGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIodGhpcylcbiAgICAgIH1cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgLy8gbGVmdFxuICAgIGVsc2UgaWYgKGtleSA9PSAzNykge1xuICAgICAgdGhpcy5zZXRDaGVja2VkKGZhbHNlKVxuICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyKHRoaXMpXG4gICAgICB9XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5Td2l0Y2hcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuU3dpdGNoL0Jvb2xlYW5Td2l0Y2guanMiLCJpbXBvcnQgeyBkZWNvcmF0ZSwgY3JlYXRlRGVmYXVsdFNldHRlciB9IGZyb20gJy4vcHJpdmF0ZS91dGlscyc7XG5jb25zdCB7IGRlZmluZVByb3BlcnR5IH0gPSBPYmplY3Q7XG5cbmZ1bmN0aW9uIGhhbmRsZURlc2NyaXB0b3IodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgY29uc3QgeyBjb25maWd1cmFibGUsIGVudW1lcmFibGUsIGluaXRpYWxpemVyLCB2YWx1ZSB9ID0gZGVzY3JpcHRvcjtcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGUsXG4gICAgZW51bWVyYWJsZSxcblxuICAgIGdldCgpIHtcbiAgICAgIC8vIFRoaXMgaGFwcGVucyBpZiBzb21lb25lIGFjY2Vzc2VzIHRoZVxuICAgICAgLy8gcHJvcGVydHkgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZVxuICAgICAgaWYgKHRoaXMgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJldCA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIuY2FsbCh0aGlzKSA6IHZhbHVlO1xuXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlLFxuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHJldFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHNldDogY3JlYXRlRGVmYXVsdFNldHRlcihrZXkpXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxhenlJbml0aWFsaXplKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGRlY29yYXRlKGhhbmRsZURlc2NyaXB0b3IsIGFyZ3MpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvbGF6eS1pbml0aWFsaXplLmpzIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5Td2l0Y2gvc3R5bGUuc2NzcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFnLWNlbGwtaW5saW5lLWVkaXRpbmcgLmJvb2xTd2l0Y2hfX3dyYXBwZXJ7bWFyZ2luOmF1dG8gMTFweH0uYm9vbFN3aXRjaF9fd3JhcHBlcntkaXNwbGF5OmZsZXg7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTthbGlnbi1pdGVtczpjZW50ZXI7b3V0bGluZTpub25lO3BhZGRpbmctbGVmdDo2cHg7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmV9LmJvb2xTd2l0Y2h7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6NTVweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lfS5ib29sU3dpdGNoX19jaGVja2JveHtkaXNwbGF5Om5vbmV9LmJvb2xTd2l0Y2hfX2xhYmVse2Rpc3BsYXk6YmxvY2s7b3ZlcmZsb3c6aGlkZGVuO2N1cnNvcjpwb2ludGVyO2JvcmRlcjoycHggc29saWQgdmFyKC0tYWctaW5wdXQtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNiYWJmYzcpKTtib3JkZXItcmFkaXVzOjIwcHh9LmJvb2xTd2l0Y2hfX2lubmVye2Rpc3BsYXk6YmxvY2s7d2lkdGg6MjAwJTttYXJnaW4tbGVmdDotMTAwJTt0cmFuc2l0aW9uOm1hcmdpbiAwLjNzIGVhc2UtaW4gMHN9LmJvb2xTd2l0Y2hfX2lubmVyOmJlZm9yZSwuYm9vbFN3aXRjaF9faW5uZXI6YWZ0ZXJ7ZGlzcGxheTpibG9jaztmbG9hdDpsZWZ0O3dpZHRoOjUwJTtoZWlnaHQ6MTVweDtwYWRkaW5nOjA7bGluZS1oZWlnaHQ6MTVweDtmb250LXNpemU6MTRweDtjb2xvcjp3aGl0ZTtmb250LWZhbWlseTonU2Vnb2UgVUkgU3ltYm9sJywgVHJlYnVjaGV0LCBBcmlhbCwgc2Fucy1zZXJpZjtmb250LXdlaWdodDpib2xkO2JveC1zaXppbmc6Ym9yZGVyLWJveH0uYm9vbFN3aXRjaF9faW5uZXI6YmVmb3Jle2NvbnRlbnQ6J1xcXFwyNzE0JztwYWRkaW5nLWxlZnQ6MTBweDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWFnLWNoZWNrYm94LWNoZWNrZWQtY29sb3IsIHZhcigtLWFnLWFscGluZS1hY3RpdmUtY29sb3IsICMyMTk2ZjMpKTtjb2xvcjojZmZmZmZmfS5ib29sU3dpdGNoX19pbm5lcjphZnRlcntjb250ZW50OidcXFxcMjcxOCc7cGFkZGluZy1yaWdodDoxMHB4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6dmFyKC0tYWctaW5wdXQtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNiYWJmYzcpKTt0ZXh0LWFsaWduOnJpZ2h0fS5ib29sU3dpdGNoX19zd2l0Y2h7ZGlzcGxheTpibG9jazt3aWR0aDoxOHB4O21hcmdpbjoxcHg7YmFja2dyb3VuZDojZmZmZmZmO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO3JpZ2h0OjM1cHg7Ym9yZGVyOjJweCBzb2xpZCB2YXIoLS1hZy1pbnB1dC1ib3JkZXItY29sb3IsIHZhcigtLWFnLWJvcmRlci1jb2xvciwgI2JhYmZjNykpO2JvcmRlci1yYWRpdXM6MjBweDt0cmFuc2l0aW9uOmFsbCAwLjNzIGVhc2UtaW4gMHN9LmJvb2xTd2l0Y2hfX2NoZWNrYm94OmNoZWNrZWQrLmJvb2xTd2l0Y2hfX2xhYmVsIC5ib29sU3dpdGNoX19pbm5lcnttYXJnaW4tbGVmdDowfS5ib29sU3dpdGNoX19jaGVja2JveDpjaGVja2VkKy5ib29sU3dpdGNoX19sYWJlbCAuYm9vbFN3aXRjaF9fc3dpdGNoe3JpZ2h0OjBweH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL0Jvb2xlYW5Td2l0Y2gvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IEJvb2xlYW5SZW5kZXJlciBmcm9tICcuL0Jvb2xlYW5SZW5kZXJlcidcblxuZXhwb3J0IGRlZmF1bHQgQm9vbGVhblJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhblJlbmRlcmVyL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgQm9vbGVhblN3aXRjaCBmcm9tICcuLi9Cb29sZWFuU3dpdGNoJ1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cblxuLyoqXG4gKiBCb29sZWFucyBSZW5kZXJlclxuICpcbiAqIEhhbmRsZSBib29sZWFuIHZhbHVlcyBSZW5kZXJpbmdcbiAqXG4gKiAjIyBPcHRpb25zXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKipib29sZWFuVHJ1ZVJlbmRlclZhbHVlKiogIFx0fCBzd2l0Y2ggICAgICBcdHwgVGhlIG9wdGlvbiBjb250cm9scyBob3cgdG8gcmVuZGVyIGB0cnVlYCB2YWx1ZXMuIDxicj4gKipzd2l0Y2gqKiBpcyBhIHNwZWNpYWwgdmFsdWUgdXNlZCB0byByZW5kZXIgdHJ1ZSB2YWx1ZXMgYXMgYSBzd2l0Y2ggY29tcG9uZW50ICBcdHxcbiAqIHwgKipib29sZWFuRmFsc2VSZW5kZXJWYWx1ZSoqIFx0fCBzd2l0Y2ggICAgICBcdHwgVGhlIG9wdGlvbiBjb250cm9scyBob3cgdG8gcmVuZGVyIGBmYWxzZWAgdmFsdWVzLiA8YnI+ICoqc3dpdGNoKiogaXMgYSBzcGVjaWFsIHZhbHVlIHVzZWQgdG8gcmVuZGVyIHRydWUgdmFsdWVzIGFzIGEgc3dpdGNoIGNvbXBvbmVudCBcdHxcbiAqIHwgKipib29sZWFuVHJ1ZVZhbHVlW10qKiAgICAgICB8IHRydWUoYm9vbCkgIFx0fCBUaGUgb3B0aW9ucyBkZXNjcmliZXMgd2hhdCBpcyBjb25zaWRlcmVkIGB0cnVlYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8ICoqYm9vbGVhbkZhbHNlVmFsdWVbXSoqICAgICAgfCBmYWxzZShib29sKSBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgZmFsc2VgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIEJvb2xlYW5SZW5kZXJlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IEJvb2xlYW5SZW5kZXJlclxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgLy8gd2lsbCB0aGlzIGFmZmVjdCBCQmogYnVpID9cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ2Jvb2xSZW5kZXJlcidcbiAgICB0aGlzLl9ndWkuc3R5bGUuZm9udEZhbWlseSA9XG4gICAgICAnXCJTZWdvZSBVSSBTeW1ib2xcIixUcmVidWNoZXQsIEFyaWFsLCBzYW5zLXNlcmlmJ1xuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgaW5pdChwYXJhbXMpIHtcbiAgICB0aGlzLnJlZnJlc2gocGFyYW1zLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0R3VpKCkge1xuICAgIHJldHVybiB0aGlzLl9ndWlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3N3aXRjaGVyKSB7XG4gICAgICB0aGlzLl9zd2l0Y2hlci5kZXN0cm95KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY2VsbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGNlbGwgcmVuZGVyZXIgcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0IHRydWUgd2hlbiB0aGlzIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgaW4gYGluaXRgIHBoYXNlICwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHJlZnJlc2ggc3VjY2VlZGVkLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJlZnJlc2gocGFyYW1zLCBpc0luaXQpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgPyBwYXJhbXMudmFsdWVGb3JtYXR0ZWQgOiBwYXJhbXMudmFsdWVcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpXG4gICAgICBjb25zdCBib29sZWFuVHJ1ZVJlbmRlclZhbHVlID0gU3RyaW5nKFxuICAgICAgICB0aGlzLmdldE9wdGlvbignYm9vbGVhblRydWVSZW5kZXJWYWx1ZScsIHBhcmFtcywgJ3N3aXRjaCcpXG4gICAgICApXG4gICAgICBjb25zdCBib29sZWFuRmFsc2VSZW5kZXJWYWx1ZSA9IFN0cmluZyhcbiAgICAgICAgdGhpcy5nZXRPcHRpb24oJ2Jvb2xlYW5GYWxzZVJlbmRlclZhbHVlJywgcGFyYW1zLCAnc3dpdGNoJylcbiAgICAgIClcbiAgICAgIGNvbnN0IGJvb2xlYW5UcnVlVmFsdWUgPSBbXVxuICAgICAgICAuY29uY2F0KHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuVHJ1ZVZhbHVlJywgcGFyYW1zLCBbdHJ1ZV0pKVxuICAgICAgICAubWFwKHggPT4gU3RyaW5nKHgpKVxuICAgICAgY29uc3QgYm9vbGVhbkZhbHNlVmFsdWUgPSBbXVxuICAgICAgICAuY29uY2F0KHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuRmFsc2VWYWx1ZScsIHBhcmFtcywgW2ZhbHNlXSkpXG4gICAgICAgIC5tYXAoeCA9PiBTdHJpbmcoeCkpXG5cbiAgICAgIC8vIGhhbmRsZSB0cnVlIHZhbHVlc1xuICAgICAgaWYgKGJvb2xlYW5UcnVlVmFsdWUuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWJvb2xlYW5UcnVlUmVuZGVyVmFsdWUubGVuZ3RoIHx8XG4gICAgICAgICAgYm9vbGVhblRydWVSZW5kZXJWYWx1ZSA9PT0gJ3N3aXRjaCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qgc3dpdGNoZXIgPSB0aGlzLl9nZXRTd2l0Y2hlcihwYXJhbXMpXG4gICAgICAgICAgc3dpdGNoZXIuc2V0Q2hlY2tlZCh0cnVlKVxuICAgICAgICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSAnJ1xuICAgICAgICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChzd2l0Y2hlci5nZXRHdWkoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gYm9vbGVhblRydWVSZW5kZXJWYWx1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBoYW5kbGUgZmFsc2UgdmFsdWVzXG4gICAgICBlbHNlIGlmIChib29sZWFuRmFsc2VWYWx1ZS5pbmRleE9mKHZhbHVlKSA+IC0xKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUubGVuZ3RoIHx8XG4gICAgICAgICAgYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUgPT09ICdzd2l0Y2gnXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN3aXRjaGVyID0gdGhpcy5fZ2V0U3dpdGNoZXIocGFyYW1zKVxuICAgICAgICAgIHN3aXRjaGVyLnNldENoZWNrZWQoZmFsc2UpXG4gICAgICAgICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9ICcnXG4gICAgICAgICAgdGhpcy5fZ3VpLmFwcGVuZENoaWxkKHN3aXRjaGVyLmdldEd1aSgpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSBib29sZWFuRmFsc2VSZW5kZXJWYWx1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzd2l0Y2ggaW5zdGFuY2UgaWYgYXZhaWxhYmxlICwgb3IgY3JlYXRlIGl0IG90aGVyd2lzZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW5Td2l0Y2h9IHN3aXRjaCBpbnN0YW5jZVxuICAgKi9cbiAgX2dldFN3aXRjaGVyKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5fc3dpdGNoZXIpIHtcbiAgICAgIHRoaXMuX3N3aXRjaGVyID0gbmV3IEJvb2xlYW5Td2l0Y2goKVxuICAgICAgdGhpcy5fc3dpdGNoZXIuc2V0RGlzYWJsZWQodHJ1ZSlcbiAgICAgIHRoaXMuX3N3aXRjaGVyLmluaXQocGFyYW1zKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zd2l0Y2hlclxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5SZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5SZW5kZXJlci9Cb29sZWFuUmVuZGVyZXIuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQm9vbGVhbkZpbHRlciBmcm9tICcuL0Jvb2xlYW5GaWx0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5GaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuRmlsdGVyL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlIH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgJy4vc3R5bGUuc2NzcydcblxuY29uc3QgdG9UaXRsZUNhc2UgPSBwaHJhc2UgPT4ge1xuICByZXR1cm4gcGhyYXNlXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAuc3BsaXQoJyAnKVxuICAgIC5tYXAod29yZCA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zbGljZSgxKSlcbiAgICAuam9pbignICcpXG59XG5cbmNvbnN0IHN0cmlwSFRNTCA9IGh0bWwgPT4ge1xuICBjb25zdCB0bXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKVxuICB0bXAuaW5uZXJIVE1MID0gaHRtbFxuICByZXR1cm4gdG1wLnRleHRDb250ZW50IHx8IHRtcC5pbm5lclRleHQgfHwgJydcbn1cblxuLyoqXG4gKiBCb29sZWFucyBGaWx0ZXJcbiAqXG4gKiBIYW5kbGUgYm9vbGVhbiB2YWx1ZXMgRmlsdGVyaW5nXG4gKlxuICogIyMgT3B0aW9uc1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqYm9vbGVhblVzZWRUcnVlVmFsdWUqKiAgIHwgdW5kZWZpbmVkICAgIHwgdGhlIHZhbHVlIHRvIHVzZSB3aGVuIHRoZSBmaWx0ZXIgZGlzcGxheXMgdGhlIHRydWUgc3RhdGUgLiBpbiBjYXNlIGl0IGlzIHVuZGVmaW5lZCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaXRlbSBpbiAqKmJvb2xlYW5UcnVlVmFsdWVbXSoqXG4gKiB8ICoqYm9vbGVhblVzZWRGYWxzZVZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IHRoZSB2YWx1ZSB0byB1c2Ugd2hlbiB0aGUgZmlsdGVyIGRpc3BsYXlzIHRoZSBmYWxzZSBzdGF0ZS4gaW4gY2FzZSBpdCBpcyB1bmRlZmluZWQgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGl0ZW0gaW4gKipib29sZWFuRmFsc2VWYWx1ZVtdKipcbiAqIHwgKipib29sZWFuVHJ1ZVZhbHVlW10qKiAgICAgICB8IHRydWUoYm9vbCkgIFx0fCBUaGUgb3B0aW9ucyBkZXNjcmliZXMgd2hhdCBpcyBjb25zaWRlcmVkIGB0cnVlYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8ICoqYm9vbGVhbkZhbHNlVmFsdWVbXSoqICAgICAgfCBmYWxzZShib29sKSBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgZmFsc2VgXG4gKiB8ICoqY2xlYXJCdXR0b24qKiAgIHwgZmFsc2UgICAgfCAgU2V0IHRvIHRydWUgdG8gaGF2ZSB0aGUgZmlsdGVyIHVzZSBhIENsZWFyIGJ1dHRvbi4gVGhlIENsZWFyIGJ1dHRvbiB3aWxsIGNsZWFyIHRoZSAoZm9ybSkgZGV0YWlscyBvZiB0aGUgZmlsdGVyIHdpdGhvdXQgcmVtb3ZpbmcgYW55IGFjdGl2ZSBmaWx0ZXJzIG9uIHRoZSBjb2x1bW4uXG4gKiB8ICoqYXBwbHlCdXR0b24qKiAgIHwgZmFsc2UgICAgfCAgU2V0IHRvIHRydWUgdG8gaGF2ZSB0aGUgZmlsdGVyIHVzZSBhbiBBcHBseSBidXR0b24uIElmIHRoZSBBcHBseSBidXR0b24gaXMgcHJlc2VudCwgdGhlbiB0aGUgZmlsdGVyIGlzIG9ubHkgYXBwbGllZCBhZnRlciB0aGUgdXNlciBoaXRzIHRoZSBBcHBseSBidXR0b24uXG4gKiB8ICoqcmVzZXRCdXR0b24qKiAgIHwgZmFsc2UgICAgfCAgU2V0IHRvIHRydWUgdG8gaGF2ZSB0aGUgZmlsdGVyIHVzZSBhIFJlc2V0IGJ1dHRvbi4gVGhlIFJlc2V0IGJ1dHRvbiB3aWxsIGNsZWFyIHRoZSBkZXRhaWxzIG9mIHRoZSBmaWx0ZXIgYW5kIGFueSBhY3RpdmUgZmlsdGVycyBvbiB0aGF0IGNvbHVtbi5cbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBCb29sZWFuRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIFRydWUgLCBmYWxzZSB0cmFuc2xhdGlvblxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbiA9IHt9XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IEJvb2xlYW5GaWx0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICdib29sZWFuRmlsdGVyIGFnLWZpbHRlci1ib2R5LXdyYXBwZXInXG4gICAgdGhpcy5fZ3VpLnRhYkluZGV4ID0gJzAnXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHBhcmFtcy5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldExvY2FsZVRleHRGdW5jKClcbiAgICBjb25zdCBpc0NsZWFyRmlsdGVyID0gdGhpcy5nZXRPcHRpb24oJ2NsZWFyQnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcbiAgICBjb25zdCBpc1Jlc2V0QnV0dG9uID0gdGhpcy5nZXRPcHRpb24oJ3Jlc2V0QnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcbiAgICBjb25zdCBpc0FwcGx5QnV0dG9uID0gdGhpcy5nZXRPcHRpb24oJ2FwcGx5QnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcblxuICAgIHRoaXMuX3RydWVWYWx1ZSA9IFtdXG4gICAgICAuY29uY2F0KHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuVHJ1ZVZhbHVlJywgcGFyYW1zLCBbdHJ1ZV0pKVxuICAgICAgLm1hcCh4ID0+IFN0cmluZyh4KSlcblxuICAgIHRoaXMuX2ZhbHNlVmFsdWUgPSBbXVxuICAgICAgLmNvbmNhdCh0aGlzLmdldE9wdGlvbignYm9vbGVhbkZhbHNlVmFsdWUnLCBwYXJhbXMsIFtmYWxzZV0pKVxuICAgICAgLm1hcCh4ID0+IFN0cmluZyh4KSlcblxuICAgIHRoaXMuX3VzZWRUcnVlVmFsdWUgPSBTdHJpbmcoXG4gICAgICB0aGlzLmdldE9wdGlvbignYm9vbGVhblVzZWRUcnVlVmFsdWUnLCBwYXJhbXMsIHRoaXMuX3RydWVWYWx1ZVswXSlcbiAgICApXG5cbiAgICB0aGlzLl91c2VkRmFsc2VWYWx1ZSA9IFN0cmluZyhcbiAgICAgIHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuVXNlZEZhbHNlVmFsdWUnLCBwYXJhbXMsIHRoaXMuX2ZhbHNlVmFsdWVbMF0pXG4gICAgKVxuXG4gICAgdGhpcy5fYm9vbGVhbkZpbHRlclRyYW5zbGF0aW9uID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAnYm9vbGVhbkZpbHRlclRyYW5zbGF0aW9uJyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHtcbiAgICAgICAgdHJ1ZTogdHJhbnNsYXRlKFxuICAgICAgICAgICdib29sZWFuVHJ1ZScsXG4gICAgICAgICAgdG9UaXRsZUNhc2UoU3RyaW5nKHRoaXMuX3VzZWRUcnVlVmFsdWUpKVxuICAgICAgICApLFxuICAgICAgICBmYWxzZTogdHJhbnNsYXRlKFxuICAgICAgICAgICdib29sZWFuRmFsc2UnLFxuICAgICAgICAgIHRvVGl0bGVDYXNlKFN0cmluZyh0aGlzLl91c2VkRmFsc2VWYWx1ZSkpXG4gICAgICAgICksXG4gICAgICAgIHJlc2V0OiB0cmFuc2xhdGUoXG4gICAgICAgICAgJ2Jvb2xlYW5SZXNldCcsXG4gICAgICAgICAgdHJhbnNsYXRlKCdyZXNldEZpbHRlcicsICdSZXNldCBGaWx0ZXInKVxuICAgICAgICApLFxuICAgICAgfVxuICAgIClcblxuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtc1xuICAgIHRoaXMuX2ZpbHRlclRleHQgPSBudWxsXG5cbiAgICB0aGlzLl9vblJhZGlvQ2hhbmdlID0gdGhpcy5fb25SYWRpb0NoYW5nZS5iaW5kKHRoaXMsIGlzQXBwbHlCdXR0b24pXG5cbiAgICAvLyBjcmVhdGUgYm9keVxuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGJvZHkuY2xhc3NOYW1lID0gJ2Jvb2xlYW5GaWx0ZXJfX2JvZHkgYWctZmlsdGVyLWJvZHknXG4gICAgYm9keS5zdHlsZS5wYWRkaW5nID0gJzVweCAxNXB4J1xuICAgIGJvZHkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgICA8ZGl2IGNsYXNzPVwiYm9vbGVhbkZpbHRlcl9fYm9keV9fbGFiZWxzXCI+XG5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYWctaW5wdXQtZmllbGQtbGFiZWwgYWctbGFiZWwgYWctcmFkaW8tYnV0dG9uLWxhYmVsXCI+ICAgICAgIFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFnLXdyYXBwZXItdHJ1ZSBhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctcmFkaW8tYnV0dG9uLWlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwidHJ1ZS1pbnB1dCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy1yYWRpby1idXR0b24taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwiYm9vbGVhblwiIHZhbHVlPVwidHJ1ZVwiLz4gICAgICAgICAgICAgIFxuICAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgICA8c3Bhbj4ke3RoaXMuX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbi50cnVlfTwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cblxuXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImFnLWlucHV0LWZpZWxkLWxhYmVsIGFnLWxhYmVsIGFnLXJhZGlvLWJ1dHRvbi1sYWJlbFwiPiAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyLWZhbHNlIGFnLXdyYXBwZXIgYWctaW5wdXQtd3JhcHBlciBhZy1yYWRpby1idXR0b24taW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJmYWxzZS1pbnB1dCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy1yYWRpby1idXR0b24taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwiYm9vbGVhblwiIHZhbHVlPVwiZmFsc2VcIi8+ICAgICAgICAgICAgICBcbiAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgPHNwYW4+JHt0aGlzLl9ib29sZWFuRmlsdGVyVHJhbnNsYXRpb24uZmFsc2V9PC9zcGFuPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIFxuICAgICAgICAgICR7XG4gICAgICAgICAgICAhaXNSZXNldEJ1dHRvblxuICAgICAgICAgICAgICA/IC8qIGh0bWwgKi8gYFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJhZy1pbnB1dC1maWVsZC1sYWJlbCBhZy1sYWJlbCBhZy1yYWRpby1idXR0b24tbGFiZWxcIj4gICAgICAgXG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWctd3JhcHBlci1yZXNldCBhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctcmFkaW8tYnV0dG9uLWlucHV0LXdyYXBwZXIgYWctY2hlY2tlZFwiPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJyZXNldC1pbnB1dCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy1yYWRpby1idXR0b24taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwiYm9vbGVhblwiIHZhbHVlPVwiXCIgY2hlY2tlZC8+ICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgICAgICAgPHNwYW4+JHt0aGlzLl9ib29sZWFuRmlsdGVyVHJhbnNsYXRpb24ucmVzZXR9PC9zcGFuPlxuICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgfSAgICAgICBcbiAgICAgICAgPC9kaXY+XG4gICAgYFxuXG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vblJhZGlvQ2hhbmdlKVxuXG4gICAgdGhpcy5fZ3VpLmFwcGVuZENoaWxkKGJvZHkpXG5cbiAgICAvLyBjcmVhdGUgYXBwbHkgZmlsdGVyIHBhbmVsXG4gICAgY29uc3QgYXBwbHlGaWx0ZXJQYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgYXBwbHlGaWx0ZXJQYW5lbC5jbGFzc05hbWUgPSBgYm9vbGVhbkZpbHRlcl9fYm9keV9fYXBwbHlQYW5lbCBhZy1maWx0ZXItYXBwbHktcGFuZWwgYWctaGlkZGVuYFxuICAgIGFwcGx5RmlsdGVyUGFuZWwuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYWctc3RhbmRhcmQtYnV0dG9uIGFnLWZpbHRlci1hcHBseS1wYW5lbC1idXR0b24gY2xlYXIgJHshaXNDbGVhckZpbHRlciAmJlxuICAgICAgICAnYWctaGlkZGVuJ31cIiB0eXBlPVwiYnV0dG9uXCI+JHt0cmFuc2xhdGUoXG4gICAgICAnY2xlYXJGaWx0ZXInLFxuICAgICAgJ0NsZWFyIEZpbHRlcidcbiAgICApfTwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImFnLXN0YW5kYXJkLWJ1dHRvbiBhZy1maWx0ZXItYXBwbHktcGFuZWwtYnV0dG9uIHJlc2V0ICR7IWlzUmVzZXRCdXR0b24gJiZcbiAgICAgICAgJ2FnLWhpZGRlbid9XCIgdHlwZT1cImJ1dHRvblwiPiR7dHJhbnNsYXRlKFxuICAgICAgJ3Jlc2V0RmlsdGVyJyxcbiAgICAgICdSZXNldCBGaWx0ZXInXG4gICAgKX08L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJhZy1zdGFuZGFyZC1idXR0b24gYWctZmlsdGVyLWFwcGx5LXBhbmVsLWJ1dHRvbiBhcHBseSAkeyFpc0FwcGx5QnV0dG9uICYmXG4gICAgICAgICdhZy1oaWRkZW4nfVwiIHR5cGU9XCJidXR0b25cIj4ke3RyYW5zbGF0ZShcbiAgICAgICdhcHBseUZpbHRlcicsXG4gICAgICAnQXBwbHkgRmlsdGVyJ1xuICAgICl9PC9idXR0b24+XG4gICAgYFxuXG4gICAgaWYgKGlzQ2xlYXJGaWx0ZXIgfHwgaXNSZXNldEJ1dHRvbiB8fCBpc0FwcGx5QnV0dG9uKSB7XG4gICAgICBhcHBseUZpbHRlclBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWhpZGRlbicpXG4gICAgfVxuXG4gICAgYXBwbHlGaWx0ZXJQYW5lbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIHRoaXMuX0FwcGx5RmlsdGVyUGFuZWxCdXR0b25DbGlja1xuICAgIClcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChhcHBseUZpbHRlclBhbmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9ndWlcbiAgICAgIC5xdWVyeVNlbGVjdG9yKCcuYm9vbGVhbkZpbHRlcl9fYm9keV9fbGFiZWxzJylcbiAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vblJhZGlvQ2hhbmdlKVxuXG4gICAgdGhpcy5fZ3VpXG4gICAgICAucXVlcnlTZWxlY3RvcignLmJvb2xlYW5GaWx0ZXJfX2JvZHlfX2FwcGx5UGFuZWwnKVxuICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fQXBwbHlGaWx0ZXJQYW5lbEJ1dHRvbkNsaWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgc2VsZWN0ZWQgZmlsdGVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZWxsIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gcGFzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBkb2VzRmlsdGVyUGFzcyhwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICB0aGlzLl9wYXJhbXMuaGFzT3duUHJvcGVydHkoJ2ZpbHRlclZhbHVlR2V0dGVyJylcbiAgICAgICAgPyB0aGlzLl9wYXJhbXMuZmlsdGVyVmFsdWVHZXR0ZXIocGFyYW1zKVxuICAgICAgICA6IHRoaXMuX3BhcmFtcy52YWx1ZUdldHRlcihwYXJhbXMpXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuX2ZpbHRlclRleHQgPT09ICd0cnVlJ1xuICAgICAgPyB0aGlzLl90cnVlVmFsdWUuaW5kZXhPZih2YWx1ZSkgPiAtMVxuICAgICAgOiB0aGlzLl9mYWxzZVZhbHVlLmluZGV4T2YodmFsdWUpID4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBjb21wb25lbnQgaXMgYXBwbHlpbmcgYW55IGZpbHRlciBvbiB0aGUgY29sdW1uXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqKi9cbiAgaXNGaWx0ZXJBY3RpdmUoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX2ZpbHRlclRleHQgIT09IG51bGwgJiZcbiAgICAgIHRoaXMuX2ZpbHRlclRleHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdGhpcy5fZmlsdGVyVGV4dCAhPT0gJydcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsdGVyIHN0YXRlLiBJZiBmaWx0ZXIgaXMgbm90IGFjdGl2ZSwgdGhlbiBzaG91bGQgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKiBUaGUgZ3JpZCBjYWxscyBnZXRNb2RlbCgpIG9uIGFsbCBhY3RpdmUgZmlsdGVycyB3aGVuIGdyaWRBcGkuZ2V0RmlsdGVyTW9kZWwoKSBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm4gT2JqZWN0IHwgbnVsbCB0aGUgZmlsdGVyIHN0YXRlXG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICBpZiAoIXRoaXMuaXNGaWx0ZXJBY3RpdmUoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBtb2RlbCA9IHsgdmFsdWU6IHRoaXMuX2ZpbHRlclRleHQsIGZpbHRlclR5cGU6ICdib29sZWFuJyB9XG4gICAgcmV0dXJuIG1vZGVsXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGZpbHRlciBzdGF0ZS4gQ2FsbGVkIGJ5IHRoZSBncmlkIGFmdGVyIGdyaWRBcGkuc2V0RmlsdGVyTW9kZWwobW9kZWwpIGlzIGNhbGxlZC5cbiAgICogVGhlIGdyaWQgd2lsbCBwYXNzIHVuZGVmaW5lZC9udWxsIHRvIGNsZWFyIHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gbW9kZWxcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG4gICAgdGhpcy5fZmlsdGVyVGV4dCA9IG1vZGVsICYmIG1vZGVsLmhhc093blByb3BlcnR5KCd2YWx1ZScpID8gbW9kZWwudmFsdWUgOiAnJ1xuXG4gICAgY29uc3QgZmlsdGVyVGV4dEFzU3RyaW5nID0gU3RyaW5nKHRoaXMuX2ZpbHRlclRleHQpXG4gICAgY29uc3QgYm9keSA9IHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCcuYm9vbGVhbkZpbHRlcl9fYm9keScpXG4gICAgYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5mb3JFYWNoKGkgPT4ge1xuICAgICAgaWYgKGkudmFsdWUgPT0gZmlsdGVyVGV4dEFzU3RyaW5nKSB7XG4gICAgICAgIGkuY2hlY2tlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkuY2hlY2tlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbHRlciBtb2RlbCBhcyBwbGFpbiBzdHJpbmcgdG8gZGlzcGxheSBpbiB0aGUgZmxvYXRpbmcgZmlsdGVyIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gbW9kZWxcbiAgICovXG4gIGdldE1vZGVsQXNTdHJpbmcobW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaXBIVE1MKFxuICAgICAgbW9kZWwudmFsdWUgPT09ICd0cnVlJ1xuICAgICAgICA/IHRoaXMuX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbi50cnVlXG4gICAgICAgIDogdGhpcy5fYm9vbGVhbkZpbHRlclRyYW5zbGF0aW9uLmZhbHNlXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBmaWx0ZXIgc3RhdGVcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmJvb2xlYW5GaWx0ZXJfX2JvZHknKVxuICAgIGJvZHkucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdJykuZm9yRWFjaChpID0+IHtcbiAgICAgIGkuY2hlY2tlZCA9IGZhbHNlXG4gICAgfSlcblxuICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItdHJ1ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItZmFsc2UnKS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICB0cnkge1xuICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1yZXNldCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIHBhc3MgKi9cbiAgICB9XG5cbiAgICB0aGlzLl9maWx0ZXJUZXh0ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBzZWxlY3Rpb24gY2hhbmdlcyBpbiB0aGUgZmlsdGVyIHJhZGlvIGJ1dHRvbnMgYW5kIHVwZGF0ZSB0aGUgY3VycmVudCBmaWx0ZXIgdGV4dFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBfb25SYWRpb0NoYW5nZShpc0FwcGx5QnV0dG9uLCBlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcbiAgICB0aGlzLl9maWx0ZXJUZXh0ID0gdGFyZ2V0LnZhbHVlXG5cbiAgICBjb25zdCBib2R5ID0gdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5ib29sZWFuRmlsdGVyX19ib2R5JylcblxuICAgIGlmIChib2R5KSB7XG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygndHJ1ZS1pbnB1dCcpKSB7XG4gICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItdHJ1ZScpLmNsYXNzTGlzdC5hZGQoJ2FnLWNoZWNrZWQnKVxuICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLWZhbHNlJykuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1yZXNldCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogcGFzcyAqL1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZhbHNlLWlucHV0JykpIHtcbiAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci10cnVlJykuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItZmFsc2UnKS5jbGFzc0xpc3QuYWRkKCdhZy1jaGVja2VkJylcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLXJlc2V0JykuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvKiBwYXNzICovXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItdHJ1ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLWZhbHNlJykuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1yZXNldCcpLmNsYXNzTGlzdC5hZGQoJ2FnLWNoZWNrZWQnKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogcGFzcyAqL1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhbHNlID09PSBpc0FwcGx5QnV0dG9uKSB7XG4gICAgICB0aGlzLl9wYXJhbXMuZmlsdGVyQ2hhbmdlZENhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIHRoZSBidXR0b24gY2xpY2tzIGluIHRoZSBidXR0b25zIHBhbmVsIGFuZCBhcHBseSB0aGUgY2hvc2VuIGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX0FwcGx5RmlsdGVyUGFuZWxCdXR0b25DbGljayhlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcblxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncmVzZXQnKSkge1xuICAgICAgICB0aGlzLnJlc2V0KClcbiAgICAgICAgdGhpcy5fcGFyYW1zLmZpbHRlckNoYW5nZWRDYWxsYmFjaygpXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2NsZWFyJykpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwcGx5JykpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmZpbHRlckNoYW5nZWRDYWxsYmFjaygpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5GaWx0ZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuRmlsdGVyL0Jvb2xlYW5GaWx0ZXIuanMiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmhlYWRcbiAgICAgICAgICAgICAgfTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhbkZpbHRlci9zdHlsZS5zY3NzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuYm9vbGVhbkZpbHRlcl9fYm9keV9fbGFiZWxzIGxhYmVse2Rpc3BsYXk6YmxvY2s7cGFkZGluZzo2cHh9LmJvb2xlYW5GaWx0ZXJfX2JvZHlfX2xhYmVscyBsYWJlbHtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6NnB4IDB9LmJvb2xlYW5GaWx0ZXJfX2JvZHlfX2xhYmVscyBsYWJlbCBzcGFue3BhZGRpbmctbGVmdDo2cHh9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9Cb29sZWFuRmlsdGVyL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBOdW1iZXJFZGl0b3IgZnJvbSAnLi9OdW1iZXJFZGl0b3InXG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL051bWJlckVkaXRvci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlIH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuXG5pbXBvcnQgJy4vc3R5bGUuc2NzcydcblxuLyoqXG4gKiBOdW1iZXJzIEVkaXRvclxuICpcbiAqIEhhbmRsZSBudW1iZXIgdmFsdWVzIEVkaXRpbmdcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKm51bWJlck1pblZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IG1pbiBhbGxvd2VkIHZhbHVlXG4gKiB8ICoqbnVtYmVyTWF4VmFsdWUqKiAgIHwgdW5kZWZpbmVkICAgIHwgbWF4IGFsbG93ZWQgdmFsdWVcbiAqIHwgKipudW1iZXJTdGVwVmFsdWUqKiAgICAgICB8IHVuZGVmaW5lZCAgXHR8IG51bWJlciBvZiBzdGVwIGJ5IGluY3JlbWVudCBvciBkZWNyZW1lbnRcbiAqIHwgKipudW1iZXJNYXNrKiogICAgICAgfCB1bmRlZmluZWQgIFx0fCBhIGJiaiBudW1iZXIgbWFzayB0byB2YWxpZGF0ZSB0aGUgbnVtYmVyIGFnYWluc3RcbiAqIHwqKm51bWJlckdyb3VwaW5nU2VwYXJhdG9yKiogfCAsIHwgYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGdyb3VwaW5nIHNlcGFyYXRvci4gVGhlIG9wdGlvbnMgaXMgdXNlZCBvbmx5IHdoZW4gKipudW1iZXJNYXNrKiogaXMgZGVmaW5lZCB8XG4gKiB8KipudW1iZXJEZWNpbWFsU2VwYXJhdG9yKiogfCAuIHwgYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGRlY2ltYWwgc2VwYXJhdG9yLiBUaGUgb3B0aW9ucyBpcyB1c2VkIG9ubHkgd2hlbiAqKm51bWJlck1hc2sqKiBpcyBkZWZpbmVkICB8XG4gKiB8KipudW1iZXJGb3JjZVRyYWlsaW5nWmVyb3MqKiB8IGZhbHNlIHwgQWZmZWN0cyB0aGUgb3V0cHV0IGJ5IHN3aXRjaGluZyB0aGUgd2F5IGEgbWFzayB3aXRoIFwiI1wiIGNoYXJhY3RlcnMgaW4gdGhlIHRyYWlsaW5nIHBvc2l0aW9ucyBpcyBmaWxsZWQuIGZvciBleGFtcGxlLCB0aGUgZnVuY3Rpb24gTnVtYmVyTWFzay5tYXNrKC4xMDpcIiMuIyNcIikgcmV0dXJucyAuMTAgaW5zdGVhZCBvZiAuMSAuIFRoZSBvcHRpb25zIGlzIHVzZWQgb25seSB3aGVuICoqbnVtYmVyTWFzayoqIGlzIGRlZmluZWR8XG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgTnVtYmVyRWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5nZXRPcHRpb24oJ251bWJlck1pblZhbHVlJywgcGFyYW1zKVxuICAgIGNvbnN0IG1heCA9IHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJNYXhWYWx1ZScsIHBhcmFtcylcbiAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRPcHRpb24oJ251bWJlclN0ZXBWYWx1ZScsIHBhcmFtcylcbiAgICBjb25zdCBtYXNrID0gdGhpcy5nZXRPcHRpb24oJ251bWJlck1hc2snLCBwYXJhbXMpXG5cbiAgICBsZXQgc3RhcnRWYWx1ZVxuXG4gICAgdGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkID0gcGFyYW1zLmNlbGxTdGFydGVkRWRpdFxuICAgIGlmICh0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIGxldCBrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlID1cbiAgICAgICAgcGFyYW1zLmtleVByZXNzID09IDMyIHx8IHBhcmFtcy5rZXlQcmVzcyA9PSA0NiAvLyBzcGFjZSAvLyBkZWxldGVcblxuICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgc3RhcnRWYWx1ZSA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jaGFyUHJlc3MpIHtcbiAgICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy5jaGFyUHJlc3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICAgICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPSAxMTMpIHtcbiAgICAgICAgICAvL0YyXG4gICAgICAgICAgdGhpcy5faGlnaGxpZ2h0QWxsT25Gb2N1cyA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgfVxuXG4gICAgLy8gbWFrZSBwYXJhbXMgaXQgYWNjZXNzaWJsZSBmcm9tIHRhbGwgbWV0aG9kc1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtc1xuXG4gICAgLy8gY3JlYXRlIHRoZSBpbnB1dCB3cmFwcGVyXG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnbnVtYmVyRWRpdG9yIGFnLWNlbGwtZWRpdC13cmFwcGVyJ1xuICAgIHRoaXMuX2d1aS50YWJJbmRleCA9ICcwJ1xuICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSAvKiBodG1sICovIGBcbiAgICA8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0b3IgYWctbGFiZWxlZCBhZy1sYWJlbC1hbGlnbi1sZWZ0IGFnLXRleHQtZmllbGQgYWctaW5wdXQtZmllbGRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctdGV4dC1maWVsZC1pbnB1dC13cmFwcGVyXCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgXG5cbiAgICAvLyBjcmVhdGUgdGhlIGlucHV0XG4gICAgdGhpcy5faW5wdXRHZW5lcmF0ZWRJZCA9IE1hdGgucmFuZG9tKClcbiAgICAgIC50b1N0cmluZygxNilcbiAgICAgIC5zbGljZSgyLCAxMCkgLy8gZ2VuZXJhdGUgcmFuZG9tIGlkXG4gICAgdGhpcy5faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgdGhpcy5faW5wdXQuY2xhc3NOYW1lID0gJ251bWJlckVkaXRvcl9faW5wdXQgYWctY2VsbC1lZGl0LWlucHV0J1xuICAgIHRoaXMuX2lucHV0LmlkID0gYGVsLSR7dGhpcy5faW5wdXRHZW5lcmF0ZWRJZH1gXG4gICAgdGhpcy5faW5wdXQudHlwZSA9IG1hc2sgPyAndGV4dCcgOiAnbnVtYmVyJ1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID0gc3RhcnRWYWx1ZVxuICAgIHRoaXMuX2lucHV0LnRhYkluZGV4ID0gMFxuXG4gICAgLy8gcGxhY2UgdGhlIGlucHV0IGluc2lkZSB0aGUgd3JhcHBlclxuICAgIHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCcuYWctaW5wdXQtd3JhcHBlcicpLmFwcGVuZENoaWxkKHRoaXMuX2lucHV0KVxuXG4gICAgaWYgKG1pbiAhPT0gbnVsbCkge1xuICAgICAgbWFzayA/ICh0aGlzLl9pbnB1dC5kYXRhc2V0Lm1pbiA9IG1pbikgOiAodGhpcy5faW5wdXQubWluID0gbWluKVxuICAgIH1cblxuICAgIGlmIChtYXggIT09IG51bGwpIHtcbiAgICAgIG1hc2sgPyAodGhpcy5faW5wdXQuZGF0YXNldC5tYXggPSBtYXgpIDogKHRoaXMuX2lucHV0Lm1heCA9IG1heClcbiAgICB9XG5cbiAgICBpZiAoc3RlcCAhPT0gbnVsbCkge1xuICAgICAgbWFzayA/ICh0aGlzLl9pbnB1dC5kYXRhc2V0LnN0ZXAgPSBzdGVwKSA6ICh0aGlzLl9pbnB1dC5zdGVwID0gc3RlcClcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIG1hc2sgdGhlbiB3ZSB1c2UgdGhlIGBCYXNpcy5JbnB1dE1hc2tpbmcuTnVtYmVySW5wdXRgXG4gICAgaWYgKG1hc2spIHtcbiAgICAgIGNvbnN0IGdyb3VwaW5nU2VwYXJhdG9yID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAgICdudW1iZXJHcm91cGluZ1NlcGFyYXRvcicsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdGhpcy5nZXRPcHRpb24oJ251bWJlckdyb3VwU2VwJywgcGFyYW1zKVxuICAgICAgKVxuICAgICAgY29uc3QgZGVjaW1hbFNlcGFyYXRvciA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgICAnbnVtYmVyRGVjaW1hbFNlcGFyYXRvcicsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgdGhpcy5nZXRPcHRpb24oJ251bWJlckRlY2ltYWxTZXAnLCBwYXJhbXMpXG4gICAgICApXG4gICAgICBjb25zdCBmb3JjZVRyYWlsaW5nWmVyb3MgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICAgJ251bWJlckZvcmNlVHJhaWxpbmdaZXJvcycsXG4gICAgICAgIHBhcmFtc1xuICAgICAgKVxuXG4gICAgICBpZiAoZ3JvdXBpbmdTZXBhcmF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuZGF0YXNldC5ncm91cGluZ1NlcGFyYXRvciA9IGdyb3VwaW5nU2VwYXJhdG9yXG4gICAgICB9XG5cbiAgICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmRhdGFzZXQuZGVjaW1hbFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3JcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlVHJhaWxpbmdaZXJvcyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5kYXRhc2V0LmZvcmNlVHJhaWxpbmdaZXJvcyA9IGZvcmNlVHJhaWxpbmdaZXJvc1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbnB1dC5kYXRhc2V0Lm1hc2sgPSBtYXNrXG4gICAgICB0aGlzLl9udW1iZXJJbnB1dCA9IG5ldyBCYXNpcy5JbnB1dE1hc2tpbmcuTnVtYmVySW5wdXQoe1xuICAgICAgICBlbGVtZW50czogW3RoaXMuX2lucHV0XSxcbiAgICAgICAgLy8gZG9jOiB0aGlzLmdldERvYyhwYXJhbXMpLFxuICAgICAgICBvblVwZGF0ZTogdGhpcy5fb25OdW1iZXJJbnB1dFVwZGF0ZSxcbiAgICAgICAgb25JbnZhbGlkOiB0aGlzLl9vbk51bWJlcklucHV0SW52YWxpZCxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbkNvbXBvbmVudEtleURvd24pXG5cbiAgICAvLyB1cGRhdGUgYGN1cnJlbnRWYWx1ZWAgdGhlIHZhbHVlIHdoaWNoIHRoaXMgY29tcG9uZW50IGlzIG1hbmFnaW5nXG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gc3RhcnRWYWx1ZVxuICAgIHRoaXMuX19pc01hc2tlZF9fID0gbWFzayAmJiBtYXNrLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9faXNNYXNrZWRfXykge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbnVtYmVySW5wdXQuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbkNvbXBvbmVudEtleURvd24pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBHVUkgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICAgKlxuICAgKiBNYWtlIHN1cmUgY29udGFpbmVyIGlzIGFsd2F5cyBmb2N1c2VkIHRvIGxpc3RlbiB0byBrZXkgY2hhbmdlc1xuICAgKi9cbiAgYWZ0ZXJHdWlBdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX19pc01hc2tlZF9fKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlucHV0KHRoaXMuX2lucHV0KVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9oaWdobGlnaHRBbGxPbkZvY3VzKSB7XG4gICAgICB0aGlzLl9pbnB1dC5zZWxlY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IGNhc3RlZCA9IE51bWJlcih0aGlzLl9jdXJyZW50VmFsdWUpXG4gICAgY29uc3QgcmV0VmFsdWUgPSBpc05hTihjYXN0ZWQpID8gdGhpcy5fY3VycmVudFZhbHVlIDogY2FzdGVkXG4gICAgcmV0dXJuIHRoaXMuX19pc01hc2tlZF9fID8gcmV0VmFsdWUgOiB0aGlzLl9wYXJhbXMucGFyc2VWYWx1ZShyZXRWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBkb2luZyBmdWxsIHJvdyBlZGl0LCB0aGVuIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyBpbnRvIHRoZSBjZWxsLlxuICAgKi9cbiAgZm9jdXNJbigpIHtcbiAgICBpZiAoIXRoaXMuX19pc01hc2tlZF9fKSB7XG4gICAgICB0aGlzLl9pbnB1dC5mb2N1cygpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LmNsaWNrKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBpbml0aWFsaXplZCBhbmQgcmV0dXJucyBmYWxzZSBzbyB0aGUgZWRpdG9yIGFwcGVhcnMgaW4gdGhlIGNlbGxcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYWx3YXlzIGZhbHNlXG4gICAqKi9cbiAgaXNQb3B1cCgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYGN1cnJlbnRWYWx1ZWAgd2hlbiB0aGUgY2hlY2tib3ggdmFsdWUgaXMgY2hhbmdlZFxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KGV2ZW50LnRhcmdldClcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5faW5wdXQudmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIHdoZW4gdGhlIE51bWJlcklucHV0IGNvbXBvbmVudHMgZmlyZSB0aGUgdXBkYXRlXG4gICAqIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gX21hc2tlZCAgdGhlIG1hc2tlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdW5tYXNrZWQgIHRoZSB1bm1hc2tlZCB2YWx1ZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbk51bWJlcklucHV0VXBkYXRlKF9tYXNrZWQsIHVubWFza2VkKSB7XG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gdW5tYXNrZWRcbiAgICB0aGlzLmZvY3VzSW4oKVxuICAgIC8vIHdlIHBhc3MgdGhlIGxhc3QgY2FwdHVyZWQgZXZlbnQgYmFjayB0byB0aGUgZ3JpZCB0byBoYW5kbGUgaXQgaW50ZXJuYWxseVxuICAgIGlmICh0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXykge1xuICAgICAgdGhpcy5fcGFyYW1zLm9uS2V5RG93bih0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXylcbiAgICAgIHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fID0gbnVsbFxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT24gaW52YWxpZCBpbnB1dHMgLCB1cGRhdGUgdGhlIGlucHV0IHdpdGggYSBjdXN0b20gdmFsaWRpdHkgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVycm9yIHRoZSBlcnJvciBtZXNzYWdlIHJlcG9ydGVkIGJ5IE51bWJlcklucHV0XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgaW5zdGFuY2VcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25OdW1iZXJJbnB1dEludmFsaWQoZXJyb3IsIGlucHV0KSB7XG4gICAgdGhpcy5mb2N1c0luKClcbiAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgY2VsbFxuICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX3BhcmFtcy52YWx1ZVxuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnB1dC5zZXRDdXN0b21WYWxpZGl0eShlcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FwdHVyZSBhbGwga2V5Ym9hcmQgZXZlbnRzIHRvIGFsbG93IHZhbHVlIHByb2Nlc3NpbmcgYnkgdGhlIE51bWJlcklucHV0IGNvbXBvbmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25Db21wb25lbnRLZXlEb3duKGUpIHtcbiAgICBjb25zdCBrZXkgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBjb25zdCBpc05hdmlnYXRpb25LZXkgPVxuICAgICAga2V5ID09PSAzNyB8fCAvLyBsZWZ0XG4gICAgICBrZXkgPT09IDM4IHx8IC8vIHVwXG4gICAgICBrZXkgPT09IDM5IHx8IC8vIHJpZ2h0XG4gICAgICBrZXkgPT09IDQwIHx8IC8vIGRvd25cbiAgICAgIGtleSA9PT0gMzMgfHwgLy8gcGFnZSB1cFxuICAgICAga2V5ID09PSAzNCB8fCAvLyBwYWdlIGRvd25cbiAgICAgIGtleSA9PT0gMzUgfHwgLy8gcGFnZSBob21lXG4gICAgICBrZXkgPT09IDM2IHx8IC8vIHBhZ2UgZW5kXG4gICAgICBrZXkgPT09IDEzIC8vIGVudGVyXG5cbiAgICBpZiAoaXNOYXZpZ2F0aW9uS2V5KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgLy8gc2F2ZSB0aGUgbGFzdCBjYXB0dXJlIGtleSBzbyBOdW1iZXJJbnB1dCBjYW4gcGFzcyBpdCBhZ2FpbiB0byB0aGUgZ3JpZC5cbiAgICAgIHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fID0gZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8ga2V5IGNoYW5nZXMgYW5kIHZhbGlkYXRlIHRoZSBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbklucHV0S2V5RG93blVwKGV2ZW50KSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuX3ZhbGlkYXRlSW5wdXQoZXZlbnQudGFyZ2V0KVxuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlXG5cbiAgICBpZiAoa2V5ID09IDM4IHx8IGtleSA9PSA0MCkge1xuICAgICAgLy8gdG9wIHwgZG93blxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5faW5wdXQudmFsdWVcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfSBlbHNlIGlmIChrZXkgPT0gMTMgfHwga2V5ID09PSA5KSB7XG4gICAgICAvLyBlbnRlclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5faW5wdXQudmFsdWVcbiAgICB9XG5cbiAgICAvLyB3ZSBwYXNzIHRoZSBsYXN0IGNhcHR1cmVkIGV2ZW50IGJhY2sgdG8gdGhlIGdyaWQgdG8gaGFuZGxlIGl0IGludGVybmFsbHlcbiAgICBpZiAodGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pIHtcbiAgICAgIHRoaXMuX3BhcmFtcy5vbktleURvd24odGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pXG4gICAgICB0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXyA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGdpdmVuIGlucHV0IGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gaW5wdXQuY2hlY2tWYWxpZGl0eSgpXG5cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2Jiai1tYXNrLWVycm9yJylcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2Jiai1tYXNrLXN1Y2Nlc3MnKVxuICAgICAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX3BhcmFtcy52YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdiYmotbWFzay1lcnJvcicpXG4gICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdiYmotbWFzay1zdWNjZXNzJylcbiAgICB9XG5cbiAgICByZXR1cm4gaXNWYWxpZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE51bWJlckVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL051bWJlckVkaXRvci9OdW1iZXJFZGl0b3IuanMiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmhlYWRcbiAgICAgICAgICAgICAgfTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTnVtYmVyRWRpdG9yL3N0eWxlLnNjc3MiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5udW1iZXJFZGl0b3J7b3ZlcmZsb3c6aGlkZGVufS5udW1iZXJFZGl0b3IgLm51bWJlcklucHV0TWFza19fd3JhcHt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdXRsaW5lOm5vbmU7ZGlzcGxheTpibG9jaztwYWRkaW5nOjA7bWFyZ2luOjA7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG87YWxpZ24taXRlbXM6Y2VudGVyO2xpbmUtaGVpZ2h0Om5vcm1hbDtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59Lm51bWJlckVkaXRvciAuYmJqLW1hc2stZXJyb3J7Ym94LXNoYWRvdzowIC0ycHggMCAjZTkxZTYzIGluc2V0fS5udW1iZXJFZGl0b3IgLmJiai1tYXNrLXN1Y2Nlc3N7Ym94LXNoYWRvdzowIC0ycHggMCAjNGNhZjUwIGluc2V0fS5udW1iZXJFZGl0b3JfX2lucHV0e3BhZGRpbmctbGVmdDo2cHg7Ym9yZGVyOnRoaW4gc29saWQgdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCByZ2JhKDMzLDE1MCwyNDMsMC40KSk7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yKTtjb2xvcjppbmhlcml0fS5hZy10aGVtZS1hbHBpbmUgLm51bWJlckVkaXRvcl9faW5wdXQsLmFnLXRoZW1lLWJhbGhhbSAubnVtYmVyRWRpdG9yX19pbnB1dCwuYWctdGhlbWUtbWF0ZXJpYWwgLm51bWJlckVkaXRvcl9faW5wdXR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKX0uYWctdGhlbWUtYWxwaW5lLWRhcmsgLm51bWJlckVkaXRvcl9faW5wdXQsLmFnLXRoZW1lLWJhbGhhbS1kYXJrIC5udW1iZXJFZGl0b3JfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzJkMzQzNil9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9OdW1iZXJFZGl0b3Ivc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IFRleHRFZGl0b3IgZnJvbSAnLi9UZXh0RWRpdG9yJ1xuXG5leHBvcnQgZGVmYXVsdCBUZXh0RWRpdG9yXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGV4dEVkaXRvci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlIH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuXG5pbXBvcnQgJy4vc3R5bGUuc2NzcydcblxuLyoqXG4gKiBUZXh0IEVkaXRvclxuICpcbiAqIEhhbmRsZSB0ZXh0IHZhbHVlcyBFZGl0aW5nXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKip0ZXh0UGF0dGVybioqICAgfCB1bmRlZmluZWQgICAgfCBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHRoZSBpbnB1dCdzIHZhbHVlIG11c3QgbWF0Y2ggaW4gb3JkZXIgZm9yIHRoZSB2YWx1ZSB0byBwYXNzIGNvbnN0cmFpbnQgdmFsaWRhdGlvblxuICogfCAqKnRleHRSZXF1aXJlZCoqICAgfCB1bmRlZmluZWQgICAgfCBCb29sZWFuLiBBIHZhbHVlIGlzIHJlcXVpcmVkIHRvIGNvbnNpZGVyIHRoZSBpbnB1dCB2YWxpZFxuICogfCAqKnRleHRNYXNrKiogICB8IHVuZGVmaW5lZCAgICB8IEEgYmJqIHN0cmluZyBtYXNrIHRvIHZhbGlkYXRlIHRoZSB2YWx1ZVxuICogfCAqKnRleHRUaXRsZSoqICAgfCBudWxsICAgIHwgVGhlIGlucHV0IHRpdGxlICwgd2hlbiBudWxsIGFuZCB0aGUgKip0ZXh0TWFzayoqIG9wdGlvbnMgaXMgZGVmaW5lZCAsIHRoZW4gd2UgdXNlIHRoZSBtYXNrIGFzIHRpdGxlICwgd2hlbiBzZXQgdG8gYGRlZmF1bHRgIHdlIHRoZSBicm93c2VyJ3MgZGVmYXVsdCB0aXRsZSAsIG90aGVyd2lzZSB0aGUgdmFsdWUgZGVmaW5lZCBpbiB0aGlzIG9wdGlvblxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIFRleHRFZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgaW5pdChwYXJhbXMpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5nZXRPcHRpb24oJ3RleHRQYXR0ZXJuJywgcGFyYW1zKVxuICAgIGNvbnN0IHJlcXVpcmVkID0gdGhpcy5nZXRPcHRpb24oJ3RleHRSZXF1aXJlZCcsIHBhcmFtcylcbiAgICBjb25zdCBtYXNrID0gdGhpcy5nZXRPcHRpb24oJ3RleHRNYXNrJywgcGFyYW1zKVxuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5nZXRPcHRpb24oJ3RleHRUaXRsZScsIHBhcmFtcylcblxuICAgIGxldCBzdGFydFZhbHVlXG5cbiAgICB0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0XG4gICAgaWYgKHRoaXMuX2ZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xuICAgICAgbGV0IGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUgPVxuICAgICAgICBwYXJhbXMua2V5UHJlc3MgPT0gMzIgfHwgcGFyYW1zLmtleVByZXNzID09IDQ2IC8vIHNwYWNlIC8vIGRlbGV0ZVxuXG4gICAgICBpZiAoa2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSkge1xuICAgICAgICBzdGFydFZhbHVlID0gJydcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmNoYXJQcmVzcykge1xuICAgICAgICBzdGFydFZhbHVlID0gcGFyYW1zLmNoYXJQcmVzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy52YWx1ZVxuICAgICAgICBpZiAocGFyYW1zLmtleVByZXNzICE9IDExMykge1xuICAgICAgICAgIC8vRjJcbiAgICAgICAgICB0aGlzLl9oaWdobGlnaHRBbGxPbkZvY3VzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcblxuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICd0ZXh0RWRpdG9yIGFnLWNlbGwtZWRpdC13cmFwcGVyJ1xuICAgIHRoaXMuX2d1aS50YWJJbmRleCA9ICcwJ1xuICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSAvKiBodG1sICovIGBcbiAgICA8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0b3IgYWctbGFiZWxlZCBhZy1sYWJlbC1hbGlnbi1sZWZ0IGFnLXRleHQtZmllbGQgYWctaW5wdXQtZmllbGRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctdGV4dC1maWVsZC1pbnB1dC13cmFwcGVyXCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgXG5cbiAgICAvLyBpbnB1dFxuICAgIHRoaXMuX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIHRoaXMuX2lucHV0LmNsYXNzTmFtZSA9XG4gICAgICAndGV4dEVkaXRvcl9faW5wdXQgYWctY2VsbC1lZGl0LWlucHV0IGFnLWlucHV0LWZpZWxkLWlucHV0IGFnLXRleHQtZmllbGQtaW5wdXQnXG4gICAgdGhpcy5faW5wdXQuaWQgPSBgZWwtJHtNYXRoLnJhbmRvbSgpXG4gICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAuc2xpY2UoMiwgMTApfWAgLy8gZ2VuZXJhdGUgcmFuZG9tIGlkXG4gICAgdGhpcy5faW5wdXQudHlwZSA9ICd0ZXh0J1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID0gc3RhcnRWYWx1ZVxuICAgIHRoaXMuX2lucHV0LnRhYkluZGV4ID0gMFxuXG4gICAgdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1pbnB1dC13cmFwcGVyJykuYXBwZW5kQ2hpbGQodGhpcy5faW5wdXQpXG5cbiAgICBpZiAocGF0dGVybiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKCdwYXR0ZXJuJywgcGF0dGVybilcbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZSgncmVxdWlyZWQnLCAncmVxdWlyZWQnKVxuICAgIH1cblxuICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRpdGxlICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdGhpcy5faW5wdXQudGl0bGUgPSB0aXRsZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWFzaykge1xuICAgICAgdGhpcy5faW5wdXQudGl0bGUgPSBtYXNrXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBtYXNrIHRoZW4gd2UgdXNlIHRoZSBgQmFzaXMuSW5wdXRNYXNraW5nLlRleHRJbnB1dGBcbiAgICBpZiAobWFzaykge1xuICAgICAgdGhpcy5faW5wdXQuZGF0YXNldC5tYXNrID0gbWFza1xuICAgICAgdGhpcy5fdGV4dElucHV0ID0gbmV3IEJhc2lzLklucHV0TWFza2luZy5UZXh0SW5wdXQoe1xuICAgICAgICBlbGVtZW50czogW3RoaXMuX2lucHV0XSxcbiAgICAgICAgZG9jOiB0aGlzLmdldERvYyhwYXJhbXMpLFxuICAgICAgICBvblVwZGF0ZTogdGhpcy5fb25UZXh0SW5wdXRVcGRhdGUsXG4gICAgICAgIG9uSW52YWxpZDogdGhpcy5fb25UZXh0SW5wdXRJbnZhbGlkLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKVxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbkNvbXBvbmVudEtleURvd24pXG5cbiAgICAvLyB1cGRhdGUgYGN1cnJlbnRWYWx1ZWAgdGhlIHZhbHVlIHdoaWNoIHRoaXMgY29tcG9uZW50IGlzIG1hbmFnaW5nXG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gc3RhcnRWYWx1ZVxuICAgIHRoaXMuX19pc01hc2tlZF9fID0gbWFzayAmJiBtYXNrLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLl9faXNNYXNrZWRfXykge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uSW5wdXRLZXlEb3duVXApXG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKVxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RleHRJbnB1dC5kZXN0cm95KClcbiAgICB9XG5cbiAgICB0aGlzLl9ndWkucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uQ29tcG9uZW50S2V5RG93bilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBvbmNlIGFmdGVyIEdVSSBpcyBhdHRhY2hlZCB0byBET00uXG4gICAqXG4gICAqIE1ha2Ugc3VyZSBjb250YWluZXIgaXMgYWx3YXlzIGZvY3VzZWQgdG8gbGlzdGVuIHRvIGtleSBjaGFuZ2VzXG4gICAqL1xuICBhZnRlckd1aUF0dGFjaGVkKCkge1xuICAgIGlmICghdGhpcy5fX2lzTWFza2VkX18pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5wdXQodGhpcy5faW5wdXQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hpZ2hsaWdodEFsbE9uRm9jdXMpIHtcbiAgICAgIHRoaXMuX2lucHV0LnNlbGVjdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgICAgdGhpcy5mb2N1c0luKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IFRoZSBjb21wb25lbnQgdmFsdWVcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5wYXJzZVZhbHVlKHRoaXMuX2N1cnJlbnRWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBkb2luZyBmdWxsIHJvdyBlZGl0LCB0aGVuIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyBpbnRvIHRoZSBjZWxsLlxuICAgKi9cbiAgZm9jdXNJbigpIHtcbiAgICB0aGlzLl9pbnB1dC5mb2N1cygpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBpbml0aWFsaXplZCBhbmQgcmV0dXJucyBmYWxzZSBzbyB0aGUgZWRpdG9yIGFwcGVhcnMgaW4gdGhlIGNlbGxcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYWx3YXlzIGZhbHNlXG4gICAqKi9cbiAgaXNQb3B1cCgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUgd2hlbiB0aGUgVGV4dElucHV0IGNvbXBvbmVudCBmaXJlcyB0aGUgdXBkYXRlXG4gICAqIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gX21hc2tlZCAgdGhlIG1hc2tlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdW5tYXNrZWQgIHRoZSB1bm1hc2tlZCB2YWx1ZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vblRleHRJbnB1dFVwZGF0ZShfbWFza2VkLCB1bm1hc2tlZCwgaW5wdXQpIHtcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB1bm1hc2tlZFxuICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KCcnKVxuICAgIHRoaXMuZm9jdXNJbigpXG4gICAgLy8gd2UgcGFzcyB0aGUgbGFzdCBjYXB0dXJlZCBldmVudCBiYWNrIHRvIHRoZSBncmlkIHRvIGhhbmRsZSBpdCBpbnRlcm5hbGx5XG4gICAgaWYgKHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fKSB7XG4gICAgICB0aGlzLl9wYXJhbXMub25LZXlEb3duKHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fKVxuICAgICAgdGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18gPSBudWxsXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPbiBpbnZhbGlkIGlucHV0cyAsIHVwZGF0ZSB0aGUgaW5wdXQgd2l0aCBhIGN1c3RvbSB2YWxpZGl0eSBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZXJyb3IgdGhlIGVycm9yIG1lc3NhZ2UgcmVwb3J0ZWQgYnkgVGV4dElucHV0XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IFRoZSBpbnB1dCBlbGVtZW50IHVzZWQgaW5zdGFuY2VcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25UZXh0SW5wdXRJbnZhbGlkKGVycm9yLCBpbnB1dCkge1xuICAgIHRoaXMuZm9jdXNJbigpXG4gICAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGNlbGxcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9wYXJhbXMudmFsdWVcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYWxsIGtleWJvYXJkIGV2ZW50cyB0byBhbGxvdyB2YWx1ZSBwcm9jZXNzaW5nIGJ5IHRoZSBOdW1iZXJJbnB1dCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uQ29tcG9uZW50S2V5RG93bihlKSB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID1cbiAgICAgIGtleSA9PT0gMzcgfHwgLy8gbGVmdFxuICAgICAga2V5ID09PSAzOCB8fCAvLyB1cFxuICAgICAga2V5ID09PSAzOSB8fCAvLyByaWdodFxuICAgICAga2V5ID09PSA0MCB8fCAvLyBkb3duXG4gICAgICBrZXkgPT09IDMzIHx8IC8vIHBhZ2UgdXBcbiAgICAgIGtleSA9PT0gMzQgfHwgLy8gcGFnZSBkb3duXG4gICAgICBrZXkgPT09IDM1IHx8IC8vIHBhZ2UgaG9tZVxuICAgICAga2V5ID09PSAzNiB8fCAvLyBwYWdlIGVuZFxuICAgICAga2V5ID09PSAxMyAvLyBlbnRlclxuXG4gICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIC8vIHNhdmUgdGhlIGxhc3QgY2FwdHVyZSBrZXkgc28gTnVtYmVySW5wdXQgY2FuIHBhc3MgaXQgYWdhaW4gdG8gdGhlIGdyaWQuXG4gICAgICB0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXyA9IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGtleSBjaGFuZ2VzIGFuZCB2YWxpZGF0ZSB0aGUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25JbnB1dEtleURvd25VcChldmVudCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KGV2ZW50LnRhcmdldClcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleSA9PSAxMyB8fCBrZXkgPT09IDkpIHtcbiAgICAgIC8vIGVudGVyXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9pbnB1dC52YWx1ZVxuICAgIH1cblxuICAgIC8vIHdlIHBhc3MgdGhlIGxhc3QgY2FwdHVyZWQgZXZlbnQgYmFjayB0byB0aGUgZ3JpZCB0byBoYW5kbGUgaXQgaW50ZXJuYWxseVxuICAgIGlmICh0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXykge1xuICAgICAgdGhpcy5fcGFyYW1zLm9uS2V5RG93bih0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXylcbiAgICAgIHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYGN1cnJlbnRWYWx1ZWAgb24gdGhlIGlucHV0IHZhbHVlIGlzIGNoYW5nZWQgYW5kIGl0IGlzIHZhbGlkXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuX3ZhbGlkYXRlSW5wdXQoZXZlbnQudGFyZ2V0KVxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9pbnB1dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gaW5wdXQgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0IGlucHV0IGVsZW1lbnRcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHZhbGlkICwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBfdmFsaWRhdGVJbnB1dChpbnB1dCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSBpbnB1dC5jaGVja1ZhbGlkaXR5KClcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnYmJqLW1hc2stZXJyb3InKVxuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnYmJqLW1hc2stc3VjY2VzcycpXG4gICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5fcGFyYW1zLnZhbHVlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2Jiai1tYXNrLWVycm9yJylcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2Jiai1tYXNrLXN1Y2Nlc3MnKVxuICAgIH1cblxuICAgIHJldHVybiBpc1ZhbGlkXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGV4dEVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1RleHRFZGl0b3IvVGV4dEVkaXRvci5qcyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZXh0RWRpdG9yL3N0eWxlLnNjc3MiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50ZXh0RWRpdG9ye292ZXJmbG93OmhpZGRlbn0udGV4dEVkaXRvciAudGV4dElucHV0TWFza19fd3JhcHt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdXRsaW5lOm5vbmU7ZGlzcGxheTpibG9jaztwYWRkaW5nOjA7bWFyZ2luOjA7ZGlzcGxheTpmbGV4O2ZsZXg6MSAxIGF1dG87YWxpZ24taXRlbXM6Y2VudGVyO2xpbmUtaGVpZ2h0Om5vcm1hbDtwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59LnRleHRFZGl0b3IgLmJiai1tYXNrLWVycm9ye2JveC1zaGFkb3c6MCAtMnB4IDAgI2U5MWU2MyBpbnNldH0udGV4dEVkaXRvciAuYmJqLW1hc2stc3VjY2Vzc3tib3gtc2hhZG93OjAgLTJweCAwICM0Y2FmNTAgaW5zZXR9LnRleHRFZGl0b3JfX2lucHV0e3BhZGRpbmctbGVmdDo2cHg7Ym9yZGVyOnRoaW4gc29saWQgdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCByZ2JhKDMzLDE1MCwyNDMsMC40KSk7Ym9yZGVyLXJhZGl1czozcHg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yKTtjb2xvcjppbmhlcml0fS5hZy10aGVtZS1hbHBpbmUgLnRleHRFZGl0b3JfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0gLnRleHRFZGl0b3JfX2lucHV0LC5hZy10aGVtZS1tYXRlcmlhbCAudGV4dEVkaXRvcl9faW5wdXR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKX0uYWctdGhlbWUtYWxwaW5lLWRhcmsgLnRleHRFZGl0b3JfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0tZGFyayAudGV4dEVkaXRvcl9faW5wdXR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjMmQzNDM2KX1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL1RleHRFZGl0b3Ivc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJ1xuXG4vKipcbiAqIE51bWJlcnMgRWRpdG9yXG4gKlxuICogSGFuZGxlIG51bWJlciB2YWx1ZXMgRWRpdGluZ1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqcmVuZGVyVGVtcGxhdGUqKiAgIHwgdW5kZWZpbmVkICAgIHwgbG9kYXNoIHRlbXBsYXRlXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgVGVtcGxhdGVSZW5kZXJlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IFRlbXBsYXRlUmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcblxuICAgIC8vIHdpbGwgdGhpcyBhZmZlY3QgQkJqIGJ1aSA/XG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ3RlbXBsYXRlUmVuZGVyZXIgYWctY2VsbC13cmFwcGVyJ1xuICAgIHRoaXMuX2d1aS5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgIHRoaXMuX2d1aS5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICB0aGlzLl9ndWkuc3R5bGUubGluZUhlaWdodCA9ICdub3JtYWwnXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBpbml0KHBhcmFtcykge1xuICAgIHRoaXMucmVmcmVzaChwYXJhbXMsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRHdWkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2d1aVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGNlbGwgbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGNlbGwgcmVuZGVyZXIgcGFyYW1zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0IHRydWUgd2hlbiB0aGlzIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgaW4gYGluaXRgIHBoYXNlICwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHJlZnJlc2ggc3VjY2VlZGVkLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICAgKi9cbiAgcmVmcmVzaChwYXJhbXMsIGlzSW5pdCkge1xuICAgIGlmIChpc0luaXQpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGVkVGVtcGxhdGUgPSB0ZW1wbGF0ZShcbiAgICAgICAgdGhpcy5nZXRPcHRpb24oJ3JlbmRlclRlbXBsYXRlJywgcGFyYW1zLCAnJylcbiAgICAgIClcbiAgICB9XG5cbiAgICBsZXQgY29udGVudFxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jb21waWxlZFRlbXBsYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gdGhpcy5fY29tcGlsZWRUZW1wbGF0ZSh7IHBhcmFtcyB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gcGFyYW1zLnZhbHVlRm9ybWF0dGVkID8gcGFyYW1zLnZhbHVlRm9ybWF0dGVkIDogcGFyYW1zLnZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9IGNvbnRlbnRcblxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGVtcGxhdGVSZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1RlbXBsYXRlUmVuZGVyZXIvVGVtcGxhdGVSZW5kZXJlci5qcyIsImltcG9ydCBhc3NpZ25JbldpdGggZnJvbSAnLi9hc3NpZ25JbldpdGguanMnO1xuaW1wb3J0IGF0dGVtcHQgZnJvbSAnLi9hdHRlbXB0LmpzJztcbmltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGN1c3RvbURlZmF1bHRzQXNzaWduSW4gZnJvbSAnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nQ2hhciBmcm9tICcuL19lc2NhcGVTdHJpbmdDaGFyLmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHRlbXBsYXRlU2V0dGluZ3MgZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdGVtcGxhdGUuanMiLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluV2l0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvYXNzaWduSW5XaXRoLmpzIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwiaW1wb3J0IGJhc2VBc3NpZ25WYWx1ZSBmcm9tICcuL19iYXNlQXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25WYWx1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCJpbXBvcnQgY29yZUpzRGF0YSBmcm9tICcuL19jb3JlSnNEYXRhLmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNNYXNrZWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qcyIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5leHBvcnQgZGVmYXVsdCBjb3JlSnNEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190b1NvdXJjZS5qcyIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRWYWx1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFZhbHVlLmpzIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQXNzaWduZXIuanMiLCJpbXBvcnQgYXBwbHkgZnJvbSAnLi9fYXBwbHkuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwiaW1wb3J0IGJhc2VTZXRUb1N0cmluZyBmcm9tICcuL19iYXNlU2V0VG9TdHJpbmcuanMnO1xuaW1wb3J0IHNob3J0T3V0IGZyb20gJy4vX3Nob3J0T3V0LmpzJztcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuZXhwb3J0IGRlZmF1bHQgc2V0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zZXRUb1N0cmluZy5qcyIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NvbnN0YW50LmpzIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaG9ydE91dDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Nob3J0T3V0LmpzIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5c0luLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0ZW1wdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvYXR0ZW1wdC5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNQbGFpbk9iamVjdC5qcyIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwiaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAqIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHBhcmVudCBvYmplY3Qgb2YgYG9ialZhbHVlYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgcmV0dXJuIHNyY1ZhbHVlO1xuICB9XG4gIHJldHVybiBvYmpWYWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMiLCIvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbnZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAnXFxcXCc6ICdcXFxcJyxcbiAgXCInXCI6IFwiJ1wiLFxuICAnXFxuJzogJ24nLFxuICAnXFxyJzogJ3InLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gIHJldHVybiAnXFxcXCcgKyBzdHJpbmdFc2NhcGVzW2Nocl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGVzY2FwZVN0cmluZ0NoYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lc2NhcGVTdHJpbmdDaGFyLmpzIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCJpbXBvcnQgZXNjYXBlIGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCByZUVzY2FwZSBmcm9tICcuL19yZUVzY2FwZS5qcyc7XG5pbXBvcnQgcmVFdmFsdWF0ZSBmcm9tICcuL19yZUV2YWx1YXRlLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndmFyaWFibGUnOiAnJyxcblxuICAvKipcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICAnaW1wb3J0cyc6IHtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICAnXyc6IHsgJ2VzY2FwZSc6IGVzY2FwZSB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlU2V0dGluZ3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsImltcG9ydCBiYXNlUHJvcGVydHlPZiBmcm9tICcuL19iYXNlUHJvcGVydHlPZi5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVIdG1sQ2hhcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUHJvcGVydHlPZjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUb1N0cmluZy5qcyIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUVzY2FwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXNjYXBlLmpzIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3JlRXZhbHVhdGUuanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgSW1hZ2VSZW5kZXJlciBmcm9tICcuL0ltYWdlUmVuZGVyZXInXG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlUmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9JbWFnZVJlbmRlcmVyL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IFRlbXBsYXRlUmVuZGVyZXIgZnJvbSAnLi4vVGVtcGxhdGVSZW5kZXJlcidcblxuLyoqXG4gKiBOdW1iZXJzIEVkaXRvclxuICpcbiAqIEhhbmRsZSBudW1iZXIgdmFsdWVzIEVkaXRpbmdcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKmltYWdlUmVuZGVyZXJXaWR0aCoqICAgfCAyOHB4ICAgIHwgaW1hZ2Ugd2lkdGhcbiAqIHwgKippbWFnZVJlbmRlcmVySGVpZ2h0KiogICB8IDI4cHggICAgfCBpbWFnZSBoZWlnaHRcbiAqIHwgKippbWFnZVJlbmRlcmVyTGlzdCoqICAgICAgIHwge30gIFx0fCBhIGxpc3Qgb2Ygd2hpY2ggbWFwcyBpbWFnZXMgd2l0aCBjZWxsIHZhbHVlcyBhcyBKU09OIG9yIHBsYWluIEpTIG9iamVjdFxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKlxuICogQHNlZSBodHRwczovL2xvZGFzaC5jb20vZG9jcy80LjE3LjE1I3RlbXBsYXRlXG4gKi9cbmNsYXNzIEltYWdlUmVuZGVyZXIgZXh0ZW5kcyBUZW1wbGF0ZVJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICByZWZyZXNoKHBhcmFtcywgaXNJbml0KSB7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICBjb25zdCBpbWFnZVdpZHRoID0gdGhpcy5nZXRPcHRpb24oJ2ltYWdlUmVuZGVyZXJXaWR0aCcsIHBhcmFtcywgJzI4cHgnKVxuICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gdGhpcy5nZXRPcHRpb24oJ2ltYWdlUmVuZGVyZXJIZWlnaHQnLCBwYXJhbXMsICcyOHB4JylcbiAgICBsZXQgaW1hZ2VMaXN0ID0gdGhpcy5nZXRPcHRpb24oJ2ltYWdlUmVuZGVyZXJMaXN0JywgcGFyYW1zKVxuXG4gICAgdHJ5IHtcbiAgICAgIGltYWdlTGlzdCA9IEpTT04ucGFyc2UoaW1hZ2VMaXN0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGltYWdlTGlzdCA9IGltYWdlTGlzdCB8fCB7fVxuICAgIH1cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuICAgIGlmIChpbWFnZUxpc3QgJiYgaW1hZ2VMaXN0Lmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgcGFyYW1zLnJlbmRlclRlbXBsYXRlID0gLypodG1sKi8gYFxuICAgICAgICA8aW1nIFxuICAgICAgICAgIHNyYz1cIiR7aW1hZ2VMaXN0W3BhcmFtcy52YWx1ZV19XCIgXG4gICAgICAgICAgd2lkdGg9XCIke2ltYWdlV2lkdGh9XCJcbiAgICAgICAgICBoZWlnaHQ9XCIke2ltYWdlSGVpZ2h0fVwiICBcbiAgICAgICAgLz5cbiAgICAgIGBcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zLnJlbmRlclRlbXBsYXRlID0gdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIucmVmcmVzaChwYXJhbXMsIGlzSW5pdClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSW1hZ2VSZW5kZXJlci9JbWFnZVJlbmRlcmVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IERhdGVUaW1lRmlsdGVyIGZyb20gJy4vRGF0ZVRpbWVGaWx0ZXInXG5cbmV4cG9ydCBkZWZhdWx0IERhdGVUaW1lRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRGF0ZVRpbWVGaWx0ZXIvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgeyBhdXRvYmluZCwgb3ZlcnJpZGUsIHJlYWRvbmx5IH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuaW1wb3J0IHV0Y1RvWm9uZWRUaW1lIGZyb20gJ2RhdGUtZm5zLXR6L3V0Y1RvWm9uZWRUaW1lJ1xuaW1wb3J0IHsgd2l0aEV2ZW50c01peGluIH0gZnJvbSAnLi4vRXZlbnRzTWl4aW4nXG5pbXBvcnQgRGF0ZVRpbWVJbnB1dCBmcm9tICcuLi9EYXRlVGltZUlucHV0J1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgJy4vc3R5bGUuc2NzcydcblxuY29uc3QgVE9LRU5TID0ge1xuICBUT0tFTl9FUVVBTDogJ2VxdWFscycsXG4gIFRPS0VOX05PVF9FUVVBTDogJ25vdEVxdWFsJyxcbiAgVE9LRU5fTEVTUzogJ2xlc3NUaGFuJyxcbiAgVE9LRU5fR1JFQVRFUjogJ2dyZWF0ZXJUaGFuJyxcbiAgVE9LRU5fUkFOR0U6ICdpblJhbmdlJyxcbiAgVE9LRU5fQU5EOiAnQU5EJyxcbiAgVE9LRU5fT1I6ICdPUicsXG59XG5cbkB3aXRoRXZlbnRzTWl4aW5cbmNsYXNzIENvbmRpdGlvblBhbmVsIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0YW50IHdoaWNoIGRlc2NyaWJlcyB0aGUgZXZlbnQgbmFtZSB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiB0aGUgb3B0aW9uXG4gICAqIHN0YXRlIGlzIGNoYW5nZWRcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIEByZWFkb25seVxuICBzdGF0aWMgT05fQ09ORElUSU9OX0NIQU5HRUQgPSAnQ29uZGl0aW9uUGFuZWwuT05fQ09ORElUSU9OX0NIQU5HRUQnXG4gIC8qKlxuICAgKiBUaGUgb3B0aW9uIHN0YXRlXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBAcmVhZG9ubHlcbiAgc3RhdGUgPSB7XG4gICAgdHlwZTogVE9LRU5TLlRPS0VOX0VRVUFMLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBmaWx0ZXJUbzogbnVsbCxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RGF0ZVRpbWVJbnB1dH1cbiAgICovXG4gIF9maWx0ZXJUaW1lSW5wdXQgPSBuZXcgRGF0ZVRpbWVJbnB1dCgpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtEYXRlVGltZUlucHV0fVxuICAgKi9cbiAgX2ZpbHRlclRvRGF0ZVRpbWVJbnB1dCA9IG5ldyBEYXRlVGltZUlucHV0KClcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgZW5hYmxlZCBmaWx0ZXIgdHlwZXNcbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cbiAgX2ZpbHRlck9wdGlvbnMgPSBbXVxuXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCBlbmFibGVkIGZpbHRlciB0eXBlXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBfZGVmYXVsdE9wdGlvbiA9IC0xXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gcGFyYW1zLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKVxuXG4gICAgdGhpcy5fZmlsdGVyT3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9uKCdmaWx0ZXJPcHRpb25zJywgcGFyYW1zLCBbXG4gICAgICBUT0tFTlMuVE9LRU5fRVFVQUwsXG4gICAgICBUT0tFTlMuVE9LRU5fTk9UX0VRVUFMLFxuICAgICAgVE9LRU5TLlRPS0VOX0xFU1MsXG4gICAgICBUT0tFTlMuVE9LRU5fR1JFQVRFUixcbiAgICAgIFRPS0VOUy5UT0tFTl9SQU5HRSxcbiAgICBdKVxuXG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbiA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ2RlZmF1bHRPcHRpb24nLFxuICAgICAgcGFyYW1zLFxuICAgICAgdGhpcy5fZmlsdGVyT3B0aW9ucy5pbmRleE9mKFRPS0VOUy5UT0tFTl9FUVVBTCkgPiAtMVxuICAgICAgICA/IFRPS0VOUy5UT0tFTl9FUVVBTFxuICAgICAgICA6IHRoaXMuX2ZpbHRlck9wdGlvbnNbMF1cbiAgICApXG5cbiAgICB0aGlzLnN0YXRlLnR5cGUgPSB0aGlzLl9kZWZhdWx0T3B0aW9uXG5cbiAgICBjb25zdCBvcHRpb25zVHJhbnNsYXRpb25zID0ge1xuICAgICAgW1RPS0VOUy5UT0tFTl9FUVVBTF06IHRyYW5zbGF0ZShUT0tFTlMuVE9LRU5fRVFVQUwsICdFcXVhbHMnKSxcbiAgICAgIFtUT0tFTlMuVE9LRU5fTk9UX0VRVUFMXTogdHJhbnNsYXRlKFRPS0VOUy5UT0tFTl9FUVVBTCwgJ05vdCBlcXVhbCcpLFxuICAgICAgW1RPS0VOUy5UT0tFTl9MRVNTXTogdHJhbnNsYXRlKFRPS0VOUy5UT0tFTl9MRVNTLCAnTGVzcyB0aGFuJyksXG4gICAgICBbVE9LRU5TLlRPS0VOX0dSRUFURVJdOiB0cmFuc2xhdGUoVE9LRU5TLlRPS0VOX0dSRUFURVIsICdHcmVhdGVyIHRoYW4nKSxcbiAgICAgIFtUT0tFTlMuVE9LRU5fUkFOR0VdOiB0cmFuc2xhdGUoVE9LRU5TLlRPS0VOX1JBTkdFLCAnSW4gcmFuZ2UnKSxcbiAgICB9XG5cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnZGF0ZVRpbWVGaWx0ZXIgYWctZmlsdGVyLWJvZHktd3JhcHBlcidcbiAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgICA8c2VsZWN0IGNsYXNzPVwiYWctZmlsdGVyLXNlbGVjdCBkYXRlVGltZUZpbHRlcl9fc2VsZWN0XCIgICR7XG4gICAgICAgIHRoaXMuX2ZpbHRlck9wdGlvbnMubGVuZ3RoID09PSAxID8gJ2Rpc2FibGVkJyA6ICcnXG4gICAgICB9PlxuICAgICAgICAke3RoaXMuX2ZpbHRlck9wdGlvbnMubWFwKFxuICAgICAgICAgIG9wdGlvbiA9PiAvKiBodG1sICovIGBcbiAgICAgICAgICA8b3B0aW9uIFxuICAgICAgICAgICAgdmFsdWU9XCIke29wdGlvbn1cIiBcbiAgICAgICAgICAgICR7b3B0aW9uID09PSB0aGlzLl9kZWZhdWx0T3B0aW9uID8gJ3NlbGVjdGVkJyA6ICcnfVxuICAgICAgICAgID5cbiAgICAgICAgICAgICAgJHtvcHRpb25zVHJhbnNsYXRpb25zW29wdGlvbl19XG4gICAgICAgICAgPC9vcHRpb24+YFxuICAgICAgICApfVxuICAgICAgPC9zZWxlY3Q+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWctZmlsdGVyLWJvZHlcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFnLWZpbHRlci1kYXRlLWZyb21cIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZy1maWx0ZXItZGF0ZS10byBhZy1oaWRkZW5cIj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgXG5cbiAgICB0aGlzLl9maWx0ZXJUaW1lSW5wdXQuaW5pdChwYXJhbXMpXG4gICAgdGhpcy5fZmlsdGVyVGltZUlucHV0Lm9uKERhdGVUaW1lSW5wdXQuT05fREFURV9DSEFOR0VELCBzZWxlY3RlZERhdGUgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5maWx0ZXIgPSBzZWxlY3RlZERhdGVcbiAgICAgIHRoaXMubm90aWZ5KENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICAgIH0pXG5cbiAgICB0aGlzLl9maWx0ZXJUb0RhdGVUaW1lSW5wdXQuaW5pdChwYXJhbXMpXG4gICAgdGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0Lm9uKFxuICAgICAgRGF0ZVRpbWVJbnB1dC5PTl9EQVRFX0NIQU5HRUQsXG4gICAgICBzZWxlY3RlZERhdGUgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlLmZpbHRlclRvID0gc2VsZWN0ZWREYXRlXG4gICAgICAgIHRoaXMubm90aWZ5KENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICAgICAgfVxuICAgIClcblxuICAgIHRoaXMuX2d1aVxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItZGF0ZS1mcm9tJylcbiAgICAgIC5hcHBlbmRDaGlsZCh0aGlzLl9maWx0ZXJUaW1lSW5wdXQuZ2V0R3VpKCkpXG4gICAgdGhpcy5fZ3VpXG4gICAgICAucXVlcnlTZWxlY3RvcignLmFnLWZpbHRlci1kYXRlLXRvJylcbiAgICAgIC5hcHBlbmRDaGlsZCh0aGlzLl9maWx0ZXJUb0RhdGVUaW1lSW5wdXQuZ2V0R3VpKCkpXG5cbiAgICBjb25zdCBzZWxlY3QgPSB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmFnLWZpbHRlci1zZWxlY3QnKVxuICAgIHNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vblR5cGVDaGFuZ2UpXG5cbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuX3N0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9mZihDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRClcbiAgICB0aGlzLl9maWx0ZXJUaW1lSW5wdXQuZGVzdHJveSgpXG4gICAgdGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0LmRlc3Ryb3koKVxuICAgIHRoaXMuX2d1aVxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItc2VsZWN0JylcbiAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vblR5cGVDaGFuZ2UpXG4gICAgdGhpcy5yZXNldCgpXG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIHN0YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnN0YXRlLmZpbHRlciA9IG51bGxcbiAgICB0aGlzLnN0YXRlLmZpbHRlclRvID0gbnVsbFxuICAgIHRoaXMuX2ZpbHRlclRpbWVJbnB1dC5yZXNldCgpXG4gICAgdGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0LnJlc2V0KClcblxuICAgIHRoaXMubm90aWZ5KENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29uZGl0aW9uIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHt9XG4gICAgdGhpcy5zdGF0ZS5maWx0ZXIgPSBzdGF0ZS5maWx0ZXIgfHwgbnVsbFxuICAgIHRoaXMuc3RhdGUuZmlsdGVyVG8gPSBzdGF0ZS5maWx0ZXJUbyB8fCBudWxsXG4gICAgdGhpcy5zdGF0ZS50eXBlID0gc3RhdGUudHlwZSB8fCB0aGlzLl9kZWZhdWx0T3B0aW9uXG5cbiAgICBjb25zdCBndWkgPSB0aGlzLl9ndWlcbiAgICBjb25zdCBmaWx0ZXJPcHRpb25zID0gdGhpcy5fZmlsdGVyT3B0aW9uc1xuICAgIGNvbnN0IHNlbGVjdEVsID0gZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItc2VsZWN0JylcbiAgICBjb25zdCBmaWx0ZXJJbnB1dCA9IHRoaXMuX2ZpbHRlclRpbWVJbnB1dFxuICAgIGNvbnN0IGZpbHRlclRvSW5wdXQgPSB0aGlzLl9maWx0ZXJUb0RhdGVUaW1lSW5wdXRcblxuICAgIHNlbGVjdEVsLnNlbGVjdGVkSW5kZXggPSBmaWx0ZXJPcHRpb25zLmluZGV4T2YodGhpcy5zdGF0ZS50eXBlKVxuICAgIGZpbHRlcklucHV0LnNldERhdGUodGhpcy5zdGF0ZS5maWx0ZXIpXG4gICAgZmlsdGVyVG9JbnB1dC5zZXREYXRlKHRoaXMuc3RhdGUuZmlsdGVyVG8pXG5cbiAgICAvLyB3ZSBmaXJlIG9uIGNoYW5nZSBldmVudCBpbiBjYXNlIHRoZSBmaWx0ZXIgb3B0aW9ucyBjb250YWluXG4gICAgLy8gb25lIG9wdGlvbiB3aGljaCBpcyBpbiBSYW5nZSBcImluUmFuZ2VcIlxuICAgIGlmICgnY3JlYXRlRXZlbnQnIGluIGRvY3VtZW50KSB7XG4gICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpXG4gICAgICBldnQuaW5pdEV2ZW50KCdjaGFuZ2UnLCBmYWxzZSwgdHJ1ZSlcbiAgICAgIHNlbGVjdEVsLmRpc3BhdGNoRXZlbnQoZXZ0KVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbC5maXJlRXZlbnQoJ29uY2hhbmdlJylcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0YXRlIHdpdGggdGhlIHNlbGVjdGVkIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vblR5cGVDaGFuZ2UoZSkge1xuICAgIGNvbnN0IGVsID0gZS50YXJnZXRcbiAgICBjb25zdCBmaWx0ZXJEYXRlVG8gPSB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmFnLWZpbHRlci1kYXRlLXRvJylcblxuICAgIHRoaXMuc3RhdGUudHlwZSA9IGVsLm9wdGlvbnNbZWwuc2VsZWN0ZWRJbmRleF0udmFsdWVcblxuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IFRPS0VOUy5UT0tFTl9SQU5HRSkge1xuICAgICAgZmlsdGVyRGF0ZVRvLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWhpZGRlbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbHRlckRhdGVUby5jbGFzc0xpc3QuYWRkKCdhZy1oaWRkZW4nKVxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG59XG5cbkB3aXRoRXZlbnRzTWl4aW5cbmNsYXNzIEpvaW5Db25kaXRpb25QYW5lbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdGFudCB3aGljaCBkZXNjcmliZXMgdGhlIGV2ZW50IG5hbWUgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhlIGpvaW5cbiAgICogc3RhdGUgaXMgY2hhbmdlZFxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgQHJlYWRvbmx5XG4gIHN0YXRpYyBPTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VEID1cbiAgICAnSm9pbkNvbmRpdGlvblBhbmVsLk9OX0pPSU5fQ09ORElUSU9OX0NIQU5HRUQnXG4gIC8qKlxuICAgKiBUaGUgam9pbiBzdGF0ZVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgQHJlYWRvbmx5XG4gIHN0YXRlID0ge1xuICAgIGNvbmRpdGlvbjE6IHt9LFxuICAgIGNvbmRpdGlvbjI6IHt9LFxuICAgIG9wZXJhdG9yOiBUT0tFTlMuVE9LRU5fT1IsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge09wdGlvbn1cbiAgICovXG4gIF9maXJzdENvbmRpdGlvblBhbmVsID0gbmV3IENvbmRpdGlvblBhbmVsKClcblxuICAvKipcbiAgICogQHR5cGUge09wdGlvbn1cbiAgICovXG4gIF9zZWNvbmRDb25kaXRpb25QYW5lbCA9IG5ldyBDb25kaXRpb25QYW5lbCgpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9vcGVyYXRvclBhbmVsID0gbnVsbFxuXG4gIC8qKlxuICAgKiBQYXJhbXMgcmVjZWl2ZWQgYWZ0ZXIgaW5pdFxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgX3BhcmFtcyA9IG51bGxcbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgaW5pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBwYXJhbXMuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMb2NhbGVUZXh0RnVuYygpXG5cbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcblxuICAgIHRoaXMuX2ZpcnN0Q29uZGl0aW9uUGFuZWwuaW5pdChwYXJhbXMpXG4gICAgdGhpcy5fZmlyc3RDb25kaXRpb25QYW5lbC5vbihcbiAgICAgIENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELFxuICAgICAgdGhpcy5fb25GaXJzdENvbmRpdGlvbkNoYW5nZWRcbiAgICApXG5cbiAgICB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5pbml0KHBhcmFtcylcbiAgICB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5vbihcbiAgICAgIENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELFxuICAgICAgdGhpcy5fb25TZWNvbmRDb25kaXRpb25DaGFuZ2VkXG4gICAgKVxuICAgIHRoaXMuX3NlY29uZENvbmRpdGlvblBhbmVsLmdldEd1aSgpLmNsYXNzTGlzdC5hZGQoJ2FnLWhpZGRlbicpXG5cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnYWctZmlsdGVyLWJvZHktd3JhcHBlciBhZy1zaW1wbGUtZmlsdGVyLWJvZHktd3JhcHBlcidcbiAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQodGhpcy5fZmlyc3RDb25kaXRpb25QYW5lbC5nZXRHdWkoKSlcblxuICAgIC8vcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgaWRPbmUgPSAnXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSksXG4gICAgICAgICAgaWRUd28gPSAnXycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSlcblxuICAgIHRoaXMuX29wZXJhdG9yUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX29wZXJhdG9yUGFuZWwuY2xhc3NOYW1lID0gJ2FnLWZpbHRlci1jb25kaXRpb24gYWctaGlkZGVuJ1xuICAgIHRoaXMuX29wZXJhdG9yUGFuZWwuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgPGRpdiBjbGFzcz1cImFnLWZpbHRlci1jb25kaXRpb24tb3BlcmF0b3IgYWctZmlsdGVyLWNvbmRpdGlvbi1vcGVyYXRvci1hbmQgYWctbGFiZWxlZCBhZy1sYWJlbC1hbGlnbi1yaWdodCBhZy1yYWRpby1idXR0b24gYWctaW5wdXQtZmllbGRcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYWctaW5wdXQtZmllbGQtbGFiZWwgYWctbGFiZWwgYWctcmFkaW8tYnV0dG9uLWxhYmVsXCIgZm9yPVwiJHtpZE9uZX1cIj4gICAgICAgXG4gICAgICAgICAgJHt0cmFuc2xhdGUoJ2FuZENvbmRpdGlvbicsICdBTkQnKX1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFnLXdyYXBwZXItYW5kIGFnLXdyYXBwZXIgYWctaW5wdXQtd3JhcHBlciBhZy1yYWRpby1idXR0b24taW5wdXQtd3JhcHBlciBhZy1jaGVja2VkXCI+XG4gICAgICAgICAgPGlucHV0IGlkPVwiJHtpZE9uZX1cIiBjbGFzcz1cIkFORCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy1yYWRpby1idXR0b24taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwib3JBbmRSYWRpb1wiIHZhbHVlPVwiJHtcbiAgICAgIFRPS0VOUy5UT0tFTl9BTkRcbiAgICB9XCIvPiAgICAgICAgICAgICAgXG4gICAgICAgIDwvZGl2PiBcbiAgICA8L2Rpdj4gICBcbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiYWctZmlsdGVyLWNvbmRpdGlvbi1vcGVyYXRvciBhZy1maWx0ZXItY29uZGl0aW9uLW9wZXJhdG9yLWFuZCBhZy1sYWJlbGVkIGFnLWxhYmVsLWFsaWduLXJpZ2h0IGFnLXJhZGlvLWJ1dHRvbiBhZy1pbnB1dC1maWVsZFwiPlxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJhZy1pbnB1dC1maWVsZC1sYWJlbCBhZy1sYWJlbCBhZy1yYWRpby1idXR0b24tbGFiZWxcIiBmb3I9XCIke2lkVHdvfVwiPiAgICAgICBcbiAgICAgICAgICAke3RyYW5zbGF0ZSgnb3JDb25kaXRpb24nLCAnT1InKX1cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFnLXdyYXBwZXItb3IgYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXJhZGlvLWJ1dHRvbi1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgPGlucHV0IGlkPVwiJHtpZFR3b31cIiBjbGFzcz1cIk9SIGFnLWlucHV0LWZpZWxkLWlucHV0IGFnLXJhZGlvLWJ1dHRvbi1pbnB1dFwiIHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJvckFuZFJhZGlvXCIgdmFsdWU9XCIke1xuICAgICAgVE9LRU5TLlRPS0VOX09SXG4gICAgfVwiLz4gICAgICAgICAgICAgIFxuICAgICAgICA8L2Rpdj4gICAgICAgICBcbiAgICA8L2Rpdj4gICBcbiAgICBgXG4gICAgdGhpcy5fZ3VpLmFwcGVuZENoaWxkKHRoaXMuX29wZXJhdG9yUGFuZWwpXG4gICAgdGhpcy5fb3BlcmF0b3JQYW5lbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbk9wZXJhdG9yQ2hhbmdlZClcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZCh0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5nZXRHdWkoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZmlyc3RDb25kaXRpb25QYW5lbC5kZXN0cm95KClcbiAgICB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5kZXN0cm95KClcbiAgICB0aGlzLl9vcGVyYXRvclBhbmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uT3BlcmF0b3JDaGFuZ2VkKVxuICAgIHRoaXMub2ZmKEpvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VEKVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fZmlyc3RDb25kaXRpb25QYW5lbC5yZXNldCgpXG4gICAgdGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwucmVzZXQoKVxuICAgIHRoaXMubm90aWZ5KENvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY29uZGl0aW9uIGpvaW4gc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHN0YXRlID0gc3RhdGUgfHwge31cbiAgICB0aGlzLnN0YXRlLm9wZXJhdG9yID0gc3RhdGUub3BlcmF0b3IgfHwgVE9LRU5TLlRPS0VOX09SXG4gICAgdGhpcy5zdGF0ZS5jb25kaXRpb24xID0gc3RhdGUuY29uZGl0aW9uMSB8fCBudWxsXG4gICAgdGhpcy5zdGF0ZS5jb25kaXRpb24yID0gc3RhdGUuY29uZGl0aW9uMiB8fCBudWxsXG5cbiAgICB0aGlzLl9maXJzdENvbmRpdGlvblBhbmVsLnNldFN0YXRlKHRoaXMuc3RhdGUuY29uZGl0aW9uMSlcbiAgICB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5zZXRTdGF0ZSh0aGlzLnN0YXRlLmNvbmRpdGlvbjIpXG4gICAgdGhpcy5fb3BlcmF0b3JQYW5lbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLnN0YXRlLm9wZXJhdG9yKSkge1xuICAgICAgICBpbnB1dC5jaGVja2VkID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMubm90aWZ5KEpvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgc2VsZWN0ZWQgY29uZGl0aW9uIHRvIHRoZSBjb21wb25lbnQgc3RhdGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25PcGVyYXRvckNoYW5nZWQoZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG5cbiAgICB0aGlzLnN0YXRlLm9wZXJhdG9yID0gdGFyZ2V0LnZhbHVlXG5cbiAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnT1InKSkge1xuICAgICAgdGhpcy5fb3BlcmF0b3JQYW5lbFxuICAgICAgICAucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItb3InKVxuICAgICAgICAuY2xhc3NMaXN0LmFkZCgnYWctY2hlY2tlZCcpXG4gICAgICB0aGlzLl9vcGVyYXRvclBhbmVsXG4gICAgICAgIC5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1hbmQnKVxuICAgICAgICAuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX29wZXJhdG9yUGFuZWxcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLW9yJylcbiAgICAgICAgLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgdGhpcy5fb3BlcmF0b3JQYW5lbFxuICAgICAgICAucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItYW5kJylcbiAgICAgICAgLmNsYXNzTGlzdC5hZGQoJ2FnLWNoZWNrZWQnKVxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KEpvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAgdGhlIG9wdGlvbiBzdGF0ZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkZpcnN0Q29uZGl0aW9uQ2hhbmdlZChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUuY29uZGl0aW9uMSA9IHN0YXRlXG5cbiAgICBjb25zdCBzdXBwcmVzc0FuZE9yQ29uZGl0aW9uID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAnc3VwcHJlc3NBbmRPckNvbmRpdGlvbicsXG4gICAgICB0aGlzLl9wYXJhbXMsXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIGlmICghc3VwcHJlc3NBbmRPckNvbmRpdGlvbikge1xuICAgICAgY29uc3QgeyBmaWx0ZXIsIGZpbHRlclRvLCB0eXBlIH0gPSB0aGlzLnN0YXRlLmNvbmRpdGlvbjFcbiAgICAgIGNvbnN0IHNlY29uZENvbmRpdGlvbkd1aSA9IHRoaXMuX3NlY29uZENvbmRpdGlvblBhbmVsLmdldEd1aSgpXG4gICAgICBjb25zdCBvcGVyYXRvclBhbmVsR3VpID0gdGhpcy5fb3BlcmF0b3JQYW5lbFxuICAgICAgY29uc3QgY29uZGl0aW9uID1cbiAgICAgICAgdHlwZSA9PT0gVE9LRU5TLlRPS0VOX1JBTkdFID8gIWZpbHRlciB8fCAhZmlsdGVyVG8gOiAhZmlsdGVyXG5cbiAgICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgc2Vjb25kQ29uZGl0aW9uR3VpLmNsYXNzTGlzdC5hZGQoJ2FnLWhpZGRlbicpXG4gICAgICAgIG9wZXJhdG9yUGFuZWxHdWkuY2xhc3NMaXN0LmFkZCgnYWctaGlkZGVuJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlY29uZENvbmRpdGlvbkd1aS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1oaWRkZW4nKVxuICAgICAgICBvcGVyYXRvclBhbmVsR3VpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWhpZGRlbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoSm9pbkNvbmRpdGlvblBhbmVsLk9OX0pPSU5fQ09ORElUSU9OX0NIQU5HRUQsIHRoaXMuc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlICB0aGUgb3B0aW9uIHN0YXRlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uU2Vjb25kQ29uZGl0aW9uQ2hhbmdlZChzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUuY29uZGl0aW9uMiA9IHN0YXRlXG4gICAgdGhpcy5ub3RpZnkoSm9pbkNvbmRpdGlvblBhbmVsLk9OX0pPSU5fQ09ORElUSU9OX0NIQU5HRUQsIHRoaXMuc3RhdGUpXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRlVGltZSBGaWx0ZXJcbiAqXG4gKiAjIyBPcHRpb25zXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKipkYXRlVGltZUVuYWJsZVRpbWUqKiAgIHwgZmFsc2UgICAgfCBlbmFibGUgLyBkaXNhYmxlIHRpbWVcbiAqIHwgKipkYXRlVGltZUVuYWJsZTI0SFIqKiAgIHwgZmFsc2UgICAgfCBlbmFibGUgLyBkaXNhYmxlIHRpbWUgMjQgZm9ybWF0XG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVTZWNvbmRzKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSBzZWNvbmRzIG1hbmFnZW1lbnRcbiAqIHwgKipkYXRlVGltZUVuYWJsZUNhbGVuZGFyKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSBDYWxlbmRhci5cbiAqIHwgKipkYXRlVGltZU1hc2sqKiAgIHwgZmFsc2UgICAgfCBUaGUgbWFzayB1c2VkIHRvIGZvcm1hdCB0aGUgc2VsZWN0ZWQgZGF0ZVxuICogfCAqKmRhdGVUaW1lTWF4KiogICB8IHVuZGVmaW5lZCAgICB8ICBNYXggYWxsb3dlZCBkYXRlXG4gKiB8ICoqZGF0ZVRpbWVNaW4qKiAgIHwgdW5kZWZpbmVkICAgIHwgIE1pbiBhbGxvd2VkIGRhdGVcbiAqIHwgKipkYXRlVGltZUZvcm1hdHRlcioqICAgfCB1bmRlZmluZWQgICAgfCAgQSBmdW5jdGlvbiBvciBleHByZXNzaW9uIHRvIGZvcm1hdCB0aGUgZGF0ZSAoQHNlZSBzdXBwb3J0ZWQgcGFyYW0pXG4gKiB8ICoqZGF0ZVRpbWVMb2NhbGUqKiAgIHwgU3lzdGVtIGRlZmF1bHQgICAgfCAgQSBsb2NhbGUgdG8gdXNlIGZvciBkYXRlIGZvcm1hdHRpbmdcbiAqIHwgKipkYXRlVGltZURlZmF1bHRIb3VyKiogICB8IDEyICAgIHwgIEluaXRpYWwgdmFsdWUgb2YgdGhlIGhvdXIgZWxlbWVudC5cbiAqIHwgKipkYXRlVGltZURlZmF1bHRNaW51dGUqKiAgIHwgMCAgICB8ICBJbml0aWFsIHZhbHVlIG9mIHRoZSBtaW51dGUgZWxlbWVudC5cbiAqIHwgKipkYXRlVGltZURpc2FibGVNb2JpbGUqKiAgIHwgZmFsc2UgICAgfCAgU2V0IGRpc2FibGVNb2JpbGUgdG8gdHJ1ZSB0byBhbHdheXMgdXNlIHRoZSBub24tbmF0aXZlIHBpY2tlci5cbiAqIHwgKipkYXRlVGltZUVuYWJsZVdlZWtOdW1iZXIqKiAgIHwgdHJ1ZSAgICB8ICBFbmFibGVzIGRpc3BsYXkgb2Ygd2VlayBudW1iZXJzIGluIGNhbGVuZGFyLlxuICogfCAqKmZpbHRlck9wdGlvbnMqKiAgIHwgRXF1YWxzLCBHcmVhdGVyIFRoYW4sIExlc3MgVGhhbiwgTm90IEVxdWFscywgSW4gUmFuZ2UuICAgIHwgIFdoYXQgRmlsdGVyIE9wdGlvbnMgdG8gcHJlc2VudCB0byB0aGUgdXNlci5cbiAqIHwgKipkZWZhdWx0T3B0aW9uKiogICB8IEVxdWFscyAgICB8ICBUaGUgZGVmYXVsdCBGaWx0ZXIgT3B0aW9ucyB0byBiZSBzZWxlY3RlZC5cbiAqIHwgKipzdXBwcmVzc0FuZE9yQ29uZGl0aW9uKiogICB8IGZhbHNlICAgIHwgIElmIHRydWUsIHRoZSBmaWx0ZXIgd2lsbCBvbmx5IG9mZmVyIENvbmRpdGlvbiAxLlxuICogfCAqKmluUmFuZ2VJbmNsdXNpdmUqKiAgIHwgZmFsc2UgICAgfCAgSWYgdHJ1ZSB0aGVuIGRvaW5nICdpblJhbmdlJyBmaWx0ZXIgb3B0aW9uIHdpbGwgaW5jbHVkZSB2YWx1ZXMgZXF1YWwgdG8gdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHJhbmdlLlxuICogfCAqKmNsZWFyQnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYSBDbGVhciBidXR0b24uIFRoZSBDbGVhciBidXR0b24gd2lsbCBjbGVhciB0aGUgKGZvcm0pIGRldGFpbHMgb2YgdGhlIGZpbHRlciB3aXRob3V0IHJlbW92aW5nIGFueSBhY3RpdmUgZmlsdGVycyBvbiB0aGUgY29sdW1uLlxuICogfCAqKmFwcGx5QnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYW4gQXBwbHkgYnV0dG9uLiBJZiB0aGUgQXBwbHkgYnV0dG9uIGlzIHByZXNlbnQsIHRoZW4gdGhlIGZpbHRlciBpcyBvbmx5IGFwcGxpZWQgYWZ0ZXIgdGhlIHVzZXIgaGl0cyB0aGUgQXBwbHkgYnV0dG9uLlxuICogfCAqKnJlc2V0QnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYSBSZXNldCBidXR0b24uIFRoZSBSZXNldCBidXR0b24gd2lsbCBjbGVhciB0aGUgZGV0YWlscyBvZiB0aGUgZmlsdGVyIGFuZCBhbnkgYWN0aXZlIGZpbHRlcnMgb24gdGhhdCBjb2x1bW4uXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgRGF0ZVRpbWVGaWx0ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQHR5cGUge0pvaW59XG4gICAqL1xuICBfSm9pbkNvbmRpdGlvblBhbmVsID0gbmV3IEpvaW5Db25kaXRpb25QYW5lbCgpXG5cbiAgLyoqXG4gICAqIEpvaW4gcGFuZWwgc3RhdGVcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9zdGF0ZSA9IHt9XG5cbiAgLyoqXG4gICAqIENvbXBvbmVudCBwYXJhbXNcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9wYXJhbXMgPSB7fVxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3Qgb2YgYWxsIHRoZSByZXF1aXJlZCBvcHRpb25zIGNhY2hlZCBmb3IgZG9lc0ZpbHRlclBhc3MgbWV0aG9kXG4gICAqL1xuICBfZG9lc0ZpbHRlclBhc3NPcHRpb25zID0gbnVsbFxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gcGFyYW1zLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKVxuICAgIGNvbnN0IGlzQ2xlYXJGaWx0ZXIgPSB0aGlzLmdldE9wdGlvbignY2xlYXJCdXR0b24nLCBwYXJhbXMsIGZhbHNlKVxuICAgIGNvbnN0IGlzUmVzZXRCdXR0b24gPSB0aGlzLmdldE9wdGlvbigncmVzZXRCdXR0b24nLCBwYXJhbXMsIGZhbHNlKVxuICAgIGNvbnN0IGlzQXBwbHlCdXR0b24gPSB0aGlzLmdldE9wdGlvbignYXBwbHlCdXR0b24nLCBwYXJhbXMsIGZhbHNlKVxuXG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcblxuICAgIHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5pbml0KHBhcmFtcylcbiAgICB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwub24oXG4gICAgICBKb2luQ29uZGl0aW9uUGFuZWwuT05fSk9JTl9DT05ESVRJT05fQ0hBTkdFRCxcbiAgICAgIHN0YXRlID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGlzYWJsZVN0YXRlQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgICB0aGlzLl9vbkpvaW5Db25kaXRpb25QYW5lbFN0YXRlQ2hhbmdlZChzdGF0ZSwgaXNBcHBseUJ1dHRvbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZCh0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwuZ2V0R3VpKCkpXG5cbiAgICBjb25zdCBhcHBseUZpbHRlclBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBhcHBseUZpbHRlclBhbmVsLmNsYXNzTmFtZSA9IGBhZy1maWx0ZXItYXBwbHktcGFuZWwgYWctaGlkZGVuYFxuICAgIGFwcGx5RmlsdGVyUGFuZWwuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYWctc3RhbmRhcmQtYnV0dG9uIGFnLWZpbHRlci1hcHBseS1wYW5lbC1idXR0b24gY2xlYXIgJHshaXNDbGVhckZpbHRlciAmJlxuICAgICAgICAnYWctaGlkZGVuJ31cIiB0eXBlPVwiYnV0dG9uXCI+JHt0cmFuc2xhdGUoXG4gICAgICAnY2xlYXJGaWx0ZXInLFxuICAgICAgJ0NsZWFyIEZpbHRlcidcbiAgICApfTwvYnV0dG9uPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImFnLXN0YW5kYXJkLWJ1dHRvbiBhZy1maWx0ZXItYXBwbHktcGFuZWwtYnV0dG9uIHJlc2V0ICR7IWlzUmVzZXRCdXR0b24gJiZcbiAgICAgICAgJ2FnLWhpZGRlbid9XCIgdHlwZT1cImJ1dHRvblwiPiR7dHJhbnNsYXRlKFxuICAgICAgJ3Jlc2V0RmlsdGVyJyxcbiAgICAgICdSZXNldCBGaWx0ZXInXG4gICAgKX08L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJhZy1zdGFuZGFyZC1idXR0b24gYWctZmlsdGVyLWFwcGx5LXBhbmVsLWJ1dHRvbiBhcHBseSAkeyFpc0FwcGx5QnV0dG9uICYmXG4gICAgICAgICdhZy1oaWRkZW4nfVwiIHR5cGU9XCJidXR0b25cIj4ke3RyYW5zbGF0ZShcbiAgICAgICdhcHBseUZpbHRlcicsXG4gICAgICAnQXBwbHkgRmlsdGVyJ1xuICAgICl9PC9idXR0b24+XG4gICAgYFxuXG4gICAgaWYgKGlzQ2xlYXJGaWx0ZXIgfHwgaXNSZXNldEJ1dHRvbiB8fCBpc0FwcGx5QnV0dG9uKSB7XG4gICAgICBhcHBseUZpbHRlclBhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWhpZGRlbicpXG4gICAgfVxuXG4gICAgYXBwbHlGaWx0ZXJQYW5lbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ2NsaWNrJyxcbiAgICAgIHRoaXMuX0FwcGx5RmlsdGVyUGFuZWxCdXR0b25DbGlja1xuICAgIClcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChhcHBseUZpbHRlclBhbmVsKVxuXG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwuc3RhdGVcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcblxuICAgIHRoaXMuX2RvZXNGaWx0ZXJQYXNzT3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZVRpbWU6IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZUVuYWJsZVRpbWUnLCB0aGlzLl9wYXJhbXMsIHRydWUpLFxuICAgICAgaW5SYW5nZUluY2x1c2l2ZTogdGhpcy5nZXRPcHRpb24oJ2luUmFuZ2VJbmNsdXNpdmUnLCB0aGlzLl9wYXJhbXMsIGZhbHNlKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIHZhbHVlR2V0dGVyOiB0aGlzLl9wYXJhbXMuaGFzT3duUHJvcGVydHkoJ2ZpbHRlclZhbHVlR2V0dGVyJylcbiAgICAgICAgPyB0aGlzLl9wYXJhbXMuZmlsdGVyVmFsdWVHZXR0ZXJcbiAgICAgICAgOiB0aGlzLl9wYXJhbXMudmFsdWVHZXR0ZXIsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwuZGVzdHJveSgpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBzZWxlY3RlZCBmaWx0ZXIgbWF0Y2hlcyB0aGUgcGFzc2VkIGNlbGwgZGF0YVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBwYXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGRvZXNGaWx0ZXJQYXNzKHBhcmFtcykge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZG9lc0ZpbHRlclBhc3NPcHRpb25zLnZhbHVlR2V0dGVyKHBhcmFtcylcbiAgICBjb25zdCB7IGNvbmRpdGlvbjEsIGNvbmRpdGlvbjIsIG9wZXJhdG9yIH0gPSB0aGlzLl9zdGF0ZVxuICAgIGNvbnN0IGRvZXNQYXNzRmlyc3RDb25kaXRpb24gPSB0aGlzLl9kb2VzUGFzc0NvbmRpdGlvbihjb25kaXRpb24xLCB2YWx1ZSlcbiAgICBjb25zdCBkb2VzUGFzc1NlY29uZENvbmRpdGlvbiA9IHRoaXMuX2RvZXNQYXNzQ29uZGl0aW9uKGNvbmRpdGlvbjIsIHZhbHVlKVxuXG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBUT0tFTlMuVE9LRU5fT1JcbiAgICAgID8gZG9lc1Bhc3NGaXJzdENvbmRpdGlvbiB8fCBkb2VzUGFzc1NlY29uZENvbmRpdGlvblxuICAgICAgOiBkb2VzUGFzc0ZpcnN0Q29uZGl0aW9uICYmIGRvZXNQYXNzU2Vjb25kQ29uZGl0aW9uXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFwcGx5aW5nIGFueSBmaWx0ZXIgb24gdGhlIGNvbHVtblxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiovXG4gIGlzRmlsdGVyQWN0aXZlKCkge1xuICAgIGNvbnN0IHsgY29uZGl0aW9uMSB9ID0gdGhpcy5fc3RhdGVcblxuICAgIGlmIChjb25kaXRpb24xICYmIGNvbmRpdGlvbjEuZmlsdGVyKSB7XG4gICAgICBpZiAoY29uZGl0aW9uMS5maWx0ZXJUbyAmJiBjb25kaXRpb24xLnR5cGUgPT09IFRPS0VOUy5UT0tFTl9SQU5HRSkge1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uMS5maWx0ZXIgIT09IG51bGwgJiYgY29uZGl0aW9uMS5maWx0ZXJUbyAhPT0gbnVsbFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZGl0aW9uMS5maWx0ZXIgIT09IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaWx0ZXIgc3RhdGUuIElmIGZpbHRlciBpcyBub3QgYWN0aXZlLCB0aGVuIHNob3VsZCByZXR1cm4gbnVsbC91bmRlZmluZWQuXG4gICAqIFRoZSBncmlkIGNhbGxzIGdldE1vZGVsKCkgb24gYWxsIGFjdGl2ZSBmaWx0ZXJzIHdoZW4gZ3JpZEFwaS5nZXRGaWx0ZXJNb2RlbCgpIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybiBPYmplY3QgfCBudWxsIHRoZSBmaWx0ZXIgc3RhdGVcbiAgICovXG4gIGdldE1vZGVsKCkge1xuICAgIGNvbnN0IGNsb25lID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLl9zdGF0ZSkpXG4gICAgO1tjbG9uZS5jb25kaXRpb24xLCBjbG9uZS5jb25kaXRpb24yXS5mb3JFYWNoKChjb25kaXRpb24sIGkpID0+IHtcbiAgICAgIGlmIChjb25kaXRpb24uZmlsdGVyKSB7XG4gICAgICAgIGNvbmRpdGlvbi5maWx0ZXIgPSB0aGlzLl9zdGF0ZVtgY29uZGl0aW9uJHtpICsgMX1gXS5maWx0ZXIudG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgICAgaWYgKGNvbmRpdGlvbi5maWx0ZXJUbykge1xuICAgICAgICBjb25kaXRpb24uZmlsdGVyVG8gPSB0aGlzLl9zdGF0ZVtcbiAgICAgICAgICBgY29uZGl0aW9uJHtpICsgMX1gXG4gICAgICAgIF0uZmlsdGVyVG8udG9JU09TdHJpbmcoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjbG9uZS5maWx0ZXJUeXBlID0gJ2RhdGV0aW1lJ1xuICAgIGNsb25lLmNvbmRpdGlvbjEuZmlsdGVyVHlwZSA9ICdkYXRldGltZSdcbiAgICBjbG9uZS5jb25kaXRpb24yLmZpbHRlclR5cGUgPSAnZGF0ZXRpbWUnXG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgcmV0dXJuIGNsb25lLmhhc093blByb3BlcnR5KCdjb25kaXRpb24yJykgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIGNsb25lLmNvbmRpdGlvbjIuaGFzT3duUHJvcGVydHkoJ2ZpbHRlcicpICYmXG4gICAgICBjbG9uZS5jb25kaXRpb24yLmZpbHRlclxuICAgICAgPyBjbG9uZVxuICAgICAgOiBjbG9uZS5jb25kaXRpb24xXG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGZpbHRlciBzdGF0ZS4gQ2FsbGVkIGJ5IHRoZSBncmlkIGFmdGVyIGdyaWRBcGkuc2V0RmlsdGVyTW9kZWwobW9kZWwpIGlzIGNhbGxlZC5cbiAgICogVGhlIGdyaWQgd2lsbCBwYXNzIHVuZGVmaW5lZC9udWxsIHRvIGNsZWFyIHRoZSBmaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gbW9kZWxcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgaWYgKFxuICAgICAgbW9kZWwgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICFtb2RlbC5oYXNPd25Qcm9wZXJ0eSgnY29uZGl0aW9uMScpICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAhbW9kZWwuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbjInKVxuICAgICkge1xuICAgICAgbW9kZWwgPSB7XG4gICAgICAgIGNvbmRpdGlvbjE6IG1vZGVsLFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fZGlzYWJsZVN0YXRlQ2hhbmdlTGlzdGVuZXIgPSB0cnVlXG4gICAgdGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLnNldFN0YXRlKG1vZGVsKVxuICAgIHRoaXMuX19kaXNhYmxlU3RhdGVDaGFuZ2VMaXN0ZW5lciA9IGZhbHNlXG5cbiAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5zdGF0ZVxuICAgIDtbdGhpcy5fc3RhdGUuY29uZGl0aW9uMSwgdGhpcy5fc3RhdGUuY29uZGl0aW9uMl0uZm9yRWFjaChjb25kaXRpb24gPT4ge1xuICAgICAgaWYgKGNvbmRpdGlvbi5maWx0ZXIpIHtcbiAgICAgICAgY29uZGl0aW9uLmZpbHRlciA9IG5ldyBEYXRlKGNvbmRpdGlvbi5maWx0ZXIpXG4gICAgICB9XG4gICAgICBpZiAoY29uZGl0aW9uLmZpbHRlclRvKSB7XG4gICAgICAgIGNvbmRpdGlvbi5maWx0ZXJUbyA9IG5ldyBEYXRlKGNvbmRpdGlvbi5maWx0ZXJUbylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlsdGVyIG1vZGVsIGFzIHBsYWluIHN0cmluZyB0byBkaXNwbGF5IGluIHRoZSBmbG9hdGluZyBmaWx0ZXIgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3QgfCBudWxsfSBtb2RlbFxuICAgKi9cbiAgZ2V0TW9kZWxBc1N0cmluZyhtb2RlbCkge1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGVUaW1lTWFzayA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ2RhdGVUaW1lTWFzaycsXG4gICAgICB0aGlzLl9wYXJhbXMsXG4gICAgICAvLyBAdG9kbyBGaW5kIGEgYmV0dGVyIHdheSBmb3IgdGhpc1xuICAgICAgdGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLl9maXJzdENvbmRpdGlvblBhbmVsLl9maWx0ZXJUaW1lSW5wdXQucGlja2VyXG4gICAgICAgIC5jb25maWdbJ2RhdGVGb3JtYXQnXVxuICAgIClcbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICdkYXRlVGltZUxvY2FsZScsXG4gICAgICB0aGlzLl9wYXJhbXMsXG4gICAgICBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlIHx8ICdlbi1VUydcbiAgICApXG5cbiAgICBjb25zdCB7IGNvbmRpdGlvbjEsIGNvbmRpdGlvbjIsIG9wZXJhdG9yIH0gPSBKU09OLnBhcnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkobW9kZWwpXG4gICAgKVxuXG4gICAgO1tjb25kaXRpb24xLCBjb25kaXRpb24yXS5mb3JFYWNoKGNvbmRpdGlvbiA9PiB7XG4gICAgICBpZiAoY29uZGl0aW9uLmZpbHRlcikge1xuICAgICAgICBjb25kaXRpb24uZmlsdGVyID0gQkJqLk1hc2tzLkRhdGVNYXNrLm1hc2soXG4gICAgICAgICAgY29uZGl0aW9uLmZpbHRlcixcbiAgICAgICAgICBkYXRlVGltZU1hc2ssXG4gICAgICAgICAgbG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmRpdGlvbi5maWx0ZXJUbykge1xuICAgICAgICBjb25kaXRpb24uZmlsdGVyVG8gPSBCQmouTWFza3MuRGF0ZU1hc2subWFzayhcbiAgICAgICAgICBjb25kaXRpb24uZmlsdGVyVG8sXG4gICAgICAgICAgZGF0ZVRpbWVNYXNrLFxuICAgICAgICAgIGxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGZpcnN0Q29uZGl0aW9uQXNTdHJpbmcgPSBgJHtjb25kaXRpb24xLmZpbHRlciB8fCAnJ30gJHtcbiAgICAgIGNvbmRpdGlvbjEuZmlsdGVyVG8gPyAn4oaSICcgKyBjb25kaXRpb24xLmZpbHRlclRvIDogJydcbiAgICB9YFxuICAgIGNvbnN0IHNlY29uZENvbmRpdGlvbkFzU3RyaW5nID0gYCR7Y29uZGl0aW9uMi5maWx0ZXIgfHwgJyd9ICR7XG4gICAgICBjb25kaXRpb24yLmZpbHRlclRvID8gJ+KGkiAnICsgY29uZGl0aW9uMi5maWx0ZXJUbyA6ICcnXG4gICAgfWBcbiAgICBjb25zdCBvcGVyYXRvckFzU3RyaW5nID0gYCR7Y29uZGl0aW9uMi5maWx0ZXIgJiYgb3BlcmF0b3IgPyBvcGVyYXRvciA6ICcnfWBcblxuICAgIHJldHVybiBgJHtmaXJzdENvbmRpdGlvbkFzU3RyaW5nfSAke29wZXJhdG9yQXNTdHJpbmd9ICR7c2Vjb25kQ29uZGl0aW9uQXNTdHJpbmd9YC50cmltKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgcGFzc2VzIHRoZSBmaWx0ZXIgZGVmaW5lZCBpbiB0aGUgcGFzc2VkIENvbmRpdGlvblBhbmVsJ3Mgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmRpdGlvbiBjb25kaXRpb24gcGFuZWwgc3RhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGNlbGwgdmFsdWVcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHBhc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgX2RvZXNQYXNzQ29uZGl0aW9uKGNvbmRpdGlvbiwgdmFsdWUpIHtcbiAgICBpZiAoIWNvbmRpdGlvbi5maWx0ZXIgfHwgIXZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCB7IGZpbHRlciwgZmlsdGVyVG8sIHR5cGUgfSA9IGNvbmRpdGlvblxuICAgIGNvbnN0IHRpbWV6b25lID0gQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmdldFRpbWV6b25lT3JPZmZzZXQoKVxuICAgIGNvbnN0IGluUmFuZ2VJbmNsdXNpdmUgPSB0aGlzLl9kb2VzRmlsdGVyUGFzc09wdGlvbnMuaW5SYW5nZUluY2x1c2l2ZVxuICAgIGNvbnN0IGVuYWJsZVRpbWUgPSB0aGlzLl9kb2VzRmlsdGVyUGFzc09wdGlvbnMuZW5hYmxlVGltZVxuICAgIGxldCBwYXNzZWQgPSBmYWxzZVxuXG4gICAgaWYgKEJCai5NYXNrcy5VdGlscy5EYXRlcy5JU19USU1FX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID0gQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmZpeFNob3J0SVNPKHZhbHVlKVxuICAgICAgO1tmaWx0ZXIsIGZpbHRlclRvXS5mb3JFYWNoKGRhdGUgPT4ge1xuICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKDE5NzApXG4gICAgICAgICAgZGF0ZS5zZXRNb250aCgwKVxuICAgICAgICAgIGRhdGUuc2V0RGF0ZSgxKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoQkJqLk1hc2tzLlV0aWxzLkRhdGVzLklTX0RBVEVfUkVHRVgudGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmZpeFNob3J0SVNPKHZhbHVlKVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgdGhlIGRhdGV0aW1lIGZyb20gdXRjIHRvIGxvY2FsZVxuICAgIHZhbHVlID0gdXRjVG9ab25lZFRpbWUodmFsdWUsIHRpbWV6b25lKVxuICAgIC8vIGZpcnN0RGF0ZSA9IGZpcnN0RGF0ZSA/IHpvbmVkVGltZVRvVXRjKGZpcnN0RGF0ZSAsIHRpbWV6b25lKSA6IGZpcnN0RGF0ZVxuICAgIC8vIHNlY29uZERhdGUgPSBzZWNvbmREYXRlID8gem9uZWRUaW1lVG9VdGMoc2Vjb25kRGF0ZSAsIHRpbWV6b25lKSA6IHNlY29uZERhdGVcblxuICAgIGlmICghZW5hYmxlVGltZSkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSB0aW1lIHBvcnRpb24gZnJvbSB0aGUgZGF0ZVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXNlbWlcbiAgICAgIDtbdmFsdWUsIGZpbHRlciwgZmlsdGVyVG9dLmZvckVhY2goZGF0ZSA9PiB7XG4gICAgICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIGRhdGUuc2V0SG91cnMoMClcbiAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoMClcbiAgICAgICAgICBkYXRlLnNldFNlY29uZHMoMClcbiAgICAgICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBUT0tFTlMuVE9LRU5fRVFVQUwpIHtcbiAgICAgIHBhc3NlZCA9IGZpbHRlciA+IHZhbHVlID09PSBmYWxzZSAmJiBmaWx0ZXIgPCB2YWx1ZSA9PSBmYWxzZVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVE9LRU5TLlRPS0VOX05PVF9FUVVBTCkge1xuICAgICAgcGFzc2VkID0gIShmaWx0ZXIgPiB2YWx1ZSA9PT0gZmFsc2UgJiYgZmlsdGVyIDwgdmFsdWUgPT0gZmFsc2UpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUT0tFTlMuVE9LRU5fR1JFQVRFUikge1xuICAgICAgcGFzc2VkID0gZmlsdGVyIDwgdmFsdWVcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRPS0VOUy5UT0tFTl9MRVNTKSB7XG4gICAgICBwYXNzZWQgPSBmaWx0ZXIgPiB2YWx1ZVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVE9LRU5TLlRPS0VOX1JBTkdFICYmIGZpbHRlclRvKSB7XG4gICAgICBpZiAoaW5SYW5nZUluY2x1c2l2ZSkge1xuICAgICAgICBwYXNzZWQgPVxuICAgICAgICAgICgoZmlsdGVyIDwgdmFsdWUgfHxcbiAgICAgICAgICAgIChmaWx0ZXIgPiB2YWx1ZSA9PT0gZmFsc2UgJiYgZmlsdGVyIDwgdmFsdWUgPT0gZmFsc2UpKSAmJlxuICAgICAgICAgICAgZmlsdGVyVG8gPiB2YWx1ZSkgfHxcbiAgICAgICAgICAoZmlsdGVyVG8gPiB2YWx1ZSA9PT0gZmFsc2UgJiYgZmlsdGVyVG8gPCB2YWx1ZSA9PSBmYWxzZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhc3NlZCA9IGZpbHRlciA8IHZhbHVlICYmIGZpbHRlclRvID4gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFzc2VkXG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0byBjbGljayBidXR0b24gZXZlbnQgb24gdGhlIGZpbHRlciBwYW5lbCBhbmQgZXhlY3V0ZSB0aGVcbiAgICogcmlnaHQgYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfQXBwbHlGaWx0ZXJQYW5lbEJ1dHRvbkNsaWNrKGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuXG4gICAgaWYgKHRhcmdldC5ub2RlTmFtZSA9PT0gJ0JVVFRPTicpIHtcbiAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdyZXNldCcpKSB7XG4gICAgICAgIHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5yZXNldCgpXG4gICAgICAgIHRoaXMuX3BhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbGVhcicpKSB7XG4gICAgICAgIHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5yZXNldCgpXG4gICAgICB9IGVsc2UgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FwcGx5JykpIHtcbiAgICAgICAgdGhpcy5fcGFyYW1zLmZpbHRlckNoYW5nZWRDYWxsYmFjaygpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZmlsdGVyIHN0YXRlIGFuZCBBcHBseSB0aGUgZmlsdGVyIGRlcGVuZGluZyBvblxuICAgKiB3aGV0aGVyIHRoZSBgaXNBcHBseUJ1dHRvbkFjdGl2ZWAgaXMgdHJ1ZSBvciBmYWxzZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0FwcGx5QnV0dG9uQWN0aXZlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uSm9pbkNvbmRpdGlvblBhbmVsU3RhdGVDaGFuZ2VkKHN0YXRlLCBpc0FwcGx5QnV0dG9uQWN0aXZlKSB7XG4gICAgdGhpcy5fc3RhdGUgPSBzdGF0ZVxuICAgIGlmIChmYWxzZSA9PT0gaXNBcHBseUJ1dHRvbkFjdGl2ZSkge1xuICAgICAgdGhpcy5fcGFyYW1zLmZpbHRlckNoYW5nZWRDYWxsYmFjaygpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERhdGVUaW1lRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRGF0ZVRpbWVGaWx0ZXIvRGF0ZVRpbWVGaWx0ZXIuanMiLCIvKipcbiAqIFJldHVybnMgdGhlIFt5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZHNdIHRva2VucyBvZiB0aGUgcHJvdmlkZWRcbiAqIGBkYXRlYCBhcyBpdCB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBgdGltZVpvbmVgLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0elRva2VuaXplRGF0ZShkYXRlLCB0aW1lWm9uZSkge1xuICB2YXIgZHRmID0gZ2V0RGF0ZVRpbWVGb3JtYXQodGltZVpvbmUpXG4gIHJldHVybiBkdGYuZm9ybWF0VG9QYXJ0cyA/IHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkgOiBoYWNreU9mZnNldChkdGYsIGRhdGUpXG59XG5cbnZhciB0eXBlVG9Qb3MgPSB7XG4gIHllYXI6IDAsXG4gIG1vbnRoOiAxLFxuICBkYXk6IDIsXG4gIGhvdXI6IDMsXG4gIG1pbnV0ZTogNCxcbiAgc2Vjb25kOiA1XG59XG5cbmZ1bmN0aW9uIHBhcnRzT2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICB2YXIgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSlcbiAgdmFyIGZpbGxlZCA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9ybWF0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IHR5cGVUb1Bvc1tmb3JtYXR0ZWRbaV0udHlwZV1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgZmlsbGVkW3Bvc10gPSBwYXJzZUludChmb3JtYXR0ZWRbaV0udmFsdWUsIDEwKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsbGVkXG59XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICB2YXIgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csICcnKVxuICB2YXIgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSw/IChcXGQrKTooXFxkKyk6KFxcZCspLy5leGVjKGZvcm1hdHRlZClcbiAgLy8gdmFyIFssIGZNb250aCwgZkRheSwgZlllYXIsIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHBhcnNlZFxuICAvLyByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXVxuICByZXR1cm4gW3BhcnNlZFszXSwgcGFyc2VkWzFdLCBwYXJzZWRbMl0sIHBhcnNlZFs0XSwgcGFyc2VkWzVdLCBwYXJzZWRbNl1dXG59XG5cbi8vIEdldCBhIGNhY2hlZCBJbnRsLkRhdGVUaW1lRm9ybWF0IGluc3RhbmNlIGZvciB0aGUgSUFOQSBgdGltZVpvbmVgLiBUaGlzIGNhbiBiZSB1c2VkXG4vLyB0byBnZXQgZGV0ZXJtaW5pc3RpYyBsb2NhbCBkYXRlL3RpbWUgb3V0cHV0IGFjY29yZGluZyB0byB0aGUgYGVuLVVTYCBsb2NhbGUgd2hpY2hcbi8vIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgbG9jYWwgdGltZSBwYXJ0cyBhcyBuZWNlc3NhcnkuXG52YXIgZHRmQ2FjaGUgPSB7fVxuZnVuY3Rpb24gZ2V0RGF0ZVRpbWVGb3JtYXQodGltZVpvbmUpIHtcbiAgaWYgKCFkdGZDYWNoZVt0aW1lWm9uZV0pIHtcbiAgICAvLyBOZXcgYnJvd3NlcnMgdXNlIGBob3VyQ3ljbGVgLCBJRSBhbmQgQ2hyb21lIDw3MyBkb2VzIG5vdCBzdXBwb3J0IGl0IGFuZCB1c2VzIGBob3VyMTJgXG4gICAgdmFyIHRlc3REYXRlRm9ybWF0dGVkID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgIHRpbWVab25lOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgIHNlY29uZDogJzItZGlnaXQnXG4gICAgfSkuZm9ybWF0KG5ldyBEYXRlKCcyMDE0LTA2LTI1VDA0OjAwOjAwLjEyM1onKSlcbiAgICB2YXIgaG91ckN5Y2xlU3VwcG9ydGVkID1cbiAgICAgIHRlc3REYXRlRm9ybWF0dGVkID09PSAnMDYvMjUvMjAxNCwgMDA6MDA6MDAnIHx8XG4gICAgICB0ZXN0RGF0ZUZvcm1hdHRlZCA9PT0gJ+KAjjA24oCOL+KAjjI14oCOL+KAjjIwMTTigI4g4oCOMDDigI464oCOMDDigI464oCOMDAnXG5cbiAgICBkdGZDYWNoZVt0aW1lWm9uZV0gPSBob3VyQ3ljbGVTdXBwb3J0ZWRcbiAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xuICAgICAgICB9KVxuICAgICAgOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7XG4gICAgICAgICAgaG91ckN5Y2xlOiAnaDIzJyxcbiAgICAgICAgICB0aW1lWm9uZTogdGltZVpvbmUsXG4gICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgICAgIG1vbnRoOiAnMi1kaWdpdCcsXG4gICAgICAgICAgZGF5OiAnMi1kaWdpdCcsXG4gICAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgICAgICAgIHNlY29uZDogJzItZGlnaXQnXG4gICAgICAgIH0pXG4gIH1cbiAgcmV0dXJuIGR0ZkNhY2hlW3RpbWVab25lXVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS9fbGliL3R6VG9rZW5pemVEYXRlL2luZGV4LmpzIiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuLi9fbGliL3RvSW50ZWdlci9pbmRleC5qcyc7XG5pbXBvcnQgYWRkTWlsbGlzZWNvbmRzIGZyb20gJy4uL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qcyc7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gJy4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzJztcbi8qKlxuICogQG5hbWUgc3ViTWlsbGlzZWNvbmRzXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xuICogQHN1bW1hcnkgU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgc3VidHJhY3RlZC4gUG9zaXRpdmUgZGVjaW1hbHMgd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmZsb29yYCwgZGVjaW1hbHMgbGVzcyB0aGFuIHplcm8gd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmNlaWxgLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc3VidHJhY3RlZFxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdWJ0cmFjdCA3NTAgbWlsbGlzZWNvbmRzIGZyb20gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIHZhciByZXN1bHQgPSBzdWJNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NToyOS4yNTBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdWJNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCAtYW1vdW50KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3N1Yk1pbGxpc2Vjb25kcy9pbmRleC5qcyIsImltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanMnO1xuaW1wb3J0IHRvRGF0ZSBmcm9tICcuLi90b0RhdGUvaW5kZXguanMnO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tICcuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qcyc7XG4vKipcbiAqIEBuYW1lIGFkZE1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcbiAqXG4gKiAtIFtDaGFuZ2VzIHRoYXQgYXJlIGNvbW1vbiBmb3IgdGhlIHdob2xlIGxpYnJhcnldKGh0dHBzOi8vZ2l0aHViLmNvbS9kYXRlLWZucy9kYXRlLWZucy9ibG9iL21hc3Rlci9kb2NzL3VwZ3JhZGVHdWlkZS5tZCNDb21tb24tQ2hhbmdlcykuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byBiZSBhZGRlZC4gUG9zaXRpdmUgZGVjaW1hbHMgd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmZsb29yYCwgZGVjaW1hbHMgbGVzcyB0aGFuIHplcm8gd2lsbCBiZSByb3VuZGVkIHVzaW5nIGBNYXRoLmNlaWxgLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgYWRkZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWRkIDc1MCBtaWxsaXNlY29uZHMgdG8gMTAgSnVseSAyMDE0IDEyOjQ1OjMwLjAwMDpcbiAqIHZhciByZXN1bHQgPSBhZGRNaWxsaXNlY29uZHMobmV3IERhdGUoMjAxNCwgNiwgMTAsIDEyLCA0NSwgMzAsIDApLCA3NTApXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xuICByZXF1aXJlZEFyZ3MoMiwgYXJndW1lbnRzKTtcbiAgdmFyIHRpbWVzdGFtcCA9IHRvRGF0ZShkaXJ0eURhdGUpLmdldFRpbWUoKTtcbiAgdmFyIGFtb3VudCA9IHRvSW50ZWdlcihkaXJ0eUFtb3VudCk7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKyBhbW91bnQpO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vYWRkTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwiaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tICcuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qcyc7XG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgbm9uZSBvZiB0aGUgYWJvdmUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIEludmFsaWQgRGF0ZS5cbiAqXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDbG9uZSB0aGUgZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHRoZSB0aW1lc3RhbXAgdG8gZGF0ZTpcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZSgxMzkyMDk4NDMwMDAwKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b0RhdGUoYXJndW1lbnQpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxuXG4gIGlmIChhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGRhdGUgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vdG9EYXRlL2luZGV4LmpzIiwiaW1wb3J0IHRvSW50ZWdlciBmcm9tICdkYXRlLWZucy9lc20vX2xpYi90b0ludGVnZXIvaW5kZXguanMnXG5pbXBvcnQgZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyBmcm9tICdkYXRlLWZucy9lc20vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzL2luZGV4LmpzJ1xuaW1wb3J0IHR6UGFyc2VUaW1lem9uZSBmcm9tICcuLi9fbGliL3R6UGFyc2VUaW1lem9uZSdcblxudmFyIE1JTExJU0VDT05EU19JTl9IT1VSID0gMzYwMDAwMFxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMFxudmFyIERFRkFVTFRfQURESVRJT05BTF9ESUdJVFMgPSAyXG5cbnZhciBwYXR0ZXJucyA9IHtcbiAgZGF0ZVRpbWVEZWxpbWV0ZXI6IC9bVCBdLyxcbiAgcGxhaW5UaW1lOiAvOi8sXG4gIHRpbWVab25lRGVsaW1ldGVyOiAvW1ogXS9pLFxuXG4gIC8vIHllYXIgdG9rZW5zXG4gIFlZOiAvXihcXGR7Mn0pJC8sXG4gIFlZWTogW1xuICAgIC9eKFsrLV1cXGR7Mn0pJC8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcbiAgICAvXihbKy1dXFxkezN9KSQvLCAvLyAxIGFkZGl0aW9uYWwgZGlnaXRcbiAgICAvXihbKy1dXFxkezR9KSQvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcbiAgXSxcbiAgWVlZWTogL14oXFxkezR9KS8sXG4gIFlZWVlZOiBbXG4gICAgL14oWystXVxcZHs0fSkvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgL14oWystXVxcZHs1fSkvLCAvLyAxIGFkZGl0aW9uYWwgZGlnaXRcbiAgICAvXihbKy1dXFxkezZ9KS8gLy8gMiBhZGRpdGlvbmFsIGRpZ2l0c1xuICBdLFxuXG4gIC8vIGRhdGUgdG9rZW5zXG4gIE1NOiAvXi0oXFxkezJ9KSQvLFxuICBEREQ6IC9eLT8oXFxkezN9KSQvLFxuICBNTUREOiAvXi0/KFxcZHsyfSktPyhcXGR7Mn0pJC8sXG4gIFd3dzogL14tP1coXFxkezJ9KSQvLFxuICBXd3dEOiAvXi0/VyhcXGR7Mn0pLT8oXFxkezF9KSQvLFxuXG4gIEhIOiAvXihcXGR7Mn0oWy4sXVxcZCopPykkLyxcbiAgSEhNTTogL14oXFxkezJ9KTo/KFxcZHsyfShbLixdXFxkKik/KSQvLFxuICBISE1NU1M6IC9eKFxcZHsyfSk6PyhcXGR7Mn0pOj8oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXG5cbiAgLy8gdGltZXpvbmUgdG9rZW5zICh0byBpZGVudGlmeSB0aGUgcHJlc2VuY2Ugb2YgYSB0eilcbiAgdGltZXpvbmU6IC8oW1orLV0uKnwgVVRDfCg/OlthLXpBLVpdK1xcL1thLXpBLVpfXSsoPzpcXC9bYS16QS1aX10rKT8pKSQvXG59XG5cbi8qKlxuICogQG5hbWUgdG9EYXRlXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGEgbnVtYmVyLCBpdCBpcyB0cmVhdGVkIGFzIGEgdGltZXN0YW1wLlxuICpcbiAqIElmIGFuIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0aGUgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgaXQuXG4gKiBGdW5jdGlvbiBhY2NlcHRzIGNvbXBsZXRlIElTTyA4NjAxIGZvcm1hdHMgYXMgd2VsbCBhcyBwYXJ0aWFsIGltcGxlbWVudGF0aW9ucy5cbiAqIElTTyA4NjAxOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxXG4gKiBJZiB0aGUgZnVuY3Rpb24gY2Fubm90IHBhcnNlIHRoZSBzdHJpbmcgb3IgdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKiBBbGwgKmRhdGUtZm5zKiBmdW5jdGlvbnMgd2lsbCB0aHJvdyBgUmFuZ2VFcnJvcmAgaWYgYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgaXMgbm90IDAsIDEsIDIgb3IgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge09wdGlvbnNXaXRoVFp9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zLiBTZWUgW09wdGlvbnNde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvT3B0aW9uc31cbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpbWVab25lPScnXSAtIHVzZWQgdG8gc3BlY2lmeSB0aGUgSUFOQSB0aW1lIHpvbmUgb2Zmc2V0IG9mIGEgZGF0ZSBTdHJpbmcuXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XG4gKiB2YXIgcmVzdWx0ID0gdG9EYXRlKCcyMDE0LTAyLTExVDExOjMwOjMwJylcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcrMDIwMTQxMDEnIHRvIGRhdGUsXG4gKiAvLyBpZiB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdCBpcyAxOlxuICogdmFyIHJlc3VsdCA9IHRvRGF0ZSgnKzAyMDE0MTAxJywge2FkZGl0aW9uYWxEaWdpdHM6IDF9KVxuICogLy89PiBGcmkgQXByIDExIDIwMTQgMDA6MDA6MDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50LCBkaXJ0eU9wdGlvbnMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgcHJlc2VudCdcbiAgICApXG4gIH1cblxuICBpZiAoYXJndW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSBkaXJ0eU9wdGlvbnMgfHwge31cblxuICB2YXIgYWRkaXRpb25hbERpZ2l0cyA9XG4gICAgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzID09IG51bGxcbiAgICAgID8gREVGQVVMVF9BRERJVElPTkFMX0RJR0lUU1xuICAgICAgOiB0b0ludGVnZXIob3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzKVxuICBpZiAoXG4gICAgYWRkaXRpb25hbERpZ2l0cyAhPT0gMiAmJlxuICAgIGFkZGl0aW9uYWxEaWdpdHMgIT09IDEgJiZcbiAgICBhZGRpdGlvbmFsRGlnaXRzICE9PSAwXG4gICkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhZGRpdGlvbmFsRGlnaXRzIG11c3QgYmUgMCwgMSBvciAyJylcbiAgfVxuXG4gIC8vIENsb25lIHRoZSBkYXRlXG4gIGlmIChcbiAgICBhcmd1bWVudCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAodHlwZW9mIGFyZ3VtZW50ID09PSAnb2JqZWN0JyAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgRGF0ZV0nKVxuICApIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKVxuICB9IGVsc2UgaWYgKFxuICAgIHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHxcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICApIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpXG4gIH0gZWxzZSBpZiAoXG4gICAgIShcbiAgICAgIHR5cGVvZiBhcmd1bWVudCA9PT0gJ3N0cmluZycgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IFN0cmluZ10nXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICB9XG5cbiAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KVxuXG4gIHZhciBwYXJzZVllYXJSZXN1bHQgPSBwYXJzZVllYXIoZGF0ZVN0cmluZ3MuZGF0ZSwgYWRkaXRpb25hbERpZ2l0cylcbiAgdmFyIHllYXIgPSBwYXJzZVllYXJSZXN1bHQueWVhclxuICB2YXIgcmVzdERhdGVTdHJpbmcgPSBwYXJzZVllYXJSZXN1bHQucmVzdERhdGVTdHJpbmdcblxuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShyZXN0RGF0ZVN0cmluZywgeWVhcilcblxuICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICB9XG5cbiAgaWYgKGRhdGUpIHtcbiAgICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKClcbiAgICB2YXIgdGltZSA9IDBcbiAgICB2YXIgb2Zmc2V0XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKVxuXG4gICAgICBpZiAoaXNOYU4odGltZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0ZVN0cmluZ3MudGltZXpvbmUgfHwgb3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgb2Zmc2V0ID0gdHpQYXJzZVRpbWV6b25lKFxuICAgICAgICBkYXRlU3RyaW5ncy50aW1lem9uZSB8fCBvcHRpb25zLnRpbWVab25lLFxuICAgICAgICBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKVxuICAgICAgKVxuICAgICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IHR6UGFyc2VUaW1lem9uZShcbiAgICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgfHwgb3B0aW9ucy50aW1lWm9uZSxcbiAgICAgICAgbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldClcbiAgICAgIClcbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldCBvZmZzZXQgYWNjdXJhdGUgdG8gaG91ciBpbiB0aW1lem9uZXMgdGhhdCBjaGFuZ2Ugb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUpKVxuICAgICAgb2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhcbiAgICAgICAgbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldClcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNwbGl0RGF0ZVN0cmluZyhkYXRlU3RyaW5nKSB7XG4gIHZhciBkYXRlU3RyaW5ncyA9IHt9XG4gIHZhciBhcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMuZGF0ZVRpbWVEZWxpbWV0ZXIpXG4gIHZhciB0aW1lU3RyaW5nXG5cbiAgaWYgKHBhdHRlcm5zLnBsYWluVGltZS50ZXN0KGFycmF5WzBdKSkge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBudWxsXG4gICAgdGltZVN0cmluZyA9IGFycmF5WzBdXG4gIH0gZWxzZSB7XG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGFycmF5WzBdXG4gICAgdGltZVN0cmluZyA9IGFycmF5WzFdXG4gICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSBhcnJheVsyXVxuICAgIGlmIChwYXR0ZXJucy50aW1lWm9uZURlbGltZXRlci50ZXN0KGRhdGVTdHJpbmdzLmRhdGUpKSB7XG4gICAgICBkYXRlU3RyaW5ncy5kYXRlID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy50aW1lWm9uZURlbGltZXRlcilbMF1cbiAgICAgIHRpbWVTdHJpbmcgPSBkYXRlU3RyaW5nLnN1YnN0cihkYXRlU3RyaW5ncy5kYXRlLmxlbmd0aCwgZGF0ZVN0cmluZy5sZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKHRpbWVTdHJpbmcpIHtcbiAgICB2YXIgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZS5leGVjKHRpbWVTdHJpbmcpXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZy5yZXBsYWNlKHRva2VuWzFdLCAnJylcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0ZVN0cmluZ3Ncbn1cblxuZnVuY3Rpb24gcGFyc2VZZWFyKGRhdGVTdHJpbmcsIGFkZGl0aW9uYWxEaWdpdHMpIHtcbiAgdmFyIHBhdHRlcm5ZWVkgPSBwYXR0ZXJucy5ZWVlbYWRkaXRpb25hbERpZ2l0c11cbiAgdmFyIHBhdHRlcm5ZWVlZWSA9IHBhdHRlcm5zLllZWVlZW2FkZGl0aW9uYWxEaWdpdHNdXG5cbiAgdmFyIHRva2VuXG5cbiAgLy8gWVlZWSBvciDCsVlZWVlZXG4gIHRva2VuID0gcGF0dGVybnMuWVlZWS5leGVjKGRhdGVTdHJpbmcpIHx8IHBhdHRlcm5ZWVlZWS5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIHZhciB5ZWFyU3RyaW5nID0gdG9rZW5bMV1cbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogcGFyc2VJbnQoeWVhclN0cmluZywgMTApLFxuICAgICAgcmVzdERhdGVTdHJpbmc6IGRhdGVTdHJpbmcuc2xpY2UoeWVhclN0cmluZy5sZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgLy8gWVkgb3IgwrFZWVlcbiAgdG9rZW4gPSBwYXR0ZXJucy5ZWS5leGVjKGRhdGVTdHJpbmcpIHx8IHBhdHRlcm5ZWVkuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB2YXIgY2VudHVyeVN0cmluZyA9IHRva2VuWzFdXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KGNlbnR1cnlTdHJpbmcsIDEwKSAqIDEwMCxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKGNlbnR1cnlTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIHJldHVybiB7XG4gICAgeWVhcjogbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nLCB5ZWFyKSB7XG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXG4gIGlmICh5ZWFyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHZhciB0b2tlblxuICB2YXIgZGF0ZVxuICB2YXIgbW9udGhcbiAgdmFyIHdlZWtcblxuICAvLyBZWVlZXG4gIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhcilcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1NTVxuICB0b2tlbiA9IHBhdHRlcm5zLk1NLmV4ZWMoZGF0ZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxuXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgIH1cblxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgpXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktREREIG9yIFlZWVlERERcbiAgdG9rZW4gPSBwYXR0ZXJucy5EREQuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMClcbiAgICB2YXIgZGF5T2ZZZWFyID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKVxuXG4gICAgaWYgKCF2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGRheU9mWWVhcilcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8geXl5eS1NTS1kZCBvciBZWVlZTU1ERFxuICB0b2tlbiA9IHBhdHRlcm5zLk1NREQuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMClcbiAgICBtb250aCA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxXG4gICAgdmFyIGRheSA9IHBhcnNlSW50KHRva2VuWzJdLCAxMClcblxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXkpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgIH1cblxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRheSlcbiAgICByZXR1cm4gZGF0ZVxuICB9XG5cbiAgLy8gWVlZWS1Xd3cgb3IgWVlZWVd3d1xuICB0b2tlbiA9IHBhdHRlcm5zLld3dy5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxuXG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWspKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgIH1cblxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWspXG4gIH1cblxuICAvLyBZWVlZLVd3dy1EIG9yIFlZWVlXd3dEXG4gIHRva2VuID0gcGF0dGVybnMuV3d3RC5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIHdlZWsgPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxuICAgIHZhciBkYXlPZldlZWsgPSBwYXJzZUludCh0b2tlblsyXSwgMTApIC0gMVxuXG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWssIGRheU9mV2VlaykpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaywgZGF5T2ZXZWVrKVxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIGRhdGVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWVTdHJpbmcpIHtcbiAgdmFyIHRva2VuXG4gIHZhciBob3Vyc1xuICB2YXIgbWludXRlc1xuXG4gIC8vIGhoXG4gIHRva2VuID0gcGF0dGVybnMuSEguZXhlYyh0aW1lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlRmxvYXQodG9rZW5bMV0ucmVwbGFjZSgnLCcsICcuJykpXG5cbiAgICBpZiAoIXZhbGlkYXRlVGltZShob3VycykpIHtcbiAgICAgIHJldHVybiBOYU5cbiAgICB9XG5cbiAgICByZXR1cm4gKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVJcbiAgfVxuXG4gIC8vIGhoOm1tIG9yIGhobW1cbiAgdG9rZW4gPSBwYXR0ZXJucy5ISE1NLmV4ZWModGltZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsxXSwgMTApXG4gICAgbWludXRlcyA9IHBhcnNlRmxvYXQodG9rZW5bMl0ucmVwbGFjZSgnLCcsICcuJykpXG5cbiAgICBpZiAoIXZhbGlkYXRlVGltZShob3VycywgbWludXRlcykpIHtcbiAgICAgIHJldHVybiBOYU5cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKGhvdXJzICUgMjQpICogTUlMTElTRUNPTkRTX0lOX0hPVVIgKyBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURVxuICAgIClcbiAgfVxuXG4gIC8vIGhoOm1tOnNzIG9yIGhobW1zc1xuICB0b2tlbiA9IHBhdHRlcm5zLkhITU1TUy5leGVjKHRpbWVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKVxuICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXG4gICAgdmFyIHNlY29uZHMgPSBwYXJzZUZsb2F0KHRva2VuWzNdLnJlcGxhY2UoJywnLCAnLicpKVxuXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpKSB7XG4gICAgICByZXR1cm4gTmFOXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSICtcbiAgICAgIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICtcbiAgICAgIHNlY29uZHMgKiAxMDAwXG4gICAgKVxuICB9XG5cbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gZGF5T2ZJU09XZWVrWWVhcihpc29XZWVrWWVhciwgd2VlaywgZGF5KSB7XG4gIHdlZWsgPSB3ZWVrIHx8IDBcbiAgZGF5ID0gZGF5IHx8IDBcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGlzb1dlZWtZZWFyLCAwLCA0KVxuICB2YXIgZm91cnRoT2ZKYW51YXJ5RGF5ID0gZGF0ZS5nZXRVVENEYXkoKSB8fCA3XG4gIHZhciBkaWZmID0gd2VlayAqIDcgKyBkYXkgKyAxIC0gZm91cnRoT2ZKYW51YXJ5RGF5XG4gIGRhdGUuc2V0VVRDRGF0ZShkYXRlLmdldFVUQ0RhdGUoKSArIGRpZmYpXG4gIHJldHVybiBkYXRlXG59XG5cbi8vIFZhbGlkYXRpb24gZnVuY3Rpb25zXG5cbnZhciBEQVlTX0lOX01PTlRIID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG52YXIgREFZU19JTl9NT05USF9MRUFQX1lFQVIgPSBbMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cblxuZnVuY3Rpb24gaXNMZWFwWWVhckluZGV4KHllYXIpIHtcbiAgcmV0dXJuIHllYXIgJSA0MDAgPT09IDAgfHwgKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICBpZiAobW9udGggPCAwIHx8IG1vbnRoID4gMTEpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChkYXRlICE9IG51bGwpIHtcbiAgICBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4KHllYXIpXG4gICAgaWYgKGlzTGVhcFllYXIgJiYgZGF0ZSA+IERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSW21vbnRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghaXNMZWFwWWVhciAmJiBkYXRlID4gREFZU19JTl9NT05USFttb250aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpIHtcbiAgaWYgKGRheU9mWWVhciA8IDEpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4KHllYXIpXG4gIGlmIChpc0xlYXBZZWFyICYmIGRheU9mWWVhciA+IDM2Nikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmICghaXNMZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5KSB7XG4gIGlmICh3ZWVrIDwgMCB8fCB3ZWVrID4gNTIpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChkYXkgIT0gbnVsbCAmJiAoZGF5IDwgMCB8fCBkYXkgPiA2KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSB7XG4gIGlmIChob3VycyAhPSBudWxsICYmIChob3VycyA8IDAgfHwgaG91cnMgPj0gMjUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWludXRlcyAhPSBudWxsICYmIChtaW51dGVzIDwgMCB8fCBtaW51dGVzID49IDYwKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKHNlY29uZHMgIT0gbnVsbCAmJiAoc2Vjb25kcyA8IDAgfHwgc2Vjb25kcyA+PSA2MCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMtdHovZXNtL3RvRGF0ZS9pbmRleC5qcyIsInZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDA7XG5cbmZ1bmN0aW9uIGdldERhdGVNaWxsaXNlY29uZHNQYXJ0KGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpICUgTUlMTElTRUNPTkRTX0lOX01JTlVURTtcbn1cbi8qKlxuICogR29vZ2xlIENocm9tZSBhcyBvZiA2Ny4wLjMzOTYuODcgaW50cm9kdWNlZCB0aW1lem9uZXMgd2l0aCBvZmZzZXQgdGhhdCBpbmNsdWRlcyBzZWNvbmRzLlxuICogVGhleSB1c3VhbGx5IGFwcGVhciBmb3IgZGF0ZXMgdGhhdCBkZW5vdGUgdGltZSBiZWZvcmUgdGhlIHRpbWV6b25lcyB3ZXJlIGludHJvZHVjZWRcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXG4gKiBhbmQgR01UKzAxOjAwOjAwIGFmdGVyIHRoYXQgZGF0ZSlcbiAqXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxuICogd2hpY2ggd291bGQgbGVhZCB0byBpbmNvcnJlY3QgY2FsY3VsYXRpb25zLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoZGlydHlEYXRlKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoZGlydHlEYXRlLmdldFRpbWUoKSk7XG4gIHZhciBiYXNlVGltZXpvbmVPZmZzZXQgPSBNYXRoLmNlaWwoZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgZGF0ZS5zZXRTZWNvbmRzKDAsIDApO1xuICB2YXIgaGFzTmVnYXRpdmVVVENPZmZzZXQgPSBiYXNlVGltZXpvbmVPZmZzZXQgPiAwO1xuICB2YXIgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQgPSBoYXNOZWdhdGl2ZVVUQ09mZnNldCA/IChNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICsgZ2V0RGF0ZU1pbGxpc2Vjb25kc1BhcnQoZGF0ZSkpICUgTUlMTElTRUNPTkRTX0lOX01JTlVURSA6IGdldERhdGVNaWxsaXNlY29uZHNQYXJ0KGRhdGUpO1xuICByZXR1cm4gYmFzZVRpbWV6b25lT2Zmc2V0ICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArIG1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbi8qKlxuICogRXZlbnRzIE1peGluXG4gKlxuICogQWxsb3cgY2xhc3NlcyB0byBoYXZlIHRoZWlyIG93biBldmVudHMgbWFuYWdlclxuICpcbiAqIEBwYXJhbSB7Q2xhc3N9IHN1cGVyQ2xhc3NcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jb25zdCBFdmVudHNNaXhpbiA9IHN1cGVyQ2xhc3MgPT5cbiAgY2xhc3MgZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgcmVnaXN0ZXJzIGhhbmRsZXJzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIF9faGFuZGxlcnMgPSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgaGFuZGxlciBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX19oYW5kbGVyc1tuYW1lXSA9IHRoaXMuX19oYW5kbGVyc1tuYW1lXSB8fCBbXVxuICAgICAgdGhpcy5fX2hhbmRsZXJzW25hbWVdLnB1c2goaGFuZGxlcilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICAgICAqXG4gICAgICogKipOb3RlIDoqKiBpZiBoYW5kbGVyIGlzIG5vdCBwcm92aWRlZCB0aGVuIGFsbCByZWdpc3RlcmVkIGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBldmVudCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvZmYobmFtZSwgaGFuZGxlcikge1xuICAgICAgdGhpcy5fX2hhbmRsZXJzW25hbWVdID0gdGhpcy5fX2hhbmRsZXJzW25hbWVdIHx8IFtdXG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX19oYW5kbGVyc1tuYW1lXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWdpc3RlcmVkSGFuZGxlciBpbiB0aGlzLl9faGFuZGxlcnMpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLl9faGFuZGxlcnMuaGFzT3duUHJvcGVydHkocmVnaXN0ZXJlZEhhbmRsZXIpICYmXG4gICAgICAgICAgICB0aGlzLl9faGFuZGxlcnNbcmVnaXN0ZXJlZEhhbmRsZXJdID09PSBoYW5kbGVyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fX2hhbmRsZXJzW25hbWVdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IGhhbmRsZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IHBheWxvYWRcbiAgICAgKi9cbiAgICBub3RpZnkobmFtZSwgcGF5bG9hZCkge1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLl9faGFuZGxlcnNbbmFtZV0gfHwgW11cbiAgICAgIGhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgIGhhbmRsZXIocGF5bG9hZClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbi8qKlxuICogQW4gZXZlbnRzIG1peGluIGRlY29yYXRvclxuICpcbiAqIEBwYXJhbSB7Q2xhc3N9IHN1cGVyQ2xhc3NcbiAqXG4gKiBAc2VlIHtFdmVudHNNaXhpbn1cbiAqL1xuZnVuY3Rpb24gd2l0aEV2ZW50c01peGluKHN1cGVyQ2xhc3MpIHtcbiAgcmV0dXJuIEV2ZW50c01peGluKHN1cGVyQ2xhc3MpXG59XG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50c01peGluXG5leHBvcnQgeyBFdmVudHNNaXhpbiwgd2l0aEV2ZW50c01peGluIH1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9FdmVudHNNaXhpbi9FdmVudHNNaXhpbi5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCB7IGF1dG9iaW5kLCBvdmVycmlkZSwgcmVhZG9ubHkgfSBmcm9tICdjb3JlLWRlY29yYXRvcnMnXG5pbXBvcnQgeyB3aXRoRXZlbnRzTWl4aW4gfSBmcm9tICcuLi9FdmVudHNNaXhpbidcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0ICcuL3N0eWxlLnNjc3MnXG5cbi8qKlxuICogRGF0ZVRpbWVJbnB1dFxuICpcbiAqIFNpbXBsZSBEYXRlVGltZUlucHV0IGNvbXBvbmVudCB3aGljaCBpbnRlZ3JhdGVzIHRoZSBmbGF0cGlja3JcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5Ad2l0aEV2ZW50c01peGluXG5jbGFzcyBEYXRlVGltZUlucHV0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0YW50IHdoaWNoIGRlc2NyaWJlcyB0aGUgZXZlbnQgbmFtZSB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhIGRhdGVcbiAgICogaXMgc2VsZWN0ZWQgdXNpbmcgdGhlIGRhdGUgcGlja2VyXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBAcmVhZG9ubHlcbiAgc3RhdGljIE9OX0RBVEVfQ0hBTkdFRCA9ICdEYXRlVGltZUlucHV0Lk9OX0RBVEVfQ0hBTkdFRCdcblxuICAvKipcbiAgICogVGhlIGRhdGUgcGlja2VyIGluc3RhbmNlXG4gICAqXG4gICAqIEB0eXBlIHtGbGF0cGlja3JGbn1cbiAgICovXG4gIHBpY2tlciA9IG51bGxcblxuICAvKipcbiAgICogVGhlIGxhc3Qgc2VsZWN0ZWQgZGF0ZVxuICAgKlxuICAgKiBAdHlwZSB7RGF0ZXxudWxsfVxuICAgKi9cbiAgc2VsZWN0ZWREYXRlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50IHJlY2VpdmVkIHBhcmFtcyB3aGVuIGluaXQgaXMgY2FsbGVkXG4gICAqc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgX3BhcmFtcyA9IHt9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBuZXcgRGF0ZVRpbWVJbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRWRpdG9yIHdoZW4gdHJ1ZSAsIHRoZSBpbnB1dCB3aWxsIHN0eWxlZCB0byBmaXQgYXMgYSBjZWxsIGVkaXRvclxuICAgKi9cbiAgY29uc3RydWN0b3IoaXNFZGl0b3IgPSBmYWxzZSkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICdhZy1jZWxsLWVkaXQtd3JhcHBlcidcbiAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgPGRpdiBjbGFzcz1cImFnLWNlbGwtZWRpdG9yIGFnLWxhYmVsZWQgYWctbGFiZWwtYWxpZ24tbGVmdCBhZy10ZXh0LWZpZWxkIGFnLWlucHV0LWZpZWxkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiZGF0ZXRpbWVfX2lucHV0ICR7XG4gICAgICAgIGlzRWRpdG9yID8gJ2RhdGV0aW1lX19pbnB1dC0tZWRpdG9yICcgOiAnJ1xuICAgICAgfSBhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctdGV4dC1maWVsZC1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgPGlucHV0IGNsYXNzPVwiZGF0ZXRpbWVfX2lucHV0X19pbnB1dCAke1xuICAgICAgICAgICAgaXNFZGl0b3IgPyAnYWctY2VsbC1lZGl0LWlucHV0ICcgOiAnJ1xuICAgICAgICAgIH0gYWctaW5wdXQtZmllbGQtaW5wdXQgYWctdGV4dC1maWVsZC1pbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgZGF0YS1pbnB1dD5cbiAgICAgICAgICA8YSBjbGFzcz1cImRhdGV0aW1lX19pbnB1dF9fY2xlYXJcIiBkYXRhLWNsZWFyPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJkYXRldGltZV9faW5wdXRfX2NsZWFyX19pY29uIGFnLWljb24gYWctaWNvbi1jcm9zc1wiPjwvaT5cbiAgICAgICAgICA8L2E+ICAgIFxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYFxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIGluaXQocGFyYW1zKSB7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zXG4gICAgY29uc3QgZW5hYmxlVGltZSA9IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZUVuYWJsZVRpbWUnLCBwYXJhbXMsIHRydWUpXG4gICAgY29uc3QgdGltZV8yNGhyID0gdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRW5hYmxlMjRIUicsIHBhcmFtcywgdHJ1ZSlcbiAgICBjb25zdCBlbmFibGVTZWNvbmRzID0gdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRW5hYmxlU2Vjb25kcycsIHBhcmFtcywgZmFsc2UpXG4gICAgY29uc3Qgbm9DYWxlbmRhciA9ICF0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVFbmFibGVDYWxlbmRhcicsIHBhcmFtcywgdHJ1ZSlcblxuICAgIGxldCBkYXRlRm9ybWF0ID0gdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lTWFzaycsIHBhcmFtcylcblxuICAgIC8vIHRyeSB0byBnZW5lcmF0ZSBhIGRlZmF1bHQgZGF0ZSBmb3JtYXQgYmFzZWQgb24gdGhlIG9wdGlvbnNcbiAgICBpZiAoIWRhdGVGb3JtYXQpIHtcbiAgICAgIGRhdGVGb3JtYXQgPSBub0NhbGVuZGFyID8gJycgOiAnJVkvJU16LyVEeidcbiAgICAgIGlmIChlbmFibGVUaW1lKSB7XG4gICAgICAgIGRhdGVGb3JtYXQgKz0gdGltZV8yNGhyID8gJyAlSHo6JW16JyA6ICcgJWh6OiVteidcblxuICAgICAgICBpZiAoZW5hYmxlU2Vjb25kcykge1xuICAgICAgICAgIGRhdGVGb3JtYXQgKz0gJzolc3onXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdC50cmltKClcblxuICAgIC8vIGluaXQgdGhlIGRhdGUgcGlja2VyXG4gICAgdGhpcy5waWNrZXIgPSBmbGF0cGlja3IodGhpcy5fZ3VpLCB7XG4gICAgICB3cmFwOiB0cnVlLFxuICAgICAgLy8gYWxsb3cgZW50ZXJpbmcgdGhlIGRhdGUgbWFudWFsbHkgcmVxdWlyZXMgZGF0ZSBwYXJzaW5nIGZyb20gc3RyaW5nXG4gICAgICAvLyB0aGlzIGlzIGEgdG91Z2ggdGhpbmcgYW5kIHJlcXVpcmVzIGxpYnMgbGlrZSBtb21lbnRcbiAgICAgIGFsbG93SW5wdXQ6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IHRoaXMuX29uRGF0ZUNoYW5nZWQsXG4gICAgICBmb3JtYXREYXRlOiB0aGlzLmZvcm1hdERhdGUsXG4gICAgICBtYXhEYXRlOiB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVNYXgnLCBwYXJhbXMsIG51bGwpLFxuICAgICAgbWluRGF0ZTogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lTWluJywgcGFyYW1zLCBudWxsKSxcbiAgICAgIGRlZmF1bHRIb3VyOiB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVEZWZhdWx0SG91cicsIHBhcmFtcywgMTIpLFxuICAgICAgZGVmYXVsdE1pbnV0ZTogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRGVmYXVsdE1pbnV0ZScsIHBhcmFtcywgMCksXG4gICAgICBkaXNhYmxlTW9iaWxlOiB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVEaXNhYmxlTW9iaWxlJywgcGFyYW1zLCBmYWxzZSksXG4gICAgICB3ZWVrTnVtYmVyczogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRW5hYmxlV2Vla051bWJlcicsIHBhcmFtcywgZmFsc2UpLFxuICAgICAgbG9jYWxlOiB0aGlzLl9nZXRQaWNrZXJMb2NhbGUoKSxcbiAgICAgIG5vQ2FsZW5kYXIsXG4gICAgICBkYXRlRm9ybWF0LFxuICAgICAgZW5hYmxlVGltZSxcbiAgICAgIGVuYWJsZVNlY29uZHMsXG4gICAgICB0aW1lXzI0aHIsXG4gICAgfSlcblxuICAgIC8vIGZvcmNlIGRpYWxvZyBvdmVyZmxvd1xuICAgIHRoaXMucGlja2VyLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FnLWN1c3RvbS1jb21wb25lbnQtcG9wdXAnKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBpY2tlci5kZXN0cm95KClcbiAgICB0aGlzLm9mZihEYXRlVGltZUlucHV0Lk9OX0RBVEVfQ0hBTkdFRClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBpY2tlciBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSB7RGF0ZXxTdHJpbmd9IHZhbHVlIHRoZSBkYXRlIHZhbHVlIHRvIHNldFxuICAgKi9cbiAgc2V0RGF0ZSh2YWx1ZSkge1xuICAgIHRoaXMucGlja2VyLnNldERhdGUodmFsdWUsIHRydWUpXG4gIH1cblxuICAvKipcbiAgICogT3BlbiBQaWNrZXJcbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5waWNrZXIub3BlbigpXG4gICAgdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykuZm9jdXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIHBpY2tlclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5waWNrZXIuY2xvc2UoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBwaWNrZXJcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIC8qKiB0aGlzIGNoZWNrIGJlY2F1c2UgdGhlIHRlc3RzIGZhaWwgaGVyZSBmb3Igc29tZSByZWFzb25zICAqL1xuICAgIGlmICh0aGlzLnBpY2tlci5jb25maWcpIHtcbiAgICAgIHRoaXMucGlja2VyLmNsZWFyKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IHRoZSBkYXRlIHVzaW5nIGBCQmouTWFza3MuVHlwZXMuZGF0ZWBcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGUgZGF0ZSBhcyBhIHN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IEJCaiBkYXRlIGZvcm1hdFxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGZvcm1hdHRlZCBkYXRlIGFzIHN0cmluZ1xuICAgKi9cbiAgQGF1dG9iaW5kXG4gIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgZGF0ZVRpbWVGb3JtYXR0ZXIgPSB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVGb3JtYXR0ZXInLCB0aGlzLl9wYXJhbXMpXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAnZGF0ZVRpbWVMb2NhbGUnLFxuICAgICAgdGhpcy5fcGFyYW1zLFxuICAgICAgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZSB8fCAnZW4tVVMnXG4gICAgKVxuXG4gICAgaWYgKGRhdGVUaW1lRm9ybWF0dGVyKSB7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGRhdGVUaW1lRm9ybWF0dGVyXG4gICAgICBsZXQgZXhwcmVzc2lvbiA9IGRhdGVUaW1lRm9ybWF0dGVyXG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGlmICghKGV4cHJlc3Npb24uaW5kZXhPZigncmV0dXJuJykgPj0gMCkpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSAncmV0dXJuICcgKyBleHByZXNzaW9uICsgJzsnXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihcbiAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICdmb3JtYXQnLFxuICAgICAgICAgICAgJ2xvY2FsZScsXG4gICAgICAgICAgICAnRGF0ZU1hc2snLFxuICAgICAgICAgICAgZXhwcmVzc2lvblxuICAgICAgICAgICkoZGF0ZSwgZm9ybWF0LCBsb2NhbGUsIEJCai5NYXNrcy5EYXRlTWFzaylcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgcmV0dXJuIGRhdGVUaW1lRm9ybWF0dGVyKGRhdGUsIGZvcm1hdCwgbG9jYWxlLCBCQmouTWFza3MuRGF0ZU1hc2spXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgZGF0ZVRpbWVGb3JtYXR0ZXIgZGVmaW5lZCBmb3IgY29sdW1uIFwiJHt0aGlzLl9wYXJhbXMuY29sRGVmLmZpZWxkfVwiLiBUaGUgZm9ybWF0dGVyIHNob3VsZCBiZSBhbiBleHByZXNzaW9uIG9yIHBsYWluIGZ1bmN0aW9uYFxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFmb3JtYXQgfHwgKGZvcm1hdCAmJiBmb3JtYXQuaW5kZXhPZignJScpIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBCQmouTWFza3MuRGF0ZU1hc2subWFzayhkYXRlLCBmb3JtYXQsIGxvY2FsZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGRhdGUgcGlja2VyIGNoYW5nZXMgYW5kIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZERhdGVzICBhcnJheSBvZiBzZWxlY3RlZCBkYXRlc1xuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkRhdGVDaGFuZ2VkKHNlbGVjdGVkRGF0ZXMpIHtcbiAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IHNlbGVjdGVkRGF0ZXNbMF0gfHwgbnVsbFxuICAgIHRoaXMubm90aWZ5KERhdGVUaW1lSW5wdXQuT05fREFURV9DSEFOR0VELCB0aGlzLnNlbGVjdGVkRGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGlja2VyIGdsb2JhbCBsb2NhbGl6YXRpb24gd2hpY2ggd2lsbCB3b3JrIHdpdGggYW55IGxvY2FsZVxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGF0cGlja3IvZmxhdHBpY2tyL2Jsb2IvbWFzdGVyL3NyYy9sMTBuL2RlZmF1bHQudHNcbiAgICovXG4gIF9nZXRQaWNrZXJMb2NhbGUoKSB7XG4gICAgY29uc3QgbG9jYWxlID0gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZSB8fCAnZW4tVVMnXG5cbiAgICBjb25zdCB3ZWVrRGF5c1Nob3J0ID0gW11cbiAgICBjb25zdCB3ZWVrRGF5c0xvbmcgPSBbXVxuXG4gICAgZm9yIChsZXQgZGF5ID0gNDsgZGF5IDwgMTE7IGRheSsrKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoMTk3MCwgMSAtIDEsIGRheSlcblxuICAgICAgd2Vla0RheXNTaG9ydC5wdXNoKFxuICAgICAgICBkYXRlXG4gICAgICAgICAgLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwge1xuICAgICAgICAgICAgd2Vla2RheTogJ3Nob3J0JyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zcGxpdCgnLCcpWzBdIC8vIHRoZSBkYXRlLXRpbWUtZm9ybWF0LXRpbWV6b25lIHBvbHlmaWxsIGF0dGFjaCB0aGUgZGF0ZSBhbHNvXG4gICAgICApXG5cbiAgICAgIHdlZWtEYXlzTG9uZy5wdXNoKFxuICAgICAgICBkYXRlXG4gICAgICAgICAgLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwge1xuICAgICAgICAgICAgd2Vla2RheTogJ2xvbmcnLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNwbGl0KCcsJylbMF0gLy8gdGhlIGRhdGUtdGltZS1mb3JtYXQtdGltZXpvbmUgcG9seWZpbGwgYXR0YWNoIHRoZSBkYXRlIGFsc29cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBtb250aHNTaG9ydCA9IFtdXG4gICAgY29uc3QgbW9udGhzTG9uZyA9IFtdXG5cbiAgICBmb3IgKGxldCBtb250aCA9IDA7IG1vbnRoIDwgMTI7IG1vbnRoKyspIHtcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgxOTcwLCBtb250aCwgNClcblxuICAgICAgbW9udGhzU2hvcnQucHVzaChcbiAgICAgICAgZGF0ZS50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHtcbiAgICAgICAgICBtb250aDogJ3Nob3J0JyxcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgICAgbW9udGhzTG9uZy5wdXNoKFxuICAgICAgICBkYXRlLnRvTG9jYWxlU3RyaW5nKGxvY2FsZSwge1xuICAgICAgICAgIG1vbnRoOiAnbG9uZycsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdlZWtkYXlzOiB7XG4gICAgICAgIHNob3J0aGFuZDogd2Vla0RheXNTaG9ydCxcbiAgICAgICAgbG9uZ2hhbmQ6IHdlZWtEYXlzTG9uZyxcbiAgICAgIH0sXG4gICAgICBtb250aHM6IHtcbiAgICAgICAgc2hvcnRoYW5kOiBtb250aHNTaG9ydCxcbiAgICAgICAgbG9uZ2hhbmQ6IG1vbnRoc0xvbmcsXG4gICAgICB9LFxuICAgICAgZGF5c0luTW9udGg6IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSxcbiAgICAgIGZpcnN0RGF5T2ZXZWVrOiBCQmouTWFza3MuVXRpbHMuRGF0ZXMuZ2V0V2Vla1N0YXJ0QnlMb2NhbGUobG9jYWxlKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgb3JkaW5hbDogbnVtYmVyID0+ICcnLFxuICAgICAgcmFuZ2VTZXBhcmF0b3I6ICcgICcsXG4gICAgICB3ZWVrQWJicmV2aWF0aW9uOiAnJyxcbiAgICAgIHNjcm9sbFRpdGxlOiAnJyxcbiAgICAgIHRvZ2dsZVRpdGxlOiAnJyxcbiAgICAgIGFtUE06IFsnQU0nLCAnUE0nXSxcbiAgICAgIHllYXJBcmlhTGFiZWw6ICcnLFxuICAgICAgaG91ckFyaWFMYWJlbDogJycsXG4gICAgICBtaW51dGVBcmlhTGFiZWw6ICcnLFxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUlucHV0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRGF0ZVRpbWVJbnB1dC9EYXRlVGltZUlucHV0LmpzIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lSW5wdXQvc3R5bGUuc2NzcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmRhdGV0aW1lX19pbnB1dHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctaW5wdXQtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNiYWJmYzcpKTtib3JkZXItcmFkaXVzOjNweH0uZGF0ZXRpbWVfX2lucHV0OmZvY3VzLC5kYXRldGltZV9faW5wdXQ6YWN0aXZlLC5kYXRldGltZV9faW5wdXQ6aG92ZXJ7Ym9yZGVyLWNvbG9yOnZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywxNTAsMjQzLDAuNCkpfS5kYXRldGltZV9faW5wdXRfX2lucHV0e2ZsZXg6MTtwYWRkaW5nOjZweDtib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yKTtjb2xvcjppbmhlcml0fS5hZy10aGVtZS1hbHBpbmUgLmRhdGV0aW1lX19pbnB1dF9faW5wdXQsLmFnLXRoZW1lLWJhbGhhbSAuZGF0ZXRpbWVfX2lucHV0X19pbnB1dCwuYWctdGhlbWUtbWF0ZXJpYWwgLmRhdGV0aW1lX19pbnB1dF9faW5wdXR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjZmZmKX0uYWctdGhlbWUtYWxwaW5lLWRhcmsgLmRhdGV0aW1lX19pbnB1dF9faW5wdXQsLmFnLXRoZW1lLWJhbGhhbS1kYXJrIC5kYXRldGltZV9faW5wdXRfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzJkMzQzNil9LmRhdGV0aW1lX19pbnB1dF9fY2xlYXJ7bWFyZ2luLWxlZnQ6MXB4O21hcmdpbi10b3A6MXB4O3BhZGRpbmc6NnB4O3RleHQtYWxpZ246Y2VudGVyO2JvcmRlcjpub25lO291dGxpbmU6bm9uZTtjdXJzb3I6cG9pbnRlcjtjb2xvcjppbmhlcml0fS5kYXRldGltZV9faW5wdXQtLWVkaXRvcntib3JkZXItY29sb3I6dmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCByZ2JhKDMzLDE1MCwyNDMsMC40KSl9LmRhdGV0aW1lX19pbnB1dC0tZWRpdG9yIC5kYXRldGltZV9faW5wdXRfX2lucHV0e3BhZGRpbmc6MDtwYWRkaW5nLWxlZnQ6NnB4fVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvRGF0ZVRpbWVJbnB1dC9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lRmlsdGVyL3N0eWxlLnNjc3MiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kYXRlVGltZUZpbHRlciBzZWxlY3R7bWFyZ2luLWJvdHRvbTo5cHg7cGFkZGluZzo2cHg7Ym9yZGVyLXJhZGl1czozcHg7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1hZy1pbnB1dC1ib3JkZXItY29sb3IsIHZhcigtLWFnLWJvcmRlci1jb2xvciwgI2JhYmZjNykpO2NvbG9yOmluaGVyaXR9LmRhdGVUaW1lRmlsdGVyIHNlbGVjdDpmb2N1cywuZGF0ZVRpbWVGaWx0ZXIgc2VsZWN0OmFjdGl2ZXtib3JkZXItY29sb3I6dmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCByZ2JhKDMzLDE1MCwyNDMsMC40KSl9LmRhdGVUaW1lRmlsdGVyIHNlbGVjdCBvcHRpb257dGV4dC1pbmRlbnQ6NnB4fVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvRGF0ZVRpbWVGaWx0ZXIvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBEYXRlVGltZUVkaXRvciBmcm9tICcuL0RhdGVUaW1lRWRpdG9yJ1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lRWRpdG9yL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlIH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuaW1wb3J0IHV0Y1RvWm9uZWRUaW1lIGZyb20gJ2RhdGUtZm5zLXR6L3V0Y1RvWm9uZWRUaW1lJ1xuaW1wb3J0IERhdGVUaW1lSW5wdXQgZnJvbSAnLi4vRGF0ZVRpbWVJbnB1dCdcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuXG4vKipcbiAqIERhdGVUaW1lSW5wdXRcbiAqXG4gKiBTaW1wbGUgRGF0ZVRpbWVJbnB1dCBjb21wb25lbnQgd2hpY2ggaW50ZWdyYXRlcyB0aGUgZmxhdHBpY2tyXG4gKlxuICogIyMgT3B0aW9uc1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVUaW1lKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSB0aW1lXG4gKiB8ICoqZGF0ZVRpbWVFbmFibGUyNEhSKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSB0aW1lIDI0IGZvcm1hdFxuICogfCAqKmRhdGVUaW1lRW5hYmxlU2Vjb25kcyoqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgc2Vjb25kcyBtYW5hZ2VtZW50XG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVDYWxlbmRhcioqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgQ2FsZW5kYXIuXG4gKiB8ICoqZGF0ZVRpbWVNYXNrKiogICB8IGZhbHNlICAgIHwgVGhlIG1hc2sgdXNlZCB0byBmb3JtYXQgdGhlIHNlbGVjdGVkIGRhdGVcbiAqIHwgKipkYXRlVGltZU1heCoqICAgfCB1bmRlZmluZWQgICAgfCAgTWF4IGFsbG93ZWQgZGF0ZVxuICogfCAqKmRhdGVUaW1lTWluKiogICB8IHVuZGVmaW5lZCAgICB8ICBNaW4gYWxsb3dlZCBkYXRlXG4gKiB8ICoqZGF0ZVRpbWVGb3JtYXR0ZXIqKiAgIHwgZmFsc2UgICAgfCAgQSBmdW5jdGlvbiBvciBleHByZXNzaW9uIHRvIGZvcm1hdCB0aGUgZGF0ZSAoQHNlZSBzdXBwb3J0ZWQgcGFyYW0pXG4gKiB8ICoqZGF0ZVRpbWVMb2NhbGUqKiAgIHwgU3lzdGVtIGRlZmF1bHQgICAgfCAgQSBsb2NhbGUgdG8gdXNlIGZvciBkYXRlIGZvcm1hdHRpbmdcbiAqIHwgKipkYXRlVGltZURlZmF1bHRIb3VyKiogICB8IDEyICAgIHwgIEluaXRpYWwgdmFsdWUgb2YgdGhlIGhvdXIgZWxlbWVudC5cbiAqIHwgKipkYXRlVGltZURlZmF1bHRNaW51dGUqKiAgIHwgMCAgICB8ICBJbml0aWFsIHZhbHVlIG9mIHRoZSBtaW51dGUgZWxlbWVudC5cbiAqIHwgKipkYXRlVGltZURpc2FibGVNb2JpbGUqKiAgIHwgZmFsc2UgICAgfCAgU2V0IGRpc2FibGVNb2JpbGUgdG8gdHJ1ZSB0byBhbHdheXMgdXNlIHRoZSBub24tbmF0aXZlIHBpY2tlci5cbiAqIHwgKipkYXRlVGltZUVuYWJsZVdlZWtOdW1iZXIqKiAgIHwgdHJ1ZSAgICB8ICBFbmFibGVzIGRpc3BsYXkgb2Ygd2VlayBudW1iZXJzIGluIGNhbGVuZGFyLlxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIERhdGVUaW1lRWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtEYXRlVGltZUlucHV0fVxuICAgKi9cbiAgX2lucHV0ID0gbmV3IERhdGVUaW1lSW5wdXQodHJ1ZSlcblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIF92YWx1ZSA9IG51bGxcblxuICAvKipcbiAgICogUGFyYW1zIHJlY2VpdmVkIGluIGluaXRcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9wYXJhbXMgPSBudWxsXG5cbiAgLyoqXG4gICAqIFRha2VzIGluY29tcGxldGUgaXNvIHN0cmluZyBhbmQgcmV0dXJuIGEgY29tcGxldGUgb25lXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIGluY29tcGxldGUgaXNvIHN0cmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGNvbXBsZXRlIGlzbyBzdHJpbmdcbiAgICovXG4gIHN0YXRpYyBmaXhTaG9ydElTTyh2YWx1ZSkge1xuICAgIHJldHVybiBCQmouTWFza3MuVXRpbHMuRGF0ZXMuZml4U2hvcnRJU08odmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtc1xuICAgIHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkID0gcGFyYW1zLmNlbGxTdGFydGVkRWRpdFxuICAgIGlmICh0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xuICAgICAgbGV0IGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUgPVxuICAgICAgICBwYXJhbXMua2V5UHJlc3MgPT0gMzIgfHwgcGFyYW1zLmtleVByZXNzID09IDQ2IC8vIHNwYWNlIC8vIGRlbGV0ZVxuXG4gICAgICBpZiAoa2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jaGFyUHJlc3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJhbXMuY2hhclByZXNzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHBhcmFtcy52YWx1ZVxuICAgICAgICBpZiAocGFyYW1zLmtleVByZXNzICE9IDExMykge1xuICAgICAgICAgIC8vRjJcbiAgICAgICAgICB0aGlzLmhpZ2hsaWdodEFsbE9uRm9jdXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZSA9IERhdGVUaW1lRWRpdG9yLmZpeFNob3J0SVNPKHRoaXMuX3ZhbHVlKVxuICAgIHRoaXMuX2lucHV0LmluaXQocGFyYW1zKVxuICAgIHRoaXMuX2lucHV0Lm9uKERhdGVUaW1lSW5wdXQuT05fREFURV9DSEFOR0VELCB0aGlzLl9vbkRhdGVDaGFuZ2UpXG5cbiAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX2lucHV0LnNldERhdGUoXG4gICAgICAgIHV0Y1RvWm9uZWRUaW1lKHRoaXMuX3ZhbHVlLCBCQmouTWFza3MuVXRpbHMuRGF0ZXMuZ2V0VGltZXpvbmVPck9mZnNldCgpKVxuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMuX2d1aSA9IHRoaXMuX2lucHV0LmdldEd1aSgpXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2lucHV0LmRlc3Ryb3koKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgR1VJIGlzIGF0dGFjaGVkIHRvIERPTS5cbiAgICogTWFrZSBzdXJlIHRoZSBjb250YWluZXIgaXMgYWx3YXlzIGZvY3VzZWQgYW5kIGxpc3RlbmluZyB0byBrZXkgY2hhbmdlc1xuICAgKi9cbiAgYWZ0ZXJHdWlBdHRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmluYWwgdmFsdWUgdG8gdGhlIGdyaWQsIHRoZSByZXN1bHQgb2YgdGhlIGVkaXRpbmdcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbXMucGFyc2VWYWx1ZSh0aGlzLl92YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBvbmNlIGFmdGVyIGluaXRpYWxpemVkIGFuZCByZXR1cm5zIGZhbHNlIHNvIHRoZSBlZGl0b3IgYXBwZWFycyBpbiB0aGUgY2VsbFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBhbHdheXMgZmFsc2VcbiAgICoqL1xuICBpc1BvcHVwKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGRvaW5nIGZ1bGwgcm93IGVkaXQsIHRoZW4gZ2V0cyBjYWxsZWQgd2hlbiB0YWJiaW5nIGludG8gdGhlIGNlbGwuXG4gICAqL1xuICBmb2N1c0luKCkge1xuICAgIHRoaXMuX2lucHV0Lm9wZW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGRvaW5nIGZ1bGwgcm93IGVkaXQsIHRoZW4gZ2V0cyBjYWxsZWQgd2hlbiB0YWJiaW5nIG91dCBvZiB0aGUgY2VsbC5cbiAgICovXG4gIGZvY3VzT3V0KCkge1xuICAgIHRoaXMuX2lucHV0LmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGVkaXRvciB2YWx1ZSB3aXRoIHNlbGVjdGVkIGRhdGUgZnJvbSB0aGUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25EYXRlQ2hhbmdlKGRhdGUpIHtcbiAgICB0aGlzLl92YWx1ZSA9IGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZS50b0lTT1N0cmluZygpIDogJydcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lRWRpdG9yL0RhdGVUaW1lRWRpdG9yLmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vKiogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50ICAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0cmEtc2VtaVxyXG47KGZ1bmN0aW9uKCkge1xyXG4gIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9IC8vSWYgbm90IElFXHJcblxyXG4gIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcclxuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfVxyXG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXHJcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpXHJcbiAgICByZXR1cm4gZXZ0XHJcbiAgfVxyXG5cclxuICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlXHJcblxyXG4gIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50XHJcbn0pKClcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QEJhc2lzLkFnR3JpZENvbXBvbmVudHMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5leHBvcnQgKiBmcm9tICcuL2luaXQuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vY29sdW1ucy5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9yb3dzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2NlbGxzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL3N0YXRlLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL3Rvb2xwYW5lbC5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9zdGF0dXNiYXIuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vb3ZlcmxheXMuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vY29udGV4dC5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9jaGFydHMuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vanNzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL3V0aWxpdGllcy5qcydcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QEJhc2lzLkFnR3JpZENvbXBvbmVudHMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyB9IGZyb20gJy4vY29sdW1ucydcclxuaW1wb3J0IHsgZ3dfbmF2aWdhdGVUb05leHRSb3csIGd3X2dldFJvd05vZGVJZCB9IGZyb20gJy4vcm93cydcclxuaW1wb3J0IHsgZ3dfZ2V0Q29udGV4dE1lbnUgfSBmcm9tICcuL21lbnVzJ1xyXG5pbXBvcnQgeyBnd19nZXRDaGFydFRvb2xiYXJJdGVtcyB9IGZyb20gJy4vY2hhcnRzJ1xyXG5pbXBvcnQgeyBnd19nZXREb2N1bWVudCwgZ3dfZ2V0V2luZG93LCBnd19hZGRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7XHJcbiAgZ3dfb25Sb3dDbGlja2VkLFxyXG4gIGd3X29uUm93RG91YmxlQ2xpY2tlZCxcclxuICBnd19vblNlbGVjdGlvbkNoYW5nZWQsXHJcbiAgZ3dfb25SYW5nZVNlbGVjdGlvbkNoYW5nZWQsXHJcbiAgZ3dfb25DZWxsQ2xpY2tFdmVudCxcclxuICBnd19vbkNlbGxFZGl0aW5nRXZlbnQsXHJcbiAgZ3dfb25Sb3dFZGl0aW5nRXZlbnQsXHJcbiAgZ3dfb25SZWFkeUV2ZW50LFxyXG4gIGd3X29uRmlsdGVyQ2hhbmdlZCxcclxuICBnd19kZWJvdW5jZSxcclxufSBmcm9tICdldmVudHMnXHJcbmltcG9ydCB0ZW1wbGF0ZSBmcm9tICdsb2Rhc2gtZXMvdGVtcGxhdGUnXHJcbmltcG9ydCBIVE1MVG9vbHRpcCBmcm9tICcuLi9jb21wb25lbnRzL0hUTUxUb29sdGlwLmpzJ1xyXG5pbXBvcnQgU3VnZ2VzdGlvbkVkaXRvciBmcm9tICcuLi9jb21wb25lbnRzL1N1Z2dlc3Rpb25FZGl0b3IuanMnXHJcblxyXG5jb25zdCB7IGRlZXBQYXJzZUpzb24gfSA9IHJlcXVpcmUoJ2RlZXAtcGFyc2UtanNvbicpXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfaW5pdChvcHRpb25zLCBsaWNlbnNlLCBkYXRhKSB7XHJcbiAgaWYgKGFnR3JpZC5MaWNlbnNlTWFuYWdlciAmJiBsaWNlbnNlKSB7XHJcbiAgICBhZ0dyaWQuTGljZW5zZU1hbmFnZXIuc2V0TGljZW5zZUtleShsaWNlbnNlKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaWQgPSBvcHRpb25zLmNvbnRleHQuaWRcclxuICBsZXQgY29udGFpbmVyID0gZ3dfZ2V0RG9jdW1lbnQoKS5nZXRFbGVtZW50QnlJZChpZClcclxuICBjb25zdCBjb250YWluZXJDbG9uZSA9IGNvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSlcclxuXHJcbiAgY29udGFpbmVyLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRhaW5lckNsb25lLCBjb250YWluZXIpXHJcbiAgY29udGFpbmVyID0gY29udGFpbmVyQ2xvbmVcclxuICAvLyB3ZSBtYWtlIHRoZSBncmlkIG9wdGlvbnMgYXZhaWxhYmxlIGFzIHNvb24gYXMgcG9zc2libGVcclxuICBjb25zdCBncmlkID0gZ3dfYWRkR3JpZChpZCwge1xyXG4gICAgY29udGFpbmVyLFxyXG4gICAgb3B0aW9ucyxcclxuICB9KVxyXG5cclxuICAvLyBUT0RPOiB1c2UgYWcgZ3JpZCBkZXN0cm95XHJcbiAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnXHJcblxyXG4gIGNvbnN0IHBhcnNlZE9wdGlvbnMgPSBnd19wYXJzZU9wdGlvbnMob3B0aW9ucylcclxuICBwYXJzZWRPcHRpb25zLnJvd0RhdGEgPSBkYXRhXHJcblxyXG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IGFnR3JpZC5HcmlkKGNvbnRhaW5lciwgcGFyc2VkT3B0aW9ucylcclxuICBncmlkLmluc3RhbmNlID0gaW5zdGFuY2VcclxuICBncmlkLm9wdGlvbnMgPSBwYXJzZWRPcHRpb25zXHJcblxyXG4gIGNvbnNvbGUubG9nKFxyXG4gICAgYCVjIEdyaWQgWyR7aWR9XSBzZXR0aW5ncyA6IGAsXHJcbiAgICAnYmFja2dyb3VuZDogIzIyMjsgY29sb3I6ICNiYWRhNTUnLFxyXG4gICAgcGFyc2VkT3B0aW9uc1xyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlIE9wdGlvbnNcclxuICpcclxuICogUGFyc2UgdGhlIGdyaWQgb3B0aW9ucyBhbmQgcmV0dXJuXHJcbiAqIGFuIG9iamVjdCB3aGljaCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBncmlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEdyaWQgb3B0aW9ucyBhcyBKc29uIE9iamVjdFxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBnd19wYXJzZU9wdGlvbnMob3B0aW9ucykge1xyXG4gIGNvbnN0IGRlZXBQYXJzZWRPcHRpb25zID0gZGVlcFBhcnNlSnNvbihKU09OLnN0cmluZ2lmeShvcHRpb25zKSlcclxuICBjb25zdCBpZCA9IGRlZXBQYXJzZWRPcHRpb25zLmNvbnRleHQuaWRcclxuICBjb25zdCBnZXREYXRhUGF0aFRlbXBsYXRlID0gZGVlcFBhcnNlZE9wdGlvbnMuY29udGV4dC5nZXREYXRhUGF0aCB8fCAnJ1xyXG4gIC8vIFRPRE86IGRvIHdlIG5lZWQgdG8gY29udHJvbCB0aGlzIHNldHRpbmcgZnJvbSBCQmogP1xyXG4gIGNvbnN0IGRlYm91bmNlRHVyYXRpb24gPSAyNTBcclxuICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7XHJcbiAgICAuLi5kZWVwUGFyc2VkT3B0aW9ucyxcclxuICAgIC4uLntcclxuICAgICAgZ2V0RG9jdW1lbnQ6ICgpID0+IGd3X2dldERvY3VtZW50KCksXHJcbiAgICAgIG9uQ2VsbEVkaXRpbmdTdGFydGVkOiBlID0+IHtcclxuICAgICAgICBnd19vbkNlbGxFZGl0aW5nRXZlbnQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQ2VsbEVkaXRpbmdTdG9wcGVkOiBlID0+IHtcclxuICAgICAgICBnd19vbkNlbGxFZGl0aW5nRXZlbnQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uQ2VsbFZhbHVlQ2hhbmdlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25DZWxsRWRpdGluZ0V2ZW50KGlkLCBlKVxyXG4gICAgICB9LFxyXG4gICAgICBvblJvd0VkaXRpbmdTdGFydGVkOiBlID0+IHtcclxuICAgICAgICBnd19vblJvd0VkaXRpbmdFdmVudChpZCwgZSlcclxuICAgICAgfSxcclxuICAgICAgb25Sb3dWYWx1ZUNoYW5nZWQ6IGUgPT4ge1xyXG4gICAgICAgIGd3X29uUm93RWRpdGluZ0V2ZW50KGlkLCBlKVxyXG4gICAgICB9LFxyXG4gICAgICBvblJvd0VkaXRpbmdTdG9wcGVkOiBlID0+IHtcclxuICAgICAgICBnd19vblJvd0VkaXRpbmdFdmVudChpZCwgZSlcclxuICAgICAgfSxcclxuICAgICAgb25HcmlkUmVhZHk6IGUgPT4ge1xyXG4gICAgICAgIGd3X29uUmVhZHlFdmVudChpZCwgZSlcclxuICAgICAgfSxcclxuICAgICAgb25GaWx0ZXJDaGFuZ2VkOiBlID0+IHtcclxuICAgICAgICBnd19vbkZpbHRlckNoYW5nZWQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIGdldFJvd0lkOiBkYXRhID0+IGd3X2dldFJvd05vZGVJZChpZCwgZGF0YSksXHJcbiAgICAgIGdldENvbnRleHRNZW51SXRlbXM6IHBhcmFtcyA9PiBnd19nZXRDb250ZXh0TWVudShpZCwgcGFyYW1zKSxcclxuICAgICAgZ2V0Q2hhcnRUb29sYmFySXRlbXM6IGd3X2dldENoYXJ0VG9vbGJhckl0ZW1zLFxyXG4gICAgICBwb3B1cFBhcmVudDogZ3dfZ2V0RG9jdW1lbnQoKS5ib2R5LFxyXG4gICAgICBvblJvd0RvdWJsZUNsaWNrZWQ6IGd3X2RlYm91bmNlKGd3X29uUm93RG91YmxlQ2xpY2tlZCwgZGVib3VuY2VEdXJhdGlvbiksXHJcbiAgICAgIG9uUm93Q2xpY2tlZDogZ3dfZGVib3VuY2UoZ3dfb25Sb3dDbGlja2VkLCBkZWJvdW5jZUR1cmF0aW9uKSxcclxuICAgICAgb25DZWxsQ2xpY2tlZDogZ3dfZGVib3VuY2UoZ3dfb25DZWxsQ2xpY2tFdmVudCwgZGVib3VuY2VEdXJhdGlvbiksXHJcbiAgICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ6IGd3X2RlYm91bmNlKGd3X29uQ2VsbENsaWNrRXZlbnQsIGRlYm91bmNlRHVyYXRpb24pLFxyXG4gICAgICBvblNlbGVjdGlvbkNoYW5nZWQ6IGd3X2RlYm91bmNlKGd3X29uU2VsZWN0aW9uQ2hhbmdlZCwgZGVib3VuY2VEdXJhdGlvbiksXHJcbiAgICAgIG9uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkOiBnd19kZWJvdW5jZShcclxuICAgICAgICBnd19vblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCxcclxuICAgICAgICBkZWJvdW5jZUR1cmF0aW9uXHJcbiAgICAgICksXHJcbiAgICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICBCb29sZWFuRmlsdGVyOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLkJvb2xlYW5GaWx0ZXIsXHJcbiAgICAgICAgQm9vbGVhblJlbmRlcmVyOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLkJvb2xlYW5SZW5kZXJlcixcclxuICAgICAgICBCb29sZWFuRWRpdG9yOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLkJvb2xlYW5FZGl0b3IsXHJcbiAgICAgICAgTnVtYmVyRWRpdG9yOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLk51bWJlckVkaXRvcixcclxuICAgICAgICBUZXh0RWRpdG9yOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLlRleHRFZGl0b3IsXHJcbiAgICAgICAgRGF0ZVRpbWVFZGl0b3I6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuRGF0ZVRpbWVFZGl0b3IsXHJcbiAgICAgICAgRGF0ZVRpbWVGaWx0ZXI6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuRGF0ZVRpbWVGaWx0ZXIsXHJcbiAgICAgICAgSW1hZ2VSZW5kZXJlcjogQmFzaXMuQWdHcmlkQ29tcG9uZW50cy5JbWFnZVJlbmRlcmVyLFxyXG4gICAgICAgIFRlbXBsYXRlUmVuZGVyZXI6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuVGVtcGxhdGVSZW5kZXJlcixcclxuICAgICAgICBIVE1MVG9vbHRpcDogSFRNTFRvb2x0aXAsXHJcbiAgICAgICAgU3VnZ2VzdGlvbkVkaXRvcjogU3VnZ2VzdGlvbkVkaXRvcixcclxuICAgICAgfSxcclxuICAgICAgY29udGV4dDoge1xyXG4gICAgICAgIC4uLmRlZXBQYXJzZWRPcHRpb25zLmNvbnRleHQsXHJcbiAgICAgICAgLi4ue1xyXG4gICAgICAgICAgZG9jdW1lbnQ6IGd3X2dldERvY3VtZW50KCksXHJcbiAgICAgICAgICB3aW5kb3c6IGd3X2dldFdpbmRvdygpLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGFsaWduZWRHcmlkczogW10sXHJcbiAgICB9LFxyXG4gIH1cclxuXHJcbiAgaWYgKFxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgZmluYWxPcHRpb25zLmNvbnRleHQuaGFzT3duUHJvcGVydHkoJ25hdmlnYXRlVG9OZXh0Q2VsbCcpICYmXHJcbiAgICBmaW5hbE9wdGlvbnMuY29udGV4dC5uYXZpZ2F0ZVRvTmV4dENlbGxcclxuICApIHtcclxuICAgIGZpbmFsT3B0aW9ucy5uYXZpZ2F0ZVRvTmV4dENlbGwgPSBwYXJhbXMgPT4ge1xyXG4gICAgICByZXR1cm4gZ3dfbmF2aWdhdGVUb05leHRSb3coaWQsIHBhcmFtcylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChnZXREYXRhUGF0aFRlbXBsYXRlICYmIGZpbmFsT3B0aW9ucy50cmVlRGF0YSkge1xyXG4gICAgY29uc3QgZ2V0RGF0YVBhdGhUZW1wbGF0ZUNvbXBsaWVkID0gdGVtcGxhdGUoZ2V0RGF0YVBhdGhUZW1wbGF0ZSlcclxuICAgIGZpbmFsT3B0aW9ucy5nZXREYXRhUGF0aCA9IGRhdGEgPT5cclxuICAgICAgZ2V0RGF0YVBhdGhUZW1wbGF0ZUNvbXBsaWVkKHsgZGF0YTogZGF0YSB9KVxyXG4gIH1cclxuXHJcbiAgLy8gZXh0ZW5kIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyhmaW5hbE9wdGlvbnMuY29sdW1uRGVmcylcclxuXHJcbiAgcmV0dXJuIGZpbmFsT3B0aW9uc1xyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19wYXJzZU5vZGVGcm9tRXZlbnQsIGd3X3NlbmRFdmVudCB9IGZyb20gJ2V2ZW50cy91dGlsaXRpZXMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0Q29udGV4dE1lbnUoZ3JpZElkLCBwYXJhbXMpIHtcclxuICBjb25zdCBidWlsZENvbnRleHRNZW51QWN0aW9uID0gKHBhcmFtcywgaWQpID0+IHtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5vZGUgPSBnd19wYXJzZU5vZGVGcm9tRXZlbnQocGFyYW1zKVxyXG4gICAgICBjb25zdCBjb2xJZCA9IHBhcmFtcy5jb2x1bW4uY29sSWRcclxuICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWVcclxuXHJcbiAgICAgIGd3X3NlbmRFdmVudChcclxuICAgICAgICBnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIHR5cGU6ICdndy5jb250ZXh0bWVudScsXHJcbiAgICAgICAgICBkZXRhaWw6IEpTT04uc3RyaW5naWZ5KHsgcjogbm9kZSwgYzogY29sSWQsIHY6IHZhbHVlLCBpOiBpZCB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlkXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IHBhcnNlTWVudSA9IG1lbnUgPT4ge1xyXG4gICAgbWVudS5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZW1bJ2FjdGlvbiddID0gYnVpbGRDb250ZXh0TWVudUFjdGlvbihwYXJhbXMsIGl0ZW0uaWQpXHJcblxyXG4gICAgICBpZiAoaXRlbVsnY3NzQ2xhc3NlcyddICYmICFBcnJheS5pc0FycmF5KGl0ZW1bJ2Nzc0NsYXNzZXMnXSkpIHtcclxuICAgICAgICBpdGVtWydjc3NDbGFzc2VzJ10gPSBpdGVtWydjc3NDbGFzc2VzJ10uc3BsaXQoJyAnKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXRlbVsnc3ViTWVudSddKSB7XHJcbiAgICAgICAgaXRlbVsnc3ViTWVudSddID0gcGFyc2VNZW51KGl0ZW1bJ3N1Yk1lbnUnXSlcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4gbWVudVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnNlTWVudShnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9ucy5jb250ZXh0LmNvbnRleHRNZW51KVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHtcclxuICBnd19vblJvd0NsaWNrZWQsXHJcbiAgZ3dfb25Sb3dEb3VibGVDbGlja2VkLFxyXG4gIGd3X29uU2VsZWN0aW9uQ2hhbmdlZCxcclxuICBnd19vbkNlbGxDbGlja0V2ZW50LFxyXG4gIGd3X29uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkLFxyXG59IGZyb20gJy4vc2VsZWN0aW9ucydcclxuaW1wb3J0IHsgZ3dfb25DZWxsRWRpdGluZ0V2ZW50LCBnd19vblJvd0VkaXRpbmdFdmVudCB9IGZyb20gJy4vZWRpdGluZydcclxuaW1wb3J0IHsgZ3dfb25SZWFkeUV2ZW50IH0gZnJvbSAnLi9yZWFkeSdcclxuaW1wb3J0IHsgZ3dfZGVib3VuY2UgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfb25GaWx0ZXJDaGFuZ2VkIH0gZnJvbSAnLi9maWx0ZXJzJ1xyXG5cclxuZXhwb3J0IHtcclxuICBnd19vblJvd0NsaWNrZWQsXHJcbiAgZ3dfb25Sb3dEb3VibGVDbGlja2VkLFxyXG4gIGd3X29uU2VsZWN0aW9uQ2hhbmdlZCxcclxuICBnd19vblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCxcclxuICBnd19vbkNlbGxDbGlja0V2ZW50LFxyXG4gIGd3X29uQ2VsbEVkaXRpbmdFdmVudCxcclxuICBnd19vblJvd0VkaXRpbmdFdmVudCxcclxuICBnd19vblJlYWR5RXZlbnQsXHJcbiAgZ3dfZGVib3VuY2UsXHJcbiAgZ3dfb25GaWx0ZXJDaGFuZ2VkLFxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfc2VuZEV2ZW50LCBnd19wYXJzZU5vZGVGcm9tRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfZXNjYXBlLCBnd19nZXRHcmlkIH0gZnJvbSAnYXBpL3V0aWxpdGllcydcclxuaW1wb3J0IHtcclxuICBHV19FVkVOVF9ST1dfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfUk9XX0RPVUJMRV9DTElDSyxcclxuICBHV19FVkVOVF9ST1dfU0VMRUNULFxyXG4gIEdXX0VWRU5UX0NFTExfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfQ0VMTF9ET1VCTEVfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRUQsXHJcbn0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG5jb25zdCBDRUxMX0NMSUNLSU5HX0VWRU5UU19NQVAgPSB7XHJcbiAgY2VsbENsaWNrZWQ6IEdXX0VWRU5UX0NFTExfQ0xJQ0ssXHJcbiAgY2VsbERvdWJsZUNsaWNrZWQ6IEdXX0VWRU5UX0NFTExfRE9VQkxFX0NMSUNLLFxyXG59XHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYHJvd0RvdWJsZUNsaWNrZWRgIGV2ZW50XHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aWxsIHNlbmQgYSBiYmogZXZlbnQgd2l0aCBgR1dfTk9ERWAgYXMgcGF5bG9hZFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQncyBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dEb3VibGVDbGlja2VkXHJcbiAqIEBmaXJlcyBndy5yb3dEb3VibGVDbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uUm93RG91YmxlQ2xpY2tlZChlKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IGUuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcblxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dEb3VibGVDbGljaycsXHJcbiAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGs6IGd3X2dldEdyaWQoY29udGV4dC5pZCkua2V5cyxcclxuICAgICAgfSksXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUk9XX0RPVUJMRV9DTElDS1xyXG4gIClcclxufVxyXG4vKipcclxuICogQSBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgcm93Q2xpY2tlZGAgZXZlbnRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dDbGlja2VkXHJcbiAqIEBmaXJlcyBndy5yb3dDbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uUm93Q2xpY2tlZChlKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IGUuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcblxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dDbGljaycsXHJcbiAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGs6IGd3X2dldEdyaWQoY29udGV4dC5pZCkua2V5cyxcclxuICAgICAgfSksXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUk9XX0NMSUNLXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogQSBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgc2VsZWN0aW9uQ2hhbmdlZGAgZXZlbnRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5zZWxlY3Rpb25DaGFuZ2VkXHJcbiAqIEBmaXJlcyBndy5yb3dTZWxlY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vblNlbGVjdGlvbkNoYW5nZWQoZSkge1xyXG4gIGNvbnN0IGNvbnRleHQgPSBlLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dFxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dTZWxlY3QnLFxyXG4gICAgICBkZXRhaWw6ICcnLFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX1JPV19TRUxFQ1RcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGhhbmRsZXIgZm9yIHRoZSBncmlkIGByYW5nZVNlbGVjdGlvbkNoYW5nZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yYW5nZVNlbGVjdGlvbkNoYW5nZWRcclxuICogQGZpcmVzIGd3LnJhbmdlU2VsZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25SYW5nZVNlbGVjdGlvbkNoYW5nZWQoZSkge1xyXG4gIGNvbnN0IGNvbnRleHQgPSBlLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dFxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yYW5nZVNlbGVjdGlvbicsXHJcbiAgICAgIGRldGFpbDogJycsXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRURcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGhhbmRsZXIgZm9yIHRoZSBncmlkIGBjZWxsQ2xpY2tFdmVudGAgJiBgY2VsbERvdWJsZUNsaWNrZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlICBUaGUgZXZlbnQgcGF5bG9hZFxyXG4gKlxyXG4gKiBAbGlzdGVucyBhZ0dyaWQuY2VsbENsaWNrRXZlbnRcclxuICogQGxpc3RlbnMgYWdHcmlkLmNlbGxEb3VibGVDbGlja2VkXHJcbiAqXHJcbiAqIEBmaXJlcyBndy5jZWxsQ2xpY2tlZFxyXG4gKiBAZmlyZXMgZ3cuY2VsbERvdWJsZUNsaWNrZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbkNlbGxDbGlja0V2ZW50KGUpIHtcclxuICBjb25zdCBjb250ZXh0ID0gZS5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdyaWRPcHRpb25zLmNvbnRleHRcclxuICBjb25zdCBpZCA9IGNvbnRleHQuaWRcclxuICBjb25zdCBwYXJzZWQgPSBnd19wYXJzZU5vZGVGcm9tRXZlbnQoZSlcclxuXHJcbiAgaWYgKHBhcnNlZCkge1xyXG4gICAgY29uc3QgdHlwZSA9IGUudHlwZVxyXG4gICAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogYGd3LiR7ZS50eXBlfWAsXHJcbiAgICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICByOiBwYXJzZWQsIC8vIHJvd1xyXG4gICAgICAgICAgdjogZ3dfZXNjYXBlKGUudmFsdWUpLCAvLyBuZXcgdmFsdWVcclxuICAgICAgICAgIG86IGd3X2VzY2FwZShlLnZhbHVlKSwgLy8gb2RsIHZhbHVlXHJcbiAgICAgICAgICBjOiBlLmNvbHVtbi5jb2xJZCwgLy8gY29sdW1uc1xyXG4gICAgICAgICAgazogZ3dfZ2V0R3JpZChpZCkua2V5cyxcclxuICAgICAgICB9KSxcclxuICAgICAgfSxcclxuICAgICAgQ0VMTF9DTElDS0lOR19FVkVOVFNfTUFQW3R5cGVdXHJcbiAgICApXHJcbiAgfVxyXG59XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X3NlbmRFdmVudCwgZ3dfcGFyc2VOb2RlRnJvbUV2ZW50IH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X2VzY2FwZSwgZ3dfZ2V0R3JpZCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcbmltcG9ydCB7XHJcbiAgR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUQVJURUQsXHJcbiAgR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUT1BQRUQsXHJcbiAgR1dfRVZFTlRfQ0VMTF9WQUxVRV9DSEFOR0VELFxyXG4gIEdXX0VWRU5UX1JPV19FRElUSU5HX1NUQVJURUQsXHJcbiAgR1dfRVZFTlRfUk9XX0VESVRJTkdfU1RPUFBFRCxcclxuICBHV19FVkVOVF9ST1dfVkFMVUVfQ0hBTkdFRCxcclxufSBmcm9tICcuL2NvbnN0YW50cydcclxuXHJcbmNvbnN0IENFTExfRURJVElOR19FVkVOVFNfTUFQID0ge1xyXG4gIGNlbGxFZGl0aW5nU3RhcnRlZDogR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUQVJURUQsXHJcbiAgY2VsbEVkaXRpbmdTdG9wcGVkOiBHV19FVkVOVF9DRUxMX0VESVRJTkdfU1RPUFBFRCxcclxuICBjZWxsVmFsdWVDaGFuZ2VkOiBHV19FVkVOVF9DRUxMX1ZBTFVFX0NIQU5HRUQsXHJcbn1cclxuXHJcbmNvbnN0IFJPV19FRElUSU5HX0VWRU5UU19NQVAgPSB7XHJcbiAgcm93RWRpdGluZ1N0YXJ0ZWQ6IEdXX0VWRU5UX1JPV19FRElUSU5HX1NUQVJURUQsXHJcbiAgcm93RWRpdGluZ1N0b3BwZWQ6IEdXX0VWRU5UX1JPV19FRElUSU5HX1NUT1BQRUQsXHJcbiAgcm93VmFsdWVDaGFuZ2VkOiBHV19FVkVOVF9ST1dfVkFMVUVfQ0hBTkdFRCxcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGhhbmRsZXIgZm9yIHRoZSBncmlkIGBjZWxsRWRpdGluZ1N0YXJ0ZWRgICwgYGNlbGxFZGl0aW5nU3RvcHBlZGAgYW5kXHJcbiAqIGBjZWxsVmFsdWVDaGFuZ2VkYCBldmVudHNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5jZWxsRWRpdGluZ1N0YXJ0ZWRcclxuICogQGxpc3RlbnMgYWdHcmlkLmNlbGxFZGl0aW5nU3RvcHBlZFxyXG4gKiBAbGlzdGVucyBhZ0dyaWQuY2VsbFZhbHVlQ2hhbmdlZFxyXG4gKlxyXG4gKiBAZmlyZXMgZ3cuY2VsbEVkaXRpbmdTdGFydGVkXHJcbiAqIEBmaXJlcyBndy5jZWxsRWRpdGluZ1N0b3BwZWRcclxuICogQGZpcmVzIGd3LmNlbGxWYWx1ZUNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbkNlbGxFZGl0aW5nRXZlbnQoaWQsIGUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGUuaGFzT3duUHJvcGVydHkoJ25ld1ZhbHVlJylcclxuICAgID8gZ3dfZXNjYXBlKGUubmV3VmFsdWUpXHJcbiAgICA6IGd3X2VzY2FwZShlLnZhbHVlKVxyXG4gIGNvbnN0IG9sZFZhbHVlID0gZS5oYXNPd25Qcm9wZXJ0eSgnb2xkVmFsdWUnKVxyXG4gICAgPyBnd19lc2NhcGUoZS5vbGRWYWx1ZSlcclxuICAgIDogZS5oYXNPd25Qcm9wZXJ0eSgnbmV3VmFsdWUnKVxyXG4gICAgPyBnd19lc2NhcGUoZS5uZXdWYWx1ZSlcclxuICAgIDogZ3dfZXNjYXBlKGUudmFsdWUpXHJcblxyXG4gIGlmICh2YWx1ZSA9PSBvbGRWYWx1ZSAmJiBlLnR5cGUgPT09ICdjZWxsVmFsdWVDaGFuZ2VkJykge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXJzZWQgPSBnd19wYXJzZU5vZGVGcm9tRXZlbnQoZSlcclxuICBjb25zdCB0eXBlID0gZS50eXBlXHJcbiAgY29uc3QgY29sSWQgPSBlLmNvbHVtbi5jb2xJZFxyXG5cclxuICBpZiAocGFyc2VkKSB7XHJcbiAgICBnd19zZW5kRXZlbnQoXHJcbiAgICAgIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6IGBndy4ke3R5cGV9YCxcclxuICAgICAgICBkZXRhaWw6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHI6IHsgLi4ucGFyc2VkLCAuLi57IGNyOiBlLmRhdGEgfSB9LCAvLyByb3cgKHdlIGFsd2F5cyBpbmNsdWRlIHRoZSBjbGllbnQgcm93IGRhdGEpXHJcbiAgICAgICAgICB2OiB2YWx1ZSwgLy8gbmV3IHZhbHVlXHJcbiAgICAgICAgICBvOiBvbGRWYWx1ZSwgLy8gb2xkIHZhbHVlXHJcbiAgICAgICAgICBjOiBjb2xJZCwgLy8gY29sdW1uXHJcbiAgICAgICAgfSksXHJcbiAgICAgIH0sXHJcbiAgICAgIENFTExfRURJVElOR19FVkVOVFNfTUFQW3R5cGVdXHJcbiAgICApXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYHJvd0VkaXRpbmdTdGFydGVkYCAsIGByb3dFZGl0aW5nU3RvcHBlZGAgYW5kIGByb3dWYWx1ZUNoYW5nZWRgIGV2ZW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZSAgVGhlIGV2ZW50IHBheWxvYWRcclxuICpcclxuICogQGxpc3RlbnMgYWdHcmlkLnJvd0VkaXRpbmdTdGFydGVkXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dFZGl0aW5nU3RvcHBlZFxyXG4gKiBAbGlzdGVucyBhZ0dyaWQucm93VmFsdWVDaGFuZ2VkXHJcbiAqXHJcbiAqIEBmaXJlcyBndy5yb3dFZGl0aW5nU3RhcnRlZFxyXG4gKiBAZmlyZXMgZ3cucm93RWRpdGluZ1N0b3BwZWRcclxuICogQGZpcmVzIGd3LnJvd1ZhbHVlQ2hhbmdlZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uUm93RWRpdGluZ0V2ZW50KGlkLCBlKSB7XHJcbiAgY29uc3QgcGFyc2VkID0gZ3dfcGFyc2VOb2RlRnJvbUV2ZW50KGUpXHJcblxyXG4gIGlmIChwYXJzZWQpIHtcclxuICAgIGNvbnN0IHR5cGUgPSBlLnR5cGVcclxuICAgIGd3X3NlbmRFdmVudChcclxuICAgICAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogYGd3LiR7ZS50eXBlfWAsXHJcbiAgICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7IC4uLnBhcnNlZCwgLi4ueyBjcjogZS5kYXRhIH0gfSksIC8vIHJvdyAod2UgYWx3YXlzIGluY2x1ZGUgdGhlIGNsaWVudCByb3cgZGF0YSlcclxuICAgICAgfSxcclxuICAgICAgUk9XX0VESVRJTkdfRVZFTlRTX01BUFt0eXBlXVxyXG4gICAgKVxyXG4gIH1cclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2RlYm91bmNlLCBnd19zZW5kRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfb25TdGF0ZUNoYW5nZWQgfSBmcm9tICcuL3N0YXRlJ1xyXG5pbXBvcnQgeyBnd19vbktleWRvd24gfSBmcm9tICcuL2tleWJvYXJkJ1xyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnYXBpL3V0aWxpdGllcydcclxuaW1wb3J0IHsgR1dfRVZFTlRfUkVBRFkgfSBmcm9tICcuL2NvbnN0YW50cydcclxuXHJcbi8qKlxyXG4gKiBPbiBSZWFkeSBFdmVudFxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIHdpbGwgaWdub3JlIGZpcnN0IHJlYWR5IGV2ZW50IGFuZCB0aGVuIHJlZ2lzdGVyIGEgZGVib3VuY2VkIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHRvIHNlbmQgc3RhdGUgZXZlbnRzIHRvIEJCalxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZSAgVGhlIGV2ZW50IHBheWxvYWRcclxuICpcclxuICogQGxpc3RlbnMgYWdHcmlkLmdyaWRSZWFkeVxyXG4gKiBAZmlyZXMgZ3cucmVhZHlcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25SZWFkeUV2ZW50KGlkLCBfZSkge1xyXG4gIGNvbnN0IGdyaWQgPSBnd19nZXRHcmlkKGlkKVxyXG5cclxuICBnd19zZW5kRXZlbnQoXHJcbiAgICBncmlkLm9wdGlvbnMuY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2d3LmdyaWRSZWFkeScsXHJcbiAgICAgIGRldGFpbDoge30sXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUkVBRFlcclxuICApXHJcblxyXG4gIC8vIHJlZ2lzdGVyIHN0YXRlIGRlYm91bmNlIG1vbml0b3JcclxuICBjb25zdCBzdGF0ZURlYm91bmNlID0gZ3dfZGVib3VuY2UoY2hhbmdlRXZlbnQgPT4ge1xyXG4gICAgZ3dfb25TdGF0ZUNoYW5nZWQoaWQsIGNoYW5nZUV2ZW50KVxyXG4gIH0sIDUwMClcclxuXHJcbiAgO1tcclxuICAgICdzb3J0Q2hhbmdlZCcsXHJcbiAgICAnZmlsdGVyQ2hhbmdlZCcsXHJcbiAgICAnY29sdW1uVmlzaWJsZScsXHJcbiAgICAnY29sdW1uUGlubmVkJyxcclxuICAgICdjb2x1bW5SZXNpemVkJyxcclxuICAgICdjb2x1bW5Nb3ZlZCcsXHJcbiAgICAnbmV3Q29sdW1uc0xvYWRlZCcsXHJcbiAgICAnZ3JpZENvbHVtbnNDaGFuZ2VkJyxcclxuICAgICdkaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZCcsXHJcbiAgICAndmlydHVhbENvbHVtbnNDaGFuZ2VkJyxcclxuICAgICdjb2x1bW5FdmVyeXRoaW5nQ2hhbmdlZCcsXHJcbiAgICAvLydncmlkU2l6ZUNoYW5nZWQnLFxyXG4gICAgJ2V4cGFuZE9yQ29sbGFwc2VBbGwnLFxyXG4gICAgLy8ndG9vbFBhbmVsVmlzaWJsZUNoYW5nZWQnXHJcbiAgXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgIGdyaWQub3B0aW9ucy5hcGkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc3RhdGVEZWJvdW5jZSlcclxuICB9KVxyXG5cclxuICAvLyBjb2xsZWN0IGtleSBkb3ducyBpbmZvcm1hdGlvbiB0byBiZSByZXBvcnRlZCB3aXRoIG90aGVyIGV2ZW50c1xyXG4gIGdyaWQuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duRXZlbnQgPT4ge1xyXG4gICAgZ3JpZC5rZXlzID0ge1xyXG4gICAgICBjOiBrZXlkb3duRXZlbnQua2V5LFxyXG4gICAgICBrYzoga2V5ZG93bkV2ZW50LndoaWNoIHx8IE51bWJlcihrZXlkb3duRXZlbnQua2V5Q29kZSksXHJcbiAgICAgIGFrOiBrZXlkb3duRXZlbnQuYWx0S2V5LFxyXG4gICAgICBzazoga2V5ZG93bkV2ZW50LnNoaWZ0S2V5LFxyXG4gICAgICBjazoga2V5ZG93bkV2ZW50LmN0cmxLZXksXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gY2xlYXIgY29sbGVjdCBrZXlkb3duIGluZm9ybWF0aW9uXHJcbiAgZ3JpZC5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICdrZXl1cCcsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuICAgIGd3X2RlYm91bmNlKF9lID0+IHtcclxuICAgICAgZ3JpZC5rZXlzID0gbnVsbFxyXG4gICAgfSwgMjUwKVxyXG4gIClcclxuXHJcbiAgLy8gcmVnaXN0ZXIga2V5Ym9hcmQgZGVib3VuY2UgbW9uaXRvclxyXG5cclxuICBncmlkLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgJ2tleWRvd24nLFxyXG4gICAgZ3dfZGVib3VuY2Uoa2V5ZG93bkV2ZW50ID0+IHtcclxuICAgICAgZ3dfb25LZXlkb3duKGlkLCBrZXlkb3duRXZlbnQpXHJcbiAgICB9LCA1MDApXHJcbiAgKVxyXG5cclxuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYCR7aWR9LXJlYWR5YCwgeyBkZXRhaWw6IGdyaWQgfSkpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19zZW5kRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcbmltcG9ydCB7IEdXX0VWRU5UX0dSSURfU1RBVEVfQ0hBTkdFIH0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYHN0YXRlQ2hhbmdlZGAgZXZlbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlICBUaGUgZXZlbnQgcGF5bG9hZFxyXG4gKlxyXG4gKiBAbGlzdGVucyBhZ0dyaWQuc3RhdGVDaGFuZ2VkXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dFZGl0aW5nU3RvcHBlZFxyXG4gKlxyXG4gKiBAZmlyZXMgZ3cuc3RhdGVDaGFuZ2VkXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uU3RhdGVDaGFuZ2VkKGlkLCBfZSkge1xyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2d3LnN0YXRlQ2hhbmdlZCcsXHJcbiAgICAgIGRldGFpbDogW10sXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfR1JJRF9TVEFURV9DSEFOR0VcclxuICApXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19zZW5kRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgR1dfRVZFTlRfS0VZUFJFU1MgfSBmcm9tICcuL2NvbnN0YW50cydcclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogQ29tcG9zZSBhIG1vZGVsIG9mIHRoZSBrZXlkb3duIGV2ZW50IGFuZCBzZW5kIGl0IHRvIEJCalxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtFdmVudH0ga2V5ZG93bkV2ZW50IGtleWRvd24gZXZlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbktleWRvd24oaWQsIGtleWRvd25FdmVudCkge1xyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogYGd3LmtleXByZXNzYCxcclxuICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgYzoga2V5ZG93bkV2ZW50LmtleSxcclxuICAgICAgICBrYzoga2V5ZG93bkV2ZW50LndoaWNoIHx8IE51bWJlcihrZXlkb3duRXZlbnQua2V5Q29kZSksXHJcbiAgICAgICAgYWs6IGtleWRvd25FdmVudC5hbHRLZXksXHJcbiAgICAgICAgc2s6IGtleWRvd25FdmVudC5zaGlmdEtleSxcclxuICAgICAgICBjazoga2V5ZG93bkV2ZW50LmN0cmxLZXksXHJcbiAgICAgIH0pLFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX0tFWVBSRVNTXHJcbiAgKVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfc2VuZEV2ZW50IH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IEdXX0VWRU5UX0ZJTFRFUl9DSEFOR0VEIH0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYGZpbHRlckNoYW5nZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCdzIHBheWxvYWRcclxuICpcclxuICogQGxpc3RlbnMgYWdHcmlkLmZpbHRlckNoYW5nZWRcclxuICogQGZpcmVzIGd3LmZpbHRlckNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbkZpbHRlckNoYW5nZWQoaWQsIGUpIHtcclxuICBjb25zdCBjb250ZXh0ID0gZS5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdyaWRPcHRpb25zLmNvbnRleHRcclxuXHJcbiAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2d3LmZpbHRlckNoYW5nZWQnLFxyXG4gICAgICBkZXRhaWw6IHt9LFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX0ZJTFRFUl9DSEFOR0VEXHJcbiAgKVxyXG59XHJcbiIsImltcG9ydCBjb3B5T2JqZWN0IGZyb20gJy4vX2NvcHlPYmplY3QuanMnO1xuaW1wb3J0IGNyZWF0ZUFzc2lnbmVyIGZyb20gJy4vX2NyZWF0ZUFzc2lnbmVyLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBhbGlhcyBleHRlbmRXaXRoXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbldpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAqIH1cbiAqXG4gKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gKlxuICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduSW5XaXRoO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnblZhbHVlO1xuIiwiaW1wb3J0IGJhc2VJc05hdGl2ZSBmcm9tICcuL19iYXNlSXNOYXRpdmUuanMnO1xuaW1wb3J0IGdldFZhbHVlIGZyb20gJy4vX2dldFZhbHVlLmpzJztcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0TmF0aXZlO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc01hc2tlZCBmcm9tICcuL19pc01hc2tlZC5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgdG9Tb3VyY2UgZnJvbSAnLi9fdG9Tb3VyY2UuanMnO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNOYXRpdmU7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVKc0RhdGE7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhbHVlO1xuIiwiaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0l0ZXJhdGVlQ2FsbCBmcm9tICcuL19pc0l0ZXJhdGVlQ2FsbC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8uYXNzaWduYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aCxcbiAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgY3VzdG9taXplciA9IChhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpXG4gICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgbGVuZ3RoID0gMTtcbiAgICB9XG4gICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFzc2lnbmVyO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlclJlc3Q7XG4iLCJpbXBvcnQgYmFzZVNldFRvU3RyaW5nIGZyb20gJy4vX2Jhc2VTZXRUb1N0cmluZy5qcyc7XG5pbXBvcnQgc2hvcnRPdXQgZnJvbSAnLi9fc2hvcnRPdXQuanMnO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5leHBvcnQgZGVmYXVsdCBzZXRUb1N0cmluZztcbiIsImltcG9ydCBjb25zdGFudCBmcm9tICcuL2NvbnN0YW50LmpzJztcbmltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnQ7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0T3V0O1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXNJbiBmcm9tICcuL19iYXNlS2V5c0luLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5c0luO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcbmltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICogfSwgJz5fPicpO1xuICpcbiAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gKiAgIGVsZW1lbnRzID0gW107XG4gKiB9XG4gKi9cbnZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB0cnkge1xuICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXR0ZW1wdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGdldFByb3RvdHlwZSBmcm9tICcuL19nZXRQcm90b3R5cGUuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQbGFpbk9iamVjdDtcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0UHJvdG90eXBlO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gKiBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllc1xuICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAoZXEob2JqVmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICByZXR1cm4gc3JjVmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9ialZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluO1xuIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVTdHJpbmdDaGFyO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgZXNjYXBlIGZyb20gJy4vZXNjYXBlLmpzJztcbmltcG9ydCByZUVzY2FwZSBmcm9tICcuL19yZUVzY2FwZS5qcyc7XG5pbXBvcnQgcmVFdmFsdWF0ZSBmcm9tICcuL19yZUV2YWx1YXRlLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gKiBlbWJlZGRlZCBSdWJ5IChFUkIpIGFzIHdlbGwgYXMgRVMyMDE1IHRlbXBsYXRlIHN0cmluZ3MuIENoYW5nZSB0aGVcbiAqIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHRlbXBsYXRlU2V0dGluZ3MgPSB7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnZXZhbHVhdGUnOiByZUV2YWx1YXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2ludGVycG9sYXRlJzogcmVJbnRlcnBvbGF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICAndmFyaWFibGUnOiAnJyxcblxuICAvKipcbiAgICogVXNlZCB0byBpbXBvcnQgdmFyaWFibGVzIGludG8gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICAnaW1wb3J0cyc6IHtcblxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c1xuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKi9cbiAgICAnXyc6IHsgJ2VzY2FwZSc6IGVzY2FwZSB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlU2V0dGluZ3M7XG4iLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG4iLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSHRtbENoYXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VQcm9wZXJ0eU9mO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUb1N0cmluZztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEFuIGltcHJvdmVkIHRvb2x0aXAgY29tcG9uZW50IHdoaWNoIHN1cHBvcnRzIEhUTUwgYW5kIGJlaGF2ZXMgdGhlIHNhbWUgaW4gYm90aCBHVUkgYW5kIEJVSVxyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXJcclxuICovXHJcbmNsYXNzIEhUTUxUb29sdGlwIHtcclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgdGhlIGNvbXBvbmVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyB0aGUgdG9vbHRpcCBjb21wb25lbnQgcGFyYW1zXHJcbiAgICovXHJcbiAgaW5pdChwYXJhbXMpIHtcclxuICAgIGNvbnN0IGVHdWkgPSAodGhpcy5lR3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXHJcbiAgICBjb25zdCB0b29sdGlwVmFsdWVHZXR0ZXIgPSBwYXJhbXMuY29sRGVmLnRvb2x0aXBWYWx1ZUdldHRlclxyXG4gICAgY29uc3QgaXNIZWFkZXIgPSBwYXJhbXMucm93SW5kZXggPT09IHVuZGVmaW5lZFxyXG4gICAgY29uc3QgaXNHcm91cGVkSGVhZGVyID0gaXNIZWFkZXIgJiYgISFwYXJhbXMuY29sRGVmLmNoaWxkcmVuXHJcbiAgICBjb25zb2xlLmxvZyhwYXJhbXMpXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICBjb25zdCBkYXRhID1cclxuICAgICAgIWlzSGVhZGVyICYmICFpc0dyb3VwZWRIZWFkZXJcclxuICAgICAgICA/IHBhcmFtcy5hcGkuZ2V0RGlzcGxheWVkUm93QXRJbmRleChwYXJhbXMucm93SW5kZXgpLmRhdGFcclxuICAgICAgICA6IG51bGxcclxuICAgIGNvbnN0IHRoZW1lID0gcGFyYW1zLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZUdyaWREaXYuY2xhc3NOYW1lLmVuZHNXaXRoKFxyXG4gICAgICAnZGFyaydcclxuICAgIClcclxuICAgICAgPyAnZ3ctdG9vbHRpcC1kYXJrJ1xyXG4gICAgICA6ICdndy10b29sdGlwLWxpZ2h0J1xyXG4gICAgY29uc3QgdG9vbHRpcEZpZWxkID0gcGFyYW1zLmNvbERlZi50b29sdGlwRmllbGRcclxuICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KHBhcmFtcy5jb2xEZWYudG9vbHRpcEZpZWxkKVxyXG4gICAgICAgID8gZGF0YVtwYXJhbXMuY29sRGVmLnRvb2x0aXBGaWVsZF1cclxuICAgICAgICA6IG51bGxcclxuICAgICAgOiBudWxsXHJcblxyXG4gICAgY29uc3QgcGFzc2VkUGFyYW1zID0ge1xyXG4gICAgICAuLi5wYXJhbXMsXHJcbiAgICAgIC4uLnsgZGF0YSB9LFxyXG4gICAgICAuLi57IGlzSGVhZGVyLCBpc0dyb3VwZWRIZWFkZXIsIHRvb2x0aXBGaWVsZCB9LFxyXG4gICAgfVxyXG5cclxuICAgIGVHdWkuY2xhc3NMaXN0LmFkZCgnZ3ctdG9vbHRpcCcsIHRoZW1lKVxyXG4gICAgZUd1aS5pbm5lckhUTUwgPVxyXG4gICAgICBpc0hlYWRlciB8fCBpc0dyb3VwZWRIZWFkZXJcclxuICAgICAgICA/IHBhcmFtcy52YWx1ZVxyXG4gICAgICAgIDogdG9vbHRpcEZpZWxkXHJcbiAgICAgICAgPyB0b29sdGlwRmllbGRcclxuICAgICAgICA6IHRvb2x0aXBWYWx1ZUdldHRlclxyXG4gICAgICAgID8gdG9vbHRpcFZhbHVlR2V0dGVyKHBhc3NlZFBhcmFtcylcclxuICAgICAgICA6IHBhcmFtcy52YWx1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBndWkgSW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldEd1aSgpIHtcclxuICAgIHJldHVybiB0aGlzLmVHdWlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhUTUxUb29sdGlwXHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IGF1dG9jb21wbGV0ZSBmcm9tICdhdXRvY29tcGxldGVyJ1xyXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJ1xyXG5pbXBvcnQgeyBnd19wYXJzZU5vZGUgfSBmcm9tICdldmVudHMvdXRpbGl0aWVzJ1xyXG4vKipcclxuICogQW4gYXV0b2NvbXBsZXRlIGNlbGwgZWRpdG9yIHdyaXR0ZW4gc3BlY2lmaWNhbGx5IHRvIEJCakdyaWRFeFdpZGdldFxyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXJcclxuICovXHJcbmNsYXNzIFN1Z2dlc3Rpb25FZGl0b3Ige1xyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGNvbXBvbmVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xyXG4gICAqXHJcbiAgICogQHJldHVybiB2b2lkXHJcbiAgICovXHJcbiAgaW5pdChwYXJhbXMpIHtcclxuICAgIGNvbnN0IHBhdHRlcm4gPSBwYXJhbXMudGV4dFBhdHRlcm4gfHwgbnVsbFxyXG4gICAgY29uc3QgcmVxdWlyZWQgPSBwYXJhbXMudGV4dFJlcXVpcmVkIHx8IGZhbHNlXHJcbiAgICBjb25zdCB0aXRsZSA9IHBhcmFtcy50ZXh0VGl0bGUgfHwgbnVsbFxyXG4gICAgY29uc3QgZGVib3VuY2VXYWl0TXMgPSBwYXJhbXMuZGVib3VuY2VXYWl0TXMgfHwgMjUwXHJcblxyXG4gICAgbGV0IHN0YXJ0VmFsdWVcclxuXHJcbiAgICB0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0XHJcbiAgICBpZiAodGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkKSB7XHJcbiAgICAgIGNvbnN0IGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUgPVxyXG4gICAgICAgIHBhcmFtcy5rZXlQcmVzcyA9PSAzMiB8fCBwYXJhbXMua2V5UHJlc3MgPT0gNDYgLy8gc3BhY2UgLy8gZGVsZXRlXHJcblxyXG4gICAgICBpZiAoa2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSkge1xyXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAnJ1xyXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jaGFyUHJlc3MpIHtcclxuICAgICAgICBzdGFydFZhbHVlID0gcGFyYW1zLmNoYXJQcmVzc1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMudmFsdWVcclxuICAgICAgICBpZiAocGFyYW1zLmtleVByZXNzICE9IDExMykge1xyXG4gICAgICAgICAgLy9GMlxyXG4gICAgICAgICAgdGhpcy5faGlnaGxpZ2h0QWxsT25Gb2N1cyA9IHRydWVcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMudmFsdWVcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcclxuXHJcbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICdhdXRvY29tcGxldGVJbnB1dFdyYXBwZXIgYWctY2VsbC1lZGl0LXdyYXBwZXInXHJcbiAgICB0aGlzLl9ndWkudGFiSW5kZXggPSAnMCdcclxuICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSAvKiBodG1sICovIGBcclxuICAgIDxkaXYgY2xhc3M9XCJhZy1jZWxsLWVkaXRvciBhZy1sYWJlbGVkIGFnLWxhYmVsLWFsaWduLWxlZnQgYWctdGV4dC1maWVsZCBhZy1pbnB1dC1maWVsZFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXRleHQtZmllbGQtaW5wdXQtd3JhcHBlclwiPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgYFxyXG5cclxuICAgIC8vIGlucHV0XHJcbiAgICB0aGlzLl9pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcclxuICAgIHRoaXMuX2lucHV0LmNsYXNzTmFtZSA9XHJcbiAgICAgICdhdXRvY29tcGxldGVJbnB1dFdyYXBwZXJfX2lucHV0IGFnLWNlbGwtZWRpdC1pbnB1dCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy10ZXh0LWZpZWxkLWlucHV0J1xyXG4gICAgdGhpcy5faW5wdXQudHlwZSA9ICd0ZXh0J1xyXG4gICAgdGhpcy5faW5wdXQudmFsdWUgPSBzdGFydFZhbHVlXHJcbiAgICB0aGlzLl9pbnB1dC50YWJJbmRleCA9IDBcclxuXHJcbiAgICB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmFnLWlucHV0LXdyYXBwZXInKS5hcHBlbmRDaGlsZCh0aGlzLl9pbnB1dClcclxuXHJcbiAgICBpZiAocGF0dGVybiAhPT0gbnVsbCkge1xyXG4gICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3BhdHRlcm4nLCBwYXR0ZXJuKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXF1aXJlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJywgJ3JlcXVpcmVkJylcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGl0bGUgIT09IG51bGwgJiYgdGl0bGUgIT09ICdkZWZhdWx0Jykge1xyXG4gICAgICB0aGlzLl9pbnB1dC50aXRsZSA9IHRpdGxlXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fb25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpXHJcblxyXG4gICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSlcclxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKVxyXG5cclxuICAgIC8vIHNldHVwIHRoZSBhdXRvY29tcGxldGUgY29tcG9uZW50XHJcbiAgICB0aGlzLl9yZW5kZXJJdGVtVGVtcGxhdGUgPSB0aGlzLl9wYXJhbXMuaXRlbVRlbXBsYXRlXHJcbiAgICAgID8gdGVtcGxhdGUodGhpcy5fcGFyYW1zLml0ZW1UZW1wbGF0ZSlcclxuICAgICAgOiAnJ1xyXG4gICAgdGhpcy5fcmVuZGVyR3JvdXBUZW1wbGF0ZSA9IHRoaXMuX3BhcmFtcy5ncm91cFRlbXBsYXRlXHJcbiAgICAgID8gdGVtcGxhdGUodGhpcy5fcGFyYW1zLmdyb3VwVGVtcGxhdGUpXHJcbiAgICAgIDogJydcclxuICAgIHRoaXMuX2F1dG9jb21wbGV0ZSA9IGF1dG9jb21wbGV0ZSh7XHJcbiAgICAgIGlucHV0OiB0aGlzLl9pbnB1dCxcclxuICAgICAgZGVib3VuY2VXYWl0TXM6IGRlYm91bmNlV2FpdE1zLFxyXG4gICAgICAvLyB3aXRob3V0IHRoaXMgb3B0aW9uIGVuYWJsZWQgLCB0aGUgbGlzdCB3b250IGJlIGNsb3NlZCBpbiBHVUlcclxuICAgICAgcHJldmVudFN1Ym1pdDogdHJ1ZSxcclxuICAgICAgZmV0Y2g6IHRoaXMuX29uQXV0b2NvbXBsZXRlRmV0Y2guYmluZCh0aGlzKSxcclxuICAgICAgb25TZWxlY3Q6IHRoaXMuX29uQXV0b2NvbXBsZXRlU2VsZWN0LmJpbmQodGhpcyksXHJcbiAgICAgIHJlbmRlckdyb3VwOiB0aGlzLl9vbkF1dG9jb21wbGV0ZVJlbmRlckdyb3VwLmJpbmQodGhpcyksXHJcbiAgICAgIHJlbmRlcjogdGhpcy5fb25BdXRvY29tcGxldGVSZW5kZXJJdGVtLmJpbmQodGhpcyksXHJcbiAgICAgIGN1c3RvbWl6ZTogdGhpcy5fb25BdXRvY29tcGxldGVDdXN0b21pemUuYmluZCh0aGlzKSxcclxuICAgICAgZW1wdHlNc2c6IHRoaXMuX3BhcmFtcy5lbXB0eU1lc3NhZ2UgfHwgbnVsbCxcclxuICAgICAgbWluTGVuZ3RoOiB0aGlzLl9wYXJhbXMubWluTGVuZ3RoIHx8IDIsXHJcbiAgICAgIHNob3dPbkZvY3VzOiB0aGlzLl9wYXJhbXMuc2hvd09uRm9jdXMgfHwgZmFsc2UsXHJcbiAgICAgIGNsYXNzTmFtZTogcGFyYW1zLmFwaS5ncmlkQ29yZS5lR3JpZERpdi5jbGFzc05hbWUuZW5kc1dpdGgoJ2RhcmsnKVxyXG4gICAgICAgID8gJ2RhcmsnXHJcbiAgICAgICAgOiAnbGlnaHQnLFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgRE9NIGVsZW1lbnQgb2YgdGhlIGNvbXBvbmVudCwgdGhpcyBpcyB3aGF0IHRoZSBncmlkIHB1dHMgaW50byB0aGUgY2VsbFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0R3VpKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2d1aVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBHVUkgaXMgYXR0YWNoZWQgdG8gRE9NLlxyXG4gICAqXHJcbiAgICogTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBhbHdheXMgZm9jdXNlZCB0byBsaXN0ZW4gdG8ga2V5IGNoYW5nZXNcclxuICAgKi9cclxuICBhZnRlckd1aUF0dGFjaGVkKCkge1xyXG4gICAgaWYgKHRoaXMuX2hpZ2hsaWdodEFsbE9uRm9jdXMpIHtcclxuICAgICAgdGhpcy5faW5wdXQuc2VsZWN0KClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQpIHtcclxuICAgICAgICB0aGlzLmZvY3VzSW4oKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgVGhlIGNvbXBvbmVudCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lucHV0LnZhbHVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBkb2luZyBmdWxsIHJvdyBlZGl0LCB0aGVuIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyBpbnRvIHRoZSBjZWxsLlxyXG4gICAqL1xyXG4gIGZvY3VzSW4oKSB7XHJcbiAgICB0aGlzLl9pbnB1dC5mb2N1cygpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGNhbGxlZCBvbmNlIHdoZW4gZWRpdGluZyBpcyBmaW5pc2hlZCAoZWcgaWYgZW50ZXIgaXMgcHJlc3NlZCkuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHRoZSByZXN1bHQgb2YgdGhlIGVkaXQgd2lsbCBiZSBpZ25vcmVkLiBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBpc0NhbmNlbEFmdGVyRW5kKCkge1xyXG4gICAgY29uc3QgYWxsb3dDdXN0b21WYWx1ZXMgPSB0aGlzLl9wYXJhbXMuYWxsb3dDdXN0b21WYWx1ZXMgfHwgZmFsc2VcclxuICAgIGxldCBpc1ZhbGlkID0gdGhpcy5fdmFsaWRhdGVJbnB1dCh0aGlzLl9pbnB1dClcclxuXHJcbiAgICBpZiAoaXNWYWxpZCAmJiBhbGxvd0N1c3RvbVZhbHVlcyA9PT0gZmFsc2UgJiYgdGhpcy5fbGFzdEZldGNoZWREYXRhKSB7XHJcbiAgICAgIGNvbnN0IGZpbHRlcmVkSXRlbXMgPSB0aGlzLl9sYXN0RmV0Y2hlZERhdGEuZmlsdGVyKFxyXG4gICAgICAgIHggPT4geC52YWx1ZSA9PT0gdGhpcy5faW5wdXQudmFsdWVcclxuICAgICAgKVxyXG4gICAgICBpc1ZhbGlkID0gZmlsdGVyZWRJdGVtcy5sZW5ndGggPT09IDFcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIWlzVmFsaWRcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXHJcbiAgICpcclxuICAgKiBDbGVhciB0aGUgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgYW5kIGRlc3Ryb3kgdGhlIGF1dG9jb21wbGV0ZVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uQ2hhbmdlKVxyXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpXHJcbiAgICB0aGlzLl9hdXRvY29tcGxldGUuZGVzdHJveSgpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB0byBwcmVwYXJlIHN1Z2dlc3Rpb25zIGFuZCB0aGVuIHBhc3MgdGhlbSB0byBhdXRvY29tcGxldGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCB0aGUgdGV4dCBpbiB0aGUgaW5wdXQgZmllbGRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGUgYSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IG11c3QgYmUgY2FsbGVkIGFmdGVyIHN1Z2dlc3Rpb25zIGFyZSBwcmVwYXJlZFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGZhbHNlIHdoZW4gdGhlIHJlcXVlc3QgaXMgaWdub3JlZCAsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIF9vbkF1dG9jb21wbGV0ZUZldGNoKHRleHQsIHVwZGF0ZSkge1xyXG4gICAgY29uc3Qgc3VwcHJlc3NTdWdnZXN0aW9uT25JbnZhbGlkSW5wdXQgPVxyXG4gICAgICB0aGlzLl9wYXJhbXMuc3VwcHJlc3NTdWdnZXN0aW9uT25JbnZhbGlkSW5wdXQgfHwgZmFsc2VcclxuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KHRoaXMuX2lucHV0KVxyXG5cclxuICAgIGlmIChzdXBwcmVzc1N1Z2dlc3Rpb25PbkludmFsaWRJbnB1dCAmJiAhaXNWYWxpZCkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpZCA9IHRoaXMuX3BhcmFtcy5ldmVudElkXHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihpZCwgZXZlbnQgPT4ge1xyXG4gICAgICB0aGlzLl9sYXN0RmV0Y2hlZERhdGEgPSBldmVudC5kZXRhaWxcclxuICAgICAgdXBkYXRlKGV2ZW50LmRldGFpbClcclxuICAgIH0pXHJcblxyXG4gICAgd2luZG93LmJhc2lzRGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLl9wYXJhbXMuZUdyaWRDZWxsLCB7XHJcbiAgICAgIHR5cGU6ICdndy5zdWdnZXN0aW9uJyxcclxuICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgaWQsXHJcbiAgICAgICAgdGV4dCxcclxuICAgICAgICBjb2x1bW46IHRoaXMuX3BhcmFtcy5jb2xEZWYuZmllbGQsXHJcbiAgICAgICAgcm93OiBnd19wYXJzZU5vZGUoXHJcbiAgICAgICAgICB0aGlzLl9wYXJhbXMubm9kZSxcclxuICAgICAgICAgIHRoaXMuX3BhcmFtcy5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdyaWRPcHRpb25zLmNvbnRleHRcclxuICAgICAgICApLFxyXG4gICAgICB9KSxcclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIHRydWVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHdoZW4gdXNlciBjaG9vc2UgYW4gaXRlbSBpbiBhdXRvY29tcGxldGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSBUaGUgc2VsZWN0ZWQgaXRlbVxyXG4gICAqL1xyXG4gIF9vbkF1dG9jb21wbGV0ZVNlbGVjdChpdGVtKSB7XHJcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IGl0ZW0udmFsdWVcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgb3ZlcnJpZGVzIHRoZSByZW5kZXJpbmcgZnVuY3Rpb24gb2YgYXV0b2NvbXBsZXRlIGl0ZW1zLlxyXG4gICAqXHJcbiAgICogSXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggc3VnZ2VzdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gc3VnZ2VzdGlvbiBvYmplY3RcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFZhbHVlIFRoZSBjdXJyZW50IGlucHV0IGZpZWxkIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgX29uQXV0b2NvbXBsZXRlUmVuZGVySXRlbShpdGVtLCBjdXJyZW50VmFsdWUpIHtcclxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICBkaXYuY2xhc3NOYW1lID0gJ3N1Z2dlc3Rpb24taXRlbSdcclxuXHJcbiAgICBpZiAodGhpcy5fcmVuZGVySXRlbVRlbXBsYXRlKSB7XHJcbiAgICAgIGRpdi5pbm5lckhUTUwgPSB0aGlzLl9yZW5kZXJJdGVtVGVtcGxhdGUoe1xyXG4gICAgICAgIGl0ZW0sXHJcbiAgICAgICAgY3VycmVudFZhbHVlLFxyXG4gICAgICB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGl2LmlubmVySFRNTCA9IGl0ZW0ubGFiZWxcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGl2XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG92ZXJyaWRlcyB0aGUgcmVuZGVyaW5nIGZ1bmN0aW9uIG9mIGF1dG9jb21wbGV0ZSBncm91cHMuXHJcbiAgICpcclxuICAgKiBJdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBncm91cFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSBUaGUgZ3JvdXAgbmFtZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50VmFsdWUgVGhlIGN1cnJlbnQgaW5wdXQgZmllbGQgdmFsdWVcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBfb25BdXRvY29tcGxldGVSZW5kZXJHcm91cChncm91cE5hbWUsIGN1cnJlbnRWYWx1ZSkge1xyXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIGRpdi5jbGFzc05hbWUgPSAnc3VnZ2VzdGlvbi1ncm91cCdcclxuXHJcbiAgICBpZiAodGhpcy5fcmVuZGVyR3JvdXBUZW1wbGF0ZSkge1xyXG4gICAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5fcmVuZGVyR3JvdXBUZW1wbGF0ZSh7IGdyb3VwTmFtZSwgY3VycmVudFZhbHVlIH0pXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkaXYuaW5uZXJIVE1MID0gZ3JvdXBOYW1lXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpdlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9vayBvbiB0aGUgYXV0b2NvbXBsZXRlIGNvbnRhaW5lciByZW5kZXIgYW5kIGNoYW5nZSB0aGUgd2lkdGggYW5kIHRoZVxyXG4gICAqIGhlaWdodCBhY2NvcmRpbmcgdG8gdGhlIG9wdGlvbnNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXRSZWN0XHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1heEhlaWdodFxyXG4gICAqL1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gIF9vbkF1dG9jb21wbGV0ZUN1c3RvbWl6ZShpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCkge1xyXG4gICAgaWYgKHRoaXMuX3BhcmFtcy53aWR0aCkge1xyXG4gICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9wYXJhbXMud2lkdGh9cHhgXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3BhcmFtcy5oZWlnaHQpIHtcclxuICAgICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX3BhcmFtcy5oZWlnaHR9cHhgXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0IHRvIHRoZSBpbnB1dCBjaGFuZ2VzIGFuZCB2YWxpZGF0ZSBpdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gVGhlIGV2ZW50IG9iamVjdFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIF9vbkNoYW5nZShldmVudCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlSW5wdXQoZXZlbnQudGFyZ2V0KVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRG8gdmFsaWRhdGUgdGhlIGdpdmVuIGlucHV0IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgaW5wdXQgZWxlbWVudFxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHZhbGlkICwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcclxuICAgIGNvbnN0IGlzVmFsaWQgPSBpbnB1dC5jaGVja1ZhbGlkaXR5KClcclxuXHJcbiAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnYXV0b2NvbXBsZXRlLWlucHV0LWVycm9yJylcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnYXV0b2NvbXBsZXRlLWlucHV0LXN1Y2Nlc3MnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnYXV0b2NvbXBsZXRlLWlucHV0LWVycm9yJylcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnYXV0b2NvbXBsZXRlLWlucHV0LXN1Y2Nlc3MnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpc1ZhbGlkXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdWdnZXN0aW9uRWRpdG9yXHJcbiIsIiAvKlxyXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXHJcbiAgKiBDb3B5cmlnaHQgKGMpIDIwMTYgRGVueXMgS3Jhc25vc2hjaG9rXHJcbiAgKiBNSVQgTGljZW5zZVxyXG4gICovXHJcblxyXG5leHBvcnQgY29uc3QgZW51bSBFdmVudFRyaWdnZXIge1xyXG4gICAgS2V5Ym9hcmQgPSAwLFxyXG4gICAgRm9jdXMgPSAxXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlSXRlbSB7XHJcbiAgICBsYWJlbD86IHN0cmluZztcclxuICAgIGdyb3VwPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZVNldHRpbmdzPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPiB7XHJcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcclxuICAgIHJlbmRlcj86IChpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XHJcbiAgICByZW5kZXJHcm91cD86IChuYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcclxuICAgIGNsYXNzTmFtZT86IHN0cmluZztcclxuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcclxuICAgIGVtcHR5TXNnPzogc3RyaW5nO1xyXG4gICAgb25TZWxlY3Q6IChpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBhdXRvY29tcGxldGUgb24gZm9jdXMgZXZlbnQuIEZvY3VzIGV2ZW50IHdpbGwgaWdub3JlIHRoZSBgbWluTGVuZ3RoYCBwcm9wZXJ0eSBhbmQgd2lsbCBhbHdheXMgY2FsbCBgZmV0Y2hgLlxyXG4gICAgICovXHJcbiAgICBzaG93T25Gb2N1cz86IGJvb2xlYW47XHJcbiAgICBmZXRjaDogKHRleHQ6IHN0cmluZywgdXBkYXRlOiAoaXRlbXM6IFRbXSB8IGZhbHNlKSA9PiB2b2lkLCB0cmlnZ2VyOiBFdmVudFRyaWdnZXIpID0+IHZvaWQ7XHJcbiAgICBkZWJvdW5jZVdhaXRNcz86IG51bWJlcjtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgZm9yIGFkZGl0aW9uYWwgYXV0b2NvbXBsZXRlIGN1c3RvbWl6YXRpb25cclxuICAgICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgLSBpbnB1dCBib3ggYXNzb2NpYXRlZCB3aXRoIGF1dG9jb21wbGV0ZVxyXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBjb250YWluZXIgLSBjb250YWluZXIgd2l0aCBzdWdnZXN0aW9uc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIG1heCBoZWlnaHQgdGhhdCBjYW4gYmUgdXNlZCBieSBhdXRvY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgY3VzdG9taXplPzogKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBtYXhIZWlnaHQ6IG51bWJlcikgPT4gdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudHMgYXV0b21hdGljIGZvcm0gc3VibWl0IHdoZW4gRU5URVIgaXMgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwcmV2ZW50U3VibWl0PzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVSZXN1bHQge1xyXG4gICAgZGVzdHJveTogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuY29uc3QgZW51bSBLZXlzIHtcclxuICAgIEVudGVyID0gMTMsXHJcbiAgICBFc2MgPSAyNyxcclxuICAgIFVwID0gMzgsXHJcbiAgICBEb3duID0gNDAsXHJcbiAgICBMZWZ0ID0gMzcsXHJcbiAgICBSaWdodCA9IDM5LFxyXG4gICAgU2hpZnQgPSAxNixcclxuICAgIEN0cmwgPSAxNyxcclxuICAgIEFsdCA9IDE4LFxyXG4gICAgQ2Fwc0xvY2sgPSAyMCxcclxuICAgIFdpbmRvd3NLZXkgPSA5MSxcclxuICAgIFRhYiA9IDksXHJcbiAgICBGMSA9IDExMixcclxuICAgIEYxMiA9IDEyM1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvY29tcGxldGU8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+KHNldHRpbmdzOiBBdXRvY29tcGxldGVTZXR0aW5nczxUPik6IEF1dG9jb21wbGV0ZVJlc3VsdCB7XHJcblxyXG4gICAgLy8ganVzdCBhbiBhbGlhcyB0byBtaW5pbWl6ZSBKUyBmaWxlIHNpemVcclxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICAgIGNvbnN0IG1vYmlsZUZpcmVmb3ggPSB1c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpICE9PSAtMTtcclxuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gc2V0dGluZ3MuZGVib3VuY2VXYWl0TXMgfHwgMDtcclxuICAgIGNvbnN0IHByZXZlbnRTdWJtaXQgPSBzZXR0aW5ncy5wcmV2ZW50U3VibWl0IHx8IGZhbHNlO1xyXG4gICAgXHJcbiAgICAvLyAna2V5dXAnIGV2ZW50IHdpbGwgbm90IGJlIGZpcmVkIG9uIE1vYmlsZSBGaXJlZm94LCBzbyB3ZSBoYXZlIHRvIHVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWRcclxuICAgIGNvbnN0IGtleVVwRXZlbnROYW1lID0gbW9iaWxlRmlyZWZveCA/IFwiaW5wdXRcIiA6IFwia2V5dXBcIjtcclxuICAgIFxyXG4gICAgbGV0IGl0ZW1zOiBUW10gPSBbXTtcclxuICAgIGxldCBpbnB1dFZhbHVlID0gXCJcIjtcclxuICAgIGxldCBtaW5MZW4gPSAyO1xyXG4gICAgY29uc3Qgc2hvd09uRm9jdXMgPSBzZXR0aW5ncy5zaG93T25Gb2N1cztcclxuICAgIGxldCBzZWxlY3RlZDogVCB8IHVuZGVmaW5lZDtcclxuICAgIGxldCBrZXlwcmVzc0NvdW50ZXIgPSAwO1xyXG4gICAgbGV0IGRlYm91bmNlVGltZXIgOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbWluTGVuID0gc2V0dGluZ3MubWluTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2V0dGluZ3MuaW5wdXQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB1bmRlZmluZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBzZXR0aW5ncy5pbnB1dDtcclxuXHJcbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJhdXRvY29tcGxldGUgXCIgKyAoc2V0dGluZ3MuY2xhc3NOYW1lIHx8IFwiXCIpO1xyXG5cclxuICAgIC8vIElPUyBpbXBsZW1lbnRhdGlvbiBmb3IgZml4ZWQgcG9zaXRpb25pbmcgaGFzIG1hbnkgYnVncywgc28gd2Ugd2lsbCB1c2UgYWJzb2x1dGUgcG9zaXRpb25pbmdcclxuICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0YWNoIHRoZSBjb250YWluZXIgZnJvbSBET01cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGV0YWNoKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGVhckRlYm91bmNlVGltZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXR0YWNoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udGFpbmVyRGlzcGxheWVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAhIWNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgYXV0b2NvbXBsZXRlIHN0YXRlIGFuZCBoaWRlIGNvbnRhaW5lclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjbGVhcigpOiB2b2lkIHtcclxuICAgICAgICAvLyBwcmV2ZW50IHRoZSB1cGRhdGUgY2FsbCBpZiB0aGVyZSBhcmUgcGVuZGluZyBBSkFYIHJlcXVlc3RzXHJcbiAgICAgICAga2V5cHJlc3NDb3VudGVyKys7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaXRlbXMgPSBbXTtcclxuICAgICAgICBpbnB1dFZhbHVlID0gXCJcIjtcclxuICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkZXRhY2goKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhdXRvY29tcGxldGUgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb250YWluZXJTdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcclxuICAgICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoICsgXCJweFwiO1xyXG5cclxuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcclxuICAgICAgICBsZXQgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY2FsYygpIHtcclxuICAgICAgICAgICAgY29uc3QgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRUb3AgPSBkb2NFbC5jbGllbnRUb3AgfHwgZG9jLmJvZHkuY2xpZW50VG9wIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudExlZnQgPSBkb2NFbC5jbGllbnRMZWZ0IHx8IGRvYy5ib2R5LmNsaWVudExlZnQgfHwgMDtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2NFbC5zY3JvbGxMZWZ0O1xyXG5cclxuICAgICAgICAgICAgaW5wdXRSZWN0ID0gaW5wdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQgKyBzY3JvbGxUb3AgLSBjbGllbnRUb3A7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpbnB1dFJlY3QubGVmdCArIHNjcm9sbExlZnQgLSBjbGllbnRMZWZ0O1xyXG4gICAgXHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XHJcbiAgICBcclxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gKGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS5ib3R0b20gPSBcIlwiO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlIGNhbGMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIHR3aWNlLCBvdGhlcndpc2UgdGhlIGNhbGN1bGF0aW9uIG1heSBiZSB3cm9uZyBvbiByZXNpemUgZXZlbnQgKGNocm9tZSBicm93c2VyKVxyXG4gICAgICAgIGNhbGMoKTtcclxuICAgICAgICBjYWxjKCk7XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUgJiYgaW5wdXRSZWN0KSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmN1c3RvbWl6ZShpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVkcmF3IHRoZSBhdXRvY29tcGxldGUgZGl2IGVsZW1lbnQgd2l0aCBzdWdnZXN0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB1cGRhdGUoKTogdm9pZCB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXHJcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1xyXG4gICAgICAgIGxldCByZW5kZXIgPSBmdW5jdGlvbihpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbUVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtRWxlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcclxuICAgICAgICAgICAgcmVuZGVyID0gc2V0dGluZ3MucmVuZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gcmVuZGVyIGF1dG9jb21wbGV0ZSBncm91cHNcclxuICAgICAgICBsZXQgcmVuZGVyR3JvdXAgPSBmdW5jdGlvbihncm91cE5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgICAgIGdyb3VwRGl2LnRleHRDb250ZW50ID0gZ3JvdXBOYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBEaXY7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyR3JvdXApIHtcclxuICAgICAgICAgICAgcmVuZGVyR3JvdXAgPSBzZXR0aW5ncy5yZW5kZXJHcm91cDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICBsZXQgcHJldkdyb3VwID0gXCIjOT8kXCI7XHJcblxyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbTogVCk6IHZvaWQge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5ncm91cCAmJiBpdGVtLmdyb3VwICE9PSBwcmV2R3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHByZXZHcm91cCA9IGl0ZW0uZ3JvdXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cERpdiA9IHJlbmRlckdyb3VwKGl0ZW0uZ3JvdXAsIGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRGl2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBEaXYuY2xhc3NOYW1lICs9IFwiIGdyb3VwXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBEaXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IHJlbmRlcihpdGVtLCBpbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGRpdikge1xyXG4gICAgICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldjogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGl0ZW0sIGlucHV0KTtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgc2VsZWN0ZWRcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eU1zZykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1wdHkgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTmFtZSA9IFwiZW1wdHlcIjtcclxuICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXR0YWNoKCk7XHJcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdXBkYXRlSWZEaXNwbGF5ZWQoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY3JvbGxFdmVudEhhbmRsZXIoZTogRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5dXBFdmVudEhhbmRsZXIoZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xyXG5cclxuICAgICAgICBjb25zdCBpZ25vcmUgPSBbS2V5cy5VcCwgS2V5cy5FbnRlciwgS2V5cy5Fc2MsIEtleXMuUmlnaHQsIEtleXMuTGVmdCwgS2V5cy5TaGlmdCwgS2V5cy5DdHJsLCBLZXlzLkFsdCwgS2V5cy5DYXBzTG9jaywgS2V5cy5XaW5kb3dzS2V5LCBLZXlzLlRhYl07XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaWdub3JlKSB7XHJcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGtleUNvZGUgPj0gS2V5cy5GMSAmJiBrZXlDb2RlIDw9IEtleXMuRjEyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHRoZSBkb3duIGtleSBpcyB1c2VkIHRvIG9wZW4gYXV0b2NvbXBsZXRlXHJcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRG93biAmJiBjb250YWluZXJEaXNwbGF5ZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdGFydEZldGNoKEV2ZW50VHJpZ2dlci5LZXlib2FyZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdXRvbWF0aWNhbGx5IG1vdmUgc2Nyb2xsIGJhciBpZiBzZWxlY3RlZCBpdGVtIGlzIG5vdCB2aXNpYmxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1swXSBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIG1ha2UgZ3JvdXAgdmlzaWJsZVxyXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmIHByZXZpb3VzLmNsYXNzTmFtZS5pbmRleE9mKFwiZ3JvdXBcIikgIT09IC0xICYmICFwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gcHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFRvcCA8IGNvbnRhaW5lci5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdEJvdHRvbSA9IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RCb3R0b20gPiBjb250YWluZXJCb3R0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc2Nyb2xsVG9wICs9IHNlbGVjdEJvdHRvbSAtIGNvbnRhaW5lckJvdHRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZWxlY3RQcmV2KCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbXNbaV0gfHwgaSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBuZXh0IGl0ZW0gaW4gc3VnZ2VzdGlvbnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2VsZWN0TmV4dCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzZWxlY3RlZCB8fCBzZWxlY3RlZCA9PT0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0pIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24ga2V5ZG93bkV2ZW50SGFuZGxlcihldjogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XHJcblxyXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLlVwIHx8IGtleUNvZGUgPT09IEtleXMuRG93biB8fCBrZXlDb2RlID09PSBLZXlzLkVzYykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJc0Rpc3BsYXllZCA9IGNvbnRhaW5lckRpc3BsYXllZCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRXNjKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQgfHwgaXRlbXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtleUNvZGUgPT09IEtleXMuVXBcclxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFByZXYoKVxyXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZWN0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWluZXJJc0Rpc3BsYXllZCkge1xyXG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVudGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBpZiAocHJldmVudFN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmb2N1c0V2ZW50SGFuZGxlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoc2hvd09uRm9jdXMpIHtcclxuICAgICAgICAgICAgc3RhcnRGZXRjaChFdmVudFRyaWdnZXIuRm9jdXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdGFydEZldGNoKHRyaWdnZXI6IEV2ZW50VHJpZ2dlcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGtleXMgd2VyZSBwcmVzc2VkLCBiZWZvcmUgd2UgZ2V0IHVwZGF0ZSBmcm9tIHNlcnZlcixcclxuICAgICAgICAvLyB0aGlzIG1heSBjYXVzZSByZWRyYXdpbmcgb3VyIGF1dG9jb21wbGV0ZSBtdWx0aXBsZSB0aW1lcyBhZnRlciB0aGUgbGFzdCBrZXkgcHJlc3MuXHJcbiAgICAgICAgLy8gdG8gYXZvaWQgdGhpcywgdGhlIG51bWJlciBvZiB0aW1lcyBrZXlib2FyZCB3YXMgcHJlc3NlZCB3aWxsIGJlXHJcbiAgICAgICAgLy8gc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdyBvdXIgYXV0b2NvbXBsZXRlIGJveC5cclxuICAgICAgICBjb25zdCBzYXZlZEtleXByZXNzQ291bnRlciA9ICsra2V5cHJlc3NDb3VudGVyO1xyXG5cclxuICAgICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZTtcclxuICAgICAgICBpZiAodmFsLmxlbmd0aCA+PSBtaW5MZW4gfHwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLkZvY3VzKSB7XHJcbiAgICAgICAgICAgIGNsZWFyRGVib3VuY2VUaW1lcigpO1xyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mZXRjaCh2YWwsIGZ1bmN0aW9uKGVsZW1lbnRzOiBUW10gfCBmYWxzZSk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlwcmVzc0NvdW50ZXIgPT09IHNhdmVkS2V5cHJlc3NDb3VudGVyICYmIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXMubGVuZ3RoID4gMCA/IGl0ZW1zWzBdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBFdmVudFRyaWdnZXIuS2V5Ym9hcmQpO1xyXG4gICAgICAgICAgICB9LCB0cmlnZ2VyID09PSBFdmVudFRyaWdnZXIuS2V5Ym9hcmQgPyBkZWJvdW5jZVdhaXRNcyA6IDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJsdXJFdmVudEhhbmRsZXIoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBjbGVhciwgYmVjYXVzZSB3aGVuIHdlIGNsaWNrIG9uIGFuIGl0ZW0sIGJsdXIgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGNsaWNrIGFuZCByZW1vdmUgaXRlbXMgZnJvbSBET01cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRvYy5hY3RpdmVFbGVtZW50ICE9PSBpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXhlcyAjMjY6IG9uIGxvbmcgY2xpY2tzIGZvY3VzIHdpbGwgYmUgbG9zdCBhbmQgb25TZWxlY3QgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxyXG4gICAgICovXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihldnQ6IEV2ZW50KSB7XHJcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXhlcyAjMzA6IGF1dG9jb21wbGV0ZSBjbG9zZXMgd2hlbiBzY3JvbGxiYXIgaXMgY2xpY2tlZCBpbiBJRVxyXG4gICAgICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTIxMDI2Ny8xMzE3MjM0OVxyXG4gICAgICovXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICgpID0+IGlucHV0LmZvY3VzKCkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBET00gZWxlbWVudHMgYW5kIGNsZWFyIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKGtleVVwRXZlbnROYW1lLCBrZXl1cEV2ZW50SGFuZGxlciBhcyBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTtcclxuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyRXZlbnRIYW5kbGVyKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcbiAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XHJcbiAgICAgICAgY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXR1cCBldmVudCBoYW5kbGVyc1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKGtleVVwRXZlbnROYW1lLCBrZXl1cEV2ZW50SGFuZGxlciBhcyBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTtcclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzRXZlbnRIYW5kbGVyKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUV2ZW50SGFuZGxlcik7XHJcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGVzdHJveVxyXG4gICAgfTtcclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2dldEdyaWQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRTdGF0ZShpZCwgc3RhdGUpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG5cclxuICB0cnkge1xyXG4gICAgb3B0aW9ucy5jb2x1bW5BcGkuYXBwbHlDb2x1bW5TdGF0ZSh7XHJcbiAgICAgIHN0YXRlOiBzdGF0ZS5jb2x1bW5zLFxyXG4gICAgICBhcHBseU9yZGVyOiB0cnVlLFxyXG4gICAgfSlcclxuICAgIG9wdGlvbnMuY29sdW1uQXBpLnNldENvbHVtbkdyb3VwU3RhdGUoc3RhdGUuZ3JvdXBzKVxyXG4gICAgb3B0aW9ucy5hcGkuc2V0RmlsdGVyTW9kZWwoc3RhdGUuZmlsdGVycylcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBncmlkIHN0YXRlIGZyb20gSlNPTicsIGUpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0U3RhdGUoaWQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IGNvbHVtbnMgPSBvcHRpb25zLmNvbHVtbkFwaS5nZXRDb2x1bW5TdGF0ZSgpXHJcbiAgY29uc3QgZ3JvdXBzID0gb3B0aW9ucy5jb2x1bW5BcGkuZ2V0Q29sdW1uR3JvdXBTdGF0ZSgpXHJcbiAgY29uc3QgZmlsdGVycyA9IG9wdGlvbnMuYXBpLmdldEZpbHRlck1vZGVsKClcclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIGNvbHVtbnMsXHJcbiAgICAgIGdyb3VwcyxcclxuICAgICAgZmlsdGVycyxcclxuICAgIH0pXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gY29udmVydCB0aGUgZ3JpZCBzdGF0ZSB0byBqc29uJywgZSlcclxuICB9XHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0U2lkZUJhclZpc2libGUoaWQsIHZhbHVlKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0U2lkZUJhclZpc2libGUoQm9vbGVhbih2YWx1ZSkpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vcGVuVG9vbHBhbmVsKGdyaWRJZCwgdG9vbHBhbmVsSWQpIHtcclxuICBnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9ucy5hcGkub3BlblRvb2xQYW5lbCh0b29scGFuZWxJZClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Nsb3NlVG9vbHBhbmVsKGdyaWRJZCwgdG9vbHBhbmVsSWQpIHtcclxuICBnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9ucy5hcGkuY2xvc2VUb29sUGFuZWwodG9vbHBhbmVsSWQpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRGdW5jdGlvbnNSZWFkT25seShpZCwgcmVhZG9ubHkpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zZXRGdW5jdGlvbnNSZWFkT25seShCb29sZWFuKHJlYWRvbmx5KSlcclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY2xvdWQ+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2dldEdyaWQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRTdGF0dXNiYXJDb21wb25lbnRWaXNpYmlsaXR5KGlkLCBrZXksIHZpc2liaWxpdHkpIHtcclxuICBnd19nZXRHcmlkKGlkKVxyXG4gICAgLm9wdGlvbnMuYXBpLmdldFN0YXR1c1BhbmVsKGtleSlcclxuICAgIC5zZXRWaXNpYmxlKEJvb2xlYW4odmlzaWJpbGl0eSkpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogU2hvdyBsb2FkaW5nIG92ZXJsYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2hvd0xvYWRpbmdPdmVybGF5KGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2hvd0xvYWRpbmdPdmVybGF5KClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3cgJ25vIHJvd3MnIG92ZXJsYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2hvd05vUm93c092ZXJsYXkoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zaG93Tm9Sb3dzT3ZlcmxheSgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhciBhbGwgb3ZlcmxheXNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfaGlkZU92ZXJsYXkoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5oaWRlT3ZlcmxheSgpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNsb3VkPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogVXBkYXRlIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgY29udGV4dCdzIGtleSB0byB1cGRhdGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICBUaGUgbmV3IGNvbnRleHQncyB2YWx1ZVxyXG4gKi9cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGd3X2xlZ2FjeVVwZGF0ZUNvbnRleHQoaWQsIGtleSwgdmFsdWUpIHtcclxuLy8gXHRnd19nZXRHcmlkKGlkKVxyXG4vLyBcdFx0Lm9wdGlvbnNcclxuLy8gXHRcdC5jb250ZXh0W2tleV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuLy8gfVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBjb250ZXh0XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBuZXcgY29udGV4dCBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd191cGRhdGVDb250ZXh0KGlkLCBjb250ZXh0KSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb250ZXh0ID0gY29udGV4dFxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0ICdleHBvc2UtbG9hZGVyP2pzcyFqc3MvanNzLmpzJ1xyXG5pbXBvcnQgeyBnd19nZXREb2N1bWVudCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5cclxuLyoqXHJcbiAqIEFkZCBuZXcgc3R5bGVcclxuICpcclxuICogQWRkIG5ldyBzdHlsZSB0byB0aGUgZG9jdW1lbnRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIGNzcyBzZWxlY3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcnVsZXMgSnNvbiBzdHJpbmcgZm9yIGFuIGFycmF5IG9mIHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0U3R5bGUoc2VsZWN0b3IsIHJ1bGVzKSB7XHJcbiAganNzLmZvckRvY3VtZW50KGd3X2dldERvY3VtZW50KCkpLnNldChzZWxlY3RvciwgSlNPTi5wYXJzZShydWxlcykpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgc3R5bGVcclxuICpcclxuICogUmVtb3ZlIGFkZGVkIHN0eWxlIGZyb20gdGhlcyBkb2N1bWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgY3NzIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVtb3ZlU3R5bGUoc2VsZWN0b3IpIHtcclxuICBqc3MuZm9yRG9jdW1lbnQoZ3dfZ2V0RG9jdW1lbnQoKSkucmVtb3ZlKHNlbGVjdG9yKVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wianNzXCJdID0gcmVxdWlyZShcIi0hRDpcXFxcR2l0aHViXFxcXEJCakdyaWRFeFdpZGdldFxcXFxjbGllbnRcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3JlZi0tNCEuXFxcXGpzcy5qc1wiKTsiLCIvKlxyXG4gKiBKU1MgdjAuNiAtIEphdmFTY3JpcHQgU3R5bGVzaGVldHNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL0JveDkvanNzXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMSwgRGF2aWQgVGFuZ1xyXG4gKiBNSVQgTGljZW5zZWQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKVxyXG4gKi9cclxudmFyIGpzcyA9IChmdW5jdGlvbigpIHtcclxuICAgIHZhciBhZGpTZWxBdHRyUmVnZXggPSAvKCg/OlxcLnwjKVteXFwuXFxzI10rKSgoPzpcXC58IylbXlxcLlxccyNdKykvZztcclxuICAgIHZhciBkb3VibGVDb2xvblBzZXVkb0VsUmVnZXggPSAvKDo6KShiZWZvcmV8YWZ0ZXJ8Zmlyc3QtbGluZXxmaXJzdC1sZXR0ZXJ8c2VsZWN0aW9uKS87XHJcbiAgICB2YXIgc2luZ2xlQ29sb25Qc2V1ZG9FbFJlZ2V4ID0gLyhbXjpdKSg6KShiZWZvcmV8YWZ0ZXJ8Zmlyc3QtbGluZXxmaXJzdC1sZXR0ZXJ8c2VsZWN0aW9uKS87XHJcbiAgICB2YXIgc2luZ2xlQ29sb25Gb3JQc2V1ZG9FbGVtZW50czsgLy8gZmxhZyBmb3Igb2xkZXIgYnJvd3NlcnNcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZWxlY3RvcnNBbmRSdWxlcyhzaGVldCkge1xyXG4gICAgICAgIHZhciBydWxlcyA9IHNoZWV0LmNzc1J1bGVzIHx8IHNoZWV0LnJ1bGVzIHx8IFtdO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBPbGRlciBicm93c2VycyBhbmQgRkYgcmVwb3J0IHBzZXVkbyBlbGVtZW50IHNlbGVjdG9ycyBpbiBhbiBvdXRkYXRlZCBmb3JtYXRcclxuICAgICAgICAgICAgdmFyIHNlbGVjdG9yVGV4dCA9IHRvRG91YmxlQ29sb25Qc2V1ZG9FbGVtZW50cyhydWxlc1tpXS5zZWxlY3RvclRleHQpO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdHNbc2VsZWN0b3JUZXh0XSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0c1tzZWxlY3RvclRleHRdID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0c1tzZWxlY3RvclRleHRdLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgc2hlZXQ6IHNoZWV0LFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICBzdHlsZTogcnVsZXNbaV0uc3R5bGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFJ1bGVzKHNoZWV0LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBydWxlcyA9IHNoZWV0LmNzc1J1bGVzIHx8IHNoZWV0LnJ1bGVzIHx8IFtdO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgLy8gQnJvd3NlcnMgcmVwb3J0IHNlbGVjdG9ycyBpbiBsb3dlcmNhc2VcclxuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JUZXh0ID0gcnVsZXNbaV0uc2VsZWN0b3JUZXh0O1xyXG4gICAgICAgICAgICAvLyBOb3RlIC0gY2VydGFpbiBydWxlcyAoZS5nLiBAcnVsZXMpIGRvbid0IGhhdmUgc2VsZWN0b3JUZXh0XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RvclRleHQgJiYgKHNlbGVjdG9yVGV4dCA9PSBzZWxlY3RvciB8fCBzZWxlY3RvclRleHQgPT0gc3dhcEFkalNlbEF0dHIoc2VsZWN0b3IpIHx8IHNlbGVjdG9yVGV4dCA9PSBzd2FwUHNldWRvRWxTeW50YXgoc2VsZWN0b3IpKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzaGVldDogc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHJ1bGVzW2ldLnN0eWxlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRSdWxlKHNoZWV0LCBzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBydWxlcyA9IHNoZWV0LmNzc1J1bGVzIHx8IHNoZWV0LnJ1bGVzIHx8IFtdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHJ1bGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgcHNldWRvRWxlbWVudFJ1bGUgPSBhZGRQc2V1ZG9FbGVtZW50UnVsZShzaGVldCwgc2VsZWN0b3IsIHJ1bGVzLCBpbmRleCk7XHJcblxyXG4gICAgICAgIGlmICghcHNldWRvRWxlbWVudFJ1bGUpIHtcclxuICAgICAgICAgICAgYWRkUnVsZVRvU2hlZXQoc2hlZXQsIHNlbGVjdG9yLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNoZWV0OiBzaGVldCxcclxuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICBzdHlsZTogcnVsZXNbaW5kZXhdLnN0eWxlXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkUnVsZVRvU2hlZXQoc2hlZXQsIHNlbGVjdG9yLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChzaGVldC5pbnNlcnRSdWxlKSB7XHJcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoc2VsZWN0b3IgKyAnIHsgfScsIGluZGV4KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzaGVldC5hZGRSdWxlKHNlbGVjdG9yLCBudWxsLCBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEhhbmRsZXMgc2luZ2xlIGNvbG9uIHN5bnRheCBmb3Igb2xkZXIgYnJvd3NlcnMgYW5kIGJ1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05NDk2NTFcclxuICAgIGZ1bmN0aW9uIGFkZFBzZXVkb0VsZW1lbnRSdWxlKHNoZWV0LCBzZWxlY3RvciwgcnVsZXMsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGRvdWJsZUNvbG9uU2VsZWN0b3I7XHJcbiAgICAgICAgdmFyIHNpbmdsZUNvbG9uU2VsZWN0b3I7XHJcblxyXG4gICAgICAgIGlmIChkb3VibGVDb2xvblBzZXVkb0VsUmVnZXguZXhlYyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgZG91YmxlQ29sb25TZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICBzaW5nbGVDb2xvblNlbGVjdG9yID0gdG9TaW5nbGVDb2xvblBzZXVkb0VsZW1lbnRzKHNlbGVjdG9yKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNpbmdsZUNvbG9uUHNldWRvRWxSZWdleC5leGVjKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICBkb3VibGVDb2xvblNlbGVjdG9yID0gdG9Eb3VibGVDb2xvblBzZXVkb0VsZW1lbnRzKHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgc2luZ2xlQ29sb25TZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm90IGRlYWxpbmcgd2l0aCBhIHBzZXVkbyBlbGVtZW50XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXNpbmdsZUNvbG9uRm9yUHNldWRvRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgLy8gQXNzdW1lIG1vZGVybiBicm93c2VyIGFuZCB0aGVuIGNoZWNrIGlmIHN1Y2Nlc3NmdWxcclxuICAgICAgICAgICAgYWRkUnVsZVRvU2hlZXQoc2hlZXQsIGRvdWJsZUNvbG9uU2VsZWN0b3IsIGluZGV4KTtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzLmxlbmd0aCA8PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlQ29sb25Gb3JQc2V1ZG9FbGVtZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpbmdsZUNvbG9uRm9yUHNldWRvRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgYWRkUnVsZVRvU2hlZXQoc2hlZXQsIHNpbmdsZUNvbG9uU2VsZWN0b3IsIGluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvRG91YmxlQ29sb25Qc2V1ZG9FbGVtZW50cyhzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKHNpbmdsZUNvbG9uUHNldWRvRWxSZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBzdWJtYXRjaDEsIHN1Ym1hdGNoMiwgc3VibWF0Y2gzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWJtYXRjaDEgKyAnOjonICsgc3VibWF0Y2gzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvU2luZ2xlQ29sb25Qc2V1ZG9FbGVtZW50cyhzZWxlY3Rvcikge1xyXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKGRvdWJsZUNvbG9uUHNldWRvRWxSZWdleCwgZnVuY3Rpb24obWF0Y2gsIHN1Ym1hdGNoMSwgc3VibWF0Y2gyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnOicgKyBzdWJtYXRjaDI7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVSdWxlKHJ1bGUpIHtcclxuICAgICAgICB2YXIgc2hlZXQgPSBydWxlLnNoZWV0O1xyXG4gICAgICAgIGlmIChzaGVldC5kZWxldGVSdWxlKSB7XHJcbiAgICAgICAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUocnVsZS5pbmRleCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzaGVldC5yZW1vdmVSdWxlKSB7XHJcbiAgICAgICAgICAgIHNoZWV0LnJlbW92ZVJ1bGUocnVsZS5pbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XHJcbiAgICAgICAgICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KGtleSkpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVN0eWxlcyhydWxlcykge1xyXG4gICAgICAgIHZhciBhZ2dyZWdhdGUgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChhZ2dyZWdhdGUsIGRlY2xhcmVkUHJvcGVydGllcyhydWxlc1tpXS5zdHlsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWdncmVnYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlY2xhcmVkUHJvcGVydGllcyhzdHlsZSkge1xyXG4gICAgICAgIHZhciBkZWNsYXJlZCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVjbGFyZWRbc3R5bGVbaV1dID0gc3R5bGVbdG9DYW1lbENhc2Uoc3R5bGVbaV0pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlY2xhcmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElFOSBzdG9yZXMgcnVsZXMgd2l0aCBhdHRyaWJ1dGVzIChjbGFzc2VzIG9yIElEJ3MpIGFkamFjZW50IGluIHRoZSBvcHBvc2l0ZSBvcmRlciBhcyBkZWZpbmVkXHJcbiAgICAvLyBjYXVzaW5nIHRoZW0gdG8gbm90IGJlIGZvdW5kLCBzbyB0aGlzIG1ldGhvZCBzd2FwcyBbI3wuXXNlbDFbI3wuXXNlbDIgdG8gYmVjb21lIFsjfC5dc2VsMlsjfC5dc2VsMVxyXG4gICAgZnVuY3Rpb24gc3dhcEFkalNlbEF0dHIoc2VsZWN0b3IpIHtcclxuICAgICAgICB2YXIgc3dhcCA9ICcnO1xyXG4gICAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICB3aGlsZSAoKG1hdGNoID0gYWRqU2VsQXR0clJlZ2V4LmV4ZWMoc2VsZWN0b3IpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFswXSA9PT0gJycpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgc3dhcCArPSBzZWxlY3Rvci5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaC5pbmRleCk7XHJcbiAgICAgICAgICAgIHN3YXAgKz0gc2VsZWN0b3Iuc3Vic3RyKG1hdGNoLmluZGV4ICsgbWF0Y2hbMV0ubGVuZ3RoLCBtYXRjaFsyXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBzd2FwICs9IHNlbGVjdG9yLnN1YnN0cihtYXRjaC5pbmRleCwgbWF0Y2hbMV0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3YXAgKz0gc2VsZWN0b3Iuc3Vic3RyKGxhc3RJbmRleCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHN3YXA7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEZGIGFuZCBvbGRlciBicm93c2VycyBzdG9yZSBydWxlcyB3aXRoIHBzZXVkbyBlbGVtZW50cyB1c2luZyBzaW5nbGUtY29sb24gc3ludGF4XHJcbiAgICBmdW5jdGlvbiBzd2FwUHNldWRvRWxTeW50YXgoc2VsZWN0b3IpIHtcclxuICAgICAgICBpZiAoZG91YmxlQ29sb25Qc2V1ZG9FbFJlZ2V4LmV4ZWMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b1NpbmdsZUNvbG9uUHNldWRvRWxlbWVudHMoc2VsZWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0U3R5bGVQcm9wZXJ0aWVzKHJ1bGUsIHByb3BlcnRpZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wZXJ0aWVzW2tleV07XHJcbiAgICAgICAgICAgIHZhciBpbXBvcnRhbnRJbmRleCA9IHZhbHVlLmluZGV4T2YoJyAhaW1wb3J0YW50Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgc2VlbSB0byBoYW5kbGUgb3ZlcnJpZGVzIGZpbmUsIGJ1dCBJRTkgZG9lc24ndFxyXG4gICAgICAgICAgICBydWxlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7IFxyXG4gICAgICAgICAgICBpZiAoaW1wb3J0YW50SW5kZXggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBydWxlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUuc3Vic3RyKDAsIGltcG9ydGFudEluZGV4KSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcnVsZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uIChtYXRjaCwgc3VibWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1Ym1hdGNoLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtQ2FtZWxDYXNlZFByb3BlcnR5TmFtZXMob2xkUHJvcHMpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2xkUHJvcHMpIHtcclxuICAgICAgICAgICAgbmV3UHJvcHNbdW5DYW1lbENhc2Uoa2V5KV0gPSBvbGRQcm9wc1trZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UHJvcHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW5DYW1lbENhc2Uoc3RyKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKG1hdGNoLCBzdWJtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJy0nICsgc3VibWF0Y2gudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgSnNzID0gZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5kb2MuaGVhZCB8fCB0aGlzLmRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG4gICAgICAgIHRoaXMuc2hlZXRzID0gdGhpcy5kb2Muc3R5bGVTaGVldHMgfHwgW107XHJcbiAgICB9O1xyXG5cclxuICAgIEpzcy5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgLy8gUmV0dXJucyBKU1MgcnVsZXMgKHNlbGVjdG9yIGlzIG9wdGlvbmFsKVxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRTaGVldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZVN0eWxlcyhnZXRSdWxlcyh0aGlzLmRlZmF1bHRTaGVldCwgc2VsZWN0b3IpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBnZXRTZWxlY3RvcnNBbmRSdWxlcyh0aGlzLmRlZmF1bHRTaGVldCk7XHJcbiAgICAgICAgICAgIGZvciAoc2VsZWN0b3IgaW4gcnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzW3NlbGVjdG9yXSA9IGFnZ3JlZ2F0ZVN0eWxlcyhydWxlc1tzZWxlY3Rvcl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFJldHVybnMgYWxsIHJ1bGVzIChzZWxlY3RvciBpcyByZXF1aXJlZClcclxuICAgICAgICBnZXRBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaGVldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChwcm9wZXJ0aWVzLCBhZ2dyZWdhdGVTdHlsZXMoZ2V0UnVsZXModGhpcy5zaGVldHNbaV0sIHNlbGVjdG9yKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQWRkcyBKU1MgcnVsZXMgZm9yIHRoZSBzZWxlY3RvciBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJvcGVydGllc1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24oc2VsZWN0b3IsIHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRTaGVldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2hlZXQgPSB0aGlzLl9jcmVhdGVTaGVldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB0cmFuc2Zvcm1DYW1lbENhc2VkUHJvcGVydHlOYW1lcyhwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gZ2V0UnVsZXModGhpcy5kZWZhdWx0U2hlZXQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVzID0gW2FkZFJ1bGUodGhpcy5kZWZhdWx0U2hlZXQsIHNlbGVjdG9yKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2V0U3R5bGVQcm9wZXJ0aWVzKHJ1bGVzW2ldLCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUmVtb3ZlcyBKU1MgcnVsZXMgKHNlbGVjdG9yIGlzIG9wdGlvbmFsKVxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRTaGVldClcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2hlZXQodGhpcy5kZWZhdWx0U2hlZXQpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGVmYXVsdFNoZWV0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IGdldFJ1bGVzKHRoaXMuZGVmYXVsdFNoZWV0LCBzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVJ1bGUocnVsZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBydWxlcy5sZW5ndGg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfY3JlYXRlU2hlZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGVOb2RlID0gdGhpcy5kb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgc3R5bGVOb2RlLnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgICAgICAgICBzdHlsZU5vZGUucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlTm9kZS5zaGVldDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9yZW1vdmVTaGVldDogZnVuY3Rpb24oc2hlZXQpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzaGVldC5vd25lck5vZGU7XHJcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBleHBvcnRzID0gbmV3IEpzcyhkb2N1bWVudCk7XHJcbiAgICBleHBvcnRzLmZvckRvY3VtZW50ID0gZnVuY3Rpb24oZG9jKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKc3MoZG9jKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufSkoKTtcclxuXHJcbnR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIChtb2R1bGUuZXhwb3J0cyA9IGpzcyk7IC8vIENvbW1vbkpTIHN1cHBvcnQiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vZmxhdHBpY2tyLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxyXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vZmxhdHBpY2tyLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcyEuL2ZsYXRwaWNrci5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IFwiLmZsYXRwaWNrci1jYWxlbmRhciB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIG9wYWNpdHk6IDA7XFxuICBkaXNwbGF5OiBub25lO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgcGFkZGluZzogMDtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBub25lO1xcbiAgICAgICAgICBhbmltYXRpb246IG5vbmU7XFxuICBkaXJlY3Rpb246IGx0cjtcXG4gIGJvcmRlcjogMDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDMwNy44NzVweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC1tcy10b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcXG4gICAgICB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbjtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDFweCAwIDAgI2U2ZTZlNiwgLTFweCAwIDAgI2U2ZTZlNiwgMCAxcHggMCAjZTZlNmU2LCAwIC0xcHggMCAjZTZlNmU2LCAwIDNweCAxM3B4IHJnYmEoMCwwLDAsMC4wOCk7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IDFweCAwIDAgI2U2ZTZlNiwgLTFweCAwIDAgI2U2ZTZlNiwgMCAxcHggMCAjZTZlNmU2LCAwIC0xcHggMCAjZTZlNmU2LCAwIDNweCAxM3B4IHJnYmEoMCwwLDAsMC4wOCk7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIub3BlbixcXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmlubGluZSB7XFxuICBvcGFjaXR5OiAxO1xcbiAgbWF4LWhlaWdodDogNjQwcHg7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLm9wZW4ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgei1pbmRleDogOTk5OTk7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYW5pbWF0ZS5vcGVuIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBmcEZhZGVJbkRvd24gMzAwbXMgY3ViaWMtYmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpO1xcbiAgICAgICAgICBhbmltYXRpb246IGZwRmFkZUluRG93biAzMDBtcyBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuaW5saW5lIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdG9wOiAycHg7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuc3RhdGljIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogY2FsYygxMDAlICsgMnB4KTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5zdGF0aWMub3BlbiB7XFxuICB6LWluZGV4OiA5OTk7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5tdWx0aU1vbnRoIC5mbGF0cGlja3ItZGF5cyAuZGF5Q29udGFpbmVyOm50aC1jaGlsZChuKzEpIC5mbGF0cGlja3ItZGF5LmluUmFuZ2U6bnRoLWNoaWxkKDduKzcpIHtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZSAhaW1wb3J0YW50O1xcbiAgICAgICAgICBib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIubXVsdGlNb250aCAuZmxhdHBpY2tyLWRheXMgLmRheUNvbnRhaW5lcjpudGgtY2hpbGQobisyKSAuZmxhdHBpY2tyLWRheS5pblJhbmdlOm50aC1jaGlsZCg3bisxKSB7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IC0ycHggMCAwICNlNmU2ZTYsIDVweCAwIDAgI2U2ZTZlNjtcXG4gICAgICAgICAgYm94LXNoYWRvdzogLTJweCAwIDAgI2U2ZTZlNiwgNXB4IDAgMCAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyIC5oYXNXZWVrcyAuZGF5Q29udGFpbmVyLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIgLmhhc1RpbWUgLmRheUNvbnRhaW5lciB7XFxuICBib3JkZXItYm90dG9tOiAwO1xcbiAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDA7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAwO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyIC5oYXNXZWVrcyAuZGF5Q29udGFpbmVyIHtcXG4gIGJvcmRlci1sZWZ0OiAwO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmhhc1RpbWUgLmZsYXRwaWNrci10aW1lIHtcXG4gIGhlaWdodDogNDBweDtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLm5vQ2FsZW5kYXIuaGFzVGltZSAuZmxhdHBpY2tyLXRpbWUge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyOmJlZm9yZSxcXG4uZmxhdHBpY2tyLWNhbGVuZGFyOmFmdGVyIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBib3JkZXI6IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgY29udGVudDogJyc7XFxuICBoZWlnaHQ6IDA7XFxuICB3aWR0aDogMDtcXG4gIGxlZnQ6IDIycHg7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIucmlnaHRNb3N0OmJlZm9yZSxcXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93UmlnaHQ6YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIucmlnaHRNb3N0OmFmdGVyLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dSaWdodDphZnRlciB7XFxuICBsZWZ0OiBhdXRvO1xcbiAgcmlnaHQ6IDIycHg7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dDZW50ZXI6YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dDZW50ZXI6YWZ0ZXIge1xcbiAgbGVmdDogNTAlO1xcbiAgcmlnaHQ6IDUwJTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhcjpiZWZvcmUge1xcbiAgYm9yZGVyLXdpZHRoOiA1cHg7XFxuICBtYXJnaW46IDAgLTVweDtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhcjphZnRlciB7XFxuICBib3JkZXItd2lkdGg6IDRweDtcXG4gIG1hcmdpbjogMCAtNHB4O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93VG9wOmJlZm9yZSxcXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93VG9wOmFmdGVyIHtcXG4gIGJvdHRvbTogMTAwJTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd1RvcDpiZWZvcmUge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2U2ZTZlNjtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd1RvcDphZnRlciB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZmZmO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93Qm90dG9tOmJlZm9yZSxcXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93Qm90dG9tOmFmdGVyIHtcXG4gIHRvcDogMTAwJTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd0JvdHRvbTpiZWZvcmUge1xcbiAgYm9yZGVyLXRvcC1jb2xvcjogI2U2ZTZlNjtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd0JvdHRvbTphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjZmZmO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyOmZvY3VzIHtcXG4gIG91dGxpbmU6IDA7XFxufVxcbi5mbGF0cGlja3Itd3JhcHBlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5mbGF0cGlja3ItbW9udGhzIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW1vbnRoIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHJnYmEoMCwwLDAsMC45KTtcXG4gIGZpbGw6IHJnYmEoMCwwLDAsMC45KTtcXG4gIGhlaWdodDogMzRweDtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICAtd2Via2l0LWJveC1mbGV4OiAxO1xcbiAgLXdlYmtpdC1mbGV4OiAxO1xcbiAgICAgIC1tcy1mbGV4OiAxO1xcbiAgICAgICAgICBmbGV4OiAxO1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGgsXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGhlaWdodDogMzRweDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICB6LWluZGV4OiAzO1xcbiAgY29sb3I6IHJnYmEoMCwwLDAsMC45KTtcXG4gIGZpbGw6IHJnYmEoMCwwLDAsMC45KTtcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoLmZsYXRwaWNrci1kaXNhYmxlZCxcXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW5leHQtbW9udGguZmxhdHBpY2tyLWRpc2FibGVkIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItcHJldi1tb250aCBpLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aCBpIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoLmZsYXRwaWNrci1wcmV2LW1vbnRoLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aC5mbGF0cGlja3ItcHJldi1tb250aCB7XFxuLypcXG4gICAgICAvKnJ0bDpiZWdpbjppZ25vcmUqL1xcbi8qXFxuICAgICAgKi9cXG4gIGxlZnQ6IDA7XFxuLypcXG4gICAgICAvKnJ0bDplbmQ6aWdub3JlKi9cXG4vKlxcbiAgICAgICovXFxufVxcbi8qXFxuICAgICAgLypydGw6YmVnaW46aWdub3JlKi9cXG4vKlxcbiAgICAgIC8qcnRsOmVuZDppZ25vcmUqL1xcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItcHJldi1tb250aC5mbGF0cGlja3ItbmV4dC1tb250aCxcXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW5leHQtbW9udGguZmxhdHBpY2tyLW5leHQtbW9udGgge1xcbi8qXFxuICAgICAgLypydGw6YmVnaW46aWdub3JlKi9cXG4vKlxcbiAgICAgICovXFxuICByaWdodDogMDtcXG4vKlxcbiAgICAgIC8qcnRsOmVuZDppZ25vcmUqL1xcbi8qXFxuICAgICAgKi9cXG59XFxuLypcXG4gICAgICAvKnJ0bDpiZWdpbjppZ25vcmUqL1xcbi8qXFxuICAgICAgLypydGw6ZW5kOmlnbm9yZSovXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoOmhvdmVyLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aDpob3ZlciB7XFxuICBjb2xvcjogIzk1OWVhOTtcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoOmhvdmVyIHN2ZyxcXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW5leHQtbW9udGg6aG92ZXIgc3ZnIHtcXG4gIGZpbGw6ICNmNjQ3NDc7XFxufVxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItcHJldi1tb250aCBzdmcsXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoIHN2ZyB7XFxuICB3aWR0aDogMTRweDtcXG4gIGhlaWdodDogMTRweDtcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoIHN2ZyBwYXRoLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aCBzdmcgcGF0aCB7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGZpbGwgMC4xcztcXG4gIHRyYW5zaXRpb246IGZpbGwgMC4xcztcXG4gIGZpbGw6IGluaGVyaXQ7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIGlucHV0LFxcbi5udW1JbnB1dFdyYXBwZXIgc3BhbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgaW5wdXQge1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgaW5wdXQ6Oi1tcy1jbGVhciB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIGlucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxcbi5udW1JbnB1dFdyYXBwZXIgaW5wdXQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xcbiAgbWFyZ2luOiAwO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4ge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB3aWR0aDogMTRweDtcXG4gIHBhZGRpbmc6IDAgNHB4IDAgMnB4O1xcbiAgaGVpZ2h0OiA1MCU7XFxuICBsaW5lLWhlaWdodDogNTAlO1xcbiAgb3BhY2l0eTogMDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoNTcsNTcsNTcsMC4xNSk7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3Bhbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMSk7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3BhbjphY3RpdmUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjIpO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW46YWZ0ZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuLmFycm93VXAge1xcbiAgdG9wOiAwO1xcbiAgYm9yZGVyLWJvdHRvbTogMDtcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuLmFycm93VXA6YWZ0ZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yaWdodDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLWJvdHRvbTogNHB4IHNvbGlkIHJnYmEoNTcsNTcsNTcsMC42KTtcXG4gIHRvcDogMjYlO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dEb3duIHtcXG4gIHRvcDogNTAlO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dEb3duOmFmdGVyIHtcXG4gIGJvcmRlci1sZWZ0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCByZ2JhKDU3LDU3LDU3LDAuNik7XFxuICB0b3A6IDQwJTtcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuIHN2ZyB7XFxuICB3aWR0aDogaW5oZXJpdDtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuIHN2ZyBwYXRoIHtcXG4gIGZpbGw6IHJnYmEoMCwwLDAsMC41KTtcXG59XFxuLm51bUlucHV0V3JhcHBlcjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMDUpO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyOmhvdmVyIHNwYW4ge1xcbiAgb3BhY2l0eTogMTtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIHtcXG4gIGZvbnQtc2l6ZTogMTM1JTtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IDc1JTtcXG4gIGxlZnQ6IDEyLjUlO1xcbiAgcGFkZGluZzogNy40OHB4IDAgMCAwO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBoZWlnaHQ6IDM0cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCk7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBzcGFuLmN1ci1tb250aCB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbi1sZWZ0OiAwLjVjaDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBzcGFuLmN1ci1tb250aDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMDUpO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggLm51bUlucHV0V3JhcHBlciB7XFxuICB3aWR0aDogNmNoO1xcbiAgd2lkdGg6IDdjaFxcXFwwO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggLm51bUlucHV0V3JhcHBlciBzcGFuLmFycm93VXA6YWZ0ZXIge1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogcmdiYSgwLDAsMCwwLjkpO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggLm51bUlucHV0V3JhcHBlciBzcGFuLmFycm93RG93bjphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOiByZ2JhKDAsMCwwLDAuOSk7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBpbnB1dC5jdXIteWVhciB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgY3Vyc29yOiB0ZXh0O1xcbiAgcGFkZGluZzogMCAwIDAgMC41Y2g7XFxuICBtYXJnaW46IDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIGhlaWdodDogYXV0bztcXG4gIGJvcmRlcjogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICB2ZXJ0aWNhbC1hbGlnbjogaW5pdGlhbDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcbiAgLW1vei1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxuICBhcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBpbnB1dC5jdXIteWVhcjpmb2N1cyB7XFxuICBvdXRsaW5lOiAwO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggaW5wdXQuY3VyLXllYXJbZGlzYWJsZWRdLFxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBpbnB1dC5jdXIteWVhcltkaXNhYmxlZF06aG92ZXIge1xcbiAgZm9udC1zaXplOiAxMDAlO1xcbiAgY29sb3I6IHJnYmEoMCwwLDAsMC41KTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzIHtcXG4gIGFwcGVhcmFuY2U6IG1lbnVsaXN0O1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogMzAwO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBtYXJnaW46IC0xcHggMCAwIDA7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgcGFkZGluZzogMCAwIDAgMC41Y2g7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogaW5pdGlhbDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbWVudWxpc3Q7XFxuICAtbW96LWFwcGVhcmFuY2U6IG1lbnVsaXN0O1xcbiAgd2lkdGg6IGF1dG87XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzOmZvY3VzLFxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzOmFjdGl2ZSB7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggLmZsYXRwaWNrci1tb250aERyb3Bkb3duLW1vbnRoczpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMDUpO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGggLmZsYXRwaWNrci1tb250aERyb3Bkb3duLW1vbnRocyAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGgge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBvdXRsaW5lOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLmZsYXRwaWNrci13ZWVrZGF5cyB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgaGVpZ2h0OiAyOHB4O1xcbn1cXG4uZmxhdHBpY2tyLXdlZWtkYXlzIC5mbGF0cGlja3Itd2Vla2RheWNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxuICAtd2Via2l0LWZsZXg6IDE7XFxuICAgICAgLW1zLWZsZXg6IDE7XFxuICAgICAgICAgIGZsZXg6IDE7XFxufVxcbnNwYW4uZmxhdHBpY2tyLXdlZWtkYXkge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgZm9udC1zaXplOiA5MCU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGNvbG9yOiByZ2JhKDAsMCwwLDAuNTQpO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBtYXJnaW46IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxuICAtd2Via2l0LWZsZXg6IDE7XFxuICAgICAgLW1zLWZsZXg6IDE7XFxuICAgICAgICAgIGZsZXg6IDE7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG4uZGF5Q29udGFpbmVyLFxcbi5mbGF0cGlja3Itd2Vla3Mge1xcbiAgcGFkZGluZzogMXB4IDAgMCAwO1xcbn1cXG4uZmxhdHBpY2tyLWRheXMge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IHN0YXJ0O1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gICAgICAtbXMtZmxleC1hbGlnbjogc3RhcnQ7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgd2lkdGg6IDMwNy44NzVweDtcXG59XFxuLmZsYXRwaWNrci1kYXlzOmZvY3VzIHtcXG4gIG91dGxpbmU6IDA7XFxufVxcbi5kYXlDb250YWluZXIge1xcbiAgcGFkZGluZzogMDtcXG4gIG91dGxpbmU6IDA7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgd2lkdGg6IDMwNy44NzVweDtcXG4gIG1pbi13aWR0aDogMzA3Ljg3NXB4O1xcbiAgbWF4LXdpZHRoOiAzMDcuODc1cHg7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIC13ZWJraXQtZmxleC13cmFwOiB3cmFwO1xcbiAgICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAtbXMtZmxleC13cmFwOiB3cmFwO1xcbiAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpO1xcbiAgb3BhY2l0eTogMTtcXG59XFxuLmRheUNvbnRhaW5lciArIC5kYXlDb250YWluZXIge1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAtMXB4IDAgMCAjZTZlNmU2O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAtMXB4IDAgMCAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWRheSB7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmFkaXVzOiAxNTBweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGNvbG9yOiAjMzkzOTM5O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gIHdpZHRoOiAxNC4yODU3MTQzJTtcXG4gIC13ZWJraXQtZmxleC1iYXNpczogMTQuMjg1NzE0MyU7XFxuICAgICAgLW1zLWZsZXgtcHJlZmVycmVkLXNpemU6IDE0LjI4NTcxNDMlO1xcbiAgICAgICAgICBmbGV4LWJhc2lzOiAxNC4yODU3MTQzJTtcXG4gIG1heC13aWR0aDogMzlweDtcXG4gIGhlaWdodDogMzlweDtcXG4gIGxpbmUtaGVpZ2h0OiAzOXB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4uZmxhdHBpY2tyLWRheS5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnByZXZNb250aERheS5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5Lm5leHRNb250aERheS5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnRvZGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkucHJldk1vbnRoRGF5LnRvZGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkubmV4dE1vbnRoRGF5LnRvZGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXk6aG92ZXIsXFxuLmZsYXRwaWNrci1kYXkucHJldk1vbnRoRGF5OmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5Lm5leHRNb250aERheTpob3ZlcixcXG4uZmxhdHBpY2tyLWRheTpmb2N1cyxcXG4uZmxhdHBpY2tyLWRheS5wcmV2TW9udGhEYXk6Zm9jdXMsXFxuLmZsYXRwaWNrci1kYXkubmV4dE1vbnRoRGF5OmZvY3VzIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIG91dGxpbmU6IDA7XFxuICBiYWNrZ3JvdW5kOiAjZTZlNmU2O1xcbiAgYm9yZGVyLWNvbG9yOiAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWRheS50b2RheSB7XFxuICBib3JkZXItY29sb3I6ICM5NTllYTk7XFxufVxcbi5mbGF0cGlja3ItZGF5LnRvZGF5OmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5LnRvZGF5OmZvY3VzIHtcXG4gIGJvcmRlci1jb2xvcjogIzk1OWVhOTtcXG4gIGJhY2tncm91bmQ6ICM5NTllYTk7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZC5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2UuaW5SYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkOmZvY3VzLFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2U6Zm9jdXMsXFxuLmZsYXRwaWNrci1kYXkuZW5kUmFuZ2U6Zm9jdXMsXFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQ6aG92ZXIsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZTpob3ZlcixcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZTpob3ZlcixcXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZC5wcmV2TW9udGhEYXksXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZS5wcmV2TW9udGhEYXksXFxuLmZsYXRwaWNrci1kYXkuZW5kUmFuZ2UucHJldk1vbnRoRGF5LFxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkLm5leHRNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlLm5leHRNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5uZXh0TW9udGhEYXkge1xcbiAgYmFja2dyb3VuZDogIzU2OWZmNztcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgYm9yZGVyLWNvbG9yOiAjNTY5ZmY3O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZC5zdGFydFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2Uuc3RhcnRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5zdGFydFJhbmdlIHtcXG4gIGJvcmRlci1yYWRpdXM6IDUwcHggMCAwIDUwcHg7XFxufVxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkLmVuZFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2UuZW5kUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuZW5kUmFuZ2UuZW5kUmFuZ2Uge1xcbiAgYm9yZGVyLXJhZGl1czogMCA1MHB4IDUwcHggMDtcXG59XFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQuc3RhcnRSYW5nZSArIC5lbmRSYW5nZTpub3QoOm50aC1jaGlsZCg3bisxKSksXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZS5zdGFydFJhbmdlICsgLmVuZFJhbmdlOm5vdCg6bnRoLWNoaWxkKDduKzEpKSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5zdGFydFJhbmdlICsgLmVuZFJhbmdlOm5vdCg6bnRoLWNoaWxkKDduKzEpKSB7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IC0xMHB4IDAgMCAjNTY5ZmY3O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAtMTBweCAwIDAgIzU2OWZmNztcXG59XFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQuc3RhcnRSYW5nZS5lbmRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlLnN0YXJ0UmFuZ2UuZW5kUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuZW5kUmFuZ2Uuc3RhcnRSYW5nZS5lbmRSYW5nZSB7XFxuICBib3JkZXItcmFkaXVzOiA1MHB4O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5pblJhbmdlIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IC01cHggMCAwICNlNmU2ZTYsIDVweCAwIDAgI2U2ZTZlNjtcXG4gICAgICAgICAgYm94LXNoYWRvdzogLTVweCAwIDAgI2U2ZTZlNiwgNXB4IDAgMCAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5mbGF0cGlja3ItZGlzYWJsZWQsXFxuLmZsYXRwaWNrci1kYXkuZmxhdHBpY2tyLWRpc2FibGVkOmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5LnByZXZNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5uZXh0TW9udGhEYXksXFxuLmZsYXRwaWNrci1kYXkubm90QWxsb3dlZCxcXG4uZmxhdHBpY2tyLWRheS5ub3RBbGxvd2VkLnByZXZNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5ub3RBbGxvd2VkLm5leHRNb250aERheSB7XFxuICBjb2xvcjogcmdiYSg1Nyw1Nyw1NywwLjMpO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5mbGF0cGlja3ItZGlzYWJsZWQsXFxuLmZsYXRwaWNrci1kYXkuZmxhdHBpY2tyLWRpc2FibGVkOmhvdmVyIHtcXG4gIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICBjb2xvcjogcmdiYSg1Nyw1Nyw1NywwLjEpO1xcbn1cXG4uZmxhdHBpY2tyLWRheS53ZWVrLnNlbGVjdGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IC01cHggMCAwICM1NjlmZjcsIDVweCAwIDAgIzU2OWZmNztcXG4gICAgICAgICAgYm94LXNoYWRvdzogLTVweCAwIDAgIzU2OWZmNywgNXB4IDAgMCAjNTY5ZmY3O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5oaWRkZW4ge1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG4ucmFuZ2VNb2RlIC5mbGF0cGlja3ItZGF5IHtcXG4gIG1hcmdpbi10b3A6IDFweDtcXG59XFxuLmZsYXRwaWNrci13ZWVrd3JhcHBlciB7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuLmZsYXRwaWNrci13ZWVrd3JhcHBlciAuZmxhdHBpY2tyLXdlZWtzIHtcXG4gIHBhZGRpbmc6IDAgMTJweDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMXB4IDAgMCAjZTZlNmU2O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAxcHggMCAwICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3Itd2Vla3dyYXBwZXIgLmZsYXRwaWNrci13ZWVrZGF5IHtcXG4gIGZsb2F0OiBub25lO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG59XFxuLmZsYXRwaWNrci13ZWVrd3JhcHBlciBzcGFuLmZsYXRwaWNrci1kYXksXFxuLmZsYXRwaWNrci13ZWVrd3JhcHBlciBzcGFuLmZsYXRwaWNrci1kYXk6aG92ZXIge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1heC13aWR0aDogbm9uZTtcXG4gIGNvbG9yOiByZ2JhKDU3LDU3LDU3LDAuMyk7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG4gIGJvcmRlcjogbm9uZTtcXG59XFxuLmZsYXRwaWNrci1pbm5lckNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuLmZsYXRwaWNrci1yQ29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHBhZGRpbmc6IDA7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbi5mbGF0cGlja3ItdGltZSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBvdXRsaW5lOiAwO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBoZWlnaHQ6IDA7XFxuICBsaW5lLWhlaWdodDogNDBweDtcXG4gIG1heC1oZWlnaHQ6IDQwcHg7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbi5mbGF0cGlja3ItdGltZTphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIGRpc3BsYXk6IHRhYmxlO1xcbiAgY2xlYXI6IGJvdGg7XFxufVxcbi5mbGF0cGlja3ItdGltZSAubnVtSW5wdXRXcmFwcGVyIHtcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxuICAtd2Via2l0LWZsZXg6IDE7XFxuICAgICAgLW1zLWZsZXg6IDE7XFxuICAgICAgICAgIGZsZXg6IDE7XFxuICB3aWR0aDogNDAlO1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5mbGF0cGlja3ItdGltZSAubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dVcDphZnRlciB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjMzkzOTM5O1xcbn1cXG4uZmxhdHBpY2tyLXRpbWUgLm51bUlucHV0V3JhcHBlciBzcGFuLmFycm93RG93bjphZnRlciB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjMzkzOTM5O1xcbn1cXG4uZmxhdHBpY2tyLXRpbWUuaGFzU2Vjb25kcyAubnVtSW5wdXRXcmFwcGVyIHtcXG4gIHdpZHRoOiAyNiU7XFxufVxcbi5mbGF0cGlja3ItdGltZS50aW1lMjRociAubnVtSW5wdXRXcmFwcGVyIHtcXG4gIHdpZHRoOiA0OSU7XFxufVxcbi5mbGF0cGlja3ItdGltZSBpbnB1dCB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogbm9uZTtcXG4gICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJvcmRlcjogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgaGVpZ2h0OiBpbmhlcml0O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBjb2xvcjogIzM5MzkzOTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcbiAgLW1vei1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxuICBhcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxufVxcbi5mbGF0cGlja3ItdGltZSBpbnB1dC5mbGF0cGlja3ItaG91ciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLmZsYXRwaWNrci10aW1lIGlucHV0LmZsYXRwaWNrci1taW51dGUsXFxuLmZsYXRwaWNrci10aW1lIGlucHV0LmZsYXRwaWNrci1zZWNvbmQge1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuLmZsYXRwaWNrci10aW1lIGlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IDA7XFxuICBib3JkZXI6IDA7XFxufVxcbi5mbGF0cGlja3ItdGltZSAuZmxhdHBpY2tyLXRpbWUtc2VwYXJhdG9yLFxcbi5mbGF0cGlja3ItdGltZSAuZmxhdHBpY2tyLWFtLXBtIHtcXG4gIGhlaWdodDogaW5oZXJpdDtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBjb2xvcjogIzM5MzkzOTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgd2lkdGg6IDIlO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIC13ZWJraXQtYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LWl0ZW0tYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbn1cXG4uZmxhdHBpY2tyLXRpbWUgLmZsYXRwaWNrci1hbS1wbSB7XFxuICBvdXRsaW5lOiAwO1xcbiAgd2lkdGg6IDE4JTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxufVxcbi5mbGF0cGlja3ItdGltZSBpbnB1dDpob3ZlcixcXG4uZmxhdHBpY2tyLXRpbWUgLmZsYXRwaWNrci1hbS1wbTpob3ZlcixcXG4uZmxhdHBpY2tyLXRpbWUgaW5wdXQ6Zm9jdXMsXFxuLmZsYXRwaWNrci10aW1lIC5mbGF0cGlja3ItYW0tcG06Zm9jdXMge1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG59XFxuLmZsYXRwaWNrci1pbnB1dFtyZWFkb25seV0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5ALXdlYmtpdC1rZXlmcmFtZXMgZnBGYWRlSW5Eb3duIHtcXG4gIGZyb20ge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwcHgsIDApO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgLTIwcHgsIDApO1xcbiAgfVxcbiAgdG8ge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBmcEZhZGVJbkRvd24ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMjBweCwgMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMjBweCwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbiAgfVxcbn1cXG5cIiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9jbGFzc2VzLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxyXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9jbGFzc2VzLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9jbGFzc2VzLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gXCIvKlxcclxcbiogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXFxyXFxuKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jbG91ZD5cXHJcXG4qXFxyXFxuKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxcclxcbiogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXFxyXFxuKi9cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtcmlnaHQsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLXJpZ2h0IC5hZy1jZWxsLXZhbHVlLFxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1yaWdodCAudGVtcGxhdGVSZW5kZXJlciB7XFxyXFxuICB0ZXh0LWFsaWduOiByaWdodDtcXHJcXG4gIC13ZWJraXQtYm94LXBhY2s6IGVuZDtcXHJcXG4gICAgICAtbXMtZmxleC1wYWNrOiBlbmQ7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxyXFxuICAtd2Via2l0LWJveC1mbGV4OiAxO1xcclxcbiAgICAgIC1tcy1mbGV4OiAxO1xcclxcbiAgICAgICAgICBmbGV4OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyLFxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1jZW50ZXIgLmFnLWNlbGwtdmFsdWUsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLWNlbnRlciAudGVtcGxhdGVSZW5kZXJlciB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxyXFxuICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xcclxcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxyXFxuICAgICAgLW1zLWZsZXg6IDE7XFxyXFxuICAgICAgICAgIGZsZXg6IDE7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1yaWdodCAuYm9vbFN3aXRjaCxcXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyIC5ib29sU3dpdGNoIHtcXHJcXG4gIHRleHQtYWxpZ246IGluaXRpYWw7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1jZW50ZXIgLmJvb2xTd2l0Y2hfX3dyYXBwZXIsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLXJpZ2h0IC5ib29sU3dpdGNoX193cmFwcGVyIHtcXHJcXG4gIHdpZHRoOiBhdXRvO1xcclxcbiAgaGVpZ2h0OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyIC5ib29sU3dpdGNoX193cmFwcGVyIHtcXHJcXG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXHJcXG4gICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtcmlnaHQgLmJvb2xTd2l0Y2hfX3dyYXBwZXIge1xcclxcbiAgLXdlYmtpdC1ib3gtcGFjazogcmlnaHQ7XFxyXFxuICAgICAgLW1zLWZsZXgtcGFjazogcmlnaHQ7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogcmlnaHQ7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLXJpZ2h0IC5hZy1oZWFkZXItY2VsbC1sYWJlbCB7XFxyXFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxyXFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IHJldmVyc2U7XFxyXFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXHJcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWhlYWRlci1jZW50ZXIgLmFnLWhlYWRlci1jZWxsLWxhYmVsIHtcXHJcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcclxcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcclxcbiAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXHJcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLWNlbnRlciAuYWctaGVhZGVyLWNlbGwtdGV4dCB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTE2cHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmd3LWFsaWdubWVudC1oZWFkZXItcmlnaHQgLmFnLWNlbGwtbGFiZWwtY29udGFpbmVyLFxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLWNlbnRlciAuYWctY2VsbC1sYWJlbC1jb250YWluZXIge1xcclxcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcclxcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxyXFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxufVxcclxcblxcclxcbi5ndy10b29sdGlwIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAxcztcXHJcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzLjFweDtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMjYwbXM7XFxyXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDI2MG1zO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctdG9vbHRpcC1saWdodCB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDZweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNnB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxyXFxufVxcclxcblxcclxcbi5ndy10b29sdGlwLWRhcmsge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFjMWYyMDtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDZweCAjNWM1YzVjO1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNnB4ICM1YzVjNWM7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblxcclxcbi5hZy1zZWxlY3Rpb24tY2hlY2tib3guYWctaW52aXNpYmxlIHtcXHJcXG4gIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmFnLWNlbGwtd3JhcHBlciB7XFxyXFxuICBoZWlnaHQ6IDEwMCU7XFxyXFxufVxcclxcblwiIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9zdWdnZXN0aW9uLWVkaXRvci5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmhlYWRcclxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vc3VnZ2VzdGlvbi1lZGl0b3IuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcyEuL3N1Z2dlc3Rpb24tZWRpdG9yLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsIm1vZHVsZS5leHBvcnRzID0gXCIuYXV0b2NvbXBsZXRlSW5wdXRXcmFwcGVyX19pbnB1dCB7XFxyXFxuICBwYWRkaW5nLWxlZnQ6IDZweDtcXHJcXG4gIGJvcmRlcjogdGhpbiBzb2xpZCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHJnYmEoMzMsIDE1MCwgMjQzLCAwLjQpKTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IpO1xcclxcbiAgY29sb3I6IGluaGVyaXQ7XFxyXFxuICBvdXRsaW5lOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uYWctdGhlbWUtYWxwaW5lIC5hdXRvY29tcGxldGVJbnB1dFdyYXBwZXJfX2lucHV0LFxcclxcbi5hZy10aGVtZS1iYWxoYW0gLmF1dG9jb21wbGV0ZUlucHV0V3JhcHBlcl9faW5wdXQsXFxyXFxuLmFnLXRoZW1lLW1hdGVyaWFsIC5hdXRvY29tcGxldGVJbnB1dFdyYXBwZXJfX2lucHV0IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICNmZmYpO1xcclxcbn1cXHJcXG5cXHJcXG4uYWctdGhlbWUtYWxwaW5lLWRhcmsgLmF1dG9jb21wbGV0ZUlucHV0V3JhcHBlcl9faW5wdXQsXFxyXFxuLmFnLXRoZW1lLWJhbGhhbS1kYXJrIC5hdXRvY29tcGxldGVJbnB1dFdyYXBwZXJfX2lucHV0IHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICMyZDM0MzYpO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICNmZmYpO1xcclxcbiAgei1pbmRleDogMTAwMDtcXHJcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXHJcXG4gIGJvcmRlcjogdGhpbiBzb2xpZCB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHJnYmEoMzMsIDE1MCwgMjQzLCAwLjQpKTtcXHJcXG4gIGJvcmRlci10b3A6IDA7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxyXFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAwO1xcclxcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDA7XFxyXFxuICBvdmVyZmxvdzogYXV0bztcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMHB4IDNweCAxNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXHJcXG4gICAgICAgICAgYm94LXNoYWRvdzogMHB4IDNweCAxNXB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcXHJcXG59XFxyXFxuXFxyXFxuLmF1dG9jb21wbGV0ZS5kYXJrIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICMyZDM0MzYpO1xcclxcbiAgY29sb3I6IHZhcigtLWFnLWRhdGEtY29sb3IsIHZhcigtLWFnLWZvcmVncm91bmQtY29sb3IsICNmZmYpKTtcXHJcXG59XFxyXFxuXFxyXFxuLmF1dG9jb21wbGV0ZSAuc3VnZ2VzdGlvbi1ncm91cCB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcclxcbiAgcGFkZGluZzogNXB4IDZweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlLmRhcmsgLnN1Z2dlc3Rpb24tZ3JvdXAge1xcclxcbiAgYmFja2dyb3VuZDogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzE4MWQxZik7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUgLnN1Z2dlc3Rpb24taXRlbSB7XFxyXFxuICBwYWRkaW5nOiAxMHB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlIC5zdWdnZXN0aW9uLWl0ZW06aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctcm93LWhvdmVyLWNvbG9yLCByZ2JhKDMzLCAxNTAsIDI0NCwgMC4xKSk7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUgLnN1Z2dlc3Rpb24taXRlbS5zZWxlY3RlZCB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoXFxyXFxuICAgIC0tYWctc2VsZWN0ZWQtcm93LWJhY2tncm91bmQtY29sb3IsXFxyXFxuICAgIHJnYmEoMzMsIDE1MCwgMjQzLCAwLjMpXFxyXFxuICApO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlIC5lbXB0eSB7XFxyXFxuICBwYWRkaW5nOiA4cHggNnB4O1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlLWlucHV0LWVycm9yIHtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAtMnB4IDAgI2U5MWU2MyBpbnNldDtcXHJcXG4gICAgICAgICAgYm94LXNoYWRvdzogMCAtMnB4IDAgI2U5MWU2MyBpbnNldDtcXHJcXG59XFxyXFxuXFxyXFxuLmF1dG9jb21wbGV0ZS1pbnB1dC1zdWNjZXNzIHtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAtMnB4IDAgIzRjYWY1MCBpbnNldDtcXHJcXG4gICAgICAgICAgYm94LXNoYWRvdzogMCAtMnB4IDAgIzRjYWY1MCBpbnNldDtcXHJcXG59XFxyXFxuXCIiXSwic291cmNlUm9vdCI6IiJ9