(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/autocompleter/autocomplete.js":
/*!****************************************************!*\
  !*** ./node_modules/autocompleter/autocomplete.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function () {
  'use strict';
  /*
   * https://github.com/kraaden/autocomplete
   * Copyright (c) 2016 Denys Krasnoshchok
   * MIT License
   */

  function autocomplete(settings) {
    // just an alias to minimize JS file size
    var doc = document;
    var container = doc.createElement("div");
    var containerStyle = container.style;
    var userAgent = navigator.userAgent;
    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;
    var debounceWaitMs = settings.debounceWaitMs || 0;
    var preventSubmit = settings.preventSubmit || false; // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead

    var keyUpEventName = mobileFirefox ? "input" : "keyup";
    var items = [];
    var inputValue = "";
    var minLen = 2;
    var showOnFocus = settings.showOnFocus;
    var selected;
    var keypressCounter = 0;
    var debounceTimer;

    if (settings.minLength !== undefined) {
      minLen = settings.minLength;
    }

    if (!settings.input) {
      throw new Error("input undefined");
    }

    var input = settings.input;
    container.className = "autocomplete " + (settings.className || ""); // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning

    containerStyle.position = "absolute";
    /**
     * Detach the container from DOM
     */

    function detach() {
      var parent = container.parentNode;

      if (parent) {
        parent.removeChild(container);
      }
    }
    /**
     * Clear debouncing timer if assigned
     */


    function clearDebounceTimer() {
      if (debounceTimer) {
        window.clearTimeout(debounceTimer);
      }
    }
    /**
     * Attach the container to DOM
     */


    function attach() {
      if (!container.parentNode) {
        doc.body.appendChild(container);
      }
    }
    /**
     * Check if container for autocomplete is displayed
     */


    function containerDisplayed() {
      return !!container.parentNode;
    }
    /**
     * Clear autocomplete state and hide container
     */


    function clear() {
      // prevent the update call if there are pending AJAX requests
      keypressCounter++;
      items = [];
      inputValue = "";
      selected = undefined;
      detach();
    }
    /**
     * Update autocomplete position
     */


    function updatePosition() {
      if (!containerDisplayed()) {
        return;
      }

      containerStyle.height = "auto";
      containerStyle.width = input.offsetWidth + "px";
      var maxHeight = 0;
      var inputRect;

      function calc() {
        var docEl = doc.documentElement;
        var clientTop = docEl.clientTop || doc.body.clientTop || 0;
        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;
        var scrollTop = window.pageYOffset || docEl.scrollTop;
        var scrollLeft = window.pageXOffset || docEl.scrollLeft;
        inputRect = input.getBoundingClientRect();
        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;
        var left = inputRect.left + scrollLeft - clientLeft;
        containerStyle.top = top + "px";
        containerStyle.left = left + "px";
        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);

        if (maxHeight < 0) {
          maxHeight = 0;
        }

        containerStyle.top = top + "px";
        containerStyle.bottom = "";
        containerStyle.left = left + "px";
        containerStyle.maxHeight = maxHeight + "px";
      } // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)


      calc();
      calc();

      if (settings.customize && inputRect) {
        settings.customize(input, inputRect, container, maxHeight);
      }
    }
    /**
     * Redraw the autocomplete div element with suggestions
     */


    function update() {
      // delete all children from autocomplete DOM container
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      } // function for rendering autocomplete suggestions


      var render = function render(item, currentValue) {
        var itemElement = doc.createElement("div");
        itemElement.textContent = item.label || "";
        return itemElement;
      };

      if (settings.render) {
        render = settings.render;
      } // function to render autocomplete groups


      var renderGroup = function renderGroup(groupName, currentValue) {
        var groupDiv = doc.createElement("div");
        groupDiv.textContent = groupName;
        return groupDiv;
      };

      if (settings.renderGroup) {
        renderGroup = settings.renderGroup;
      }

      var fragment = doc.createDocumentFragment();
      var prevGroup = "#9?$";
      items.forEach(function (item) {
        if (item.group && item.group !== prevGroup) {
          prevGroup = item.group;
          var groupDiv = renderGroup(item.group, inputValue);

          if (groupDiv) {
            groupDiv.className += " group";
            fragment.appendChild(groupDiv);
          }
        }

        var div = render(item, inputValue);

        if (div) {
          div.addEventListener("click", function (ev) {
            settings.onSelect(item, input);
            clear();
            ev.preventDefault();
            ev.stopPropagation();
          });

          if (item === selected) {
            div.className += " selected";
          }

          fragment.appendChild(div);
        }
      });
      container.appendChild(fragment);

      if (items.length < 1) {
        if (settings.emptyMsg) {
          var empty = doc.createElement("div");
          empty.className = "empty";
          empty.textContent = settings.emptyMsg;
          container.appendChild(empty);
        } else {
          clear();
          return;
        }
      }

      attach();
      updatePosition();
      updateScroll();
    }

    function updateIfDisplayed() {
      if (containerDisplayed()) {
        update();
      }
    }

    function resizeEventHandler() {
      updateIfDisplayed();
    }

    function scrollEventHandler(e) {
      if (e.target !== container) {
        updateIfDisplayed();
      } else {
        e.preventDefault();
      }
    }

    function keyupEventHandler(ev) {
      var keyCode = ev.which || ev.keyCode || 0;
      var ignore = [38
      /* Up */
      , 13
      /* Enter */
      , 27
      /* Esc */
      , 39
      /* Right */
      , 37
      /* Left */
      , 16
      /* Shift */
      , 17
      /* Ctrl */
      , 18
      /* Alt */
      , 20
      /* CapsLock */
      , 91
      /* WindowsKey */
      , 9
      /* Tab */
      ];

      for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {
        var key = ignore_1[_i];

        if (keyCode === key) {
          return;
        }
      }

      if (keyCode >= 112
      /* F1 */
      && keyCode <= 123
      /* F12 */
      ) {
          return;
        } // the down key is used to open autocomplete


      if (keyCode === 40
      /* Down */
      && containerDisplayed()) {
        return;
      }

      startFetch(0
      /* Keyboard */
      );
    }
    /**
     * Automatically move scroll bar if selected item is not visible
     */


    function updateScroll() {
      var elements = container.getElementsByClassName("selected");

      if (elements.length > 0) {
        var element = elements[0]; // make group visible

        var previous = element.previousElementSibling;

        if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {
          element = previous;
        }

        if (element.offsetTop < container.scrollTop) {
          container.scrollTop = element.offsetTop;
        } else {
          var selectBottom = element.offsetTop + element.offsetHeight;
          var containerBottom = container.scrollTop + container.offsetHeight;

          if (selectBottom > containerBottom) {
            container.scrollTop += selectBottom - containerBottom;
          }
        }
      }
    }
    /**
     * Select the previous item in suggestions
     */


    function selectPrev() {
      if (items.length < 1) {
        selected = undefined;
      } else {
        if (selected === items[0]) {
          selected = items[items.length - 1];
        } else {
          for (var i = items.length - 1; i > 0; i--) {
            if (selected === items[i] || i === 1) {
              selected = items[i - 1];
              break;
            }
          }
        }
      }
    }
    /**
     * Select the next item in suggestions
     */


    function selectNext() {
      if (items.length < 1) {
        selected = undefined;
      }

      if (!selected || selected === items[items.length - 1]) {
        selected = items[0];
        return;
      }

      for (var i = 0; i < items.length - 1; i++) {
        if (selected === items[i]) {
          selected = items[i + 1];
          break;
        }
      }
    }

    function keydownEventHandler(ev) {
      var keyCode = ev.which || ev.keyCode || 0;

      if (keyCode === 38
      /* Up */
      || keyCode === 40
      /* Down */
      || keyCode === 27
      /* Esc */
      ) {
          var containerIsDisplayed = containerDisplayed();

          if (keyCode === 27
          /* Esc */
          ) {
              clear();
            } else {
            if (!containerDisplayed || items.length < 1) {
              return;
            }

            keyCode === 38
            /* Up */
            ? selectPrev() : selectNext();
            update();
          }

          ev.preventDefault();

          if (containerIsDisplayed) {
            ev.stopPropagation();
          }

          return;
        }

      if (keyCode === 13
      /* Enter */
      ) {
          if (selected) {
            settings.onSelect(selected, input);
            clear();
          }

          if (preventSubmit) {
            ev.preventDefault();
          }
        }
    }

    function focusEventHandler() {
      if (showOnFocus) {
        startFetch(1
        /* Focus */
        );
      }
    }

    function startFetch(trigger) {
      // if multiple keys were pressed, before we get update from server,
      // this may cause redrawing our autocomplete multiple times after the last key press.
      // to avoid this, the number of times keyboard was pressed will be
      // saved and checked before redraw our autocomplete box.
      var savedKeypressCounter = ++keypressCounter;
      var val = input.value;

      if (val.length >= minLen || trigger === 1
      /* Focus */
      ) {
          clearDebounceTimer();
          debounceTimer = window.setTimeout(function () {
            settings.fetch(val, function (elements) {
              if (keypressCounter === savedKeypressCounter && elements) {
                items = elements;
                inputValue = val;
                selected = items.length > 0 ? items[0] : undefined;
                update();
              }
            }, 0
            /* Keyboard */
            );
          }, trigger === 0
          /* Keyboard */
          ? debounceWaitMs : 0);
        } else {
        clear();
      }
    }

    function blurEventHandler() {
      // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM
      setTimeout(function () {
        if (doc.activeElement !== input) {
          clear();
        }
      }, 200);
    }
    /**
     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called
     */


    container.addEventListener("mousedown", function (evt) {
      evt.stopPropagation();
      evt.preventDefault();
    });
    /**
     * Fixes #30: autocomplete closes when scrollbar is clicked in IE
     * See: https://stackoverflow.com/a/9210267/13172349
     */

    container.addEventListener("focus", function () {
      return input.focus();
    });
    /**
     * This function will remove DOM elements and clear event handlers
     */

    function destroy() {
      input.removeEventListener("focus", focusEventHandler);
      input.removeEventListener("keydown", keydownEventHandler);
      input.removeEventListener(keyUpEventName, keyupEventHandler);
      input.removeEventListener("blur", blurEventHandler);
      window.removeEventListener("resize", resizeEventHandler);
      doc.removeEventListener("scroll", scrollEventHandler, true);
      clearDebounceTimer();
      clear();
    } // setup event handlers


    input.addEventListener("keydown", keydownEventHandler);
    input.addEventListener(keyUpEventName, keyupEventHandler);
    input.addEventListener("blur", blurEventHandler);
    input.addEventListener("focus", focusEventHandler);
    window.addEventListener("resize", resizeEventHandler);
    doc.addEventListener("scroll", scrollEventHandler, true);
    return {
      destroy: destroy
    };
  }

  return autocomplete;
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof2(exports)) === 'object' && ( false ? undefined : _typeof2(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 42);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(45);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ];
      /***/
    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = autobind;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var defineProperty = Object.defineProperty,
          getPrototypeOf = Object.getPrototypeOf;
      var mapStore;

      function getBoundSuper(obj, fn) {
        if (typeof WeakMap === 'undefined') {
          throw new Error("Using @autobind on ".concat(fn.name, "() requires WeakMap support due to its use of super.").concat(fn.name, "()\n      See https://github.com/jayphelps/core-decorators.js/issues/20"));
        }

        if (!mapStore) {
          mapStore = new WeakMap();
        }

        if (mapStore.has(obj) === false) {
          mapStore.set(obj, new WeakMap());
        }

        var superStore = mapStore.get(obj);

        if (superStore.has(fn) === false) {
          superStore.set(fn, Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["a"
          /* bind */
          ])(fn, obj));
        }

        return superStore.get(fn);
      }

      function autobindClass(klass) {
        var descs = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["e"
        /* getOwnPropertyDescriptors */
        ])(klass.prototype);
        var keys = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["d"
        /* getOwnKeys */
        ])(descs);

        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          var desc = descs[key];

          if (typeof desc.value !== 'function' || key === 'constructor') {
            continue;
          }

          defineProperty(klass.prototype, key, autobindMethod(klass.prototype, key, desc));
        }
      }

      function autobindMethod(target, key, _ref) {
        var fn = _ref.value,
            configurable = _ref.configurable,
            enumerable = _ref.enumerable;

        if (typeof fn !== 'function') {
          throw new SyntaxError("@autobind can only be used on functions, not: ".concat(fn));
        }

        var constructor = target.constructor;
        return {
          configurable: configurable,
          enumerable: enumerable,
          get: function get() {
            // Class.prototype.key lookup
            // Someone accesses the property directly on the prototype on which it is
            // actually defined on, i.e. Class.prototype.hasOwnProperty(key)
            if (this === target) {
              return fn;
            } // Class.prototype.key lookup
            // Someone accesses the property directly on a prototype but it was found
            // up the chain, not defined directly on it
            // i.e. Class.prototype.hasOwnProperty(key) == false && key in Class.prototype


            if (this.constructor !== constructor && getPrototypeOf(this).constructor === constructor) {
              return fn;
            } // Autobound method calling super.sameMethod() which is also autobound and so on.


            if (this.constructor !== constructor && key in this.constructor.prototype) {
              return getBoundSuper(this, fn);
            }

            var boundFn = Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["a"
            /* bind */
            ])(fn, this);
            defineProperty(this, key, {
              configurable: true,
              writable: true,
              // NOT enumerable when it's a bound method
              enumerable: false,
              value: boundFn
            });
            return boundFn;
          },
          set: Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["b"
          /* createDefaultSetter */
          ])(key)
        };
      }

      function handle(args) {
        if (args.length === 1) {
          return autobindClass.apply(void 0, _toConsumableArray(args));
        } else {
          return autobindMethod.apply(void 0, _toConsumableArray(args));
        }
      }

      function autobind() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 0) {
          return function () {
            return handle(arguments);
          };
        } else {
          return handle(args);
        }
      }
      /***/

    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = override;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var GENERIC_FUNCTION_ERROR = '{child} does not properly override {parent}';
      var FUNCTION_REGEXP = /^function ([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?(\([^\)]*\))[\s\S]+$/;

      var SyntaxErrorReporter = /*#__PURE__*/function () {
        _createClass(SyntaxErrorReporter, [{
          key: "_getTopic",
          value: function _getTopic(descriptor) {
            if (descriptor === undefined) {
              return null;
            }

            if ('value' in descriptor) {
              return descriptor.value;
            }

            if ('get' in descriptor) {
              return descriptor.get;
            }

            if ('set' in descriptor) {
              return descriptor.set;
            }
          }
        }, {
          key: "_extractTopicSignature",
          value: function _extractTopicSignature(topic) {
            switch (_typeof(topic)) {
              case 'function':
                return this._extractFunctionSignature(topic);

              default:
                return this.key;
            }
          }
        }, {
          key: "_extractFunctionSignature",
          value: function _extractFunctionSignature(fn) {
            var _this = this;

            return fn.toString().replace(FUNCTION_REGEXP, function (match) {
              var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.key;
              var params = arguments.length > 2 ? arguments[2] : undefined;
              return name + params;
            });
          }
        }, {
          key: "key",
          get: function get() {
            return this.childDescriptor.key;
          }
        }, {
          key: "parentNotation",
          get: function get() {
            return "".concat(this.parentKlass.constructor.name, "#").concat(this.parentPropertySignature);
          }
        }, {
          key: "childNotation",
          get: function get() {
            return "".concat(this.childKlass.constructor.name, "#").concat(this.childPropertySignature);
          }
        }, {
          key: "parentTopic",
          get: function get() {
            return this._getTopic(this.parentDescriptor);
          }
        }, {
          key: "childTopic",
          get: function get() {
            return this._getTopic(this.childDescriptor);
          }
        }, {
          key: "parentPropertySignature",
          get: function get() {
            return this._extractTopicSignature(this.parentTopic);
          }
        }, {
          key: "childPropertySignature",
          get: function get() {
            return this._extractTopicSignature(this.childTopic);
          }
        }]);

        function SyntaxErrorReporter(parentKlass, childKlass, parentDescriptor, childDescriptor) {
          _classCallCheck(this, SyntaxErrorReporter);

          this.parentKlass = void 0;
          this.childKlass = void 0;
          this.parentDescriptor = void 0;
          this.childDescriptor = void 0;
          this.parentKlass = parentKlass;
          this.childKlass = childKlass;
          this.parentDescriptor = parentDescriptor;
          this.childDescriptor = childDescriptor;
        }

        _createClass(SyntaxErrorReporter, [{
          key: "assert",
          value: function assert(condition) {
            var msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            if (condition !== true) {
              this.error(GENERIC_FUNCTION_ERROR + msg);
            }
          }
        }, {
          key: "error",
          value: function error(msg) {
            var _this2 = this;

            msg = msg // Replace lazily, because they actually might not
            // be available in all cases
            .replace('{parent}', function (m) {
              return _this2.parentNotation;
            }).replace('{child}', function (m) {
              return _this2.childNotation;
            });
            throw new SyntaxError(msg);
          }
        }]);

        return SyntaxErrorReporter;
      }();

      function getDescriptorType(descriptor) {
        if (descriptor.hasOwnProperty('value')) {
          return 'data';
        }

        if (descriptor.hasOwnProperty('get') || descriptor.hasOwnProperty('set')) {
          return 'accessor';
        } // If none of them exist, browsers treat it as
        // a data descriptor with a value of `undefined`


        return 'data';
      }

      function checkFunctionSignatures(parent, child, reporter) {
        reporter.assert(parent.length === child.length);
      }

      function checkDataDescriptors(parent, child, reporter) {
        var parentValueType = _typeof(parent.value);

        var childValueType = _typeof(child.value);

        if (parentValueType === 'undefined' && childValueType === 'undefined') {
          // class properties can be any expression, which isn't ran until the
          // the instance is created, so we can't reliably get type information
          // for them yet (per spec). Perhaps when Babel includes flow-type info
          // in runtime? Tried regex solutions, but super hacky and only feasible
          // on primitives, which is confusing for usage...
          reporter.error("descriptor values are both undefined. (class properties are are not currently supported)'");
        }

        if (parentValueType !== childValueType) {
          var isFunctionOverUndefined = childValueType === 'function' && parentValueType === undefined; // Even though we don't support class properties, this
          // will still handle more than just functions, just in case.
          // Shadowing an undefined value is an error if the inherited
          // value was undefined (usually a class property, not a method)

          if (isFunctionOverUndefined || parentValueType !== undefined) {
            reporter.error("value types do not match. {parent} is \"".concat(parentValueType, "\", {child} is \"").concat(childValueType, "\""));
          }
        } // Switch, in preparation for supporting more types


        switch (childValueType) {
          case 'function':
            checkFunctionSignatures(parent.value, child.value, reporter);
            break;

          default:
            reporter.error("Unexpected error. Please file a bug with: {parent} is \"".concat(parentValueType, "\", {child} is \"").concat(childValueType, "\""));
            break;
        }
      }

      function checkAccessorDescriptors(parent, child, reporter) {
        var parentHasGetter = typeof parent.get === 'function';
        var childHasGetter = typeof child.get === 'function';
        var parentHasSetter = typeof parent.set === 'function';
        var childHasSetter = typeof child.set === 'function';

        if (parentHasGetter || childHasGetter) {
          if (!parentHasGetter && parentHasSetter) {
            reporter.error("{parent} is setter but {child} is getter");
          }

          if (!childHasGetter && childHasSetter) {
            reporter.error("{parent} is getter but {child} is setter");
          }

          checkFunctionSignatures(parent.get, child.get, reporter);
        }

        if (parentHasSetter || childHasSetter) {
          if (!parentHasSetter && parentHasGetter) {
            reporter.error("{parent} is getter but {child} is setter");
          }

          if (!childHasSetter && childHasGetter) {
            reporter.error("{parent} is setter but {child} is getter");
          }

          checkFunctionSignatures(parent.set, child.set, reporter);
        }
      }

      function checkDescriptors(parent, child, reporter) {
        var parentType = getDescriptorType(parent);
        var childType = getDescriptorType(child);

        if (parentType !== childType) {
          reporter.error("descriptor types do not match. {parent} is \"".concat(parentType, "\", {child} is \"").concat(childType, "\""));
        }

        switch (childType) {
          case 'data':
            checkDataDescriptors(parent, child, reporter);
            break;

          case 'accessor':
            checkAccessorDescriptors(parent, child, reporter);
            break;
        }
      }

      var suggestionTransforms = [function (key) {
        return key.toLowerCase();
      }, function (key) {
        return key.toUpperCase();
      }, function (key) {
        return key + 's';
      }, function (key) {
        return key.slice(0, -1);
      }, function (key) {
        return key.slice(1, key.length);
      }];

      function findPossibleAlternatives(superKlass, key) {
        for (var i = 0, l = suggestionTransforms.length; i < l; i++) {
          var fn = suggestionTransforms[i];
          var suggestion = fn(key);

          if (suggestion in superKlass) {
            return suggestion;
          }
        }

        return null;
      }

      function handleDescriptor(target, key, descriptor) {
        descriptor.key = key;
        var superKlass = Object.getPrototypeOf(target);
        var superDescriptor = Object.getOwnPropertyDescriptor(superKlass, key);
        var reporter = new SyntaxErrorReporter(superKlass, target, superDescriptor, descriptor);

        if (superDescriptor === undefined) {
          var suggestedKey = findPossibleAlternatives(superKlass, key);
          var suggestion = suggestedKey ? "\n\n  Did you mean \"".concat(suggestedKey, "\"?") : '';
          reporter.error("No descriptor matching {child} was found on the prototype chain.".concat(suggestion));
        }

        checkDescriptors(superDescriptor, descriptor, reporter);
        return descriptor;
      }

      function override() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 3 */

    /***/
    function (module, exports) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      // css base code, injected by the css-loader
      module.exports = function (useSourceMap) {
        var list = []; // return the list of modules as css string

        list.toString = function toString() {
          return this.map(function (item) {
            var content = cssWithMappingToString(item, useSourceMap);

            if (item[2]) {
              return "@media " + item[2] + "{" + content + "}";
            } else {
              return content;
            }
          }).join("");
        }; // import a list of modules into the list


        list.i = function (modules, mediaQuery) {
          if (typeof modules === "string") modules = [[null, modules, ""]];
          var alreadyImportedModules = {};

          for (var i = 0; i < this.length; i++) {
            var id = this[i][0];
            if (typeof id === "number") alreadyImportedModules[id] = true;
          }

          for (i = 0; i < modules.length; i++) {
            var item = modules[i]; // skip already imported module
            // this implementation is not 100% perfect for weird media query combinations
            //  when a module is imported multiple times with different media queries.
            //  I hope this will never occur (Hey this way we have smaller bundles)

            if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
              if (mediaQuery && !item[2]) {
                item[2] = mediaQuery;
              } else if (mediaQuery) {
                item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
              }

              list.push(item);
            }
          }
        };

        return list;
      };

      function cssWithMappingToString(item, useSourceMap) {
        var content = item[1] || '';
        var cssMapping = item[3];

        if (!cssMapping) {
          return content;
        }

        if (useSourceMap && typeof btoa === 'function') {
          var sourceMapping = toComment(cssMapping);
          var sourceURLs = cssMapping.sources.map(function (source) {
            return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
          });
          return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
        }

        return [content].join('\n');
      } // Adapted from convert-source-map (MIT)


      function toComment(sourceMap) {
        // eslint-disable-next-line no-undef
        var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
        var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
        return '/*# ' + data + ' */';
      }
      /***/

    },
    /* 4 */

    /***/
    function (module, exports, __webpack_require__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */
      var stylesInDom = {};

      var memoize = function memoize(fn) {
        var memo;
        return function () {
          if (typeof memo === "undefined") memo = fn.apply(this, arguments);
          return memo;
        };
      };

      var isOldIE = memoize(function () {
        // Test for IE <= 9 as proposed by Browserhacks
        // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
        // Tests for existence of standard globals is to allow style-loader
        // to operate correctly into non-standard environments
        // @see https://github.com/webpack-contrib/style-loader/issues/177
        return window && document && document.all && !window.atob;
      });

      var getTarget = function getTarget(target) {
        return document.querySelector(target);
      };

      var getElement = function (fn) {
        var memo = {};
        return function (target) {
          // If passing function in options, then use it for resolve "head" element.
          // Useful for Shadow Root style i.e
          // {
          //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
          // }
          if (typeof target === 'function') {
            return target();
          }

          if (typeof memo[target] === "undefined") {
            var styleTarget = getTarget.call(this, target); // Special case to return head of iframe instead of iframe itself

            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
              try {
                // This will throw an exception if access to iframe is blocked
                // due to cross-origin restrictions
                styleTarget = styleTarget.contentDocument.head;
              } catch (e) {
                styleTarget = null;
              }
            }

            memo[target] = styleTarget;
          }

          return memo[target];
        };
      }();

      var singleton = null;
      var singletonCounter = 0;
      var stylesInsertedAtTop = [];

      var fixUrls = __webpack_require__(50);

      module.exports = function (list, options) {
        if (typeof DEBUG !== "undefined" && DEBUG) {
          if ((typeof document === "undefined" ? "undefined" : _typeof2(document)) !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
        }

        options = options || {};
        options.attrs = _typeof2(options.attrs) === "object" ? options.attrs : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
        // tags it will allow on a page

        if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE(); // By default, add <style> tags to the <head> element

        if (!options.insertInto) options.insertInto = "head"; // By default, add <style> tags to the bottom of the target

        if (!options.insertAt) options.insertAt = "bottom";
        var styles = listToStyles(list, options);
        addStylesToDom(styles, options);
        return function update(newList) {
          var mayRemove = [];

          for (var i = 0; i < styles.length; i++) {
            var item = styles[i];
            var domStyle = stylesInDom[item.id];
            domStyle.refs--;
            mayRemove.push(domStyle);
          }

          if (newList) {
            var newStyles = listToStyles(newList, options);
            addStylesToDom(newStyles, options);
          }

          for (var i = 0; i < mayRemove.length; i++) {
            var domStyle = mayRemove[i];

            if (domStyle.refs === 0) {
              for (var j = 0; j < domStyle.parts.length; j++) {
                domStyle.parts[j]();
              }

              delete stylesInDom[domStyle.id];
            }
          }
        };
      };

      function addStylesToDom(styles, options) {
        for (var i = 0; i < styles.length; i++) {
          var item = styles[i];
          var domStyle = stylesInDom[item.id];

          if (domStyle) {
            domStyle.refs++;

            for (var j = 0; j < domStyle.parts.length; j++) {
              domStyle.parts[j](item.parts[j]);
            }

            for (; j < item.parts.length; j++) {
              domStyle.parts.push(addStyle(item.parts[j], options));
            }
          } else {
            var parts = [];

            for (var j = 0; j < item.parts.length; j++) {
              parts.push(addStyle(item.parts[j], options));
            }

            stylesInDom[item.id] = {
              id: item.id,
              refs: 1,
              parts: parts
            };
          }
        }
      }

      function listToStyles(list, options) {
        var styles = [];
        var newStyles = {};

        for (var i = 0; i < list.length; i++) {
          var item = list[i];
          var id = options.base ? item[0] + options.base : item[0];
          var css = item[1];
          var media = item[2];
          var sourceMap = item[3];
          var part = {
            css: css,
            media: media,
            sourceMap: sourceMap
          };
          if (!newStyles[id]) styles.push(newStyles[id] = {
            id: id,
            parts: [part]
          });else newStyles[id].parts.push(part);
        }

        return styles;
      }

      function insertStyleElement(options, style) {
        var target = getElement(options.insertInto);

        if (!target) {
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        }

        var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

        if (options.insertAt === "top") {
          if (!lastStyleElementInsertedAtTop) {
            target.insertBefore(style, target.firstChild);
          } else if (lastStyleElementInsertedAtTop.nextSibling) {
            target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
          } else {
            target.appendChild(style);
          }

          stylesInsertedAtTop.push(style);
        } else if (options.insertAt === "bottom") {
          target.appendChild(style);
        } else if (_typeof2(options.insertAt) === "object" && options.insertAt.before) {
          var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
          target.insertBefore(style, nextSibling);
        } else {
          throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
        }
      }

      function removeStyleElement(style) {
        if (style.parentNode === null) return false;
        style.parentNode.removeChild(style);
        var idx = stylesInsertedAtTop.indexOf(style);

        if (idx >= 0) {
          stylesInsertedAtTop.splice(idx, 1);
        }
      }

      function createStyleElement(options) {
        var style = document.createElement("style");
        options.attrs.type = "text/css";
        addAttrs(style, options.attrs);
        insertStyleElement(options, style);
        return style;
      }

      function createLinkElement(options) {
        var link = document.createElement("link");
        options.attrs.type = "text/css";
        options.attrs.rel = "stylesheet";
        addAttrs(link, options.attrs);
        insertStyleElement(options, link);
        return link;
      }

      function addAttrs(el, attrs) {
        Object.keys(attrs).forEach(function (key) {
          el.setAttribute(key, attrs[key]);
        });
      }

      function addStyle(obj, options) {
        var style, update, remove, result; // If a transform function was defined, run it on the css

        if (options.transform && obj.css) {
          result = options.transform(obj.css);

          if (result) {
            // If transform returns a value, use that instead of the original css.
            // This allows running runtime transformations on the css.
            obj.css = result;
          } else {
            // If the transform function returns a falsy value, don't add this css.
            // This allows conditional loading of css
            return function () {// noop
            };
          }
        }

        if (options.singleton) {
          var styleIndex = singletonCounter++;
          style = singleton || (singleton = createStyleElement(options));
          update = applyToSingletonTag.bind(null, style, styleIndex, false);
          remove = applyToSingletonTag.bind(null, style, styleIndex, true);
        } else if (obj.sourceMap && typeof URL === "function" && typeof URL.createObjectURL === "function" && typeof URL.revokeObjectURL === "function" && typeof Blob === "function" && typeof btoa === "function") {
          style = createLinkElement(options);
          update = updateLink.bind(null, style, options);

          remove = function remove() {
            removeStyleElement(style);
            if (style.href) URL.revokeObjectURL(style.href);
          };
        } else {
          style = createStyleElement(options);
          update = applyToTag.bind(null, style);

          remove = function remove() {
            removeStyleElement(style);
          };
        }

        update(obj);
        return function updateStyle(newObj) {
          if (newObj) {
            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
              return;
            }

            update(obj = newObj);
          } else {
            remove();
          }
        };
      }

      var replaceText = function () {
        var textStore = [];
        return function (index, replacement) {
          textStore[index] = replacement;
          return textStore.filter(Boolean).join('\n');
        };
      }();

      function applyToSingletonTag(style, index, remove, obj) {
        var css = remove ? "" : obj.css;

        if (style.styleSheet) {
          style.styleSheet.cssText = replaceText(index, css);
        } else {
          var cssNode = document.createTextNode(css);
          var childNodes = style.childNodes;
          if (childNodes[index]) style.removeChild(childNodes[index]);

          if (childNodes.length) {
            style.insertBefore(cssNode, childNodes[index]);
          } else {
            style.appendChild(cssNode);
          }
        }
      }

      function applyToTag(style, obj) {
        var css = obj.css;
        var media = obj.media;

        if (media) {
          style.setAttribute("media", media);
        }

        if (style.styleSheet) {
          style.styleSheet.cssText = css;
        } else {
          while (style.firstChild) {
            style.removeChild(style.firstChild);
          }

          style.appendChild(document.createTextNode(css));
        }
      }

      function updateLink(link, options, obj) {
        var css = obj.css;
        var sourceMap = obj.sourceMap;
        /*
        	If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
        	and there is no publicPath defined then lets turn convertToAbsoluteUrls
        	on by default.  Otherwise default to the convertToAbsoluteUrls option
        	directly
        */

        var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

        if (options.convertToAbsoluteUrls || autoFixUrls) {
          css = fixUrls(css);
        }

        if (sourceMap) {
          // http://stackoverflow.com/a/26603875
          css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
        }

        var blob = new Blob([css], {
          type: "text/css"
        });
        var oldSrc = link.href;
        link.href = URL.createObjectURL(blob);
        if (oldSrc) URL.revokeObjectURL(oldSrc);
      }
      /***/

    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getRawTag_js__ = __webpack_require__(72);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__objectToString_js__ = __webpack_require__(73);
      /** `Object#toString` result references. */


      var nullTag = '[object Null]',
          undefinedTag = '[object Undefined]';
      /** Built-in value references. */

      var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].toStringTag : undefined;
      /**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */

      function baseGetTag(value) {
        if (value == null) {
          return value === undefined ? undefinedTag : nullTag;
        }

        return symToStringTag && symToStringTag in Object(value) ? Object(__WEBPACK_IMPORTED_MODULE_1__getRawTag_js__["a"
        /* default */
        ])(value) : Object(__WEBPACK_IMPORTED_MODULE_2__objectToString_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseGetTag;
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */


      function isObjectLike(value) {
        return value != null && _typeof(value) == 'object';
      }
      /* harmony default export */


      __webpack_exports__["a"] = isObjectLike;
      /***/
    },
    /* 7 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export isDescriptor */

      /* harmony export (immutable) */

      __webpack_exports__["c"] = decorate;
      /* unused harmony export metaFor */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "d", function () {
        return getOwnKeys;
      });
      /* harmony export (immutable) */


      __webpack_exports__["e"] = getOwnPropertyDescriptors;
      /* harmony export (immutable) */

      __webpack_exports__["b"] = createDefaultSetter;
      /* harmony export (immutable) */

      __webpack_exports__["a"] = bind;
      /* unused harmony export warn */

      /* unused harmony export internalDeprecation */

      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lazy_initialize__ = __webpack_require__(47);

      var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }

      function _initializerWarningHelper(descriptor, context) {
        throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var defineProperty = Object.defineProperty,
          getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
          getOwnPropertyNames = Object.getOwnPropertyNames,
          getOwnPropertySymbols = Object.getOwnPropertySymbols;

      function isDescriptor(desc) {
        if (!desc || !desc.hasOwnProperty) {
          return false;
        }

        var keys = ['value', 'initializer', 'get', 'set'];

        for (var i = 0, l = keys.length; i < l; i++) {
          if (desc.hasOwnProperty(keys[i])) {
            return true;
          }
        }

        return false;
      }

      function decorate(handleDescriptor, entryArgs) {
        if (isDescriptor(entryArgs[entryArgs.length - 1])) {
          return handleDescriptor.apply(void 0, _toConsumableArray(entryArgs).concat([[]]));
        } else {
          return function () {
            return handleDescriptor.apply(void 0, _toConsumableArray(Array.prototype.slice.call(arguments)).concat([entryArgs]));
          };
        }
      }

      var Meta = (_class = (_temp = function Meta() {
        _classCallCheck(this, Meta);

        _initializerDefineProperty(this, "debounceTimeoutIds", _descriptor, this);

        _initializerDefineProperty(this, "throttleTimeoutIds", _descriptor2, this);

        _initializerDefineProperty(this, "throttlePreviousTimestamps", _descriptor3, this);

        _initializerDefineProperty(this, "throttleTrailingArgs", _descriptor4, this);

        _initializerDefineProperty(this, "profileLastRan", _descriptor5, this);
      }, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "debounceTimeoutIds", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "throttleTimeoutIds", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "throttlePreviousTimestamps", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {};
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "throttleTrailingArgs", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "profileLastRan", [__WEBPACK_IMPORTED_MODULE_0__lazy_initialize__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return null;
        }
      })), _class);
      var META_KEY = typeof Symbol === 'function' ? Symbol('__core_decorators__') : '__core_decorators__';

      function metaFor(obj) {
        if (obj.hasOwnProperty(META_KEY) === false) {
          defineProperty(obj, META_KEY, {
            // Defaults: NOT enumerable, configurable, or writable
            value: new Meta()
          });
        }

        return obj[META_KEY];
      }

      var getOwnKeys = getOwnPropertySymbols ? function (object) {
        return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
      } : getOwnPropertyNames;

      function getOwnPropertyDescriptors(obj) {
        var descs = {};
        getOwnKeys(obj).forEach(function (key) {
          return descs[key] = getOwnPropertyDescriptor(obj, key);
        });
        return descs;
      }

      function createDefaultSetter(key) {
        return function set(newValue) {
          Object.defineProperty(this, key, {
            configurable: true,
            writable: true,
            // IS enumerable when reassigned by the outside word
            enumerable: true,
            value: newValue
          });
          return newValue;
        };
      }

      function bind(fn, context) {
        if (fn.bind) {
          return fn.bind(context);
        } else {
          return function __autobind__() {
            return fn.apply(context, arguments);
          };
        }
      }

      var warn = function () {
        if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== 'object' || !console || typeof console.warn !== 'function') {
          return function () {};
        } else {
          return bind(console.warn, console);
        }
      }();

      var seenDeprecations = {};

      function internalDeprecation(msg) {
        if (seenDeprecations[msg] !== true) {
          seenDeprecations[msg] = true;
          warn('DEPRECATION: ' + msg);
        }
      }
      /***/

    },
    /* 8 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */


      function isObject(value) {
        var type = _typeof(value);

        return value != null && (type == 'object' || type == 'function');
      }
      /* harmony default export */


      __webpack_exports__["a"] = isObject;
      /***/
    },
    /* 9 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
      /** Built-in value references. */


      var _Symbol = __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
      /* default */
      ].Symbol;
      /* harmony default export */

      __webpack_exports__["a"] = _Symbol;
      /***/
    },
    /* 10 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(20);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** Detect free variable `self`. */


      var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
      /** Used as a reference to the global object. */

      var root = __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a"
      /* default */
      ] || freeSelf || Function('return this')();
      /* harmony default export */

      __webpack_exports__["a"] = root;
      /***/
    },
    /* 11 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */

      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      /* harmony default export */


      __webpack_exports__["a"] = eq;
      /***/
    },
    /* 12 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(19);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(26);
      /**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */


      function isArrayLike(value) {
        return value != null && Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a"
        /* default */
        ])(value.length) && !Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = isArrayLike;
      /***/
    },
    /* 13 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toInteger;

      function toInteger(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }

        var number = Number(dirtyNumber);

        if (isNaN(number)) {
          return number;
        }

        return number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      /***/

    },
    /* 14 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = requiredArgs;

      function requiredArgs(required, args) {
        if (args.length < required) {
          throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
        }
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanSwitch__ = __webpack_require__(46);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanSwitch__["a"
      /* default */
      ];
      /***/
    },
    /* 16 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__ = __webpack_require__(65);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 17 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__ = __webpack_require__(18);
      /**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */


      function baseAssignValue(object, key, value) {
        if (key == '__proto__' && __WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a"
        /* default */
        ]) {
          Object(__WEBPACK_IMPORTED_MODULE_0__defineProperty_js__["a"
          /* default */
          ])(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
          });
        } else {
          object[key] = value;
        }
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseAssignValue;
      /***/
    },
    /* 18 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__getNative_js__ = __webpack_require__(70);

      var defineProperty = function () {
        try {
          var func = Object(__WEBPACK_IMPORTED_MODULE_0__getNative_js__["a"
          /* default */
          ])(Object, 'defineProperty');
          func({}, '', {});
          return func;
        } catch (e) {}
      }();
      /* harmony default export */


      __webpack_exports__["a"] = defineProperty;
      /***/
    },
    /* 19 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObject_js__ = __webpack_require__(8);
      /** `Object#toString` result references. */


      var asyncTag = '[object AsyncFunction]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          proxyTag = '[object Proxy]';
      /**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */

      function isFunction(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__isObject_js__["a"
        /* default */
        ])(value)) {
          return false;
        } // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.


        var tag = Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isFunction;
      /***/
    },
    /* 20 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (global) {
        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `global` from Node.js. */


        var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
        /* harmony default export */

        __webpack_exports__["a"] = freeGlobal;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(21));
      /***/
    },
    /* 21 */

    /***/
    function (module, exports) {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        // This works if the window reference is available
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;
      /***/
    },
    /* 22 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__identity_js__ = __webpack_require__(23);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__overRest_js__ = __webpack_require__(79);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__setToString_js__ = __webpack_require__(80);
      /**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */


      function baseRest(func, start) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__setToString_js__["a"
        /* default */
        ])(Object(__WEBPACK_IMPORTED_MODULE_1__overRest_js__["a"
        /* default */
        ])(func, start, __WEBPACK_IMPORTED_MODULE_0__identity_js__["a"
        /* default */
        ]), func + '');
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseRest;
      /***/
    },
    /* 23 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */

      function identity(value) {
        return value;
      }
      /* harmony default export */


      __webpack_exports__["a"] = identity;
      /***/
    },
    /* 24 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */

      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);

          case 1:
            return func.call(thisArg, args[0]);

          case 2:
            return func.call(thisArg, args[0], args[1]);

          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }

        return func.apply(thisArg, args);
      }
      /* harmony default export */


      __webpack_exports__["a"] = apply;
      /***/
    },
    /* 25 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(11);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__ = __webpack_require__(12);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isIndex_js__ = __webpack_require__(27);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isObject_js__ = __webpack_require__(8);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */


      function isIterateeCall(value, index, object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_3__isObject_js__["a"
        /* default */
        ])(object)) {
          return false;
        }

        var type = _typeof(index);

        if (type == 'number' ? Object(__WEBPACK_IMPORTED_MODULE_1__isArrayLike_js__["a"
        /* default */
        ])(object) && Object(__WEBPACK_IMPORTED_MODULE_2__isIndex_js__["a"
        /* default */
        ])(index, object.length) : type == 'string' && index in object) {
          return Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a"
          /* default */
          ])(object[index], value);
        }

        return false;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isIterateeCall;
      /***/
    },
    /* 26 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used as references for various `Number` constants. */

      var MAX_SAFE_INTEGER = 9007199254740991;
      /**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */

      function isLength(value) {
        return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isLength;
      /***/
    },
    /* 27 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** Used as references for various `Number` constants. */


      var MAX_SAFE_INTEGER = 9007199254740991;
      /** Used to detect unsigned integer values. */

      var reIsUint = /^(?:0|[1-9]\d*)$/;
      /**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */

      function isIndex(value, length) {
        var type = _typeof(value);

        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isIndex;
      /***/
    },
    /* 28 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseTimes_js__ = __webpack_require__(85);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isArguments_js__ = __webpack_require__(86);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(29);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isBuffer_js__ = __webpack_require__(88);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__isIndex_js__ = __webpack_require__(27);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__ = __webpack_require__(90);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */

      function arrayLikeKeys(value, inherited) {
        var isArr = Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["a"
        /* default */
        ])(value),
            isArg = !isArr && Object(__WEBPACK_IMPORTED_MODULE_1__isArguments_js__["a"
        /* default */
        ])(value),
            isBuff = !isArr && !isArg && Object(__WEBPACK_IMPORTED_MODULE_3__isBuffer_js__["a"
        /* default */
        ])(value),
            isType = !isArr && !isArg && !isBuff && Object(__WEBPACK_IMPORTED_MODULE_5__isTypedArray_js__["a"
        /* default */
        ])(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? Object(__WEBPACK_IMPORTED_MODULE_0__baseTimes_js__["a"
        /* default */
        ])(value.length, String) : [],
            length = result.length;

        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
          key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
          Object(__WEBPACK_IMPORTED_MODULE_4__isIndex_js__["a"
          /* default */
          ])(key, length)))) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = arrayLikeKeys;
      /***/
    },
    /* 29 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */

      var isArray = Array.isArray;
      /* harmony default export */

      __webpack_exports__["a"] = isArray;
      /***/
    },
    /* 30 */

    /***/
    function (module, exports) {
      module.exports = function (originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule); // module.parent = undefined by default

          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function get() {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function get() {
              return module.i;
            }
          });
          Object.defineProperty(module, "exports", {
            enumerable: true
          });
          module.webpackPolyfill = 1;
        }

        return module;
      };
      /***/

    },
    /* 31 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */

      function isPrototype(value) {
        var Ctor = value && value.constructor,
            proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
        return value === proto;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isPrototype;
      /***/
    },
    /* 32 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isPlainObject_js__ = __webpack_require__(97);
      /** `Object#toString` result references. */


      var domExcTag = '[object DOMException]',
          errorTag = '[object Error]';
      /**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */

      function isError(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value)) {
          return false;
        }

        var tag = Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !Object(__WEBPACK_IMPORTED_MODULE_2__isPlainObject_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = isError;
      /***/
    },
    /* 33 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */

      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = overArg;
      /***/
    },
    /* 34 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */

      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = arrayMap;
      /***/
    },
    /* 35 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reInterpolate = /<%=([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reInterpolate;
      /***/
    },
    /* 36 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseToString_js__ = __webpack_require__(109);
      /**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */


      function toString(value) {
        return value == null ? '' : Object(__WEBPACK_IMPORTED_MODULE_0__baseToString_js__["a"
        /* default */
        ])(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = toString;
      /***/
    },
    /* 37 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = readonly;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      function handleDescriptor(target, key, descriptor) {
        descriptor.writable = false;
        return descriptor;
      }

      function readonly() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 38 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = utcToZonedTime;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__ = __webpack_require__(39);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__ = __webpack_require__(118);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__toDate__ = __webpack_require__(121);
      /**
       * @name utcToZonedTime
       * @category Time Zone Helpers
       * @summary Get a date/time representing local time in a given time zone from the UTC date
       *
       * @description
       * Returns a date instance with values representing the local time in the time zone
       * specified of the UTC time from the date provided. In other words, when the new date
       * is formatted it will show the equivalent hours in the target time zone regardless
       * of the current system time zone.
       *
       * @param {Date|String|Number} date - the date with the relevant UTC time
       * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
       * @returns {Date} the new date with the equivalent time in the time zone
       * @throws {TypeError} 2 arguments required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // In June 10am UTC is 6am in New York (-04:00)
       * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
       * //=> Jun 25 2014 06:00:00
       */


      function utcToZonedTime(dirtyDate, timeZone, options) {
        var date = Object(__WEBPACK_IMPORTED_MODULE_2__toDate__["a"
        /* default */
        ])(dirtyDate, options); // This date has the UTC time values of the input date at the system time zone

        var utcDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()); // We just need to apply the offset indicated by the time zone to this localized date

        var offsetMilliseconds = Object(__WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__["a"
        /* default */
        ])(timeZone, utcDate);
        return offsetMilliseconds ? Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__["a"
        /* default */
        ])(utcDate, offsetMilliseconds) : utcDate;
      }
      /***/

    },
    /* 39 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzParseTimezone;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__ = __webpack_require__(117);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var patterns = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-])(\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
        timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      }; // Parse various time zone offset formats to an offset in milliseconds

      function tzParseTimezone(timezoneString, date) {
        var token;
        var absoluteOffset; // Z

        token = patterns.timezoneZ.exec(timezoneString);

        if (token) {
          return 0;
        }

        var hours; // ±hh

        token = patterns.timezoneHH.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);

          if (!validateTimezone(hours)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // ±hh:mm or ±hhmm


        token = patterns.timezoneHHMM.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);
          var minutes = parseInt(token[3], 10);

          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // IANA time zone


        token = patterns.timezoneIANA.exec(timezoneString);

        if (token) {
          // var [fYear, fMonth, fDay, fHour, fMinute, fSecond] = tzTokenizeDate(date, timezoneString)
          var tokens = Object(__WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__["a"
          /* default */
          ])(date, timezoneString);
          var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3], tokens[4], tokens[5]);
          var timestampWithMsZeroed = date.getTime() - date.getTime() % 1000;
          return -(asUTC - timestampWithMsZeroed);
        }

        return 0;
      }

      function validateTimezone(hours, minutes) {
        if (minutes != null && (minutes < 0 || minutes > 59)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 40 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__EventsMixin__ = __webpack_require__(123);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__EventsMixin__["b"];
      });
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* unused harmony default export */


      var _unused_webpack_default_export = __WEBPACK_IMPORTED_MODULE_0__EventsMixin__["a"
      /* EventsMixin */
      ];
      /***/
    },
    /* 41 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeInput__ = __webpack_require__(124);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeInput__["a"
      /* default */
      ];
      /***/
    },
    /* 42 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__ = __webpack_require__(43);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanRenderer__ = __webpack_require__(51);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__BooleanFilter__ = __webpack_require__(53);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__NumberEditor__ = __webpack_require__(57);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__TextEditor__ = __webpack_require__(61);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__TemplateRenderer__ = __webpack_require__(16);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__ImageRenderer__ = __webpack_require__(113);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__DateTimeFilter__ = __webpack_require__(115);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__DateTimeEditor__ = __webpack_require__(129);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_1__BooleanRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "BooleanFilter", function () {
        return __WEBPACK_IMPORTED_MODULE_2__BooleanFilter__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_3__NumberEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TextEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_4__TextEditor__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TemplateRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_5__TemplateRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "ImageRenderer", function () {
        return __WEBPACK_IMPORTED_MODULE_6__ImageRenderer__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateTimeFilter", function () {
        return __WEBPACK_IMPORTED_MODULE_7__DateTimeFilter__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateTimeEditor", function () {
        return __WEBPACK_IMPORTED_MODULE_8__DateTimeEditor__["a"];
      });
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /***/

    },
    /* 43 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__ = __webpack_require__(44);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 44 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__ = __webpack_require__(15);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Booleans Editor
       *
       * Handle boolean values Editing
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanUsedTrueValue**   | undefined    | the value to return when the editor changes the current cell value to true. in case it is undefined then we use the first item in **booleanTrueValue[]**
       * | **booleanUsedFalseValue**   | undefined    | the value to return when the editor changes the current cell value to false. in case it is undefined then we use the first item in **booleanFalseValue[]**
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanEditor = /*#__PURE__*/function (_Component) {
        _inherits(BooleanEditor, _Component);

        var _super = _createSuper(BooleanEditor);

        function BooleanEditor() {
          _classCallCheck(this, BooleanEditor);

          return _super.apply(this, arguments);
        }

        _createClass(BooleanEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var _this = this;

            if (params.keyPress !== null) {
              this._value = Boolean(params.keyPress);
            } else if (params.charPress !== null) {
              this._value = Boolean(params.charPress);
            }

            this._trueValue = [].concat(this.getOption('booleanTrueValue', params, [true]));
            this._falseValue = [].concat(this.getOption('booleanFalseValue', params, [false]));
            this._returnTrueValue = this.getOption('booleanUsedTrueValue', params, this._trueValue[0]);
            this._returnFalseValue = this.getOption('booleanUsedFalseValue', params, this._falseValue[0]);
            this._trueValue = this._trueValue.map(function (x) {
              return String(x);
            });
            this._falseValue = this._falseValue.map(function (x) {
              return String(x);
            });
            this.focusAfterAttached = params.cellStartedEdit;

            if (this.focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                this._value = false;
              } else if (params.charPress !== null) {
                this._value = params.charPress;
              } else {
                this._value = params.value;
              }
            } else {
              this._value = params.value;
            }

            this._value = this._convertValue(this._value, this._trueValue, this._falseValue);
            this._switcher = new __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__["a"
            /* default */
            ](this._value, function (switcher) {
              _this._value = _this._convertValue(switcher.isChecked(), _this._trueValue, _this._falseValue);
            });

            this._switcher.init(params);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._switcher.getGui();
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._switcher.destroy();
          }
          /**
           * Gets called once after GUI is attached to DOM.
           * Make sure the container is always focused and listening to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (this.focusAfterAttached) {
              this.focusIn();
            }
          }
          /**
           * Get the final value to the grid, the result of the editing
           *
           * @return {Boolean}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._value ? this._returnTrueValue : this._returnFalseValue;
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           *
           * @return {Boolean}
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._switcher.setDisabled(false);

            this._switcher.focus();

            return true;
          }
          /**
           * If doing full row edit, then gets called when tabbing out of the cell.
           *
           * @return {Boolean}
           */

        }, {
          key: "focusOut",
          value: function focusOut() {
            this._switcher.setDisabled(true);

            return true;
          }
          /**
           * @param {Boolean} value the current cell value
           * @param {String|Number} trueValue true value alias
           * @param {String|Number} falseValue false value alias
           */

        }, {
          key: "_convertValue",
          value: function _convertValue(value, trueValue, falseValue) {
            var valueAsString = String(value);
            return trueValue.indexOf(valueAsString) > -1 ? true : falseValue.indexOf(valueAsString) > -1 ? false : value;
          }
        }]);

        return BooleanEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = BooleanEditor;
      /***/
    },
    /* 45 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * The base component class
       *
       * This class is the abstract class which all components should use
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var Component = /*#__PURE__*/function () {
        function Component() {
          _classCallCheck(this, Component);

          this._gui = null;
        }

        _createClass(Component, [{
          key: "init",

          /**
           * Initialize the component
           *
           * @param {Object} params
           *
           * @return void
           */
          // eslint-disable-next-line no-unused-vars
          value: function init(params) {
            console.warn("".concat(this.constructor.name, " does not implement the [init] method"));
          }
          /**
           * Return the DOM element of the component, this is what the grid puts into the cell
           *
           * @return {HTMLElement}
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           * Gets called when the component is destroyed. If your custom component needs to do
           * any resource cleaning up, do it here.
           */

        }, {
          key: "destroy",
          value: function destroy() {// pass
          }
          /**
           * Find the required option value
           *
           * This function will try to find the passed option's value in the following order
           *
           *  1. params
           *  2. Search `params.colDef`
           *  3. Search `params.context.AGridComponentsMetaConfig[COLUMN_ID]` or `params.context.meta[COLUMN_ID]`
           *  4. Search `params.context.AGridComponentsMetaConfig` or `params.context.meta`
           *  5. Search `params.context`
           *  6. If none found return the fallback
           *
           * @param {String} name the name of the option
           * @param {params} params an object used to search for the option
           * @param {String} fallback a value to return in case the option can not be found
           */

        }, {
          key: "getOption",
          value: function getOption(name, params) {
            var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
            var option;

            if (params && params.hasOwnProperty(name) && params[name] !== null) {
              option = params[name];
            } else {
              // try to fetch from the column def first
              if (params.hasOwnProperty('colDef') && params.colDef.hasOwnProperty(name) && params.colDef[name] !== null) {
                option = params.colDef[name];
              } else {
                // try to fetch from AGridComponentsMetaConfig|meta in the context
                var AGridComponentsMetaConfig = null;

                if (params.hasOwnProperty('context')) {
                  AGridComponentsMetaConfig = params.context.AGridComponentsMetaConfig || params.context.meta;
                }

                if (AGridComponentsMetaConfig && AGridComponentsMetaConfig.hasOwnProperty(params.column.colId) && AGridComponentsMetaConfig[params.column.colId].hasOwnProperty(name) && AGridComponentsMetaConfig[params.column.colId][name] !== null) {
                  option = AGridComponentsMetaConfig[params.column.colId][name];
                } else if (AGridComponentsMetaConfig && AGridComponentsMetaConfig.hasOwnProperty(name) && AGridComponentsMetaConfig[name] !== null) {
                  option = AGridComponentsMetaConfig[name];
                } else {
                  // try to fetch from the context object itself
                  var context = params.context;

                  if (context && context.hasOwnProperty(name) && context[name] !== null) {
                    option = context[name];
                  } else {
                    // try to check params itself or fallback to default
                    option = fallback;
                  }
                }
              }
            }

            return typeof option !== 'undefined' ? option : fallback;
          }
          /**
           * Get Window Instance
           *
           * @param {params} params an object used to search for the window instance
           *
           * @return {Window}
           */

        }, {
          key: "getWin",
          value: function getWin(params) {
            var win = this.getOption('window', params) || window || null;

            if (!win) {
              throw new Error('Current environment does not support window');
            }

            return win;
          }
          /**
           * Get document Instance
           *
           * @param {params} params an object used to search for the document instance
           *
           * @return {HTMLDocument}
           */

        }, {
          key: "getDoc",
          value: function getDoc(params) {
            var doc = this.getOption('document', params) || document || null;

            if (!doc) {
              throw new Error('Current environment does not support document');
            }

            return doc;
          }
        }]);

        return Component;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = Component;
      /***/
    },
    /* 46 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(48);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Boolean Renderer
       *
       * Simple toggle switch to handle boolean values
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanSwitch = (_class = /*#__PURE__*/function (_Component) {
        _inherits(BooleanSwitch, _Component);

        var _super = _createSuper(BooleanSwitch);
        /**
         * Construct new BooleanSwitch Component
         *
         * @param {Boolean} [initialValue = false] the default state , checked or unchecked
         * @param {Function} [listener = null] a listener to be called when the state is changed
         */


        function BooleanSwitch() {
          var _this;

          var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          var listener = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          _classCallCheck(this, BooleanSwitch);

          _this = _super.call(this);

          _this.setChecked(initialValue);

          _this.setListener(listener);

          _this.setDisabled(false);

          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(BooleanSwitch, [{
          key: "init",
          value: function init(params) {
            this._params = params;
            this._onClick = this._onClick.bind(this);
            this._onKeydown = this._onKeydown.bind(this);
            this._gui = this.getDoc(params).createElement('div');
            this._gui.className = 'boolSwitch__wrapper';
            this._gui.tabIndex = -1;
            this.render();
          }
          /**
           * Render the switch slider and hidden input.
           */

        }, {
          key: "render",
          value: function render() {
            var doc = this.getDoc(this._params);
            var boolSwitch = document.createElement('div');
            boolSwitch.className = 'boolSwitch'; // input

            this._input = doc.createElement('input');
            this._input.id = "el-".concat(Math.random());
            this._input.name = 'checkbox';
            this._input.className = 'boolSwitch__checkbox';
            this._input.type = 'checkbox';
            this._input.checked = this.isChecked();
            this._input.disabled = this.isDisabled();
            this._input.tabIndex = '0'; // label

            var label = document.createElement('label');
            label.className = 'boolSwitch__label';
            label["for"] = this._input.id;
            label.innerHTML =
            /* html */
            "\n      <span class=\"boolSwitch__inner\"></span>\n      <span class=\"boolSwitch__switch\"></span>\n    "; // attache input and slider to component

            boolSwitch.appendChild(this._input);
            boolSwitch.appendChild(label);
            boolSwitch.addEventListener('click', this._onClick);

            this._gui.addEventListener('keydown', this._onKeydown);

            this._gui.appendChild(boolSwitch);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var boolSwitch = this._gui.querySelector('.boolSwitch');

            boolSwitch.removeEventListener('click', this._onClick);

            this._gui.removeEventListener('keydown', this._onKeydown);
          }
          /**
           * Focus the component
           */

        }, {
          key: "focus",
          value: function focus() {
            this._gui.focus();

            this._input.focus();
          }
          /**
           * Set a listener to be called when the switch state is changed
           *
           * @param {Function} listener
           */

        }, {
          key: "setListener",
          value: function setListener(listener) {
            this._listener = listener;
          }
          /**
           * Get the listener instance , if
           *
           * @return {Function|null}
           */

        }, {
          key: "getListener",
          value: function getListener() {
            return this._listener;
          }
          /**
           * Set checked
           *
           * @param {Boolean} value true to check , false to uncheck
           */

        }, {
          key: "setChecked",
          value: function setChecked(value) {
            this._checked = value;

            if (this._input) {
              this._input.checked = value;
            }
          }
          /**
           * Check the if switch is checked
           *
           * @return {Boolean}  true when checked , false otherwise
           */

        }, {
          key: "isChecked",
          value: function isChecked() {
            return this._checked;
          }
          /**
           * Toggle the component state
           */

        }, {
          key: "toggle",
          value: function toggle() {
            this.setChecked(!this.isChecked());
          }
          /**
           * Set disabled
           *
           * @param {Boolean} value true to disabled , false to enable
           */

        }, {
          key: "setDisabled",
          value: function setDisabled(value) {
            this._disabled = value;

            if (this._input) {
              this._input.disabled = value;
            }
          }
          /**
           * Check if the switch is disabled
           *
           * @return {Boolean} true when disabled , false otherwise
           */

        }, {
          key: "isDisabled",
          value: function isDisabled() {
            return this._disabled;
          }
          /**
           * The default click listener of the switch. It will toggle the state and fire any registered listener
           *
           * @param {Event} e the event object
           *
           * @protected
           */

        }, {
          key: "_onClick",
          value: function _onClick(e) {
            if (this._disabled) {
              return false;
            }

            this.toggle();

            if (this._listener) {
              this._listener(this);
            }
          }
          /**
           * The default key listener of the switch. It will toggle the state using keyboard keys (left , right , space)
           * and fire any registered listener
           *
           * @param {Event} e  the event object
           *
           * @protected
           */

        }, {
          key: "_onKeydown",
          value: function _onKeydown(e) {
            if (this._disabled) {
              return false;
            }

            var key = e.which || e.keyCode; // space

            if (key == 32) {
              this.toggle();

              if (this._listener) {
                this._listener(this);
              }

              e.stopPropagation();
            } // right
            else if (key == 39) {
                this.setChecked(true);

                if (this._listener) {
                  this._listener(this);
                }

                e.stopPropagation();
              } // left
              else if (key == 37) {
                  this.setChecked(false);

                  if (this._listener) {
                    this._listener(this);
                  }

                  e.stopPropagation();
                }
          }
        }]);

        return BooleanSwitch;
      }(__WEBPACK_IMPORTED_MODULE_2__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onKeydown", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onKeydown"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = BooleanSwitch;
      /***/
    },
    /* 47 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = lazyInitialize;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__private_utils__ = __webpack_require__(7);

      var defineProperty = Object.defineProperty;

      function handleDescriptor(target, key, descriptor) {
        var configurable = descriptor.configurable,
            enumerable = descriptor.enumerable,
            initializer = descriptor.initializer,
            value = descriptor.value;
        return {
          configurable: configurable,
          enumerable: enumerable,
          get: function get() {
            // This happens if someone accesses the
            // property directly on the prototype
            if (this === target) {
              return;
            }

            var ret = initializer ? initializer.call(this) : value;
            defineProperty(this, key, {
              configurable: configurable,
              enumerable: enumerable,
              writable: true,
              value: ret
            });
            return ret;
          },
          set: Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["b"
          /* createDefaultSetter */
          ])(key)
        };
      }

      function lazyInitialize() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return Object(__WEBPACK_IMPORTED_MODULE_0__private_utils__["c"
        /* decorate */
        ])(handleDescriptor, args);
      }
      /***/

    },
    /* 48 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(49);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 49 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".ag-cell-inline-editing .boolSwitch__wrapper{margin:auto 11px}.boolSwitch__wrapper{display:flex;width:100%;height:100%;align-items:center;outline:none;padding-left:6px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.boolSwitch{position:relative;width:55px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.boolSwitch__checkbox{display:none}.boolSwitch__label{display:block;overflow:hidden;cursor:pointer;border:2px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:20px}.boolSwitch__inner{display:block;width:200%;margin-left:-100%;transition:margin 0.3s ease-in 0s}.boolSwitch__inner:before,.boolSwitch__inner:after{display:block;float:left;width:50%;height:15px;padding:0;line-height:15px;font-size:14px;color:white;font-family:'Segoe UI Symbol', Trebuchet, Arial, sans-serif;font-weight:bold;box-sizing:border-box}.boolSwitch__inner:before{content:'\\2714';padding-left:10px;background-color:var(--ag-checkbox-checked-color, var(--ag-alpine-active-color, #2196f3));color:#ffffff}.boolSwitch__inner:after{content:'\\2718';padding-right:10px;background-color:var(--ag-background-color);color:var(--ag-input-border-color, var(--ag-border-color, #babfc7));text-align:right}.boolSwitch__switch{display:block;width:18px;margin:1px;background:#ffffff;position:absolute;top:0;bottom:0;right:35px;border:2px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:20px;transition:all 0.3s ease-in 0s}.boolSwitch__checkbox:checked+.boolSwitch__label .boolSwitch__inner{margin-left:0}.boolSwitch__checkbox:checked+.boolSwitch__label .boolSwitch__switch{right:0px}\n", ""]); // exports

      /***/
    },
    /* 50 */

    /***/
    function (module, exports) {
      /**
       * When source maps are enabled, `style-loader` uses a link element with a data-uri to
       * embed the css on the page. This breaks all relative urls because now they are relative to a
       * bundle instead of the current page.
       *
       * One solution is to only use full urls, but that may be impossible.
       *
       * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
       *
       * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
       *
       */
      module.exports = function (css) {
        // get current location
        var location = typeof window !== "undefined" && window.location;

        if (!location) {
          throw new Error("fixUrls requires window.location");
        } // blank or null?


        if (!css || typeof css !== "string") {
          return css;
        }

        var baseUrl = location.protocol + "//" + location.host;
        var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

        /*
        This regular expression is just a way to recursively match brackets within
        a string.
        	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
           (  = Start a capturing group
             (?:  = Start a non-capturing group
                 [^)(]  = Match anything that isn't a parentheses
                 |  = OR
                 \(  = Match a start parentheses
                     (?:  = Start another non-capturing groups
                         [^)(]+  = Match anything that isn't a parentheses
                         |  = OR
                         \(  = Match a start parentheses
                             [^)(]*  = Match anything that isn't a parentheses
                         \)  = Match a end parentheses
                     )  = End Group
                     *\) = Match anything and then a close parens
                 )  = Close non-capturing group
                 *  = Match anything
              )  = Close capturing group
         \)  = Match a close parens
        	 /gi  = Get all matches, not the first.  Be case insensitive.
         */

        var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
          // strip quotes (if they exist)
          var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
            return $1;
          }).replace(/^'(.*)'$/, function (o, $1) {
            return $1;
          }); // already a full url? no change

          if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
            return fullMatch;
          } // convert the url to a full url


          var newUrl;

          if (unquotedOrigUrl.indexOf("//") === 0) {
            //TODO: should we add protocol?
            newUrl = unquotedOrigUrl;
          } else if (unquotedOrigUrl.indexOf("/") === 0) {
            // path should be relative to the base url
            newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
          } else {
            // path should be relative to current directory
            newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
          } // send back the fixed url(...)


          return "url(" + JSON.stringify(newUrl) + ")";
        }); // send back the fixed css

        return fixedCss;
      };
      /***/

    },
    /* 51 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanRenderer__ = __webpack_require__(52);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 52 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__ = __webpack_require__(15);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * Booleans Renderer
       *
       * Handle boolean values Rendering
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanTrueRenderValue**  	| switch      	| The option controls how to render `true` values. <br> **switch** is a special value used to render true values as a switch component  	|
       * | **booleanFalseRenderValue** 	| switch      	| The option controls how to render `false` values. <br> **switch** is a special value used to render true values as a switch component 	|
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`                                                                               	|
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanRenderer = /*#__PURE__*/function (_Component) {
        _inherits(BooleanRenderer, _Component);

        var _super = _createSuper(BooleanRenderer);
        /**
         * Construct new BooleanRenderer
         */


        function BooleanRenderer() {
          var _this;

          _classCallCheck(this, BooleanRenderer);

          _this = _super.call(this); // will this affect BBj bui ?

          _this._gui = document.createElement('span');
          _this._gui.className = 'boolRenderer';
          _this._gui.style.fontFamily = '"Segoe UI Symbol",Trebuchet, Arial, sans-serif';
          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(BooleanRenderer, [{
          key: "init",
          value: function init(params) {
            this.refresh(params, true);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (this._switcher) {
              this._switcher.destroy();
            }
          }
          /**
           * Refresh the cell
           *
           * @param {Object} params cell renderer params
           * @param {Boolean} isInit true when this method is being called in `init` phase , false otherwise
           *
           * @return {Boolean} true if the refresh succeeded, otherwise return false.
           */
          // eslint-disable-next-line no-unused-vars

        }, {
          key: "refresh",
          value: function refresh(params, isInit) {
            var value = params.valueFormatted ? params.valueFormatted : params.value;

            if (value === null || typeof value === 'undefined') {
              this._gui.innerHTML = '';
            } else {
              value = String(value);
              var booleanTrueRenderValue = String(this.getOption('booleanTrueRenderValue', params, 'switch'));
              var booleanFalseRenderValue = String(this.getOption('booleanFalseRenderValue', params, 'switch'));
              var booleanTrueValue = [].concat(this.getOption('booleanTrueValue', params, [true])).map(function (x) {
                return String(x);
              });
              var booleanFalseValue = [].concat(this.getOption('booleanFalseValue', params, [false])).map(function (x) {
                return String(x);
              }); // handle true values

              if (booleanTrueValue.indexOf(value) > -1) {
                if (!booleanTrueRenderValue.length || booleanTrueRenderValue === 'switch') {
                  var switcher = this._getSwitcher(params);

                  switcher.setChecked(true);
                  this._gui.innerHTML = '';

                  this._gui.appendChild(switcher.getGui());
                } else {
                  this._gui.innerHTML = booleanTrueRenderValue;
                }
              } // handle false values
              else if (booleanFalseValue.indexOf(value) > -1) {
                  if (!booleanFalseRenderValue.length || booleanFalseRenderValue === 'switch') {
                    var _switcher = this._getSwitcher(params);

                    _switcher.setChecked(false);

                    this._gui.innerHTML = '';

                    this._gui.appendChild(_switcher.getGui());
                  } else {
                    this._gui.innerHTML = booleanFalseRenderValue;
                  }
                } else {
                  this._gui.innerHTML = value;
                }
            }

            return true;
          }
          /**
           * Get switch instance if available , or create it otherwise
           *
           * @param {Object} params
           *
           * @return {BooleanSwitch} switch instance
           */

        }, {
          key: "_getSwitcher",
          value: function _getSwitcher(params) {
            if (!this._switcher) {
              this._switcher = new __WEBPACK_IMPORTED_MODULE_1__BooleanSwitch__["a"
              /* default */
              ]();

              this._switcher.setDisabled(true);

              this._switcher.init(params);
            }

            return this._switcher;
          }
        }]);

        return BooleanRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = BooleanRenderer;
      /***/
    },
    /* 53 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__BooleanFilter__ = __webpack_require__(54);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__BooleanFilter__["a"
      /* default */
      ];
      /***/
    },
    /* 54 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(55);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var toTitleCase = function toTitleCase(phrase) {
        return phrase.toLowerCase().split(' ').map(function (word) {
          return word.charAt(0).toUpperCase() + word.slice(1);
        }).join(' ');
      };

      var stripHTML = function stripHTML(html) {
        var tmp = document.createElement('DIV');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
      };
      /**
       * Booleans Filter
       *
       * Handle boolean values Filtering
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **booleanUsedTrueValue**   | undefined    | the value to use when the filter displays the true state . in case it is undefined then we use the first item in **booleanTrueValue[]**
       * | **booleanUsedFalseValue**   | undefined    | the value to use when the filter displays the false state. in case it is undefined then we use the first item in **booleanFalseValue[]**
       * | **booleanTrueValue[]**       | true(bool)  	| The options describes what is considered `true`                                                                                	|
       * | **booleanFalseValue[]**      | false(bool) 	| The options describes what is considered `false`
       * | **clearButton**   | false    |  Set to true to have the filter use a Clear button. The Clear button will clear the (form) details of the filter without removing any active filters on the column.
       * | **applyButton**   | false    |  Set to true to have the filter use an Apply button. If the Apply button is present, then the filter is only applied after the user hits the Apply button.
       * | **resetButton**   | false    |  Set to true to have the filter use a Reset button. The Reset button will clear the details of the filter and any active filters on that column.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var BooleanFilter = (_class = (_temp = /*#__PURE__*/function (_Component) {
        _inherits(BooleanFilter, _Component);

        var _super = _createSuper(BooleanFilter);
        /**
         * True , false translation
         *
         * @type {Object}
         */

        /**
         * Construct new BooleanFilter
         */


        function BooleanFilter() {
          var _this;

          _classCallCheck(this, BooleanFilter);

          _this = _super.call(this);
          _this._booleanFilterTranslation = {};
          _this._gui = document.createElement('div');
          _this._gui.className = 'booleanFilter ag-filter-body-wrapper';
          _this._gui.tabIndex = '0';
          return _this;
        }
        /**
         * @inheritDoc
         */


        _createClass(BooleanFilter, [{
          key: "init",
          value: function init(params) {
            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            var isClearFilter = this.getOption('clearButton', params, false);
            var isResetButton = this.getOption('resetButton', params, false);
            var isApplyButton = this.getOption('applyButton', params, false);
            this._trueValue = [].concat(this.getOption('booleanTrueValue', params, [true])).map(function (x) {
              return String(x);
            });
            this._falseValue = [].concat(this.getOption('booleanFalseValue', params, [false])).map(function (x) {
              return String(x);
            });
            this._usedTrueValue = String(this.getOption('booleanUsedTrueValue', params, this._trueValue[0]));
            this._usedFalseValue = String(this.getOption('booleanUsedFalseValue', params, this._falseValue[0]));
            this._booleanFilterTranslation = this.getOption('booleanFilterTranslation', params, {
              "true": translate('booleanTrue', toTitleCase(String(this._usedTrueValue))),
              "false": translate('booleanFalse', toTitleCase(String(this._usedFalseValue))),
              reset: translate('booleanReset', translate('resetFilter', 'Reset Filter'))
            });
            this._params = params;
            this._filterText = null;
            this._onRadioChange = this._onRadioChange.bind(this, isApplyButton); // create body

            var body = document.createElement('div');
            body.className = 'booleanFilter__body ag-filter-body';
            body.style.padding = '5px 15px';
            body.innerHTML =
            /* html */
            "\n      <div class=\"booleanFilter__body__labels\">\n\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n            <div class=\"ag-wrapper-true ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n              <input class=\"true-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"true\"/>              \n          </div> \n          <span>".concat(this._booleanFilterTranslation["true"], "</span>\n        </label>\n\n\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n            <div class=\"ag-wrapper-false ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n              <input class=\"false-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"false\"/>              \n          </div> \n          <span>").concat(this._booleanFilterTranslation["false"], "</span>\n        </label>\n          \n          ").concat(!isResetButton ?
            /* html */
            "\n              <label class=\"ag-input-field-label ag-label ag-radio-button-label\">       \n                  <div class=\"ag-wrapper-reset ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper ag-checked\">\n                    <input class=\"reset-input ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"boolean\" value=\"\" checked/>              \n                </div> \n                <span>".concat(this._booleanFilterTranslation.reset, "</span>\n              </label>                \n              ") : '', "       \n        </div>\n    ");
            body.addEventListener('change', this._onRadioChange);

            this._gui.appendChild(body); // create apply filter panel


            var applyFilterPanel = document.createElement('div');
            applyFilterPanel.className = "booleanFilter__body__applyPanel ag-filter-apply-panel ag-hidden";
            applyFilterPanel.innerHTML =
            /* html */
            "\n      <button class=\"ag-standard-button ag-filter-apply-panel-button clear ".concat(!isClearFilter && 'ag-hidden', "\" type=\"button\">").concat(translate('clearFilter', 'Clear Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button reset ").concat(!isResetButton && 'ag-hidden', "\" type=\"button\">").concat(translate('resetFilter', 'Reset Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button apply ").concat(!isApplyButton && 'ag-hidden', "\" type=\"button\">").concat(translate('applyFilter', 'Apply Filter'), "</button>\n    ");

            if (isClearFilter || isResetButton || isApplyButton) {
              applyFilterPanel.classList.remove('ag-hidden');
            }

            applyFilterPanel.addEventListener('click', this._ApplyFilterPanelButtonClick);

            this._gui.appendChild(applyFilterPanel);
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._gui.querySelector('.booleanFilter__body__labels').removeEventListener('change', this._onRadioChange);

            this._gui.querySelector('.booleanFilter__body__applyPanel').removeEventListener('click', this._ApplyFilterPanelButtonClick);
          }
          /**
           * Check whether selected filter matches the passed cell data
           *
           * @param {Object} params
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "doesFilterPass",
          value: function doesFilterPass(params) {
            // eslint-disable-next-line no-prototype-builtins
            var value = String( // eslint-disable-next-line no-prototype-builtins
            this._params.hasOwnProperty('filterValueGetter') ? this._params.filterValueGetter(params) : this._params.valueGetter(params));
            return this._filterText === 'true' ? this._trueValue.indexOf(value) > -1 : this._falseValue.indexOf(value) > -1;
          }
          /**
           * Check whether the component is applying any filter on the column
           *
           * @return {Boolean}
           **/

        }, {
          key: "isFilterActive",
          value: function isFilterActive() {
            return this._filterText !== null && this._filterText !== undefined && this._filterText !== '';
          }
          /**
           * Gets the filter state. If filter is not active, then should return null/undefined.
           * The grid calls getModel() on all active filters when gridApi.getFilterModel() is called.
           *
           * @return Object | null the filter state
           */

        }, {
          key: "getModel",
          value: function getModel() {
            if (!this.isFilterActive()) {
              return null;
            }

            var model = {
              value: this._filterText,
              filterType: 'boolean'
            };
            return model;
          }
          /**
           * Restores the filter state. Called by the grid after gridApi.setFilterModel(model) is called.
           * The grid will pass undefined/null to clear the filter.
           *
           * @param {Object | null} model
           */

        }, {
          key: "setModel",
          value: function setModel(model) {
            /* eslint-disable no-prototype-builtins */
            this._filterText = model && model.hasOwnProperty('value') ? model.value : '';
            var filterTextAsString = String(this._filterText);

            var body = this._gui.querySelector('.booleanFilter__body');

            body.querySelectorAll('input[type="radio"]').forEach(function (i) {
              if (i.value == filterTextAsString) {
                i.checked = true;
              } else {
                i.checked = false;
              }
            });
          }
          /**
           * Get the filter model as plain string to display in the floating filter input
           *
           * @param {Object | null} model
           */

        }, {
          key: "getModelAsString",
          value: function getModelAsString(model) {
            if (!model) {
              return '';
            }

            return stripHTML(model.value === 'true' ? this._booleanFilterTranslation["true"] : this._booleanFilterTranslation["false"]);
          }
          /**
           * Reset the filter state
           */

        }, {
          key: "reset",
          value: function reset() {
            var body = this._gui.querySelector('.booleanFilter__body');

            body.querySelectorAll('input[type="radio"]').forEach(function (i) {
              i.checked = false;
            });
            body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
            body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

            try {
              body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
            } catch (e) {
              /* pass */
            }

            this._filterText = null;
          }
          /**
           * Listen to selection changes in the filter radio buttons and update the current filter text
           *
           * @param {Event} e
           */

        }, {
          key: "_onRadioChange",
          value: function _onRadioChange(isApplyButton, e) {
            var target = e.target;
            this._filterText = target.value;

            var body = this._gui.querySelector('.booleanFilter__body');

            if (body) {
              if (target.classList.contains('true-input')) {
                body.querySelector('.ag-wrapper-true').classList.add('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
                } catch (e) {
                  /* pass */
                }
              } else if (target.classList.contains('false-input')) {
                body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.add('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.remove('ag-checked');
                } catch (e) {
                  /* pass */
                }
              } else {
                body.querySelector('.ag-wrapper-true').classList.remove('ag-checked');
                body.querySelector('.ag-wrapper-false').classList.remove('ag-checked');

                try {
                  body.querySelector('.ag-wrapper-reset').classList.add('ag-checked');
                } catch (e) {
                  /* pass */
                }
              }
            }

            if (false === isApplyButton) {
              this._params.filterChangedCallback();
            }
          }
          /**
           * Listen to the button clicks in the buttons panel and apply the chosen action
           *
           * @param {Event} e
           */

        }, {
          key: "_ApplyFilterPanelButtonClick",
          value: function _ApplyFilterPanelButtonClick(e) {
            var target = e.target;

            if (target.nodeName === 'BUTTON') {
              if (target.classList.contains('reset')) {
                this.reset();

                this._params.filterChangedCallback();
              } else if (target.classList.contains('clear')) {
                this.reset();
              } else if (target.classList.contains('apply')) {
                this._params.filterChangedCallback();
              }
            }
          }
        }]);

        return BooleanFilter;
      }(__WEBPACK_IMPORTED_MODULE_2__Component__["a"
      /* default */
      ]), _temp), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_ApplyFilterPanelButtonClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_ApplyFilterPanelButtonClick"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = BooleanFilter;
      /***/
    },
    /* 55 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(56);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 56 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".booleanFilter__body__labels label{display:block;padding:6px}.booleanFilter__body__labels label{display:block;padding:6px 0}.booleanFilter__body__labels label span{padding-left:6px}\n", ""]); // exports

      /***/
    },
    /* 57 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberEditor__ = __webpack_require__(58);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 58 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(59);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **numberMinValue**   | undefined    | min allowed value
       * | **numberMaxValue**   | undefined    | max allowed value
       * | **numberStepValue**       | undefined  	| number of step by increment or decrement
       * | **numberMask**       | undefined  	| a bbj number mask to validate the number against
       * |**numberGroupingSeparator** | , | a char which will be used as a grouping separator. The options is used only when **numberMask** is defined |
       * |**numberDecimalSeparator** | . | a char which will be used as a decimal separator. The options is used only when **numberMask** is defined  |
       * |**numberForceTrailingZeros** | false | Affects the output by switching the way a mask with "#" characters in the trailing positions is filled. for example, the function NumberMask.mask(.10:"#.##") returns .10 instead of .1 . The options is used only when **numberMask** is defined|
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberEditor = (_class = /*#__PURE__*/function (_Component) {
        _inherits(NumberEditor, _Component);

        var _super = _createSuper(NumberEditor);

        function NumberEditor() {
          _classCallCheck(this, NumberEditor);

          return _super.apply(this, arguments);
        }

        _createClass(NumberEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var min = this.getOption('numberMinValue', params);
            var max = this.getOption('numberMaxValue', params);
            var step = this.getOption('numberStepValue', params);
            var mask = this.getOption('numberMask', params);
            var startValue;
            this._focusAfterAttached = params.cellStartedEdit;

            if (this._focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                startValue = '';
              } else if (params.charPress) {
                startValue = params.charPress;
              } else {
                startValue = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this._highlightAllOnFocus = true;
                }
              }
            } else {
              startValue = params.value;
            } // make params it accessible from tall methods


            this._params = params; // create the input wrapper

            this._gui = document.createElement('label');
            this._gui.className = 'numberEditor ag-cell-edit-wrapper';
            this._gui.tabIndex = '0';
            this._gui.innerHTML =
            /* html */
            "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // create the input

            this._inputGeneratedId = Math.random().toString(16).slice(2, 10); // generate random id

            this._input = document.createElement('input');
            this._input.className = 'numberEditor__input ag-cell-edit-input';
            this._input.id = "el-".concat(this._inputGeneratedId);
            this._input.type = mask ? 'text' : 'number';
            this._input.value = startValue;
            this._input.tabIndex = 0; // place the input inside the wrapper

            this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

            if (min !== null) {
              mask ? this._input.dataset.min = min : this._input.min = min;
            }

            if (max !== null) {
              mask ? this._input.dataset.max = max : this._input.max = max;
            }

            if (step !== null) {
              mask ? this._input.dataset.step = step : this._input.step = step;
            } // If there is a mask then we use the `Basis.InputMasking.NumberInput`


            if (mask) {
              var groupingSeparator = this.getOption('numberGroupingSeparator', params, this.getOption('numberGroupSep', params));
              var decimalSeparator = this.getOption('numberDecimalSeparator', params, this.getOption('numberDecimalSep', params));
              var forceTrailingZeros = this.getOption('numberForceTrailingZeros', params);

              if (groupingSeparator !== null) {
                this._input.dataset.groupingSeparator = groupingSeparator;
              }

              if (decimalSeparator !== null) {
                this._input.dataset.decimalSeparator = decimalSeparator;
              }

              if (forceTrailingZeros !== null) {
                this._input.dataset.forceTrailingZeros = forceTrailingZeros;
              }

              this._input.dataset.mask = mask;
              this._numberInput = new Basis.InputMasking.NumberInput({
                elements: [this._input],
                // doc: this.getDoc(params),
                onUpdate: this._onNumberInputUpdate,
                onInvalid: this._onNumberInputInvalid
              });
            } else {
              this._input.addEventListener('keydown', this._onInputKeyDownUp);

              this._input.addEventListener('keyup', this._onInputKeyDownUp);

              this._input.addEventListener('change', this._onChange);
            }

            this._gui.addEventListener('keydown', this._onComponentKeyDown); // update `currentValue` the value which this component is managing


            this._currentValue = startValue;
            this.__isMasked__ = mask && mask.length;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (!this.__isMasked__) {
              this._input.removeEventListener('keydown', this._onInputKeyDownUp);

              this._input.removeEventListener('keyup', this._onInputKeyDownUp);

              this._input.removeEventListener('change', this._onChange);
            } else {
              this._numberInput.destroy();
            }

            this._gui.removeEventListener('keydown', this._onComponentKeyDown);
          }
          /**
           * Gets called once after GUI is attached to DOM.
           *
           * Make sure container is always focused to listen to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (!this.__isMasked__) {
              this._validateInput(this._input);
            }

            if (this._highlightAllOnFocus) {
              this._input.select();
            } else {
              if (this._focusAfterAttached) {
                this.focusIn();
              }
            }
          }
          /**
           * Get The component value
           *
           * @return {Number}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            var casted = Number(this._currentValue);
            var retValue = isNaN(casted) ? this._currentValue : casted;
            return this.__isMasked__ ? retValue : this._params.parseValue(retValue);
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            if (!this.__isMasked__) {
              this._input.focus();
            } else {
              this._input.click();
            }
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * Update `currentValue` when the checkbox value is changed
           */

        }, {
          key: "_onChange",
          value: function _onChange(event) {
            var isValid = this._validateInput(event.target);

            if (isValid) {
              this._currentValue = this._input.value;
            }
          }
          /**
           * Update the current value when the NumberInput components fire the update
           * event.
           *
           * @param {String} _masked  the masked value
           * @param {Number} unmasked  the unmasked value
           */

        }, {
          key: "_onNumberInputUpdate",
          value: function _onNumberInputUpdate(_masked, unmasked) {
            this._currentValue = unmasked;
            this.focusIn(); // we pass the last captured event back to the grid to handle it internally

            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * On invalid inputs , update the input with a custom validity message
           *
           * @param {String|Object} error the error message reported by NumberInput
           * @param {HTMLElement} input The input element used instance
           */

        }, {
          key: "_onNumberInputInvalid",
          value: function _onNumberInputInvalid(error, input) {
            this.focusIn(); // restore the original value of the cell

            this._currentValue = this._params.value;

            if (typeof error === 'string') {
              input.setCustomValidity(error);
            } else {
              input.setCustomValidity(error.message);
            }
          }
          /**
           * Capture all keyboard events to allow value processing by the NumberInput component
           *
           * @param {KeyboardEvent} e
           */

        }, {
          key: "_onComponentKeyDown",
          value: function _onComponentKeyDown(e) {
            var key = event.which || event.keyCode;
            var isNavigationKey = key === 37 || // left
            key === 38 || // up
            key === 39 || // right
            key === 40 || // down
            key === 33 || // page up
            key === 34 || // page down
            key === 35 || // page home
            key === 36 || // page end
            key === 13; // enter

            if (isNavigationKey) {
              event.stopPropagation(); // save the last capture key so NumberInput can pass it again to the grid.

              this.__lastComponentKeyboardPress__ = e;
            }
          }
          /**
           * Listen to key changes and validate the input
           *
           * @param {Event} event
           */

        }, {
          key: "_onInputKeyDownUp",
          value: function _onInputKeyDownUp(event) {
            var isValid = this._validateInput(event.target);

            if (!isValid) {
              return;
            }

            var key = event.which || event.keyCode;

            if (key == 38 || key == 40) {
              // top | down
              this._currentValue = this._input.value;
              event.stopPropagation();
            } else if (key == 13 || key === 9) {
              // enter
              this._currentValue = this._input.value;
            } // we pass the last captured event back to the grid to handle it internally


            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * Validate the given input element
           *
           * @param {HTMLInputElement} input input element
           *
           * @return {Boolean} true when valid , false otherwise
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (!isValid) {
              input.classList.add('bbj-mask-error');
              input.classList.remove('bbj-mask-success'); // restore the original value

              this._currentValue = this._params.value;
            } else {
              input.classList.remove('bbj-mask-error');
              input.classList.add('bbj-mask-success');
            }

            return isValid;
          }
        }]);

        return NumberEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onChange", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onNumberInputUpdate", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onNumberInputUpdate"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onNumberInputInvalid", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onNumberInputInvalid"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onComponentKeyDown", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onComponentKeyDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onInputKeyDownUp", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onInputKeyDownUp"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = NumberEditor;
      /***/
    },
    /* 59 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(60);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 60 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".numberEditor{overflow:hidden}.numberEditor .numberInputMask__wrap{width:100%;height:100%;box-sizing:border-box;outline:none;display:block;padding:0;margin:0;display:flex;flex:1 1 auto;align-items:center;line-height:normal;position:relative;overflow:hidden}.numberEditor .bbj-mask-error{box-shadow:0 -2px 0 #e91e63 inset}.numberEditor .bbj-mask-success{box-shadow:0 -2px 0 #4caf50 inset}.numberEditor__input{padding-left:6px;border:thin solid var(--ag-input-focus-border-color, rgba(33,150,243,0.4));border-radius:3px;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .numberEditor__input,.ag-theme-balham .numberEditor__input,.ag-theme-material .numberEditor__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .numberEditor__input,.ag-theme-balham-dark .numberEditor__input{background-color:var(--ag-background-color, #2d3436)}\n", ""]); // exports

      /***/
    },
    /* 61 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextEditor__ = __webpack_require__(62);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TextEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 62 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss__ = __webpack_require__(63);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__style_scss__);

      var _class;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Text Editor
       *
       * Handle text values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **textPattern**   | undefined    | A regular expression that the input's value must match in order for the value to pass constraint validation
       * | **textRequired**   | undefined    | Boolean. A value is required to consider the input valid
       * | **textMask**   | undefined    | A bbj string mask to validate the value
       * | **textTitle**   | null    | The input title , when null and the **textMask** options is defined , then we use the mask as title , when set to `default` we the browser's default title , otherwise the value defined in this option
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TextEditor = (_class = /*#__PURE__*/function (_Component) {
        _inherits(TextEditor, _Component);

        var _super = _createSuper(TextEditor);

        function TextEditor() {
          _classCallCheck(this, TextEditor);

          return _super.apply(this, arguments);
        }

        _createClass(TextEditor, [{
          key: "init",

          /**
           *  @inheritDoc
           */
          value: function init(params) {
            var pattern = this.getOption('textPattern', params);
            var required = this.getOption('textRequired', params);
            var mask = this.getOption('textMask', params);
            var title = this.getOption('textTitle', params);
            var startValue;
            this._focusAfterAttached = params.cellStartedEdit;

            if (this._focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                startValue = '';
              } else if (params.charPress) {
                startValue = params.charPress;
              } else {
                startValue = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this._highlightAllOnFocus = true;
                }
              }
            } else {
              startValue = params.value;
            }

            this._params = params;
            this._gui = document.createElement('div');
            this._gui.className = 'textEditor ag-cell-edit-wrapper';
            this._gui.tabIndex = '0';
            this._gui.innerHTML =
            /* html */
            "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // input

            this._input = document.createElement('input');
            this._input.className = 'textEditor__input ag-cell-edit-input ag-input-field-input ag-text-field-input';
            this._input.id = "el-".concat(Math.random().toString(16).slice(2, 10)); // generate random id

            this._input.type = 'text';
            this._input.value = startValue;
            this._input.tabIndex = 0;

            this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

            if (pattern !== null) {
              this._input.setAttribute('pattern', pattern);
            }

            if (required === true) {
              this._input.setAttribute('required', 'required');
            }

            if (title !== null) {
              if (title !== 'default') {
                this._input.title = title;
              }
            } else if (mask) {
              this._input.title = mask;
            } // If there is a mask then we use the `Basis.InputMasking.TextInput`


            if (mask) {
              this._input.dataset.mask = mask;
              this._textInput = new Basis.InputMasking.TextInput({
                elements: [this._input],
                doc: this.getDoc(params),
                onUpdate: this._onTextInputUpdate,
                onInvalid: this._onTextInputInvalid
              });
            } else {
              this._input.addEventListener('keydown', this._onInputKeyDownUp);

              this._input.addEventListener('keyup', this._onInputKeyDownUp);

              this._input.addEventListener('input', this._onChange);

              this._input.addEventListener('change', this._onChange);
            }

            this._gui.addEventListener('keydown', this._onComponentKeyDown); // update `currentValue` the value which this component is managing


            this._currentValue = startValue;
            this.__isMasked__ = mask && mask.length;
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            if (!this.__isMasked__) {
              this._input.removeEventListener('keydown', this._onInputKeyDownUp);

              this._input.removeEventListener('keyup', this._onInputKeyDownUp);

              this._input.removeEventListener('input', this._onChange);

              this._input.removeEventListener('change', this._onChange);
            } else {
              this._textInput.destroy();
            }

            this._gui.removeEventListener('keydown', this._onComponentKeyDown);
          }
          /**
           * Gets called once after GUI is attached to DOM.
           *
           * Make sure container is always focused to listen to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (!this.__isMasked__) {
              this._validateInput(this._input);
            }

            if (this._highlightAllOnFocus) {
              this._input.select();
            } else {
              if (this._focusAfterAttached) {
                this.focusIn();
              }
            }
          }
          /**
           * Get The component value
           *
           * @return {Number}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._params.parseValue(this._currentValue);
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._input.focus();
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * Update the current value when the TextInput component fires the update
           * event.
           *
           * @param {String} _masked  the masked value
           * @param {String} unmasked  the unmasked value
           */

        }, {
          key: "_onTextInputUpdate",
          value: function _onTextInputUpdate(_masked, unmasked, input) {
            this._currentValue = unmasked;
            input.setCustomValidity('');
            this.focusIn(); // we pass the last captured event back to the grid to handle it internally

            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * On invalid inputs , update the input with a custom validity message
           *
           * @param {String|Object} error the error message reported by TextInput
           * @param {HTMLElement} input The input element used instance
           */

        }, {
          key: "_onTextInputInvalid",
          value: function _onTextInputInvalid(error, input) {
            this.focusIn(); // restore the original value of the cell

            this._currentValue = this._params.value;

            if (typeof error === 'string') {
              input.setCustomValidity(error);
            }
          }
          /**
           * Capture all keyboard events to allow value processing by the NumberInput component
           *
           * @param {KeyboardEvent} e
           */

        }, {
          key: "_onComponentKeyDown",
          value: function _onComponentKeyDown(e) {
            var key = event.which || event.keyCode;
            var isNavigationKey = key === 37 || // left
            key === 38 || // up
            key === 39 || // right
            key === 40 || // down
            key === 33 || // page up
            key === 34 || // page down
            key === 35 || // page home
            key === 36 || // page end
            key === 13; // enter

            if (isNavigationKey) {
              event.stopPropagation(); // save the last capture key so NumberInput can pass it again to the grid.

              this.__lastComponentKeyboardPress__ = e;
            }
          }
          /**
           * Listen to key changes and validate the input
           *
           * @param {Event} event
           */

        }, {
          key: "_onInputKeyDownUp",
          value: function _onInputKeyDownUp(event) {
            var isValid = this._validateInput(event.target);

            if (!isValid) {
              return;
            }

            var key = event.which || event.keyCode;

            if (key == 13 || key === 9) {
              // enter
              this._currentValue = this._input.value;
            } // we pass the last captured event back to the grid to handle it internally


            if (this.__lastComponentKeyboardPress__) {
              this._params.onKeyDown(this.__lastComponentKeyboardPress__);

              this.__lastComponentKeyboardPress__ = null;
            }
          }
          /**
           * Update `currentValue` on the input value is changed and it is valid
           */

        }, {
          key: "_onChange",
          value: function _onChange(event) {
            var isValid = this._validateInput(event.target);

            if (isValid) {
              this._currentValue = this._input.value;
            }
          }
          /**
           * Validate the given input element
           *
           * @param {HTMLInputElement} input input element
           *
           * @return {Boolean} true when valid , false otherwise
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (!isValid) {
              input.classList.add('bbj-mask-error');
              input.classList.remove('bbj-mask-success'); // restore the original value

              this._currentValue = this._params.value;
            } else {
              input.classList.remove('bbj-mask-error');
              input.classList.add('bbj-mask-success');
            }

            return isValid;
          }
        }]);

        return TextEditor;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onTextInputUpdate", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onTextInputUpdate"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onTextInputInvalid", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onTextInputInvalid"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onComponentKeyDown", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onComponentKeyDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onInputKeyDownUp", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onInputKeyDownUp"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onChange", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onChange"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = TextEditor;
      /***/
    },
    /* 63 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(64);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 64 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".textEditor{overflow:hidden}.textEditor .textInputMask__wrap{width:100%;height:100%;box-sizing:border-box;outline:none;display:block;padding:0;margin:0;display:flex;flex:1 1 auto;align-items:center;line-height:normal;position:relative;overflow:hidden}.textEditor .bbj-mask-error{box-shadow:0 -2px 0 #e91e63 inset}.textEditor .bbj-mask-success{box-shadow:0 -2px 0 #4caf50 inset}.textEditor__input{padding-left:6px;border:thin solid var(--ag-input-focus-border-color, rgba(33,150,243,0.4));border-radius:3px;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .textEditor__input,.ag-theme-balham .textEditor__input,.ag-theme-material .textEditor__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .textEditor__input,.ag-theme-balham-dark .textEditor__input{background-color:var(--ag-background-color, #2d3436)}\n", ""]); // exports

      /***/
    },
    /* 65 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_lodash_es_template__ = __webpack_require__(66);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **renderTemplate**   | undefined    | lodash template
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TemplateRenderer = /*#__PURE__*/function (_Component) {
        _inherits(TemplateRenderer, _Component);

        var _super = _createSuper(TemplateRenderer);
        /**
         * Construct new TemplateRenderer
         */


        function TemplateRenderer() {
          var _this;

          _classCallCheck(this, TemplateRenderer);

          _this = _super.call(this); // will this affect BBj bui ?

          _this._gui = document.createElement('div');
          _this._gui.className = 'templateRenderer ag-cell-wrapper';
          _this._gui.style.width = '100%';
          _this._gui.style.height = '100%';
          _this._gui.style.lineHeight = 'normal';
          return _this;
        }
        /**
         *  @inheritDoc
         */


        _createClass(TemplateRenderer, [{
          key: "init",
          value: function init(params) {
            this.refresh(params, true);
          }
          /**
           *  @inheritDoc
           */

        }, {
          key: "getGui",
          value: function getGui() {
            return this._gui;
          }
          /**
           * Refresh the cell l
           *
           * @param {Object} params cell renderer params
           * @param {Boolean} isInit true when this method is being called in `init` phase , false otherwise
           *
           * @return {Boolean} true if the refresh succeeded, otherwise return false.
           */

        }, {
          key: "refresh",
          value: function refresh(params, isInit) {
            if (isInit) {
              this._compiledTemplate = Object(__WEBPACK_IMPORTED_MODULE_1_lodash_es_template__["a"
              /* default */
              ])(this.getOption('renderTemplate', params, ''));
            }

            var content;

            if (typeof this._compiledTemplate === 'function') {
              content = this._compiledTemplate({
                params: params
              });
            } else {
              content = params.valueFormatted ? params.valueFormatted : params.value;
            }

            this._gui.innerHTML = content;
            return true;
          }
        }]);

        return TemplateRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__Component__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = TemplateRenderer;
      /***/
    },
    /* 66 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__assignInWith_js__ = __webpack_require__(67);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__attempt_js__ = __webpack_require__(96);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__baseValues_js__ = __webpack_require__(99);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__ = __webpack_require__(100);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__escapeStringChar_js__ = __webpack_require__(101);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__isError_js__ = __webpack_require__(32);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__isIterateeCall_js__ = __webpack_require__(25);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__keys_js__ = __webpack_require__(102);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_8__reInterpolate_js__ = __webpack_require__(35);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__ = __webpack_require__(105);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_10__toString_js__ = __webpack_require__(36);
      /** Used to match empty string literals in compiled template source. */


      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */

      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      /** Used to ensure capturing order of template delimiters. */

      var reNoMatch = /($^)/;
      /** Used to match unescaped characters in compiled string literals. */

      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */

      function template(string, options, guard) {
        // Based on John Resig's `tmpl` implementation
        // (http://ejohn.org/blog/javascript-micro-templating/)
        // and Laura Doktorova's doT.js (https://github.com/olado/doT).
        var settings = __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__["a"
        /* default */
        ].imports._.templateSettings || __WEBPACK_IMPORTED_MODULE_9__templateSettings_js__["a"
        /* default */
        ];

        if (guard && Object(__WEBPACK_IMPORTED_MODULE_6__isIterateeCall_js__["a"
        /* default */
        ])(string, options, guard)) {
          options = undefined;
        }

        string = Object(__WEBPACK_IMPORTED_MODULE_10__toString_js__["a"
        /* default */
        ])(string);
        options = Object(__WEBPACK_IMPORTED_MODULE_0__assignInWith_js__["a"
        /* default */
        ])({}, options, settings, __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__["a"
        /* default */
        ]);
        var imports = Object(__WEBPACK_IMPORTED_MODULE_0__assignInWith_js__["a"
        /* default */
        ])({}, options.imports, settings.imports, __WEBPACK_IMPORTED_MODULE_3__customDefaultsAssignIn_js__["a"
        /* default */
        ]),
            importsKeys = Object(__WEBPACK_IMPORTED_MODULE_7__keys_js__["a"
        /* default */
        ])(imports),
            importsValues = Object(__WEBPACK_IMPORTED_MODULE_2__baseValues_js__["a"
        /* default */
        ])(imports, importsKeys);
        var isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '"; // Compile the regexp to match each delimiter.

        var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === __WEBPACK_IMPORTED_MODULE_8__reInterpolate_js__["a"
        /* default */
        ] ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
        // The sourceURL gets injected into the source that's eval-ed, so be careful
        // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
        // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

        var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
        string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

          source += string.slice(index, offset).replace(reUnescapedString, __WEBPACK_IMPORTED_MODULE_4__escapeStringChar_js__["a"
          /* default */
          ]); // Replace delimiters with snippets.

          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }

          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }

          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }

          index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
          // order to produce the correct `offset` value.

          return match;
        });
        source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
        // code to add the data object to the top of the scope chain.
        // Like with sourceURL, we take care to not check the option's prototype,
        // as this configuration is a code injection vector.

        var variable = hasOwnProperty.call(options, 'variable') && options.variable;

        if (!variable) {
          source = 'with (obj) {\n' + source + '\n}\n';
        } // Cleanup code by stripping empty strings.


        source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

        source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
        var result = Object(__WEBPACK_IMPORTED_MODULE_1__attempt_js__["a"
        /* default */
        ])(function () {
          return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
        }); // Provide the compiled function's source by its `toString` method or
        // the `source` property as a convenience for inlining compiled templates.

        result.source = source;

        if (Object(__WEBPACK_IMPORTED_MODULE_5__isError_js__["a"
        /* default */
        ])(result)) {
          throw result;
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = template;
      /***/
    },
    /* 67 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__copyObject_js__ = __webpack_require__(68);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__createAssigner_js__ = __webpack_require__(78);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__keysIn_js__ = __webpack_require__(84);
      /**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */


      var assignInWith = Object(__WEBPACK_IMPORTED_MODULE_1__createAssigner_js__["a"
      /* default */
      ])(function (object, source, srcIndex, customizer) {
        Object(__WEBPACK_IMPORTED_MODULE_0__copyObject_js__["a"
        /* default */
        ])(source, Object(__WEBPACK_IMPORTED_MODULE_2__keysIn_js__["a"
        /* default */
        ])(source), object, customizer);
      });
      /* harmony default export */

      __webpack_exports__["a"] = assignInWith;
      /***/
    },
    /* 68 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__assignValue_js__ = __webpack_require__(69);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__ = __webpack_require__(17);
      /**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */


      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

          if (newValue === undefined) {
            newValue = source[key];
          }

          if (isNew) {
            Object(__WEBPACK_IMPORTED_MODULE_1__baseAssignValue_js__["a"
            /* default */
            ])(object, key, newValue);
          } else {
            Object(__WEBPACK_IMPORTED_MODULE_0__assignValue_js__["a"
            /* default */
            ])(object, key, newValue);
          }
        }

        return object;
      }
      /* harmony default export */


      __webpack_exports__["a"] = copyObject;
      /***/
    },
    /* 69 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__eq_js__ = __webpack_require__(11);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */

      function assignValue(object, key, value) {
        var objValue = object[key];

        if (!(hasOwnProperty.call(object, key) && Object(__WEBPACK_IMPORTED_MODULE_1__eq_js__["a"
        /* default */
        ])(objValue, value)) || value === undefined && !(key in object)) {
          Object(__WEBPACK_IMPORTED_MODULE_0__baseAssignValue_js__["a"
          /* default */
          ])(object, key, value);
        }
      }
      /* harmony default export */


      __webpack_exports__["a"] = assignValue;
      /***/
    },
    /* 70 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__ = __webpack_require__(71);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getValue_js__ = __webpack_require__(77);
      /**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */


      function getNative(object, key) {
        var value = Object(__WEBPACK_IMPORTED_MODULE_1__getValue_js__["a"
        /* default */
        ])(object, key);
        return Object(__WEBPACK_IMPORTED_MODULE_0__baseIsNative_js__["a"
        /* default */
        ])(value) ? value : undefined;
      }
      /* harmony default export */


      __webpack_exports__["a"] = getNative;
      /***/
    },
    /* 71 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isFunction_js__ = __webpack_require__(19);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isMasked_js__ = __webpack_require__(74);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObject_js__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__toSource_js__ = __webpack_require__(76);
      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */


      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      /** Used to detect host constructors (Safari). */

      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
          objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to detect if a method is native. */

      var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
      /**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */

      function baseIsNative(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObject_js__["a"
        /* default */
        ])(value) || Object(__WEBPACK_IMPORTED_MODULE_1__isMasked_js__["a"
        /* default */
        ])(value)) {
          return false;
        }

        var pattern = Object(__WEBPACK_IMPORTED_MODULE_0__isFunction_js__["a"
        /* default */
        ])(value) ? reIsNative : reIsHostCtor;
        return pattern.test(Object(__WEBPACK_IMPORTED_MODULE_3__toSource_js__["a"
        /* default */
        ])(value));
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsNative;
      /***/
    },
    /* 72 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /** Built-in value references. */

      var symToStringTag = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].toStringTag : undefined;
      /**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */

      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

        try {
          value[symToStringTag] = undefined;
          var unmasked = true;
        } catch (e) {}

        var result = nativeObjectToString.call(value);

        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = getRawTag;
      /***/
    },
    /* 73 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var objectProto = Object.prototype;
      /**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */

      var nativeObjectToString = objectProto.toString;
      /**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */

      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      /* harmony default export */


      __webpack_exports__["a"] = objectToString;
      /***/
    },
    /* 74 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__ = __webpack_require__(75);
      /** Used to detect methods masquerading as native. */


      var maskSrcKey = function () {
        var uid = /[^.]+$/.exec(__WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ] && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ].keys && __WEBPACK_IMPORTED_MODULE_0__coreJsData_js__["a"
        /* default */
        ].keys.IE_PROTO || '');
        return uid ? 'Symbol(src)_1.' + uid : '';
      }();
      /**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */


      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isMasked;
      /***/
    },
    /* 75 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
      /** Used to detect overreaching core-js shims. */


      var coreJsData = __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
      /* default */
      ]['__core-js_shared__'];
      /* harmony default export */

      __webpack_exports__["a"] = coreJsData;
      /***/
    },
    /* 76 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used for built-in method references. */

      var funcProto = Function.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */

      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {}

          try {
            return func + '';
          } catch (e) {}
        }

        return '';
      }
      /* harmony default export */


      __webpack_exports__["a"] = toSource;
      /***/
    },
    /* 77 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */

      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }
      /* harmony default export */


      __webpack_exports__["a"] = getValue;
      /***/
    },
    /* 78 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseRest_js__ = __webpack_require__(22);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__ = __webpack_require__(25);
      /**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */


      function createAssigner(assigner) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__baseRest_js__["a"
        /* default */
        ])(function (object, sources) {
          var index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;
          customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

          if (guard && Object(__WEBPACK_IMPORTED_MODULE_1__isIterateeCall_js__["a"
          /* default */
          ])(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
          }

          object = Object(object);

          while (++index < length) {
            var source = sources[index];

            if (source) {
              assigner(object, source, index, customizer);
            }
          }

          return object;
        });
      }
      /* harmony default export */


      __webpack_exports__["a"] = createAssigner;
      /***/
    },
    /* 79 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(24);
      /* Built-in method references for those with the same name as other `lodash` methods. */


      var nativeMax = Math.max;
      /**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */

      function overRest(func, start, transform) {
        start = nativeMax(start === undefined ? func.length - 1 : start, 0);
        return function () {
          var args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

          while (++index < length) {
            array[index] = args[start + index];
          }

          index = -1;
          var otherArgs = Array(start + 1);

          while (++index < start) {
            otherArgs[index] = args[index];
          }

          otherArgs[start] = transform(array);
          return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a"
          /* default */
          ])(func, this, otherArgs);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = overRest;
      /***/
    },
    /* 80 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__ = __webpack_require__(81);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__shortOut_js__ = __webpack_require__(83);
      /**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var setToString = Object(__WEBPACK_IMPORTED_MODULE_1__shortOut_js__["a"
      /* default */
      ])(__WEBPACK_IMPORTED_MODULE_0__baseSetToString_js__["a"
      /* default */
      ]);
      /* harmony default export */

      __webpack_exports__["a"] = setToString;
      /***/
    },
    /* 81 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__constant_js__ = __webpack_require__(82);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__defineProperty_js__ = __webpack_require__(18);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__identity_js__ = __webpack_require__(23);
      /**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */


      var baseSetToString = !__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_2__identity_js__["a"
      /* default */
      ] : function (func, string) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__defineProperty_js__["a"
        /* default */
        ])(func, 'toString', {
          'configurable': true,
          'enumerable': false,
          'value': Object(__WEBPACK_IMPORTED_MODULE_0__constant_js__["a"
          /* default */
          ])(string),
          'writable': true
        });
      };
      /* harmony default export */

      __webpack_exports__["a"] = baseSetToString;
      /***/
    },
    /* 82 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */

      function constant(value) {
        return function () {
          return value;
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = constant;
      /***/
    },
    /* 83 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to detect hot functions by number of calls within a span of milliseconds. */

      var HOT_COUNT = 800,
          HOT_SPAN = 16;
      /* Built-in method references for those with the same name as other `lodash` methods. */

      var nativeNow = Date.now;
      /**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */

      function shortOut(func) {
        var count = 0,
            lastCalled = 0;
        return function () {
          var stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;

          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }

          return func.apply(undefined, arguments);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = shortOut;
      /***/
    },
    /* 84 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(28);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__ = __webpack_require__(94);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(12);
      /**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */


      function keysIn(object) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a"
        /* default */
        ])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a"
        /* default */
        ])(object, true) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeysIn_js__["a"
        /* default */
        ])(object);
      }
      /* harmony default export */


      __webpack_exports__["a"] = keysIn;
      /***/
    },
    /* 85 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */

      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseTimes;
      /***/
    },
    /* 86 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__ = __webpack_require__(87);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Built-in value references. */

      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      /**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */

      var isArguments = Object(__WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a"
      /* default */
      ])(function () {
        return arguments;
      }()) ? __WEBPACK_IMPORTED_MODULE_0__baseIsArguments_js__["a"
      /* default */
      ] : function (value) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
      };
      /* harmony default export */

      __webpack_exports__["a"] = isArguments;
      /***/
    },
    /* 87 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]';
      /**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */

      function baseIsArguments(value) {
        return Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) == argsTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsArguments;
      /***/
    },
    /* 88 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (module) {
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__root_js__ = __webpack_require__(10);
        /* harmony import */


        var __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__ = __webpack_require__(89);

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `exports`. */


        var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && (false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Built-in value references. */

        var Buffer = moduleExports ? __WEBPACK_IMPORTED_MODULE_0__root_js__["a"
        /* default */
        ].Buffer : undefined;
        /* Built-in method references for those with the same name as other `lodash` methods. */

        var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */

        var isBuffer = nativeIsBuffer || __WEBPACK_IMPORTED_MODULE_1__stubFalse_js__["a"
        /* default */
        ];
        /* harmony default export */

        __webpack_exports__["a"] = isBuffer;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(30)(module));
      /***/
    },
    /* 89 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */

      function stubFalse() {
        return false;
      }
      /* harmony default export */


      __webpack_exports__["a"] = stubFalse;
      /***/
    },
    /* 90 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__ = __webpack_require__(91);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseUnary_js__ = __webpack_require__(92);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__ = __webpack_require__(93);
      /* Node.js helper references. */


      var nodeIsTypedArray = __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a"
      /* default */
      ] && __WEBPACK_IMPORTED_MODULE_2__nodeUtil_js__["a"
      /* default */
      ].isTypedArray;
      /**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */

      var isTypedArray = nodeIsTypedArray ? Object(__WEBPACK_IMPORTED_MODULE_1__baseUnary_js__["a"
      /* default */
      ])(nodeIsTypedArray) : __WEBPACK_IMPORTED_MODULE_0__baseIsTypedArray_js__["a"
      /* default */
      ];
      /* harmony default export */

      __webpack_exports__["a"] = isTypedArray;
      /***/
    },
    /* 91 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isLength_js__ = __webpack_require__(26);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          objectTag = '[object Object]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          weakMapTag = '[object WeakMap]';
      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';
      /** Used to identify `toStringTag` values of typed arrays. */

      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      /**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */

      function baseIsTypedArray(value) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_1__isLength_js__["a"
        /* default */
        ])(value.length) && !!typedArrayTags[Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value)];
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseIsTypedArray;
      /***/
    },
    /* 92 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */

      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseUnary;
      /***/
    },
    /* 93 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (module) {
        /* harmony import */
        var __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__ = __webpack_require__(20);

        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }

          return _typeof(obj);
        }
        /** Detect free variable `exports`. */


        var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
        /** Detect free variable `module`. */

        var freeModule = freeExports && (false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
        /** Detect the popular CommonJS extension `module.exports`. */

        var moduleExports = freeModule && freeModule.exports === freeExports;
        /** Detect free variable `process` from Node.js. */

        var freeProcess = moduleExports && __WEBPACK_IMPORTED_MODULE_0__freeGlobal_js__["a"
        /* default */
        ].process;
        /** Used to access faster Node.js helpers. */

        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;

            if (types) {
              return types;
            } // Legacy `process.binding('util')` for Node.js < 10.


            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();
        /* harmony default export */


        __webpack_exports__["a"] = nodeUtil;
        /* WEBPACK VAR INJECTION */
      }).call(__webpack_exports__, __webpack_require__(30)(module));
      /***/
    },
    /* 94 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isObject_js__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isPrototype_js__ = __webpack_require__(31);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__ = __webpack_require__(95);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function baseKeysIn(object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__isObject_js__["a"
        /* default */
        ])(object)) {
          return Object(__WEBPACK_IMPORTED_MODULE_2__nativeKeysIn_js__["a"
          /* default */
          ])(object);
        }

        var isProto = Object(__WEBPACK_IMPORTED_MODULE_1__isPrototype_js__["a"
        /* default */
        ])(object),
            result = [];

        for (var key in object) {
          if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseKeysIn;
      /***/
    },
    /* 95 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function nativeKeysIn(object) {
        var result = [];

        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = nativeKeysIn;
      /***/
    },
    /* 96 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__apply_js__ = __webpack_require__(24);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseRest_js__ = __webpack_require__(22);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isError_js__ = __webpack_require__(32);
      /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */


      var attempt = Object(__WEBPACK_IMPORTED_MODULE_1__baseRest_js__["a"
      /* default */
      ])(function (func, args) {
        try {
          return Object(__WEBPACK_IMPORTED_MODULE_0__apply_js__["a"
          /* default */
          ])(func, undefined, args);
        } catch (e) {
          return Object(__WEBPACK_IMPORTED_MODULE_2__isError_js__["a"
          /* default */
          ])(e) ? e : new Error(e);
        }
      });
      /* harmony default export */

      __webpack_exports__["a"] = attempt;
      /***/
    },
    /* 97 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__getPrototype_js__ = __webpack_require__(98);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__ = __webpack_require__(6);
      /** `Object#toString` result references. */


      var objectTag = '[object Object]';
      /** Used for built-in method references. */

      var funcProto = Function.prototype,
          objectProto = Object.prototype;
      /** Used to resolve the decompiled source of functions. */

      var funcToString = funcProto.toString;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /** Used to infer the `Object` constructor. */

      var objectCtorString = funcToString.call(Object);
      /**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */

      function isPlainObject(value) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_2__isObjectLike_js__["a"
        /* default */
        ])(value) || Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) != objectTag) {
          return false;
        }

        var proto = Object(__WEBPACK_IMPORTED_MODULE_1__getPrototype_js__["a"
        /* default */
        ])(value);

        if (proto === null) {
          return true;
        }

        var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
        return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isPlainObject;
      /***/
    },
    /* 98 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(33);
      /** Built-in value references. */


      var getPrototype = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a"
      /* default */
      ])(Object.getPrototypeOf, Object);
      /* harmony default export */

      __webpack_exports__["a"] = getPrototype;
      /***/
    },
    /* 99 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayMap_js__ = __webpack_require__(34);
      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */


      function baseValues(object, props) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__arrayMap_js__["a"
        /* default */
        ])(props, function (key) {
          return object[key];
        });
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseValues;
      /***/
    },
    /* 100 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__eq_js__ = __webpack_require__(11);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */

      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined || Object(__WEBPACK_IMPORTED_MODULE_0__eq_js__["a"
        /* default */
        ])(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }

        return objValue;
      }
      /* harmony default export */


      __webpack_exports__["a"] = customDefaultsAssignIn;
      /***/
    },
    /* 101 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to escape characters for inclusion in compiled string literals. */

      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        "\u2028": 'u2028',
        "\u2029": 'u2029'
      };
      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */

      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }
      /* harmony default export */


      __webpack_exports__["a"] = escapeStringChar;
      /***/
    },
    /* 102 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__ = __webpack_require__(28);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__baseKeys_js__ = __webpack_require__(103);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__ = __webpack_require__(12);
      /**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */


      function keys(object) {
        return Object(__WEBPACK_IMPORTED_MODULE_2__isArrayLike_js__["a"
        /* default */
        ])(object) ? Object(__WEBPACK_IMPORTED_MODULE_0__arrayLikeKeys_js__["a"
        /* default */
        ])(object) : Object(__WEBPACK_IMPORTED_MODULE_1__baseKeys_js__["a"
        /* default */
        ])(object);
      }
      /* harmony default export */


      __webpack_exports__["a"] = keys;
      /***/
    },
    /* 103 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__isPrototype_js__ = __webpack_require__(31);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__ = __webpack_require__(104);
      /** Used for built-in method references. */


      var objectProto = Object.prototype;
      /** Used to check objects for own properties. */

      var hasOwnProperty = objectProto.hasOwnProperty;
      /**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */

      function baseKeys(object) {
        if (!Object(__WEBPACK_IMPORTED_MODULE_0__isPrototype_js__["a"
        /* default */
        ])(object)) {
          return Object(__WEBPACK_IMPORTED_MODULE_1__nativeKeys_js__["a"
          /* default */
          ])(object);
        }

        var result = [];

        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
          }
        }

        return result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseKeys;
      /***/
    },
    /* 104 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__overArg_js__ = __webpack_require__(33);
      /* Built-in method references for those with the same name as other `lodash` methods. */


      var nativeKeys = Object(__WEBPACK_IMPORTED_MODULE_0__overArg_js__["a"
      /* default */
      ])(Object.keys, Object);
      /* harmony default export */

      __webpack_exports__["a"] = nativeKeys;
      /***/
    },
    /* 105 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__escape_js__ = __webpack_require__(106);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__reEscape_js__ = __webpack_require__(111);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__reEvaluate_js__ = __webpack_require__(112);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__reInterpolate_js__ = __webpack_require__(35);
      /**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */


      var templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'escape': __WEBPACK_IMPORTED_MODULE_1__reEscape_js__["a"
        /* default */
        ],

        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'evaluate': __WEBPACK_IMPORTED_MODULE_2__reEvaluate_js__["a"
        /* default */
        ],

        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        'interpolate': __WEBPACK_IMPORTED_MODULE_3__reInterpolate_js__["a"
        /* default */
        ],

        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        'variable': '',

        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        'imports': {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          '_': {
            'escape': __WEBPACK_IMPORTED_MODULE_0__escape_js__["a"
            /* default */
            ]
          }
        }
      };
      /* harmony default export */

      __webpack_exports__["a"] = templateSettings;
      /***/
    },
    /* 106 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__escapeHtmlChar_js__ = __webpack_require__(107);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toString_js__ = __webpack_require__(36);
      /** Used to match HTML entities and HTML characters. */


      var reUnescapedHtml = /[&<>"']/g,
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      /**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */

      function escape(string) {
        string = Object(__WEBPACK_IMPORTED_MODULE_1__toString_js__["a"
        /* default */
        ])(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, __WEBPACK_IMPORTED_MODULE_0__escapeHtmlChar_js__["a"
        /* default */
        ]) : string;
      }
      /* harmony default export */


      __webpack_exports__["a"] = escape;
      /***/
    },
    /* 107 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__basePropertyOf_js__ = __webpack_require__(108);
      /** Used to map characters to HTML entities. */


      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };
      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */

      var escapeHtmlChar = Object(__WEBPACK_IMPORTED_MODULE_0__basePropertyOf_js__["a"
      /* default */
      ])(htmlEscapes);
      /* harmony default export */

      __webpack_exports__["a"] = escapeHtmlChar;
      /***/
    },
    /* 108 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */

      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined : object[key];
        };
      }
      /* harmony default export */


      __webpack_exports__["a"] = basePropertyOf;
      /***/
    },
    /* 109 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Symbol_js__ = __webpack_require__(9);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__arrayMap_js__ = __webpack_require__(34);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__isArray_js__ = __webpack_require__(29);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__isSymbol_js__ = __webpack_require__(110);
      /** Used as references for various `Number` constants. */


      var INFINITY = 1 / 0;
      /** Used to convert symbols to primitives and strings. */

      var symbolProto = __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ] ? __WEBPACK_IMPORTED_MODULE_0__Symbol_js__["a"
      /* default */
      ].prototype : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;
      /**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */

      function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
          return value;
        }

        if (Object(__WEBPACK_IMPORTED_MODULE_2__isArray_js__["a"
        /* default */
        ])(value)) {
          // Recursively convert values (susceptible to call stack limits).
          return Object(__WEBPACK_IMPORTED_MODULE_1__arrayMap_js__["a"
          /* default */
          ])(value, baseToString) + '';
        }

        if (Object(__WEBPACK_IMPORTED_MODULE_3__isSymbol_js__["a"
        /* default */
        ])(value)) {
          return symbolToString ? symbolToString.call(value) : '';
        }

        var result = value + '';
        return result == '0' && 1 / value == -INFINITY ? '-0' : result;
      }
      /* harmony default export */


      __webpack_exports__["a"] = baseToString;
      /***/
    },
    /* 110 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__ = __webpack_require__(5);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__ = __webpack_require__(6);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /** `Object#toString` result references. */


      var symbolTag = '[object Symbol]';
      /**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */

      function isSymbol(value) {
        return _typeof(value) == 'symbol' || Object(__WEBPACK_IMPORTED_MODULE_1__isObjectLike_js__["a"
        /* default */
        ])(value) && Object(__WEBPACK_IMPORTED_MODULE_0__baseGetTag_js__["a"
        /* default */
        ])(value) == symbolTag;
      }
      /* harmony default export */


      __webpack_exports__["a"] = isSymbol;
      /***/
    },
    /* 111 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reEscape = /<%-([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reEscape;
      /***/
    },
    /* 112 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /** Used to match template delimiters. */

      var reEvaluate = /<%([\s\S]+?)%>/g;
      /* harmony default export */

      __webpack_exports__["a"] = reEvaluate;
      /***/
    },
    /* 113 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__ImageRenderer__ = __webpack_require__(114);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__ImageRenderer__["a"
      /* default */
      ];
      /***/
    },
    /* 114 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__ = __webpack_require__(16);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _get(target, property, receiver) {
        if (typeof Reflect !== "undefined" && Reflect.get) {
          _get = Reflect.get;
        } else {
          _get = function _get(target, property, receiver) {
            var base = _superPropBase(target, property);

            if (!base) return;
            var desc = Object.getOwnPropertyDescriptor(base, property);

            if (desc.get) {
              return desc.get.call(receiver);
            }

            return desc.value;
          };
        }

        return _get(target, property, receiver || target);
      }

      function _superPropBase(object, property) {
        while (!Object.prototype.hasOwnProperty.call(object, property)) {
          object = _getPrototypeOf(object);
          if (object === null) break;
        }

        return object;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Numbers Editor
       *
       * Handle number values Editing
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **imageRendererWidth**   | 28px    | image width
       * | **imageRendererHeight**   | 28px    | image height
       * | **imageRendererList**       | {}  	| a list of which maps images with cell values as JSON or plain JS object
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       *
       * @see https://lodash.com/docs/4.17.15#template
       */


      var ImageRenderer = /*#__PURE__*/function (_TemplateRenderer) {
        _inherits(ImageRenderer, _TemplateRenderer);

        var _super = _createSuper(ImageRenderer);

        function ImageRenderer() {
          _classCallCheck(this, ImageRenderer);

          return _super.apply(this, arguments);
        }

        _createClass(ImageRenderer, [{
          key: "refresh",

          /**
           * @inheritDoc
           */
          value: function refresh(params, isInit) {
            var value = params.value;
            var imageWidth = this.getOption('imageRendererWidth', params, '28px');
            var imageHeight = this.getOption('imageRendererHeight', params, '28px');
            var imageList = this.getOption('imageRendererList', params);

            try {
              imageList = JSON.parse(imageList);
            } catch (e) {
              imageList = imageList || {};
            }
            /* eslint-disable no-prototype-builtins */


            if (imageList && imageList.hasOwnProperty(value)) {
              params.renderTemplate =
              /*html*/
              "\n        <img \n          src=\"".concat(imageList[params.value], "\" \n          width=\"").concat(imageWidth, "\"\n          height=\"").concat(imageHeight, "\"  \n        />\n      ");
            } else {
              params.renderTemplate = value;
            }

            return _get(_getPrototypeOf(ImageRenderer.prototype), "refresh", this).call(this, params, isInit);
          }
        }]);

        return ImageRenderer;
      }(__WEBPACK_IMPORTED_MODULE_0__TemplateRenderer__["a"
      /* default */
      ]);
      /* harmony default export */


      __webpack_exports__["a"] = ImageRenderer;
      /***/
    },
    /* 115 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeFilter__ = __webpack_require__(116);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeFilter__["a"
      /* default */
      ];
      /***/
    },
    /* 116 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__ = __webpack_require__(37);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3_date_fns_tz_utcToZonedTime__ = __webpack_require__(38);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__EventsMixin__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__ = __webpack_require__(41);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_6__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__style_scss__ = __webpack_require__(127);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_7__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7__style_scss__);

      var _class, _class2, _init, _descriptor, _class3, _temp, _class4, _class5, _init2, _descriptor2, _class6, _temp2, _class7, _temp3;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _initializerDefineProperty(target, property, descriptor, context) {
        if (!descriptor) return;
        Object.defineProperty(target, property, {
          enumerable: descriptor.enumerable,
          configurable: descriptor.configurable,
          writable: descriptor.writable,
          value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
        });
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _initializerWarningHelper(descriptor, context) {
        throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var TOKENS = {
        TOKEN_EQUAL: 'equals',
        TOKEN_NOT_EQUAL: 'notEqual',
        TOKEN_LESS: 'lessThan',
        TOKEN_GREATER: 'greaterThan',
        TOKEN_RANGE: 'inRange',
        TOKEN_AND: 'AND',
        TOKEN_OR: 'OR'
      };

      var ConditionPanel = Object(__WEBPACK_IMPORTED_MODULE_4__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inherits(ConditionPanel, _Component);

        var _super = _createSuper(ConditionPanel);

        function ConditionPanel() {
          var _this;

          _classCallCheck(this, ConditionPanel);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));

          _initializerDefineProperty(_this, "state", _descriptor, _assertThisInitialized(_this));

          _this._filterTimeInput = new __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
          /* default */
          ]();
          _this._filterToDateTimeInput = new __WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
          /* default */
          ]();
          _this._filterOptions = [];
          _this._defaultOption = -1;
          return _this;
        }

        _createClass(ConditionPanel, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var _optionsTranslations,
                _this2 = this;

            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            this._filterOptions = this.getOption('filterOptions', params, [TOKENS.TOKEN_EQUAL, TOKENS.TOKEN_NOT_EQUAL, TOKENS.TOKEN_LESS, TOKENS.TOKEN_GREATER, TOKENS.TOKEN_RANGE]);
            this._defaultOption = this.getOption('defaultOption', params, this._filterOptions.indexOf(TOKENS.TOKEN_EQUAL) > -1 ? TOKENS.TOKEN_EQUAL : this._filterOptions[0]);
            this.state.type = this._defaultOption;
            var optionsTranslations = (_optionsTranslations = {}, _defineProperty(_optionsTranslations, TOKENS.TOKEN_EQUAL, translate(TOKENS.TOKEN_EQUAL, 'Equals')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_NOT_EQUAL, translate(TOKENS.TOKEN_EQUAL, 'Not equal')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_LESS, translate(TOKENS.TOKEN_LESS, 'Less than')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_GREATER, translate(TOKENS.TOKEN_GREATER, 'Greater than')), _defineProperty(_optionsTranslations, TOKENS.TOKEN_RANGE, translate(TOKENS.TOKEN_RANGE, 'In range')), _optionsTranslations);
            this._gui = document.createElement('div');
            this._gui.className = 'dateTimeFilter ag-filter-body-wrapper';
            this._gui.innerHTML =
            /* html */
            "\n      <select class=\"ag-filter-select dateTimeFilter__select\"  ".concat(this._filterOptions.length === 1 ? 'disabled' : '', ">\n        ").concat(this._filterOptions.map(function (option) {
              return (
                /* html */
                "\n          <option \n            value=\"".concat(option, "\" \n            ").concat(option === _this2._defaultOption ? 'selected' : '', "\n          >\n              ").concat(optionsTranslations[option], "\n          </option>")
              );
            }), "\n      </select>\n      <div class=\"ag-filter-body\">\n        <div class=\"ag-filter-date-from\">\n        </div>\n        <div class=\"ag-filter-date-to ag-hidden\">\n        </div>\n      </div>\n    ");

            this._filterTimeInput.init(params);

            this._filterTimeInput.on(__WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, function (selectedDate) {
              _this2.state.filter = selectedDate;

              _this2.notify(ConditionPanel.ON_CONDITION_CHANGED, _this2.state);
            });

            this._filterToDateTimeInput.init(params);

            this._filterToDateTimeInput.on(__WEBPACK_IMPORTED_MODULE_5__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, function (selectedDate) {
              _this2.state.filterTo = selectedDate;

              _this2.notify(ConditionPanel.ON_CONDITION_CHANGED, _this2.state);
            });

            this._gui.querySelector('.ag-filter-date-from').appendChild(this._filterTimeInput.getGui());

            this._gui.querySelector('.ag-filter-date-to').appendChild(this._filterToDateTimeInput.getGui());

            var select = this._gui.querySelector('.ag-filter-select');

            select.addEventListener('change', this._onTypeChange);
            this.setState(this._state);
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this.off(ConditionPanel.ON_CONDITION_CHANGED);

            this._filterTimeInput.destroy();

            this._filterToDateTimeInput.destroy();

            this._gui.querySelector('.ag-filter-select').removeEventListener('change', this._onTypeChange);

            this.reset();
          }
          /**
           * Reset the state
           */

        }, {
          key: "reset",
          value: function reset() {
            this.state.filter = null;
            this.state.filterTo = null;

            this._filterTimeInput.reset();

            this._filterToDateTimeInput.reset();

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Set the condition state
           *
           * @param {Object} state
           */

        }, {
          key: "setState",
          value: function setState(state) {
            state = state || {};
            this.state.filter = state.filter || null;
            this.state.filterTo = state.filterTo || null;
            this.state.type = state.type || this._defaultOption;
            var gui = this._gui;
            var filterOptions = this._filterOptions;
            var selectEl = gui.querySelector('.ag-filter-select');
            var filterInput = this._filterTimeInput;
            var filterToInput = this._filterToDateTimeInput;
            selectEl.selectedIndex = filterOptions.indexOf(this.state.type);
            filterInput.setDate(this.state.filter);
            filterToInput.setDate(this.state.filterTo); // we fire on change event in case the filter options contain
            // one option which is in Range "inRange"

            if ('createEvent' in document) {
              var evt = document.createEvent('HTMLEvents');
              evt.initEvent('change', false, true);
              selectEl.dispatchEvent(evt);
            } else {
              selectEl.fireEvent('onchange');
            }

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Update the state with the selected type
           *
           * @param {Event} e
           */

        }, {
          key: "_onTypeChange",
          value: function _onTypeChange(e) {
            var el = e.target;

            var filterDateTo = this._gui.querySelector('.ag-filter-date-to');

            this.state.type = el.options[el.selectedIndex].value;

            if (this.state.type === TOKENS.TOKEN_RANGE) {
              filterDateTo.classList.remove('ag-hidden');
            } else {
              filterDateTo.classList.add('ag-hidden');
            }

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
        }]);

        return ConditionPanel;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _class3.ON_CONDITION_CHANGED = 'ConditionPanel.ON_CONDITION_CHANGED', _temp), (_applyDecoratedDescriptor(_class2, "ON_CONDITION_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init = Object.getOwnPropertyDescriptor(_class2, "ON_CONDITION_CHANGED"), _init = _init ? _init.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init;
        }
      }), _class2), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "state", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {
            type: TOKENS.TOKEN_EQUAL,
            filter: null,
            filterTo: null
          };
        }
      }), _applyDecoratedDescriptor(_class2.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "init"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "destroy"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "_onTypeChange", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "_onTypeChange"), _class2.prototype)), _class2)) || _class;

      var JoinConditionPanel = Object(__WEBPACK_IMPORTED_MODULE_4__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class4 = (_class5 = (_temp2 = _class6 = /*#__PURE__*/function (_Component2) {
        _inherits(JoinConditionPanel, _Component2);

        var _super2 = _createSuper(JoinConditionPanel);

        function JoinConditionPanel() {
          var _this3;

          _classCallCheck(this, JoinConditionPanel);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          _this3 = _super2.call.apply(_super2, [this].concat(args));

          _initializerDefineProperty(_this3, "state", _descriptor2, _assertThisInitialized(_this3));

          _this3._firstConditionPanel = new ConditionPanel();
          _this3._secondConditionPanel = new ConditionPanel();
          _this3._operatorPanel = null;
          _this3._params = null;
          return _this3;
        }

        _createClass(JoinConditionPanel, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            this._params = params;

            this._firstConditionPanel.init(params);

            this._firstConditionPanel.on(ConditionPanel.ON_CONDITION_CHANGED, this._onFirstConditionChanged);

            this._secondConditionPanel.init(params);

            this._secondConditionPanel.on(ConditionPanel.ON_CONDITION_CHANGED, this._onSecondConditionChanged);

            this._secondConditionPanel.getGui().classList.add('ag-hidden');

            this._gui = document.createElement('div');
            this._gui.className = 'ag-filter-body-wrapper ag-simple-filter-body-wrapper';

            this._gui.appendChild(this._firstConditionPanel.getGui()); //prettier-ignore


            var idOne = '_' + Math.random().toString(36).substr(2, 9),
                idTwo = '_' + Math.random().toString(36).substr(2, 9);
            this._operatorPanel = document.createElement('div');
            this._operatorPanel.className = 'ag-filter-condition ag-hidden';
            this._operatorPanel.innerHTML =
            /* html */
            "\n    <div class=\"ag-filter-condition-operator ag-filter-condition-operator-and ag-labeled ag-label-align-right ag-radio-button ag-input-field\">\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\" for=\"".concat(idOne, "\">       \n          ").concat(translate('andCondition', 'AND'), "\n        </label>\n        <div class=\"ag-wrapper-and ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper ag-checked\">\n          <input id=\"").concat(idOne, "\" class=\"AND ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"orAndRadio\" value=\"").concat(TOKENS.TOKEN_AND, "\"/>              \n        </div> \n    </div>   \n    \n    <div class=\"ag-filter-condition-operator ag-filter-condition-operator-and ag-labeled ag-label-align-right ag-radio-button ag-input-field\">\n        <label class=\"ag-input-field-label ag-label ag-radio-button-label\" for=\"").concat(idTwo, "\">       \n          ").concat(translate('orCondition', 'OR'), "\n        </label>\n        <div class=\"ag-wrapper-or ag-wrapper ag-input-wrapper ag-radio-button-input-wrapper\">\n          <input id=\"").concat(idTwo, "\" class=\"OR ag-input-field-input ag-radio-button-input\" type=\"radio\" name=\"orAndRadio\" value=\"").concat(TOKENS.TOKEN_OR, "\"/>              \n        </div>         \n    </div>   \n    ");

            this._gui.appendChild(this._operatorPanel);

            this._operatorPanel.addEventListener('change', this._onOperatorChanged);

            this._gui.appendChild(this._secondConditionPanel.getGui());
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._firstConditionPanel.destroy();

            this._secondConditionPanel.destroy();

            this._operatorPanel.removeEventListener('change', this._onOperatorChanged);

            this.off(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED);
            this.reset();
          }
          /**
           * Reset the state
           */

        }, {
          key: "reset",
          value: function reset() {
            this._firstConditionPanel.reset();

            this._secondConditionPanel.reset();

            this.notify(ConditionPanel.ON_CONDITION_CHANGED, this.state);
          }
          /**
           * Set the condition join state
           *
           * @param {Object} state
           */

        }, {
          key: "setState",
          value: function setState(state) {
            var _this4 = this;

            state = state || {};
            this.state.operator = state.operator || TOKENS.TOKEN_OR;
            this.state.condition1 = state.condition1 || null;
            this.state.condition2 = state.condition2 || null;

            this._firstConditionPanel.setState(this.state.condition1);

            this._secondConditionPanel.setState(this.state.condition2);

            this._operatorPanel.querySelectorAll('input').forEach(function (input) {
              if (input.classList.contains(_this4.state.operator)) {
                input.checked = true;
              } else {
                input.checked = false;
              }
            });

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * Add the selected condition to the component stater
           *
           * @param {Event} e
           */

        }, {
          key: "_onOperatorChanged",
          value: function _onOperatorChanged(e) {
            var target = e.target;
            this.state.operator = target.value;

            if (target.classList.contains('OR')) {
              this._operatorPanel.querySelector('.ag-wrapper-or').classList.add('ag-checked');

              this._operatorPanel.querySelector('.ag-wrapper-and').classList.remove('ag-checked');
            } else {
              this._operatorPanel.querySelector('.ag-wrapper-or').classList.remove('ag-checked');

              this._operatorPanel.querySelector('.ag-wrapper-and').classList.add('ag-checked');
            }

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * @param {Object} state  the option state
           */

        }, {
          key: "_onFirstConditionChanged",
          value: function _onFirstConditionChanged(state) {
            this.state.condition1 = state;
            var suppressAndOrCondition = this.getOption('suppressAndOrCondition', this._params, false);

            if (!suppressAndOrCondition) {
              var _this$state$condition = this.state.condition1,
                  filter = _this$state$condition.filter,
                  filterTo = _this$state$condition.filterTo,
                  type = _this$state$condition.type;

              var secondConditionGui = this._secondConditionPanel.getGui();

              var operatorPanelGui = this._operatorPanel;
              var condition = type === TOKENS.TOKEN_RANGE ? !filter || !filterTo : !filter;

              if (condition) {
                secondConditionGui.classList.add('ag-hidden');
                operatorPanelGui.classList.add('ag-hidden');
              } else {
                secondConditionGui.classList.remove('ag-hidden');
                operatorPanelGui.classList.remove('ag-hidden');
              }
            }

            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
          /**
           * @param {Object} state  the option state
           */

        }, {
          key: "_onSecondConditionChanged",
          value: function _onSecondConditionChanged(state) {
            this.state.condition2 = state;
            this.notify(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, this.state);
          }
        }]);

        return JoinConditionPanel;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _class6.ON_JOIN_CONDITION_CHANGED = 'JoinConditionPanel.ON_JOIN_CONDITION_CHANGED', _temp2), (_applyDecoratedDescriptor(_class5, "ON_JOIN_CONDITION_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init2 = Object.getOwnPropertyDescriptor(_class5, "ON_JOIN_CONDITION_CHANGED"), _init2 = _init2 ? _init2.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init2;
        }
      }), _class5), _descriptor2 = _applyDecoratedDescriptor(_class5.prototype, "state", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function initializer() {
          return {
            condition1: {},
            condition2: {},
            operator: TOKENS.TOKEN_OR
          };
        }
      }), _applyDecoratedDescriptor(_class5.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "init"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "destroy"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onOperatorChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onOperatorChanged"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onFirstConditionChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onFirstConditionChanged"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "_onSecondConditionChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class5.prototype, "_onSecondConditionChanged"), _class5.prototype)), _class5)) || _class4;
      /**
       * DateTime Filter
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **dateTimeEnableTime**   | false    | enable / disable time
       * | **dateTimeEnable24HR**   | false    | enable / disable time 24 format
       * | **dateTimeEnableSeconds**   | false    | enable / disable seconds management
       * | **dateTimeEnableCalendar**   | false    | enable / disable Calendar.
       * | **dateTimeMask**   | false    | The mask used to format the selected date
       * | **dateTimeMax**   | undefined    |  Max allowed date
       * | **dateTimeMin**   | undefined    |  Min allowed date
       * | **dateTimeFormatter**   | undefined    |  A function or expression to format the date (@see supported param)
       * | **dateTimeLocale**   | System default    |  A locale to use for date formatting
       * | **dateTimeDefaultHour**   | 12    |  Initial value of the hour element.
       * | **dateTimeDefaultMinute**   | 0    |  Initial value of the minute element.
       * | **dateTimeDisableMobile**   | false    |  Set disableMobile to true to always use the non-native picker.
       * | **dateTimeEnableWeekNumber**   | true    |  Enables display of week numbers in calendar.
       * | **filterOptions**   | Equals, Greater Than, Less Than, Not Equals, In Range.    |  What Filter Options to present to the user.
       * | **defaultOption**   | Equals    |  The default Filter Options to be selected.
       * | **suppressAndOrCondition**   | false    |  If true, the filter will only offer Condition 1.
       * | **inRangeInclusive**   | false    |  If true then doing 'inRange' filter option will include values equal to the start and end of the range.
       * | **clearButton**   | false    |  Set to true to have the filter use a Clear button. The Clear button will clear the (form) details of the filter without removing any active filters on the column.
       * | **applyButton**   | false    |  Set to true to have the filter use an Apply button. If the Apply button is present, then the filter is only applied after the user hits the Apply button.
       * | **resetButton**   | false    |  Set to true to have the filter use a Reset button. The Reset button will clear the details of the filter and any active filters on that column.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeFilter = (_class7 = (_temp3 = /*#__PURE__*/function (_Component3) {
        _inherits(DateTimeFilter, _Component3);

        var _super3 = _createSuper(DateTimeFilter);

        function DateTimeFilter() {
          var _this5;

          _classCallCheck(this, DateTimeFilter);

          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          _this5 = _super3.call.apply(_super3, [this].concat(args));
          _this5._JoinConditionPanel = new JoinConditionPanel();
          _this5._state = {};
          _this5._params = {};
          _this5._doesFilterPassOptions = null;
          return _this5;
        }

        _createClass(DateTimeFilter, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            var _this6 = this;

            var translate = params.api.gridOptionsWrapper.getLocaleTextFunc();
            var isClearFilter = this.getOption('clearButton', params, false);
            var isResetButton = this.getOption('resetButton', params, false);
            var isApplyButton = this.getOption('applyButton', params, false);
            this._gui = document.createElement('div');

            this._JoinConditionPanel.init(params);

            this._JoinConditionPanel.on(JoinConditionPanel.ON_JOIN_CONDITION_CHANGED, function (state) {
              if (!_this6.__disableStateChangeListener) {
                _this6._onJoinConditionPanelStateChanged(state, isApplyButton);
              }
            });

            this._gui.appendChild(this._JoinConditionPanel.getGui());

            var applyFilterPanel = document.createElement('div');
            applyFilterPanel.className = "ag-filter-apply-panel ag-hidden";
            applyFilterPanel.innerHTML =
            /* html */
            "\n      <button class=\"ag-standard-button ag-filter-apply-panel-button clear ".concat(!isClearFilter && 'ag-hidden', "\" type=\"button\">").concat(translate('clearFilter', 'Clear Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button reset ").concat(!isResetButton && 'ag-hidden', "\" type=\"button\">").concat(translate('resetFilter', 'Reset Filter'), "</button>\n      <button class=\"ag-standard-button ag-filter-apply-panel-button apply ").concat(!isApplyButton && 'ag-hidden', "\" type=\"button\">").concat(translate('applyFilter', 'Apply Filter'), "</button>\n    ");

            if (isClearFilter || isResetButton || isApplyButton) {
              applyFilterPanel.classList.remove('ag-hidden');
            }

            applyFilterPanel.addEventListener('click', this._ApplyFilterPanelButtonClick);

            this._gui.appendChild(applyFilterPanel);

            this._state = this._JoinConditionPanel.state;
            this._params = params;
            this._doesFilterPassOptions = {
              enableTime: this.getOption('dateTimeEnableTime', this._params, true),
              inRangeInclusive: this.getOption('inRangeInclusive', this._params, false),
              // eslint-disable-next-line no-prototype-builtins
              valueGetter: this._params.hasOwnProperty('filterValueGetter') ? this._params.filterValueGetter : this._params.valueGetter
            };
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._JoinConditionPanel.destroy();
          }
          /**
           * Check whether selected filter matches the passed cell data
           *
           * @param {Object} params
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "doesFilterPass",
          value: function doesFilterPass(params) {
            var value = this._doesFilterPassOptions.valueGetter(params);

            var _this$_state = this._state,
                condition1 = _this$_state.condition1,
                condition2 = _this$_state.condition2,
                operator = _this$_state.operator;

            var doesPassFirstCondition = this._doesPassCondition(condition1, value);

            var doesPassSecondCondition = this._doesPassCondition(condition2, value);

            return operator === TOKENS.TOKEN_OR ? doesPassFirstCondition || doesPassSecondCondition : doesPassFirstCondition && doesPassSecondCondition;
          }
          /**
           * Check whether the component is applying any filter on the column
           *
           * @return {Boolean}
           **/

        }, {
          key: "isFilterActive",
          value: function isFilterActive() {
            var condition1 = this._state.condition1;

            if (condition1 && condition1.filter) {
              if (condition1.filterTo && condition1.type === TOKENS.TOKEN_RANGE) {
                return condition1.filter !== null && condition1.filterTo !== null;
              }

              return condition1.filter !== null;
            }

            return false;
          }
          /**
           * Gets the filter state. If filter is not active, then should return null/undefined.
           * The grid calls getModel() on all active filters when gridApi.getFilterModel() is called.
           *
           * @return Object | null the filter state
           */

        }, {
          key: "getModel",
          value: function getModel() {
            var _this7 = this;

            var clone = JSON.parse(JSON.stringify(this._state));
            [clone.condition1, clone.condition2].forEach(function (condition, i) {
              if (condition.filter) {
                condition.filter = _this7._state["condition".concat(i + 1)].filter.toISOString();
              }

              if (condition.filterTo) {
                condition.filterTo = _this7._state["condition".concat(i + 1)].filterTo.toISOString();
              }
            });
            clone.filterType = 'datetime';
            clone.condition1.filterType = 'datetime';
            clone.condition2.filterType = 'datetime'; // eslint-disable-next-line no-prototype-builtins

            return clone.hasOwnProperty('condition2') && // eslint-disable-next-line no-prototype-builtins
            clone.condition2.hasOwnProperty('filter') && clone.condition2.filter ? clone : clone.condition1;
          }
          /**
           * Restores the filter state. Called by the grid after gridApi.setFilterModel(model) is called.
           * The grid will pass undefined/null to clear the filter.
           *
           * @param {Object | null} model
           */

        }, {
          key: "setModel",
          value: function setModel(model) {
            if (model && // eslint-disable-next-line no-prototype-builtins
            !model.hasOwnProperty('condition1') && // eslint-disable-next-line no-prototype-builtins
            !model.hasOwnProperty('condition2')) {
              model = {
                condition1: model
              };
            }

            this.__disableStateChangeListener = true;

            this._JoinConditionPanel.setState(model);

            this.__disableStateChangeListener = false;
            this._state = this._JoinConditionPanel.state;
            [this._state.condition1, this._state.condition2].forEach(function (condition) {
              if (condition.filter) {
                condition.filter = new Date(condition.filter);
              }

              if (condition.filterTo) {
                condition.filterTo = new Date(condition.filterTo);
              }
            });
          }
          /**
           * Get the filter model as plain string to display in the floating filter input
           *
           * @param {Object | null} model
           */

        }, {
          key: "getModelAsString",
          value: function getModelAsString(model) {
            if (!model) {
              return '';
            }

            var dateTimeMask = this.getOption('dateTimeMask', this._params, // @todo Find a better way for this
            this._JoinConditionPanel._firstConditionPanel._filterTimeInput.picker.config['dateFormat']);
            var locale = this.getOption('dateTimeLocale', this._params, Intl.DateTimeFormat().resolvedOptions().locale || 'en-US');

            var _JSON$parse = JSON.parse(JSON.stringify(model)),
                condition1 = _JSON$parse.condition1,
                condition2 = _JSON$parse.condition2,
                operator = _JSON$parse.operator;

            [condition1, condition2].forEach(function (condition) {
              if (condition.filter) {
                condition.filter = BBj.Masks.DateMask.mask(condition.filter, dateTimeMask, locale);
              }

              if (condition.filterTo) {
                condition.filterTo = BBj.Masks.DateMask.mask(condition.filterTo, dateTimeMask, locale);
              }
            });
            var firstConditionAsString = "".concat(condition1.filter || '', " ").concat(condition1.filterTo ? '→ ' + condition1.filterTo : '');
            var secondConditionAsString = "".concat(condition2.filter || '', " ").concat(condition2.filterTo ? '→ ' + condition2.filterTo : '');
            var operatorAsString = "".concat(condition2.filter && operator ? operator : '');
            return "".concat(firstConditionAsString, " ").concat(operatorAsString, " ").concat(secondConditionAsString).trim();
          }
          /**
           * Check if the given value passes the filter defined in the passed ConditionPanel's state
           *
           * @param {Object} condition condition panel state
           * @param {String} value cell value
           *
           * @return {Boolean} true when pass, false otherwise
           */

        }, {
          key: "_doesPassCondition",
          value: function _doesPassCondition(condition, value) {
            if (!condition.filter || !value) {
              return false;
            }

            var filter = condition.filter,
                filterTo = condition.filterTo,
                type = condition.type;
            var timezone = BBj.Masks.Utils.Dates.getTimezoneOrOffset();
            var inRangeInclusive = this._doesFilterPassOptions.inRangeInclusive;
            var enableTime = this._doesFilterPassOptions.enableTime;
            var passed = false;

            if (BBj.Masks.Utils.Dates.IS_TIME_REGEX.test(value)) {
              value = value = BBj.Masks.Utils.Dates.fixShortISO(value);
              [filter, filterTo].forEach(function (date) {
                if (date instanceof Date) {
                  date.setFullYear(1970);
                  date.setMonth(0);
                  date.setDate(1);
                }
              });
            } else if (BBj.Masks.Utils.Dates.IS_DATE_REGEX.test(value)) {
              value = BBj.Masks.Utils.Dates.fixShortISO(value);
            } // convert the datetime from utc to locale


            value = Object(__WEBPACK_IMPORTED_MODULE_3_date_fns_tz_utcToZonedTime__["a"
            /* default */
            ])(value, timezone); // firstDate = firstDate ? zonedTimeToUtc(firstDate , timezone) : firstDate
            // secondDate = secondDate ? zonedTimeToUtc(secondDate , timezone) : secondDate

            if (!enableTime) {
              // remove the time portion from the date
              // eslint-disable-next-line no-extra-semi
              ;
              [value, filter, filterTo].forEach(function (date) {
                if (date instanceof Date) {
                  date.setHours(0);
                  date.setMinutes(0);
                  date.setSeconds(0);
                  date.setMilliseconds(0);
                }
              });
            }

            if (type === TOKENS.TOKEN_EQUAL) {
              passed = filter > value === false && filter < value == false;
            } else if (type === TOKENS.TOKEN_NOT_EQUAL) {
              passed = !(filter > value === false && filter < value == false);
            } else if (type === TOKENS.TOKEN_GREATER) {
              passed = filter < value;
            } else if (type === TOKENS.TOKEN_LESS) {
              passed = filter > value;
            } else if (type === TOKENS.TOKEN_RANGE && filterTo) {
              if (inRangeInclusive) {
                passed = (filter < value || filter > value === false && filter < value == false) && filterTo > value || filterTo > value === false && filterTo < value == false;
              } else {
                passed = filter < value && filterTo > value;
              }
            }

            return passed;
          }
          /**
           * List to click button event on the filter panel and execute the
           * right action
           *
           * @param {Event} e
           */

        }, {
          key: "_ApplyFilterPanelButtonClick",
          value: function _ApplyFilterPanelButtonClick(e) {
            var target = e.target;

            if (target.nodeName === 'BUTTON') {
              if (target.classList.contains('reset')) {
                this._JoinConditionPanel.reset();

                this._params.filterChangedCallback();
              } else if (target.classList.contains('clear')) {
                this._JoinConditionPanel.reset();
              } else if (target.classList.contains('apply')) {
                this._params.filterChangedCallback();
              }
            }
          }
          /**
           * Update the filter state and Apply the filter depending on
           * whether the `isApplyButtonActive` is true or false
           *
           * @param {Object} state
           * @param {Boolean} isApplyButtonActive
           */

        }, {
          key: "_onJoinConditionPanelStateChanged",
          value: function _onJoinConditionPanelStateChanged(state, isApplyButtonActive) {
            this._state = state;

            if (false === isApplyButtonActive) {
              this._params.filterChangedCallback();
            }
          }
        }]);

        return DateTimeFilter;
      }(__WEBPACK_IMPORTED_MODULE_6__Component__["a"
      /* default */
      ]), _temp3), (_applyDecoratedDescriptor(_class7.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "init"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "destroy"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "_ApplyFilterPanelButtonClick", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "_ApplyFilterPanelButtonClick"), _class7.prototype), _applyDecoratedDescriptor(_class7.prototype, "_onJoinConditionPanelStateChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class7.prototype, "_onJoinConditionPanelStateChanged"), _class7.prototype)), _class7);
      /* harmony default export */

      __webpack_exports__["a"] = DateTimeFilter;
      /***/
    },
    /* 117 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzTokenizeDate;
      /**
       * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
       * `date` as it will be rendered in the `timeZone`.
       */

      function tzTokenizeDate(date, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      }

      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };

      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date);
        var filled = [];

        for (var i = 0; i < formatted.length; i++) {
          var pos = typeToPos[formatted[i].type];

          if (pos >= 0) {
            filled[pos] = parseInt(formatted[i].value, 10);
          }
        }

        return filled;
      }

      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, '');
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted); // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
        // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]

        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      } // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
      // to get deterministic local date/time output according to the `en-US` locale which
      // can be used to extract local time parts as necessary.


      var dtfCache = {};

      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
          var testDateFormatted = new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: 'America/New_York',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }).format(new Date('2014-06-25T04:00:00.123Z'));
          var hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }) : new Intl.DateTimeFormat('en-US', {
            hourCycle: 'h23',
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        }

        return dtfCache[timeZone];
      }
      /***/

    },
    /* 118 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = subMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__ = __webpack_require__(119);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__ = __webpack_require__(14);
      /**
       * @name subMilliseconds
       * @category Millisecond Helpers
       * @summary Subtract the specified number of milliseconds from the given date.
       *
       * @description
       * Subtract the specified number of milliseconds from the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
       * @returns {Date} the new date with the milliseconds subtracted
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
       * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:29.250
       */


      function subMilliseconds(dirtyDate, dirtyAmount) {
        Object(__WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__["a"
        /* default */
        ])(2, arguments);
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return Object(__WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__["a"
        /* default */
        ])(dirtyDate, -amount);
      }
      /***/

    },
    /* 119 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = addMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toDate_index_js__ = __webpack_require__(120);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__ = __webpack_require__(14);
      /**
       * @name addMilliseconds
       * @category Millisecond Helpers
       * @summary Add the specified number of milliseconds to the given date.
       *
       * @description
       * Add the specified number of milliseconds to the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
       * @returns {Date} the new date with the milliseconds added
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
       * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:30.750
       */


      function addMilliseconds(dirtyDate, dirtyAmount) {
        Object(__WEBPACK_IMPORTED_MODULE_2__lib_requiredArgs_index_js__["a"
        /* default */
        ])(2, arguments);
        var timestamp = Object(__WEBPACK_IMPORTED_MODULE_1__toDate_index_js__["a"
        /* default */
        ])(dirtyDate).getTime();
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return new Date(timestamp + amount);
      }
      /***/

    },
    /* 120 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_requiredArgs_index_js__ = __webpack_require__(14);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       *
       * @param {Date|Number} argument - the value to convert
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       *
       * @example
       * // Clone the date:
       * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert the timestamp to date:
       * const result = toDate(1392098430000)
       * //=> Tue Feb 11 2014 11:30:30
       */


      function toDate(argument) {
        Object(__WEBPACK_IMPORTED_MODULE_0__lib_requiredArgs_index_js__["a"
        /* default */
        ])(1, arguments);
        var argStr = Object.prototype.toString.call(argument); // Clone the date

        if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || argStr === '[object Number]') {
          return new Date(argument);
        } else {
          if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
            // eslint-disable-next-line no-console
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

            console.warn(new Error().stack);
          }

          return new Date(NaN);
        }
      }
      /***/

    },
    /* 121 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__ = __webpack_require__(13);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__ = __webpack_require__(122);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__ = __webpack_require__(39);

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns = {
        dateTimeDelimeter: /[T ]/,
        plainTime: /:/,
        timeZoneDelimeter: /[Z ]/i,
        // year tokens
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, // 0 additional digits
        /^([+-]\d{3})$/, // 1 additional digit
        /^([+-]\d{4})$/ // 2 additional digits
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, // 0 additional digits
        /^([+-]\d{5})/, // 1 additional digit
        /^([+-]\d{6})/ // 2 additional digits
        ],
        // date tokens
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        // timezone tokens (to identify the presence of a tz)
        timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If an argument is a string, the function tries to parse it.
       * Function accepts complete ISO 8601 formats as well as partial implementations.
       * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
       * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
       *
       * @param {Date|String|Number} argument - the value to convert
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
       * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // Convert string '2014-02-11T11:30:30' to date:
       * var result = toDate('2014-02-11T11:30:30')
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert string '+02014101' to date,
       * // if the additional number of digits in the extended year format is 1:
       * var result = toDate('+02014101', {additionalDigits: 1})
       * //=> Fri Apr 11 2014 00:00:00
       */

      function toDate(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        if (argument === null) {
          return new Date(NaN);
        }

        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__["a"
        /* default */
        ])(options.additionalDigits);

        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError('additionalDigits must be 0, 1 or 2');
        } // Clone the date


        if (argument instanceof Date || _typeof(argument) === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
          return new Date(argument);
        } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
          return new Date(NaN);
        }

        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date = parseDate(restDateString, year);

        if (isNaN(date)) {
          return new Date(NaN);
        }

        if (date) {
          var timestamp = date.getTime();
          var time = 0;
          var offset;

          if (dateStrings.time) {
            time = parseTime(dateStrings.time);

            if (isNaN(time)) {
              return new Date(NaN);
            }
          }

          if (dateStrings.timezone || options.timeZone) {
            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time));

            if (isNaN(offset)) {
              return new Date(NaN);
            }

            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time + offset));

            if (isNaN(offset)) {
              return new Date(NaN);
            }
          } else {
            // get offset accurate to hour in timezones that change offset
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time));
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time + offset));
          }

          return new Date(timestamp + time + offset);
        } else {
          return new Date(NaN);
        }
      }

      function splitDateString(dateString) {
        var dateStrings = {};
        var array = dateString.split(patterns.dateTimeDelimeter);
        var timeString;

        if (patterns.plainTime.test(array[0])) {
          dateStrings.date = null;
          timeString = array[0];
        } else {
          dateStrings.date = array[0];
          timeString = array[1];
          dateStrings.timezone = array[2];

          if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
          }
        }

        if (timeString) {
          var token = patterns.timezone.exec(timeString);

          if (token) {
            dateStrings.time = timeString.replace(token[1], '');
            dateStrings.timezone = token[1];
          } else {
            dateStrings.time = timeString;
          }
        }

        return dateStrings;
      }

      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns.YYY[additionalDigits];
        var patternYYYYY = patterns.YYYYY[additionalDigits];
        var token; // YYYY or ±YYYYY

        token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

        if (token) {
          var yearString = token[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        } // YY or ±YYY


        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

        if (token) {
          var centuryString = token[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        } // Invalid ISO-formatted year


        return {
          year: null
        };
      }

      function parseDate(dateString, year) {
        // Invalid ISO-formatted year
        if (year === null) {
          return null;
        }

        var token;
        var date;
        var month;
        var week; // YYYY

        if (dateString.length === 0) {
          date = new Date(0);
          date.setUTCFullYear(year);
          return date;
        } // YYYY-MM


        token = patterns.MM.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;

          if (!validateDate(year, month)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month);
          return date;
        } // YYYY-DDD or YYYYDDD


        token = patterns.DDD.exec(dateString);

        if (token) {
          date = new Date(0);
          var dayOfYear = parseInt(token[1], 10);

          if (!validateDayOfYearDate(year, dayOfYear)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, 0, dayOfYear);
          return date;
        } // yyyy-MM-dd or YYYYMMDD


        token = patterns.MMDD.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;
          var day = parseInt(token[2], 10);

          if (!validateDate(year, month, day)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month, day);
          return date;
        } // YYYY-Www or YYYYWww


        token = patterns.Www.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;

          if (!validateWeekDate(year, week)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week);
        } // YYYY-Www-D or YYYYWwwD


        token = patterns.WwwD.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;
          var dayOfWeek = parseInt(token[2], 10) - 1;

          if (!validateWeekDate(year, week, dayOfWeek)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week, dayOfWeek);
        } // Invalid ISO-formatted date


        return null;
      }

      function parseTime(timeString) {
        var token;
        var hours;
        var minutes; // hh

        token = patterns.HH.exec(timeString);

        if (token) {
          hours = parseFloat(token[1].replace(',', '.'));

          if (!validateTime(hours)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR;
        } // hh:mm or hhmm


        token = patterns.HHMM.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseFloat(token[2].replace(',', '.'));

          if (!validateTime(hours, minutes)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
        } // hh:mm:ss or hhmmss


        token = patterns.HHMMSS.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseInt(token[2], 10);
          var seconds = parseFloat(token[3].replace(',', '.'));

          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
        } // Invalid ISO-formatted time


        return null;
      }

      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date = new Date(0);
        date.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date.setUTCDate(date.getUTCDate() + diff);
        return date;
      } // Validation functions


      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }

      function validateDate(year, month, date) {
        if (month < 0 || month > 11) {
          return false;
        }

        if (date != null) {
          if (date < 1) {
            return false;
          }

          var isLeapYear = isLeapYearIndex(year);

          if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }

          if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
            return false;
          }
        }

        return true;
      }

      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }

        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear && dayOfYear > 366) {
          return false;
        }

        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }

        return true;
      }

      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }

        if (day != null && (day < 0 || day > 6)) {
          return false;
        }

        return true;
      }

      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }

        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }

        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 122 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = getTimezoneOffsetInMilliseconds;
      var MILLISECONDS_IN_MINUTE = 60000;

      function getDateMillisecondsPart(date) {
        return date.getTime() % MILLISECONDS_IN_MINUTE;
      }
      /**
       * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
       * They usually appear for dates that denote time before the timezones were introduced
       * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
       * and GMT+01:00:00 after that date)
       *
       * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
       * which would lead to incorrect calculations.
       *
       * This function returns the timezone offset in milliseconds that takes seconds in account.
       */


      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime());
        var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        date.setSeconds(0, 0);
        var hasNegativeUTCOffset = baseTimezoneOffset > 0;
        var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date);
        return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
      }
      /***/

    },
    /* 123 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return EventsMixin;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return withEventsMixin;
      });

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* eslint-disable no-prototype-builtins */

      /**
       * Events Mixin
       *
       * Allow classes to have their own events manager
       *
       * @param {Class} superClass
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var EventsMixin = function EventsMixin(superClass) {
        var _temp;

        return _temp = /*#__PURE__*/function (_superClass) {
          _inherits(_temp, _superClass);

          var _super = _createSuper(_temp);

          function _temp() {
            var _this;

            _classCallCheck(this, _temp);

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            _this = _super.call.apply(_super, [this].concat(args));
            _this.__handlers = {};
            return _this;
          }

          _createClass(_temp, [{
            key: "on",

            /**
             * Register an event handler
             *
             * @param {String} name event name
             * @param {Function} handler handler function
             */
            value: function on(name, handler) {
              this.__handlers[name] = this.__handlers[name] || [];

              this.__handlers[name].push(handler);
            }
            /**
             * Remove an event handler
             *
             * **Note :** if handler is not provided then all registered handler for the given event will be removed
             *
             * @param {String} name event name
             * @param {Function} handler handler function
             */

          }, {
            key: "off",
            value: function off(name, handler) {
              this.__handlers[name] = this.__handlers[name] || [];

              if (!handler) {
                delete this.__handlers[name];
              } else {
                for (var registeredHandler in this.__handlers) {
                  if (this.__handlers.hasOwnProperty(registeredHandler) && this.__handlers[registeredHandler] === handler) {
                    delete this.__handlers[name];
                  }
                }
              }
            }
            /**
             * Notify handlers
             *
             * @param {String} name event name
             * @param {Object} event payload
             */

          }, {
            key: "notify",
            value: function notify(name, payload) {
              var handlers = this.__handlers[name] || [];
              handlers.forEach(function (handler) {
                handler(payload);
              });
            }
          }]);

          return _temp;
        }(superClass), _temp;
      };
      /**
       * An events mixin decorator
       *
       * @param {Class} superClass
       *
       * @see {EventsMixin}
       */


      function withEventsMixin(superClass) {
        return EventsMixin(superClass);
      }
      /* unused harmony default export */


      var _unused_webpack_default_export = EventsMixin;
      /***/
    },
    /* 124 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__ = __webpack_require__(37);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__EventsMixin__ = __webpack_require__(40);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__Component__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__style_scss__ = __webpack_require__(125);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_5__style_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__style_scss__);

      var _class, _class2, _init, _class3, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * DateTimeInput
       *
       * Simple DateTimeInput component which integrates the flatpickr
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeInput = Object(__WEBPACK_IMPORTED_MODULE_3__EventsMixin__["a"
      /* withEventsMixin */
      ])(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Component) {
        _inherits(DateTimeInput, _Component);

        var _super = _createSuper(DateTimeInput);
        /**
         * Constant which describes the event name that will be fired when a date
         * is selected using the date picker
         *
         * @type {String}
         */

        /**
         * The date picker instance
         *
         * @type {FlatpickrFn}
         */

        /**
         * The last selected date
         *
         * @type {Date|null}
         */

        /**
         * The component received params when init is called
         *s
         * @type {Object}
         */

        /**
         * Construct new DateTimeInput
         *
         * @param {Boolean} isEditor when true , the input will styled to fit as a cell editor
         */


        function DateTimeInput() {
          var _this;

          var isEditor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          _classCallCheck(this, DateTimeInput);

          _this = _super.call(this);
          _this.picker = null;
          _this.selectedDate = null;
          _this._params = {};
          _this._gui = document.createElement('div');
          _this._gui.className = 'ag-cell-edit-wrapper';
          _this._gui.innerHTML =
          /* html */
          "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"datetime__input ".concat(isEditor ? 'datetime__input--editor ' : '', " ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n          <input class=\"datetime__input__input ").concat(isEditor ? 'ag-cell-edit-input ' : '', " ag-input-field-input ag-text-field-input\" type=\"text\" data-input>\n          <a class=\"datetime__input__clear\" data-clear>\n            <i class=\"datetime__input__clear__icon ag-icon ag-icon-cross\"></i>\n          </a>    \n      </div>\n    </div>\n    ");
          return _this;
        }
        /**
         * @inheritDoc
         */


        _createClass(DateTimeInput, [{
          key: "init",
          value: function init(params) {
            this._params = params;
            var enableTime = this.getOption('dateTimeEnableTime', params, true);
            var time_24hr = this.getOption('dateTimeEnable24HR', params, true);
            var enableSeconds = this.getOption('dateTimeEnableSeconds', params, false);
            var noCalendar = !this.getOption('dateTimeEnableCalendar', params, true);
            var dateFormat = this.getOption('dateTimeMask', params); // try to generate a default date format based on the options

            if (!dateFormat) {
              dateFormat = noCalendar ? '' : '%Y/%Mz/%Dz';

              if (enableTime) {
                dateFormat += time_24hr ? ' %Hz:%mz' : ' %hz:%mz';

                if (enableSeconds) {
                  dateFormat += ':%sz';
                }
              }
            }

            dateFormat = dateFormat.trim(); // init the date picker

            this.picker = flatpickr(this._gui, {
              wrap: true,
              // allow entering the date manually requires date parsing from string
              // this is a tough thing and requires libs like moment
              allowInput: false,
              onChange: this._onDateChanged,
              formatDate: this.formatDate,
              maxDate: this.getOption('dateTimeMax', params, null),
              minDate: this.getOption('dateTimeMin', params, null),
              defaultHour: this.getOption('dateTimeDefaultHour', params, 12),
              defaultMinute: this.getOption('dateTimeDefaultMinute', params, 0),
              disableMobile: this.getOption('dateTimeDisableMobile', params, false),
              weekNumbers: this.getOption('dateTimeEnableWeekNumber', params, false),
              locale: this._getPickerLocale(),
              noCalendar: noCalendar,
              dateFormat: dateFormat,
              enableTime: enableTime,
              enableSeconds: enableSeconds,
              time_24hr: time_24hr
            }); // force dialog overflow

            this.picker.calendarContainer.classList.add('ag-custom-component-popup');
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this.picker.destroy();
            this.off(DateTimeInput.ON_DATE_CHANGED);
          }
          /**
           * Set the picker date
           *
           * @param {Date|String} value the date value to set
           */

        }, {
          key: "setDate",
          value: function setDate(value) {
            this.picker.setDate(value, true);
          }
          /**
           * Open Picker
           */

        }, {
          key: "open",
          value: function open() {
            this.picker.open();

            this._gui.querySelector('input').focus();
          }
          /**
           * Close picker
           */

        }, {
          key: "close",
          value: function close() {
            this.picker.close();
          }
          /**
           * Reset the picker
           */

        }, {
          key: "reset",
          value: function reset() {
            /** this check because the tests fail here for some reasons  */
            if (this.picker.config) {
              this.picker.clear();
            }
          }
          /**
           * Format the date using `BBj.Masks.Types.date`
           *
           * @param {String} date date as a string
           * @param {String} format BBj date format
           *
           * @return {String} formatted date as string
           */

        }, {
          key: "formatDate",
          value: function formatDate(date, format) {
            var dateTimeFormatter = this.getOption('dateTimeFormatter', this._params);
            var locale = this.getOption('dateTimeLocale', this._params, Intl.DateTimeFormat().resolvedOptions().locale || 'en-US');

            if (dateTimeFormatter) {
              var type = _typeof(dateTimeFormatter);

              var expression = dateTimeFormatter;

              switch (type) {
                case 'string':
                  if (!(expression.indexOf('return') >= 0)) {
                    expression = 'return ' + expression + ';';
                  }

                  return new Function('date', 'format', 'locale', 'DateMask', expression)(date, format, locale, BBj.Masks.DateMask);

                case 'function':
                  return dateTimeFormatter(date, format, locale, BBj.Masks.DateMask);

                default:
                  throw new Error("Invalid dateTimeFormatter defined for column \"".concat(this._params.colDef.field, "\". The formatter should be an expression or plain function"));
              }
            } else {
              if (!format || format && format.indexOf('%') < 0) {
                return;
              }

              return BBj.Masks.DateMask.mask(date, format, locale);
            }
          }
          /**
           * Listen to date picker changes and update the selected date
           *
           * @param {Array} selectedDates  array of selected dates
           */

        }, {
          key: "_onDateChanged",
          value: function _onDateChanged(selectedDates) {
            this.selectedDate = selectedDates[0] || null;
            this.notify(DateTimeInput.ON_DATE_CHANGED, this.selectedDate);
          }
          /**
           * Get picker global localization which will work with any locale
           *
           * @return {Object}
           *
           * https://github.com/flatpickr/flatpickr/blob/master/src/l10n/default.ts
           */

        }, {
          key: "_getPickerLocale",
          value: function _getPickerLocale() {
            var locale = Intl.DateTimeFormat().resolvedOptions().locale || 'en-US';
            var weekDaysShort = [];
            var weekDaysLong = [];

            for (var day = 4; day < 11; day++) {
              var date = new Date(1970, 1 - 1, day);
              weekDaysShort.push(date.toLocaleString(locale, {
                weekday: 'short'
              }).split(',')[0] // the date-time-format-timezone polyfill attach the date also
              );
              weekDaysLong.push(date.toLocaleString(locale, {
                weekday: 'long'
              }).split(',')[0] // the date-time-format-timezone polyfill attach the date also
              );
            }

            var monthsShort = [];
            var monthsLong = [];

            for (var month = 0; month < 12; month++) {
              var _date = new Date(1970, month, 4);

              monthsShort.push(_date.toLocaleString(locale, {
                month: 'short'
              }));
              monthsLong.push(_date.toLocaleString(locale, {
                month: 'long'
              }));
            }

            return {
              weekdays: {
                shorthand: weekDaysShort,
                longhand: weekDaysLong
              },
              months: {
                shorthand: monthsShort,
                longhand: monthsLong
              },
              daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
              firstDayOfWeek: BBj.Masks.Utils.Dates.getWeekStartByLocale(locale),
              // eslint-disable-next-line no-unused-vars
              ordinal: function ordinal(number) {
                return '';
              },
              rangeSeparator: '  ',
              weekAbbreviation: '',
              scrollTitle: '',
              toggleTitle: '',
              amPM: ['AM', 'PM'],
              yearAriaLabel: '',
              hourAriaLabel: '',
              minuteAriaLabel: ''
            };
          }
        }]);

        return DateTimeInput;
      }(__WEBPACK_IMPORTED_MODULE_4__Component__["a"
      /* default */
      ]), _class3.ON_DATE_CHANGED = 'DateTimeInput.ON_DATE_CHANGED', _temp), (_applyDecoratedDescriptor(_class2, "ON_DATE_CHANGED", [__WEBPACK_IMPORTED_MODULE_2_core_decorators_src_readonly__["a"
      /* default */
      ]], (_init = Object.getOwnPropertyDescriptor(_class2, "ON_DATE_CHANGED"), _init = _init ? _init.value : undefined, {
        enumerable: true,
        configurable: true,
        writable: true,
        initializer: function initializer() {
          return _init;
        }
      }), _class2), _applyDecoratedDescriptor(_class2.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "init"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "destroy"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "formatDate", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "formatDate"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "_onDateChanged", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class2.prototype, "_onDateChanged"), _class2.prototype)), _class2)) || _class;
      /* harmony default export */


      __webpack_exports__["a"] = DateTimeInput;
      /***/
    },
    /* 125 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(126);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 126 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".datetime__input{display:flex;align-items:center;width:100%;height:100%;overflow:hidden;border:1px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));border-radius:3px}.datetime__input:focus,.datetime__input:active,.datetime__input:hover{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.datetime__input__input{flex:1;padding:6px;border:none;outline:none;background-color:var(--ag-background-color);color:inherit}.ag-theme-alpine .datetime__input__input,.ag-theme-balham .datetime__input__input,.ag-theme-material .datetime__input__input{background-color:var(--ag-background-color, #fff)}.ag-theme-alpine-dark .datetime__input__input,.ag-theme-balham-dark .datetime__input__input{background-color:var(--ag-background-color, #2d3436)}.datetime__input__clear{margin-left:1px;margin-top:1px;padding:6px;text-align:center;border:none;outline:none;cursor:pointer;color:inherit}.datetime__input--editor{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.datetime__input--editor .datetime__input__input{padding:0;padding-left:6px}\n", ""]); // exports

      /***/
    },
    /* 127 */

    /***/
    function (module, exports, __webpack_require__) {
      var content = __webpack_require__(128);

      if (typeof content === 'string') content = [[module.i, content, '']];
      var transform;
      var insertInto;
      var options = {
        "hmr": true
      };
      options.transform = transform;

      options.insertInto = function () {
        return window.parent.document.head;
      };

      var update = __webpack_require__(4)(content, options);

      if (content.locals) module.exports = content.locals;

      if (false) {}
      /***/

    },
    /* 128 */

    /***/
    function (module, exports, __webpack_require__) {
      exports = module.exports = __webpack_require__(3)(false); // imports
      // module

      exports.push([module.i, ".dateTimeFilter select{margin-bottom:9px;padding:6px;border-radius:3px;border:1px solid var(--ag-input-border-color, var(--ag-border-color, #babfc7));color:inherit}.dateTimeFilter select:focus,.dateTimeFilter select:active{border-color:var(--ag-input-focus-border-color, rgba(33,150,243,0.4))}.dateTimeFilter select option{text-indent:6px}\n", ""]); // exports

      /***/
    },
    /* 129 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateTimeEditor__ = __webpack_require__(130);
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__DateTimeEditor__["a"
      /* default */
      ];
      /***/
    },
    /* 130 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2_date_fns_tz_utcToZonedTime__ = __webpack_require__(38);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__DateTimeInput__ = __webpack_require__(41);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_4__Component__ = __webpack_require__(0);

      var _class, _temp;

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof(obj) {
            return typeof obj;
          };
        } else {
          _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) _setPrototypeOf(subClass, superClass);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();

        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived),
              result;

          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;

            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }

          return _possibleConstructorReturn(this, result);
        };
      }

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }

        return _assertThisInitialized(self);
      }

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
        var desc = {};
        Object.keys(descriptor).forEach(function (key) {
          desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;

        if ('value' in desc || desc.initializer) {
          desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
          return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0) {
          desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
          desc.initializer = undefined;
        }

        if (desc.initializer === void 0) {
          Object.defineProperty(target, property, desc);
          desc = null;
        }

        return desc;
      }
      /*
       * This file is part of basis-aggrid-components lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * DateTimeInput
       *
       * Simple DateTimeInput component which integrates the flatpickr
       *
       * ## Options
       *
       * | Name                  	| Default     	| Description                                                                                                                    	|
       * |-------------------------	|:-------------:|--------------------------------------------------------------------------------------------------------------------------------|
       * | **dateTimeEnableTime**   | false    | enable / disable time
       * | **dateTimeEnable24HR**   | false    | enable / disable time 24 format
       * | **dateTimeEnableSeconds**   | false    | enable / disable seconds management
       * | **dateTimeEnableCalendar**   | false    | enable / disable Calendar.
       * | **dateTimeMask**   | false    | The mask used to format the selected date
       * | **dateTimeMax**   | undefined    |  Max allowed date
       * | **dateTimeMin**   | undefined    |  Min allowed date
       * | **dateTimeFormatter**   | false    |  A function or expression to format the date (@see supported param)
       * | **dateTimeLocale**   | System default    |  A locale to use for date formatting
       * | **dateTimeDefaultHour**   | 12    |  Initial value of the hour element.
       * | **dateTimeDefaultMinute**   | 0    |  Initial value of the minute element.
       * | **dateTimeDisableMobile**   | false    |  Set disableMobile to true to always use the non-native picker.
       * | **dateTimeEnableWeekNumber**   | true    |  Enables display of week numbers in calendar.
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateTimeEditor = (_class = (_temp = /*#__PURE__*/function (_Component) {
        _inherits(DateTimeEditor, _Component);

        var _super = _createSuper(DateTimeEditor);

        function DateTimeEditor() {
          var _this;

          _classCallCheck(this, DateTimeEditor);

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this = _super.call.apply(_super, [this].concat(args));
          _this._input = new __WEBPACK_IMPORTED_MODULE_3__DateTimeInput__["a"
          /* default */
          ](true);
          _this._value = null;
          _this._params = null;
          return _this;
        }

        _createClass(DateTimeEditor, [{
          key: "init",

          /**
           * @inheritDoc
           */
          value: function init(params) {
            this._params = params;
            this.focusAfterAttached = params.cellStartedEdit;

            if (this.focusAfterAttached) {
              var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

              if (keyPressBackspaceOrDelete) {
                this._value = '';
              } else if (params.charPress !== null) {
                this._value = params.charPress;
              } else {
                this._value = params.value;

                if (params.keyPress != 113) {
                  //F2
                  this.highlightAllOnFocus = true;
                }
              }
            } else {
              this._value = params.value;
            }

            this._value = DateTimeEditor.fixShortISO(this._value);

            this._input.init(params);

            this._input.on(__WEBPACK_IMPORTED_MODULE_3__DateTimeInput__["a"
            /* default */
            ].ON_DATE_CHANGED, this._onDateChange);

            if (this._value) {
              this._input.setDate(Object(__WEBPACK_IMPORTED_MODULE_2_date_fns_tz_utcToZonedTime__["a"
              /* default */
              ])(this._value, BBj.Masks.Utils.Dates.getTimezoneOrOffset()));
            }

            this._gui = this._input.getGui();
          }
          /**
           * @inheritDoc
           */

        }, {
          key: "destroy",
          value: function destroy() {
            this._input.destroy();
          }
          /**
           * Gets called once after GUI is attached to DOM.
           * Make sure the container is always focused and listening to key changes
           */

        }, {
          key: "afterGuiAttached",
          value: function afterGuiAttached() {
            if (this.focusAfterAttached) {
              this.focusIn();
            }
          }
          /**
           * Get the final value to the grid, the result of the editing
           *
           * @return {Boolean}
           */

        }, {
          key: "getValue",
          value: function getValue() {
            return this._params.parseValue(this._value);
          }
          /**
           * Gets called once after initialized and returns false so the editor appears in the cell
           *
           * @return {Boolean} always false
           **/

        }, {
          key: "isPopup",
          value: function isPopup() {
            return false;
          }
          /**
           * If doing full row edit, then gets called when tabbing into the cell.
           */

        }, {
          key: "focusIn",
          value: function focusIn() {
            this._input.open();
          }
          /**
           * If doing full row edit, then gets called when tabbing out of the cell.
           */

        }, {
          key: "focusOut",
          value: function focusOut() {
            this._input.close();
          }
          /**
           * Update the editor value with selected date from the input
           *
           * @param {String} date
           */

        }, {
          key: "_onDateChange",
          value: function _onDateChange(date) {
            this._value = date instanceof Date ? date.toISOString() : '';
          }
        }], [{
          key: "fixShortISO",

          /**
           * Takes incomplete iso string and return a complete one
           *
           * @param {String} date incomplete iso string
           *
           * @return {String} complete iso string
           */
          value: function fixShortISO(value) {
            return BBj.Masks.Utils.Dates.fixShortISO(value);
          }
        }]);

        return DateTimeEditor;
      }(__WEBPACK_IMPORTED_MODULE_4__Component__["a"
      /* default */
      ]), _temp), (_applyDecoratedDescriptor(_class.prototype, "init", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "init"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "destroy", [__WEBPACK_IMPORTED_MODULE_1_core_decorators_src_override__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "destroy"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "_onDateChange", [__WEBPACK_IMPORTED_MODULE_0_core_decorators_src_autobind__["a"
      /* default */
      ]], Object.getOwnPropertyDescriptor(_class.prototype, "_onDateChange"), _class.prototype)), _class);
      /* harmony default export */

      __webpack_exports__["a"] = DateTimeEditor;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/basis-input-masking/dist/basis-input-masking.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/basis-input-masking/dist/basis-input-masking.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(/*! bbj-masks/src/StringMask */ "./node_modules/bbj-masks/src/StringMask/index.js"), __webpack_require__(/*! bbj-masks/src/NumberMask */ "./node_modules/bbj-masks/src/NumberMask/index.js"));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! bbj-masks/src/StringMask */ "./node_modules/bbj-masks/src/StringMask/index.js"), __webpack_require__(/*! bbj-masks/src/NumberMask */ "./node_modules/bbj-masks/src/NumberMask/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function (__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_7__) {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 1);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE_0__;
      /***/
    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextInput__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__NumberInput__ = __webpack_require__(5);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "TextInput", function () {
        return __WEBPACK_IMPORTED_MODULE_0__TextInput__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberInput", function () {
        return __WEBPACK_IMPORTED_MODULE_1__NumberInput__["a"];
      });
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /***/

    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__TextInput__ = __webpack_require__(3);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__TextInput__["a"
      /* default */
      ];
      /***/
    },
    /* 3 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__tools_js__ = __webpack_require__(4);

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * The `TextInput` will wrap text inputs and apply the given [bbj string mask](https://github.com/BasisHub/bbj-masks#string-masks)
       *
       * **Options**
       *
       * _Options can be passed via data attributes . For data attributes, append the option name to data-, as in data-mask_
       *
       * | Option    | Default | Description                                                                                             |
       * |-----------|---------|---------------------------------------------------------------------------------------------------------|
       * | mask |         | The bbj string mask @see [BBj String Masks](https://github.com/BasisHub/bbj-masks#string-masks) |
       *
       *  <br>
       *
       * **Example :**
       * ```html
       *  <input class="bbj-text-masked" name="test" id="test" value="ed23" data-mask="AA-00">
       *
       *  <script>
       *    document.addEventListener('DOMContentLoaded', function (e) {
       *      new Basis.InputMasking.TextInput({
       *         onUpdate: (maskedValue , rawValue , input) => {
       *            // do something
       *         },
       *         onInvalid: (err , input) => {
       *            // do something
       *         }
       *      })
       *    })
       *  </script>
       * ```
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var TextInput = /*#__PURE__*/function () {
        /**
         * Construct new TextInput
         *
         * @param {?Object} options - The input options.
         * @param {HTMLElement|String} [options.elements=".bbj-text-masked"] - The class name or the node to use
         * @param {HTMLDocument} [options.document=document] - Document instance to use
         * @param {String} [options.cssClassError="bbj-mask-error"] - A css class to attach to the input when it is invalid
         * @param {String} [options.cssClassSuccess="bbj-mask-success"] - A css class to attach to the input when it is valid after the user interaction
         * @param {Function} [options.onUpdate=null] - A callback to be called on the new masked value is set
         * @param {Function} [options.onInvalid=null] - A callback to be called on the input or the mask is invalid
         */
        function TextInput() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, TextInput);

          this.options = _objectSpread({}, {
            elements: '.bbj-text-masked',
            doc: document,
            cssClassError: 'bbj-mask-error',
            cssClassSuccess: 'bbj-mask-success',
            onUpdate: null,
            onInvalid: null
          }, {}, options);
          this._onKeystroke = this._onKeystroke.bind(this);
          this._onFocus = this._onFocus.bind(this);
          this.refresh();
        }
        /**
         * Initialize the component and wrap the input elements for masking in case
         * they are not wrapped yet
         */


        _createClass(TextInput, [{
          key: "refresh",
          value: function refresh() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];

              if (input instanceof HTMLInputElement) {
                parentClass = input.parentNode.getAttribute('class');

                if (!input.getAttribute('id')) {
                  console.warn("BBjMasking: Input has no ID. Without an ID the input cannot be masked", input);
                  continue;
                } // we don't initialize the input's wrap twice


                var isWrapped = parentClass && parentClass.indexOf('textInputMask__wrap') > -1;

                this._wrap(input, isWrapped);
              } else {
                console.warn("BBjMasking: Invalid input element. The element will be ignored", input);
              }
            }
          }
          /**
           * Unwrap the input elements and remove attached listeners
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parent, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];
              parent = input.parentNode;
              parentClass = parent.getAttribute('class');

              if (parentClass && parentClass.indexOf('textInputMask__wrap') > -1) {
                this._unwrap(parent);
              }
            }
          }
          /**
           * Create the text masking input wrapper
           *
           * @param {HTMLInputElement} input the input element
           * @param {Boolean} isWrapped when true the input is already wrapped and we need to add what is
           *                            missing only
           *
           * @returns {HTMLSpanElement} the wrap element
           *
           * @protected
           */

        }, {
          key: "_wrap",
          value: function _wrap(input, isWrapped) {
            var inputId = input.getAttribute('id'),
                inputName = input.getAttribute('name'),
                mask = input.dataset.mask || '',
                originalPattern = input.pattern,
                defaultPattern = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["b"
            /* generatePatternFromMask */
            ])(mask),
                pattern = originalPattern || defaultPattern;
            var wrap = null,
                unmaskInput = null;

            if (!isWrapped) {
              wrap = this.options.doc.createElement('span');
              unmaskInput = this.options.doc.createElement('input'); // hidden input with the unmasked values for forms
            } else {
              wrap = input.parentNode;
              unmaskInput = wrap.querySelector('.textInputMask__unmaskedInput');
            } // configure the actual input
            // -----------------------------------------------------


            input.value = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["c"
            /* maskIfNotMasked */
            ])(input.value, mask);
            input.pattern = pattern;
            input.classList.add('textInputMask__textInput');
            input.dataset.mask = mask;
            input.dataset.valueUnmasked = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["d"
            /* unmask */
            ])(input.value, mask);

            if (originalPattern && originalPattern !== defaultPattern) {
              input.dataset.isCustomPattern = true;
            }

            if (!isWrapped) {
              if (!(input.hasAttribute('readonly') || input.hasAttribute('disable'))) {
                input.addEventListener('keyup', this._onKeystroke);
                input.addEventListener('keypress', this._onKeystroke);
                input.addEventListener('paste', this._onKeystroke);
                input.addEventListener('focusin', this._onFocus);
                input.addEventListener('click', this._onFocus);
              }

              input.parentNode.insertBefore(wrap, input); // move the input outside the wrapper
            }

            if (this._validateInput(input)) {
              this.__fireOnUpdate(input.value, input.dataset.valueUnmasked, input);
            } // configure the unmasked input
            // ----------------------------------------------------


            unmaskInput.setAttribute('aria-hidden', 'true');
            unmaskInput.setAttribute('type', 'hidden');
            unmaskInput.classList.add('textInputMask__unmaskedInput');
            unmaskInput.value = input.dataset.valueUnmasked;
            if (inputId) unmaskInput.setAttribute('id', "".concat(inputId, "-unmasked"));
            if (inputName) unmaskInput.setAttribute('name', "".concat(inputName, "-unmasked"));

            if (!isWrapped) {
              // configure the wrapper
              wrap.setAttribute('class', 'textInputMask__wrap');
              wrap.appendChild(unmaskInput);
              wrap.appendChild(input);
            }

            return wrap;
          }
          /**
           * Unwrap the masked input and remove the value changed listener
           *
           * @param {HTMLSpanElement} textInput the wrapper span instance
           *
           * @protected
           */

        }, {
          key: "_unwrap",
          value: function _unwrap(textInput) {
            textInput.removeChild(textInput.querySelector('.textInputMask__unmaskedInput'));
            var input = textInput.querySelector('.textInputMask__textInput');
            input.removeEventListener('keyup', this._onKeystroke);
            input.removeEventListener('keypress', this._onKeystroke);
            input.removeEventListener('paste', this._onKeystroke);
            input.removeEventListener('focusin', this._onFocus);
            input.removeEventListener('click', this._onFocus);
            delete input.dataset.valueUnmasked;

            if (!input.dataset.isCustomPattern) {
              input.removeAttribute('pattern');
              delete input.dataset.isCustomPattern;
            }

            input.classList.remove(this.options.cssClassError);
            textInput.parentNode.insertBefore(input, textInput);
            textInput.parentNode.removeChild(textInput);
          }
          /**
           * Listen to every keystroke on the input and update the masked and the unmasked value
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_onKeystroke",
          value: function _onKeystroke(e) {
            if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) return;
            if (e.keyCode !== 13) e.preventDefault();
            var input = e.target,
                mask = input.dataset.mask || this.options.mask,
                eventType = e.type;
            input.classList.remove(this.options.cssClassError);
            input.classList.remove(this.options.cssClassSuccess);
            input.setCustomValidity('');
            var value = input.value,
                keyCode = e.keyCode,
                keyContent = e.key || e.code.replace(/[^0-9]/g, ''),
                key = keyContent ? keyContent.length > 1 ? '' : keyContent : '',
                insertPosition = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["a"
            /* findCaretPosition */
            ])(value, mask),
                newValue,
                unmaskedValue,
                maskError = false;

            switch (eventType) {
              case 'paste':
                newValue = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["c"
                /* maskIfNotMasked */
                ])((e.clipboardData || window.clipboardData).getData('Text'), mask);
                break;

              case 'keyup':
                newValue = value;
                break;

              case 'keypress':
                var selectionStart = input.selectionStart;
                if (selectionStart !== insertPosition) insertPosition = selectionStart;
                newValue = value.substr(0, insertPosition) + key + value.substr(insertPosition);
                break;

              default:
                break;
            }

            unmaskedValue = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["d"
            /* unmask */
            ])(newValue, mask);

            if ([35, 36, 37, 38, 39, 40].indexOf(keyCode) === -1) {
              try {
                input.value = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(unmaskedValue, mask, false);

                if (this._validateInput(input)) {
                  input.dataset.valueUnmasked = unmaskedValue;
                  this.options.doc.querySelector("#".concat(input.getAttribute('id'), "-unmasked")).value = unmaskedValue;

                  this.__applyCssClassState(input, 'success');

                  this.__fireOnUpdate(input.value, input.dataset.valueUnmasked, input);
                }

                maskError = false;
              } catch (error) {
                this.__applyCssClassState(input, 'error');

                this.__fireOnInvalid(error, input);

                maskError = true;
              }

              this._updateCaretPosition(input, mask);
            }

            if (!maskError) this._validateInput(input);
          }
          /**
           * Listen to focus events on the input and update the caret position
           * where the next char should be inserted according to the mask
           *
           * @param {FocusEvent} e
           *
           * @protected
           */

        }, {
          key: "_onFocus",
          value: function _onFocus(e) {
            var input = e.target;
            var mask = input.dataset.mask || this.options.mask;

            this._updateCaretPosition(input, mask);
          }
          /**
           * Update the caret position on the input based on the given mask
           *
           * @param {HTMLInputElement} input instance
           * @param {String} mask  bbj string
           *
           * @protected
           */

        }, {
          key: "_updateCaretPosition",
          value: function _updateCaretPosition(input, mask) {
            setTimeout(function () {
              var position = Object(__WEBPACK_IMPORTED_MODULE_1__tools_js__["a"
              /* findCaretPosition */
              ])(input.value, mask);
              input.setSelectionRange(position, position);
            }, 0);
          }
          /**
           * Trigger `checkValidity` on the input
           *
           * @param {HTMLInputElement} input
           *
           * @returns {Boolean} true when valid , false otherwise
           *
           * @protected
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(input) {
            var isValid = input.checkValidity();

            if (isValid) {
              this.__applyCssClassState(input, 'success');

              input.setCustomValidity('');
            } else {
              this.__applyCssClassState(input, 'error');

              this.__fireOnInvalid(input.validationMessage, input);
            }

            return isValid;
          }
          /**
           * @private
           */

        }, {
          key: "__fireOnUpdate",
          value: function __fireOnUpdate(valueMasked, valueUnmasked, input) {
            if (this.options.onUpdate) {
              this.options.onUpdate(valueMasked, valueUnmasked, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__fireOnInvalid",
          value: function __fireOnInvalid(error, input) {
            if (this.options.onInvalid) {
              this.options.onInvalid(error, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__applyCssClassState",
          value: function __applyCssClassState(input, state) {
            if (input.hasAttribute('readonly') || input.hasAttribute('disabled')) {
              input.classList.remove(this.options.cssClassError);
              input.classList.remove(this.options.cssClassSuccess);
            } else {
              if (state === 'success') {
                input.classList.remove(this.options.cssClassError);
                input.classList.add(this.options.cssClassSuccess);
              }

              if (state === 'error') {
                input.classList.add(this.options.cssClassError);
                input.classList.remove(this.options.cssClassSuccess);
              }
            }
          }
        }]);

        return TextInput;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = TextInput;
      /***/
    },
    /* 4 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export isMaskedValue */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "c", function () {
        return maskIfNotMasked;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return unmask;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return findCaretPosition;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return generatePatternFromMask;
      });
      /* unused harmony export IS_UNICODE_PROPERTY_SUPPORTED */

      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask__);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var SUPPORTED_MASKS = ['X', 'a', 'A', '0', 'z', 'Z', 'U'];
      /**
       * When true , then the browser supports Unicode Property Escapes
       * otherwise it is false 
       * 
       * {@link https://github.com/tc39/proposal-regexp-unicode-property-escapes}
       */

      var IS_UNICODE_PROPERTY_SUPPORTED = false;

      try {
        eval('/\\p{L}/u');
        IS_UNICODE_PROPERTY_SUPPORTED = true;
      } catch (err) {
        IS_UNICODE_PROPERTY_SUPPORTED = false;
      }
      /**
       * Check if the given value is masked with the given mask or not
       *
       * @param {String} value masked or unmasked value
       * @param {String} mask  a bbj mask
       *
       * @return {Boolean} true when the value is masked with given mask , false otherwise
       */


      var isMaskedValue = function isMaskedValue(value, mask) {
        if (typeof isMaskedValue.__CACHE__ === 'undefined') {
          isMaskedValue.__CACHE__ = {};
        }

        var cacheKey = "".concat(value, "-").concat(mask);

        if (!isMaskedValue.__CACHE__[cacheKey]) {
          var unmaskedValue = unmask(value, mask);
          isMaskedValue.__CACHE__[cacheKey] = value === __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(unmaskedValue, mask);
        }

        return isMaskedValue.__CACHE__[cacheKey];
      };
      /**
       * Mask the given value with the given mask in case the value is not already masked with the
       * given mask
       *
       * @param {String} value masked or unmasked value
       * @param {String} mask  a bbj mask
       *
       * @return {String} a masked value
       */


      var maskIfNotMasked = function maskIfNotMasked(value, mask) {
        if (typeof maskIfNotMasked.__CACHE__ === 'undefined') {
          maskIfNotMasked.__CACHE__ = {};
        }

        var cacheKey = "".concat(value, "-").concat(mask);

        if (!maskIfNotMasked.__CACHE__[cacheKey]) {
          if (isMaskedValue(value, mask)) {
            maskIfNotMasked.__CACHE__[cacheKey] = value;
          } else {
            try {
              maskIfNotMasked.__CACHE__[cacheKey] = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask(value, mask, false);
            } catch (e) {
              maskIfNotMasked.__CACHE__[cacheKey] = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_StringMask___default.a.mask('', mask);
            }
          }
        }

        return maskIfNotMasked.__CACHE__[cacheKey];
      };
      /**
       * Generate a regex patter based on the give task
       *
       * @param {String} mask  bbj string mask
       *
       * @return {String} regex for the give mask
       */


      var generatePatternFromMask = function generatePatternFromMask(mask) {
        if (typeof generatePatternFromMask.__CACHE__ === 'undefined') {
          generatePatternFromMask.__CACHE__ = {};
        }

        var cacheKey = mask;

        if (!generatePatternFromMask.__CACHE__[cacheKey]) {
          var maskAsArry = mask.split('');
          var regex = '';
          maskAsArry.forEach(function (c) {
            switch (c) {
              case 'X':
                regex += '([^ -~])';
                break;

              case 'a':
              case 'A':
                // https://mothereff.in/regexpu#input=var+regex+%3D+/%5Cp%7BL%7D/u%3B&unicodePropertyEscape=1
                // https://stackoverflow.com/questions/150033/regular-expression-to-match-non-ascii-characters#answer-48902765
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '\\p{L}' : "((?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              case '0':
                regex += '([0-9])';
                break;

              case 'z':
              case 'Z':
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '([0-9]|\\p{L})' : "([0-9]|(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              case 'U':
                regex += IS_UNICODE_PROPERTY_SUPPORTED ? '(([0-9])|(\\s)|([.,/#!$%^&*;:{}=-_`~()])|(\\p{L}))' : "(([0-9])|(\\s)|([.,/#!$%^&*;:{}=-_`~()])|(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDEC0-\uDEEB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]))";
                break;

              default:
                regex += c.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                break;
            }
          });
          generatePatternFromMask.__CACHE__[cacheKey] = regex;
        }

        return generatePatternFromMask.__CACHE__[cacheKey];
      };
      /**
       * Unmask the given value
       *
       * @param {String} maskedValue masked string
       * @param {String} mask  the used mask to produce the masked string
       */


      var unmask = function unmask(maskedValue, mask) {
        if (typeof unmask.__CACHE__ === 'undefined') {
          unmask.__CACHE__ = {};
        }

        var cacheKey = "".concat(maskedValue, "-").concat(mask);

        if (!unmask.__CACHE__[cacheKey]) {
          var maskAsArray = mask.split('');
          var maskedValueAsArray = maskedValue.split('');
          var unmasked = '';

          for (var index = 0; index < maskedValueAsArray.length; index++) {
            var el = maskedValueAsArray[index];
            var _mask = maskAsArray[index];
            var elHasMask = SUPPORTED_MASKS.indexOf(_mask) > -1;

            if (elHasMask) {
              var pattern = new RegExp(generatePatternFromMask(_mask), IS_UNICODE_PROPERTY_SUPPORTED ? 'u' : '');
              if (pattern.test(el)) unmasked += el;else break;
            }
          }

          unmask.__CACHE__[cacheKey] = unmasked.toLocaleLowerCase();
        }

        return unmask.__CACHE__[cacheKey];
      };
      /**
       * Given the masked string , find the next caret position depending on
       * what is missing to complete the mask
       *
       * @param {String} maskedValue masked string
       * @param {String} mask  the used mask to produce the masked string
       */


      var findCaretPosition = function findCaretPosition(maskedValue, mask) {
        if (typeof findCaretPosition.__CACHE__ === 'undefined') {
          findCaretPosition.__CACHE__ = {};
        }

        var cacheKey = "".concat(maskedValue, "-").concat(mask);

        if (!findCaretPosition.__CACHE__[cacheKey]) {
          var maskAsArray = mask.split('');
          var maskedValueAsArray = maskedValue.split('');

          if (maskedValueAsArray.length < maskAsArray.length) {
            maskedValueAsArray = maskedValueAsArray.concat(new Array(maskAsArray.length - maskedValueAsArray.length).join(' ').split(''));
          }

          var position = -1;

          for (var index = 0; index < maskAsArray.length; index++) {
            var el = maskAsArray[index];

            if (el !== maskedValueAsArray[index]) {
              // if (maskedValueAsArray[index] === ' ') return index
              if (SUPPORTED_MASKS.indexOf(el) > -1) {
                var pattern = new RegExp(generatePatternFromMask(el), IS_UNICODE_PROPERTY_SUPPORTED ? 'u' : '');

                if (!pattern.test(maskedValueAsArray[index])) {
                  position = index;
                  break;
                }
              }
            }
          }

          findCaretPosition.__CACHE__[cacheKey] = position < 0 ? maskedValueAsArray.length : position;
        }

        return findCaretPosition.__CACHE__[cacheKey];
      };
      /***/

    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberInput__ = __webpack_require__(6);
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberInput__["a"
      /* default */
      ];
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask__ = __webpack_require__(7);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask__);

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of basis-input-masking lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var countDecimals = function countDecimals(value) {
        if (value % 1 != 0) {
          var split = value.toString().split('.');
          if (split.length === 2) return split[1].length;
        }

        return 0;
      };
      /**
       * The `NumberInput` will wrap text inputs and apply the given [bbj Number mask](https://github.com/BasisHub/bbj-masks#number-masks)
       *
       * **Options**
       *
       * _Options can be passed via data attributes . For data attributes, append the option name to data-, as in data-mask_
       *
       * | Option    | Default | Description                                                                                             |
       * |-----------|---------|---------------------------------------------------------------------------------------------------------|
       * | mask |         | The bbj number mask @see [BBj Number Masks](https://github.com/BasisHub/bbj-masks#number-masks) |
       * | min |         | The maximum value to accept for this input|
       * | max |         | The minimum value to accept for this input|
       * | step |         | A stepping interval to use when using up and down arrows to adjust the value, as well as for validation|
       * |grouping-separator | , | a char which will be used as a grouping separator |
       * |decimal-separator | . | a char which will be used as a decimal separator |
       * |force-trailing-zeros | false | Affects the output by switching the way a mask with "#" characters in the trailing positions is filled. for example, the function NumberMask.mask(.10:"#.##") returns .10 instead of .1|
       *
       *  <br>
       *
       * **Example :**
       * ```html
       *  <input class="bbj-number-masked" name="test" id="test" value="1234" data-mask="##,##0">
       *
       *  <script>
       *    document.addEventListener('DOMContentLoaded', function (e) {
       *      new Basis.InputMasking.NumberInput({
       *
       *         // @param {String} valueMasked  masked value
       *         // @param {Number} valueUnmasked  original value
       *         // @param {HTMLInputElement} input the actual input instance
       *         onUpdate: (valueMasked, valueUnmasked, input, isApplied, isInitial) => {
       *            // do something
       *         },
       *
       *         // @param {String|Object} error last occurred error. could be mask error or validation error
       *         // @param {HTMLInputElement} input the actual input instance
       *         onInvalid: (err , input) => {
       *            // do something
       *         }
       *      })
       *    })
       *  </script>
       * ```
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberInput = /*#__PURE__*/function () {
        /**
         * Construct new NumberInput
         *
         * @param {?Object} options - The input options.
         * @param {HTMLElement|String} [options.elements=".bbj-number-masked"] - The class name or the node to use
         * @param {HTMLDocument} [options.document=document] - Document instance to use
         * @param {String} [options.cssClassError="bbj-mask-error"] - A css class to attach to the input when it is invalid
         * @param {String} [options.cssClassSuccess="bbj-mask-success"] - A css class to attach to the input when it is valid after the user interaction
         * @param {Function} [options.onUpdate=null] - A callback to be called on the new masked value is set
         * @param {Function} [options.onInvalid=null] - A callback to be called on the input or the mask is invalid
         */
        function NumberInput() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, NumberInput);

          this.options = _objectSpread({}, {
            elements: '.bbj-number-masked',
            doc: document,
            cssClassError: 'bbj-mask-error',
            cssClassSuccess: 'bbj-mask-success',
            onUpdate: null,
            onInvalid: null
          }, {}, options);
          this._actualInputHandler = this._actualInputHandler.bind(this);
          this._unmaskedInputHandler = this._unmaskedInputHandler.bind(this);
          this.refresh();
        }
        /**
         * Initialize the component and wrap the input elements for masking in case
         * they are not wrapped yet
         */


        _createClass(NumberInput, [{
          key: "refresh",
          value: function refresh() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];

              if (input instanceof HTMLInputElement) {
                parentClass = input.parentNode.getAttribute('class');

                if (!input.getAttribute('id')) {
                  console.warn("BBjMasking: Input has no ID. Without an ID the input cannot be masked", input);
                  continue;
                } // we don't initialize the input's wrap twice


                var isWrapped = parentClass && parentClass.indexOf('numberInputMask__wrap') > -1;

                this._wrap(input, isWrapped);
              } else {
                console.warn("BBjMasking: Invalid input element. The element will be ignored", input);
              }
            }
          }
          /**
           * Unwrap the input elements and remove attached listeners
           */

        }, {
          key: "destroy",
          value: function destroy() {
            var elements = typeof this.options.elements === 'string' ? this.options.doc.querySelectorAll(this.options.elements) : this.options.elements;
            var input, parent, parentClass;

            for (var i = 0; i < elements.length; i++) {
              input = elements[i];
              parent = input.parentNode;
              parentClass = parent.getAttribute('class');

              if (parentClass && parentClass.indexOf('numberInputMask__wrap') > -1) {
                this._unwrap(parent);
              }
            }
          }
          /**
           * Create the number masking input wrapper
           *
           * @param {HTMLInputElement} actualInput the input element
           * @param {Boolean} isWrapped when true the input is already wrapped and we need to add what is
           *                            missing only
           *
           * @returns {HTMLSpanElement} wrapper instance
           *
           * @protected
           */

        }, {
          key: "_wrap",
          value: function _wrap(actualInput, isWrapped) {
            var actualInputId = actualInput.getAttribute('id'),
                actualInputName = actualInput.getAttribute('name'),
                actualInputStep = actualInput.dataset.step || null,
                actualInputMax = actualInput.dataset.max || null,
                actualInputMin = actualInput.dataset.min || null,
                actualInputGroupingSeparator = actualInput.dataset.groupingSeparator || ',',
                actualInputDecimalSeparator = actualInput.dataset.decimalSeparator || '.',
                actualInputForceTrailingZeros = actualInput.dataset.forceTrailingZeros || null,
                actualInputMask = actualInput.dataset.mask || '',
                actualInputClasses = actualInput.getAttribute('class'),
                actualInputRequired = actualInput.getAttribute('required') || null;
            var wrap = null,
                unmaskedInput = null;

            if (!isWrapped) {
              wrap = this.options.doc.createElement('span');
              unmaskedInput = this.options.doc.createElement('input'); // hidden input with the unmasked values for forms
            } else {
              wrap = actualInput.parentNode;
              unmaskedInput = wrap.querySelector('.numberInputMask__unmaskedInput');
            } // configure the actual input
            // -----------------------------------------------------


            if (!isWrapped) {
              actualInput.parentNode.insertBefore(wrap, actualInput); // move the input outside the wrapper

              if (!(actualInput.hasAttribute('readonly') || actualInput.hasAttribute('disabled'))) {
                actualInput.addEventListener('click', this._actualInputHandler);
                actualInput.addEventListener('focusin', this._actualInputHandler);
              }
            }

            actualInput.dataset.valueUnmasked = actualInput.value || 0;
            actualInput.dataset.groupingSeparator = actualInputGroupingSeparator;
            actualInput.dataset.decimalSeparator = actualInputDecimalSeparator;
            actualInput.dataset.forceTrailingZeros = actualInputForceTrailingZeros;
            actualInput.value = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default.a.mask(actualInput.dataset.valueUnmasked, actualInputMask, actualInputGroupingSeparator, actualInputDecimalSeparator, actualInputForceTrailingZeros).trim();
            actualInput.classList.add('numberInputMask__textInput', this.options.cssClassSuccess); // configure the unmasked input
            // ----------------------------------------------------

            unmaskedInput.value = actualInput.dataset.valueUnmasked;
            unmaskedInput.setAttribute('aria-hidden', 'true');
            unmaskedInput.setAttribute('type', 'hidden');
            unmaskedInput.setAttribute('class', actualInputClasses);
            if (actualInputId) unmaskedInput.setAttribute('id', "".concat(actualInputId, "-unmasked"));
            if (actualInputName) unmaskedInput.setAttribute('name', "".concat(actualInputName, "-unmasked"));
            if (actualInputRequired) unmaskedInput.setAttribute('required', 'required');
            if (actualInputStep) unmaskedInput.setAttribute('step', actualInputStep);else {
              var decimals = countDecimals(unmaskedInput.value);
              var step = '1';

              if (decimals > 0) {
                step = ".".concat(Array(decimals).join('0'), "1");
              }

              unmaskedInput.setAttribute('step', step);
            }
            if (actualInputMin) unmaskedInput.setAttribute('min', actualInputMin);
            if (actualInputMax) unmaskedInput.setAttribute('max', actualInputMax);
            unmaskedInput.dataset.inputId = actualInputId;
            unmaskedInput.dataset.mask = actualInputMask;
            unmaskedInput.dataset.groupingSeparator = actualInputGroupingSeparator;
            unmaskedInput.dataset.decimalSeparator = actualInputDecimalSeparator;
            if (actualInputForceTrailingZeros) unmaskedInput.dataset.forceTrailingZeros = actualInputForceTrailingZeros;

            if (!isWrapped) {
              unmaskedInput.classList.add('numberInputMask__unmaskedInput');
              unmaskedInput.addEventListener('keydown', this._unmaskedInputHandler);
              unmaskedInput.addEventListener('keyup', this._unmaskedInputHandler);
              unmaskedInput.addEventListener('focusout', this._unmaskedInputHandler); // configure the wrapper

              wrap.setAttribute('class', 'numberInputMask__wrap');
              wrap.appendChild(unmaskedInput);
              wrap.appendChild(actualInput);
            }

            if (!isNaN(Number(actualInput.dataset.valueUnmasked))) {
              if (this._validateInput(unmaskedInput, actualInput)) {
                this.__fireOnUpdate(actualInput.value, actualInput.dataset.valueUnmasked, actualInput);
              }
            } else {
              actualInput.classList.add(this.options.cssClassError);
            }

            return wrap;
          }
          /**
           * Unwrap the masked input and remove the value changed listener
           *
           * @param {HTMLSpanElement} wrapper the wrapper span instance
           *
           * @protected
           */

        }, {
          key: "_unwrap",
          value: function _unwrap(wrapper) {
            var actualInput = wrapper.querySelector('.numberInputMask__textInput'),
                actualInputId = actualInput.id,
                unmaskedInput = wrapper.querySelector("#".concat(actualInputId, "-unmasked"));
            unmaskedInput.removeEventListener('keyup', this._unmaskedInputHandler);
            unmaskedInput.removeEventListener('keypress', this._unmaskedInputHandler);
            unmaskedInput.removeEventListener('focusout', this._unmaskedInputHandler);
            wrapper.removeChild(unmaskedInput);
            actualInput.removeEventListener('click', this._actualInputHandler);
            actualInput.removeEventListener('focusin', this._actualInputHandler);
            actualInput.classList.remove('numberInputMask__textInput');
            actualInput.classList.remove(this.options.cssClassError);
            actualInput.classList.remove(this.options.cssClassSuccess);
            delete actualInput.dataset.valueUnmasked;
            wrapper.parentNode.insertBefore(actualInput, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
          /**
           * Listen to click and focusin event on the actual input and toggle the number input
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_actualInputHandler",
          value: function _actualInputHandler(e) {
            var actualInput = e.target,
                actualInputId = actualInput.id,
                unmaskedInput = this.options.doc.querySelector("#".concat(actualInputId, "-unmasked"));
            actualInput.setAttribute('aria-hidden', 'true');
            actualInput.setAttribute('type', 'hidden');
            unmaskedInput.removeAttribute('aria-hidden');
            unmaskedInput.setAttribute('type', 'number');

            this._validateInput(unmaskedInput, actualInput);

            setTimeout(function () {
              unmaskedInput.focus();
              var length = String(unmaskedInput.value).length;
              unmaskedInput.type = 'text';
              unmaskedInput.setSelectionRange(length, length);
              unmaskedInput.type = 'number';
            }, 0);
          }
          /**
           * Listen to the unmasked input keydown and focusout events and check
           * if the input value can be masked or not
           *
           * @param {Event} e
           *
           * @protected
           */

        }, {
          key: "_unmaskedInputHandler",
          value: function _unmaskedInputHandler(e) {
            var unmaskedInput = e.target,
                keyCode = e.keyCode,
                mask = unmaskedInput.dataset.mask,
                groupingSeparator = unmaskedInput.dataset.groupingSeparator,
                decimalSeparator = unmaskedInput.dataset.decimalSeparator,
                forceTrailingZeros = unmaskedInput.dataset.forceTrailingZeros,
                actualInputId = unmaskedInput.dataset.inputId,
                actualInput = this.options.doc.querySelector("#".concat(actualInputId));

            var restore = false,
                apply = false,
                maskedValue = false,
                isValid = this._validateInput(unmaskedInput, actualInput);

            try {
              maskedValue = __WEBPACK_IMPORTED_MODULE_0_bbj_masks_src_NumberMask___default.a.mask(unmaskedInput.value || 0, mask, groupingSeparator, decimalSeparator, forceTrailingZeros, false).trim();
            } catch (e) {
              maskedValue = false;

              this.__applyCssClassState(unmaskedInput, actualInput, 'error');

              this.__fireOnInvalid(e, actualInput);
            }

            restore = [13, 27].indexOf(keyCode) > -1 || e.type === 'focusout';
            apply = maskedValue && isValid;

            if (restore) {
              unmaskedInput.classList.remove(this.options.cssClassError);
              unmaskedInput.classList.remove(this.options.cssClassSuccess);
              unmaskedInput.setAttribute('aria-hidden', 'true');
              unmaskedInput.setAttribute('type', 'hidden');
              actualInput.removeAttribute('aria-hidden');
              actualInput.setAttribute('type', 'text');
              actualInput.classList.add(this.options.cssClassSuccess);

              if (apply) {
                actualInput.value = maskedValue;
                actualInput.dataset.valueUnmasked = unmaskedInput.value;

                this.__fireOnUpdate(maskedValue, unmaskedInput.value, actualInput);
              } else {
                unmaskedInput.value = actualInput.dataset.valueUnmasked;

                this.__applyCssClassState(unmaskedInput, actualInput, 'success');
              }
            }
          }
          /**
           * Trigger `checkValidity` on the input
           *
           * @param {HTMLInputElement} unmaskedInput
           * @param {HTMLInputElement} actualInput
           *
           * @returns {Boolean} true when valid , false otherwise
           *
           * @protected
           */

        }, {
          key: "_validateInput",
          value: function _validateInput(unmaskedInput, actualInput) {
            var isValid = true;
            var value = Number(unmaskedInput.value);

            if (unmaskedInput.getAttribute('type') === 'hidden' && !isNaN(value)) {
              var max = unmaskedInput.getAttribute('max');
              var min = unmaskedInput.getAttribute('min');
              var step = unmaskedInput.getAttribute('step');
              if (min) isValid = isValid && value >= Number(min);
              if (max) isValid = isValid && value <= Number(max);
              if (step) isValid = isValid && countDecimals(step) === countDecimals(unmaskedInput.value);
            } else isValid = unmaskedInput.checkValidity();

            if (isValid) {
              this.__applyCssClassState(unmaskedInput, actualInput, 'success');
            } else {
              this.__applyCssClassState(unmaskedInput, actualInput, 'error');

              this.__fireOnInvalid(unmaskedInput.validationMessage || 'Validity check fails', actualInput);
            }

            return isValid;
          }
          /**
           * @param {String} valueMasked  masked value
           * @param {Number} valueUnmasked  original value
           * @param {HTMLInputElement} input the actual input instance
           *
           * @private
           */

        }, {
          key: "__fireOnUpdate",
          value: function __fireOnUpdate(valueMasked, valueUnmasked, input) {
            if (this.options.onUpdate) {
              this.options.onUpdate(valueMasked, valueUnmasked, input);
            }
          }
          /**
           * @param {String|Object} error last occurred error. could be mask error or validation error
           * @param {HTMLInputElement} input the actual input instance
           *
           * @private
           */

        }, {
          key: "__fireOnInvalid",
          value: function __fireOnInvalid(error, input) {
            if (this.options.onInvalid) {
              this.options.onInvalid(error, input);
            }
          }
          /**
           * @private
           */

        }, {
          key: "__applyCssClassState",
          value: function __applyCssClassState(unmaskedInput, actualInput, state) {
            if (actualInput.hasAttribute('readonly') || actualInput.hasAttribute('disabled')) {
              actualInput.classList.remove(this.options.cssClassError);
              actualInput.classList.remove(this.options.cssClassSuccess);
              unmaskedInput.classList.remove(this.options.cssClassError);
              unmaskedInput.classList.remove(this.options.cssClassSuccess);
            } else {
              if (state === 'success') {
                actualInput.classList.remove(this.options.cssClassError);
                actualInput.classList.add(this.options.cssClassSuccess);
                unmaskedInput.classList.remove(this.options.cssClassError);
                unmaskedInput.classList.add(this.options.cssClassSuccess);
              }

              if (state === 'error') {
                actualInput.classList.add(this.options.cssClassError);
                actualInput.classList.remove(this.options.cssClassSuccess);
                unmaskedInput.classList.add(this.options.cssClassError);
                unmaskedInput.classList.remove(this.options.cssClassSuccess);
              }
            }
          }
        }]);

        return NumberInput;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = NumberInput;
      /***/
    },
    /* 7 */

    /***/
    function (module, exports) {
      module.exports = __WEBPACK_EXTERNAL_MODULE_7__;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/bbj-masks/dist/bbj-masks.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/bbj-masks/dist/bbj-masks.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(typeof self !== 'undefined' ? self : void 0, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 5);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toInteger;

      function toInteger(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }

        var number = Number(dirtyNumber);

        if (isNaN(number)) {
          return number;
        }

        return number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      /***/

    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(6);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"
      /* default */
      ];
      /***/
    },
    /* 2 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__DateMask__ = __webpack_require__(7);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["e"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "g", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["g"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "h", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["h"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "b", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["b"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["d"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "f", function () {
        return __WEBPACK_IMPORTED_MODULE_0__DateMask__["f"];
      });
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["c"] = __WEBPACK_IMPORTED_MODULE_0__DateMask__["c"
      /* default */
      ];
      /***/
    },
    /* 3 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzParseTimezone;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__ = __webpack_require__(9);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var patterns = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-])(\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
        timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      }; // Parse various time zone offset formats to an offset in milliseconds

      function tzParseTimezone(timezoneString, date) {
        var token;
        var absoluteOffset; // Z

        token = patterns.timezoneZ.exec(timezoneString);

        if (token) {
          return 0;
        }

        var hours; // ±hh

        token = patterns.timezoneHH.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);

          if (!validateTimezone(hours)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // ±hh:mm or ±hhmm


        token = patterns.timezoneHHMM.exec(timezoneString);

        if (token) {
          hours = parseInt(token[2], 10);
          var minutes = parseInt(token[3], 10);

          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }

          absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
          return token[1] === '+' ? -absoluteOffset : absoluteOffset;
        } // IANA time zone


        token = patterns.timezoneIANA.exec(timezoneString);

        if (token) {
          // var [fYear, fMonth, fDay, fHour, fMinute, fSecond] = tzTokenizeDate(date, timezoneString)
          var tokens = Object(__WEBPACK_IMPORTED_MODULE_0__tzTokenizeDate_index_js__["a"
          /* default */
          ])(date, timezoneString);
          var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3], tokens[4], tokens[5]);
          var timestampWithMsZeroed = date.getTime() - date.getTime() % 1000;
          return -(asUTC - timestampWithMsZeroed);
        }

        return 0;
      }

      function validateTimezone(hours, minutes) {
        if (minutes != null && (minutes < 0 || minutes > 59)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 4 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__StringMask__ = __webpack_require__(19);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__StringMask__["a"
      /* default */
      ];
      /***/
    },
    /* 5 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      Object.defineProperty(__webpack_exports__, "__esModule", {
        value: true
      });
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "Utils", function () {
        return Utils;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__DateMask__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__StringMask__ = __webpack_require__(4);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_3__Types__ = __webpack_require__(20);
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "Types", function () {
        return __WEBPACK_IMPORTED_MODULE_3__Types__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "NumberMask", function () {
        return __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "DateMask", function () {
        return __WEBPACK_IMPORTED_MODULE_1__DateMask__["c"];
      });
      /* harmony reexport (binding) */


      __webpack_require__.d(__webpack_exports__, "StringMask", function () {
        return __WEBPACK_IMPORTED_MODULE_2__StringMask__["a"];
      });
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var Utils = {
        Dates: {
          getDayOfYear: __WEBPACK_IMPORTED_MODULE_1__DateMask__["e"
          /* getDayOfYear */
          ],
          getWeekNumber: __WEBPACK_IMPORTED_MODULE_1__DateMask__["g"
          /* getWeekNumber */
          ],
          getWeekStartByLocale: __WEBPACK_IMPORTED_MODULE_1__DateMask__["h"
          /* getWeekStartByLocale */
          ],
          IS_DATE_REGEX: __WEBPACK_IMPORTED_MODULE_1__DateMask__["a"
          /* IS_DATE_REGEX */
          ],
          IS_TIME_REGEX: __WEBPACK_IMPORTED_MODULE_1__DateMask__["b"
          /* IS_TIME_REGEX */
          ],
          fixShortISO: __WEBPACK_IMPORTED_MODULE_1__DateMask__["d"
          /* fixShortISO */
          ],
          getTimezoneOrOffset: __WEBPACK_IMPORTED_MODULE_1__DateMask__["f"
          /* getTimezoneOrOffset */
          ]
        }
      };
      /* harmony default export */

      __webpack_exports__["default"] = __WEBPACK_IMPORTED_MODULE_3__Types__["a"
      /* default */
      ];
      /***/
    },
    /* 6 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * NumberMask
       *
       * A javascript implementation for BBj numbers masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var NumberMask = /*#__PURE__*/function () {
        function NumberMask() {
          _classCallCheck(this, NumberMask);
        }

        _createClass(NumberMask, null, [{
          key: "mask",

          /**
           * Mask the given number with the given mask according to BBj rules
           *
           * @param {Number} number the number to format
           * @param {String} mask the mask to use for formatting
           * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
           * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
           * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
           *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           * 
           * @throws {MaskError} only if loose is disabled
           * 
           * @returns {String} the masked number
           */
          value: function mask(number, _mask) {
            var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
            var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
            var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
            var maskLen = _mask.length;

            if (0 === maskLen) {
              if (loose) return str; // friendly silent fail
              else throw {
                  name: 'MaskError',
                  message: "MaskError: Mask is empty"
                };
            } // Get magnitude and precision of MASK


            var maskBeforeDecimal = 0;
            var maskAfterDecimal = 0;
            var foundDecimal = false;

            for (var i = 0; i < maskLen; ++i) {
              var m = _mask.charAt(i);

              if (m == '0' || m == '#') {
                if (foundDecimal) ++maskAfterDecimal;else ++maskBeforeDecimal;
              } else if (m == '.') foundDecimal = true;
            }

            var num = NumberMask._round(number, maskAfterDecimal);

            var bytes = NumberMask._toCharArray(num); // Get magnitude and precision of NUMBER


            var inLen = bytes.length;
            var numBeforeDecimal = 0;
            var numAfterDecimal = 0;
            foundDecimal = false;

            for (var _i = 0; _i < inLen; ++_i) {
              if (bytes[_i] == '.') foundDecimal = true;else {
                if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
              }
            } // always ignore mask overflow


            if (numBeforeDecimal > maskBeforeDecimal) {
              if (loose) return number.toString(); // friendly silent fail
              else throw {
                  name: 'MaskError',
                  message: "MaskError: Number is too large for mask"
                };
            } // round if mask is for a lower precision number


            if (numAfterDecimal > maskAfterDecimal) {
              num = NumberMask._round(num, maskAfterDecimal);
              bytes = NumberMask._toCharArray(num);
              inLen = bytes.length; // Get new magnitude and precision of NUMBER

              numBeforeDecimal = 0;
              numAfterDecimal = 0;
              foundDecimal = false;

              for (var _i2 = 0; _i2 < inLen; ++_i2) {
                if (bytes[_i2] == '.') foundDecimal = true;else {
                  if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
                }
              } // always ignore mask overflow


              if (numBeforeDecimal > maskBeforeDecimal) {
                if (loose) return number.toString(); // friendly silent fail
                else throw {
                    name: 'MaskError',
                    message: "MaskError: Number is too large for mask"
                  };
              }
            }

            var fillByte = ' ',
                floatByte = ' ';
            var inPos = 0,
                outPos = 0,
                floatPos = 0;
            if (_mask.charAt(0) == '*') fillByte = '*';
            var fillInit = fillByte;
            var isNegative = NumberMask._getSign(num) < 0;
            var emitDecimal = inLen > 0 || _mask.indexOf('0') >= 0;
            var foundZero = false;
            var foundDigit = false;
            var currency = false;
            foundDecimal = false;
            var ret = new Array(maskLen);

            for (var maskPos = 0; maskPos < maskLen; ++maskPos) {
              var _m = _mask.charAt(maskPos);

              switch (_m) {
                case '0':
                  --maskBeforeDecimal;

                  if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
                    ret[outPos] = bytes[inPos];
                    ++inPos;
                    foundDigit = true;
                  } else {
                    ret[outPos] = '0';
                    foundZero = true;
                  }

                  ++outPos;
                  break;

                case '#':
                  --maskBeforeDecimal;

                  if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
                    ret[outPos] = bytes[inPos];
                    ++inPos;
                    foundDigit = true;
                  } else {
                    ret[outPos] = foundDecimal && forceTrailingZeros && NumberMask._getSign(num) != 0 ? '0' : fillByte;
                    if (!foundDecimal) floatPos = maskPos;
                  }

                  ++outPos;
                  break;

                case ',':
                  if (foundZero || inPos > 0) ret[outPos] = groupingSeparator;else {
                    ret[outPos] = fillByte;
                    if (!foundDecimal) floatPos = maskPos;
                  }
                  ++outPos;
                  break;

                case '-':
                  if (!foundDigit && floatByte == ' ') {
                    if (isNegative) floatByte = '-';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else ret[outPos] = isNegative ? '-' : fillByte;

                  ++outPos;
                  break;

                case '+':
                  if (!foundDigit && floatByte == ' ') {
                    floatByte = isNegative ? '-' : '+';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else ret[outPos] = isNegative ? '-' : '+';

                  ++outPos;
                  break;

                case '$':
                  if (!foundDigit && floatByte == ' ') {
                    floatByte = '$';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else {
                    ret[outPos] = '$';
                  }

                  ++outPos;
                  break;
                // case '&':
                //   currency = true
                //   if (!foundDigit && floatByte == ' ') {
                //     floatByte = '&'
                //     ret[outPos] = fillByte
                //     floatPos = foundDecimal ? -1 : maskPos
                //   } else {
                //     ret[outPos] = '&'
                //   }
                //   ++outPos
                //   break
                // case '@':
                //   currency = true
                //   if (!foundDigit && floatByte == ' ') {
                //     floatByte = '@'
                //     ret[outPos] = fillByte
                //     floatPos = foundDecimal ? -1 : maskPos
                //   } else {
                //     ret[outPos] = '@'
                //   }
                //   ++outPos
                //   break

                case '(':
                  if (!foundDigit && floatByte == ' ') {
                    if (isNegative) floatByte = '(';
                    ret[outPos] = fillByte;
                    floatPos = foundDecimal ? -1 : maskPos;
                  } else {
                    if (isNegative) {
                      ret[outPos] = '(';
                    } else {
                      ret[outPos] = foundDecimal ? ' ' : fillByte;
                    }
                  }

                  ++outPos;
                  break;

                case ')':
                  if (isNegative) {
                    ret[outPos] = ')';
                  } else {
                    ret[outPos] = foundDecimal ? ' ' : fillByte;
                  }

                  ++outPos;
                  break;

                case 'C':
                  if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
                    if (isNegative) {
                      ret[outPos] = 'C';
                      ret[outPos + 1] = 'R';
                    } else {
                      ret[outPos] = ' ';
                      ret[outPos + 1] = ' ';
                    }

                    outPos += 2;
                    ++maskPos;
                  } else {
                    ret[outPos] = 'C';
                    ++outPos;
                  }

                  break;

                case 'D':
                  if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
                    if (isNegative) {
                      ret[outPos] = 'C';
                      ret[outPos + 1] = 'R';
                    } else {
                      ret[outPos] = 'D';
                      ret[outPos + 1] = 'R';
                    }

                    outPos += 2;
                    ++maskPos;
                  } else {
                    ret[outPos] = 'D';
                    ++outPos;
                  }

                  break;

                case '*':
                  ret[outPos] = '*';
                  ++outPos;
                  break;

                case '.':
                  ret[outPos] = emitDecimal ? decimalSeparator : fillByte;
                  fillByte = ' ';
                  foundDecimal = true;
                  ++inPos;
                  ++outPos;
                  break;

                case 'B':
                  ret[outPos] = ' ';
                  ++outPos;
                  break;

                default:
                  ret[outPos] = _m;
                  ++outPos;
                  break;
              }
            }

            if (floatByte != ' ') {
              if (floatPos < 0) floatPos = outPos;

              while (floatPos >= maskLen) {
                --floatPos;
              }

              if (ret[floatPos] == fillInit) ret[floatPos] = floatByte;
            }

            return ret.join('');
          }
        }, {
          key: "_shift",
          value: function _shift(number, precision, reverseShift) {
            if (reverseShift) precision = -precision;
            var numArray = ('' + number).split('e');
            return +(numArray[0] + 'e' + (numArray[1] ? +numArray[1] + precision : precision));
          }
        }, {
          key: "_round",
          value: function _round(number, precision) {
            return NumberMask._shift(Math.round(NumberMask._shift(number, precision, false)), precision, true);
          }
        }, {
          key: "_toCharArray",
          value: function _toCharArray(number) {
            var signum = NumberMask._getSign(number);

            var chars = [];

            if (signum !== 0) {
              var string = signum < 0 ? "".concat(-1 * number.toString()) : number.toString();
              if (string.length > 1 && string.charAt(0) == '0') string = string.substring(1); // The string contains only [0-9] and '.'

              chars = string.split('');
            }

            return chars;
          }
          /**
           * Returns the sign of a number
           *
           * @param {Number} x number
           * @returns {Number} A number representing the sign of the given argument.
           *                   If the argument is a positive number, negative number, positive zero
           *                   or negative zero, the function will return 1, -1, 0 or -0 respectively.
           *                   Otherwise, NaN is returned.
           */

        }, {
          key: "_getSign",
          value: function _getSign(x) {
            return (x > 0) - (x < 0) || +x;
          }
        }]);

        return NumberMask;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = NumberMask;
      /***/
    },
    /* 7 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return IS_TIME_REGEX;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return IS_DATE_REGEX;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "h", function () {
        return getWeekStartByLocale;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "e", function () {
        return getDayOfYear;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "d", function () {
        return fixShortISO;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "f", function () {
        return getTimezoneOrOffset;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "g", function () {
        return getWeekNumber;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0_date_fns_tz_utcToZonedTime__ = __webpack_require__(8);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_weekstart__ = __webpack_require__(15);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var IS_TIME_REGEX = /^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$/;
      var IS_DATE_REGEX = /^(([12]\d{3})-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?))$/;
      /**
       * Find out when the first day of the week based on the passed locale
       *
       * @param {locale} locale
       *
       * @return {Number} a number 0 = sunday , 1 = monday , ....
       */

      var getWeekStartByLocale = function getWeekStartByLocale(locale) {
        return Object(__WEBPACK_IMPORTED_MODULE_1_weekstart__["a"
        /* getWeekStartByLocale */
        ])(locale);
      };
      /**
       *  Get day number in the year of the passed date
       *
       * @param {Date} date
       *
       * @return {Number} day number
       */


      var getDayOfYear = function getDayOfYear(date) {
        var start = new Date(date.getFullYear(), 0, 0);
        var diff = date - start + (start.getTimezoneOffset() - date.getTimezoneOffset()) * 60 * 1000;
        var oneDay = 1000 * 60 * 60 * 24;
        var day = Math.floor(diff / oneDay);
        return day;
      };
      /**
       * Takes incomplete iso string and return a complete one
       *
       * @param {String} date incomplete iso string
       *
       * @return {String} complete iso string
       */


      var fixShortISO = function fixShortISO(date) {
        var value = date;
        var offset = (value.match(/z$|[+\-]\d\d:\d\d$/i) || [])[0];

        if (!offset) {
          offset = 'Z';
          value += offset;
        }

        if (IS_TIME_REGEX.test(value)) {
          value = "1970-01-01T".concat(value);
        } else if (IS_DATE_REGEX.test(value)) {
          value = "".concat(value.split(offset)[0], "T00:00:00").concat(offset);
        }

        return value;
      };
      /**
       * Get the browser timezone name , if not supported then the browser
       * timezone offset formatted
       *
       * @return {String} timezone of offset
       */


      var getTimezoneOrOffset = function getTimezoneOrOffset() {
        var timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        if (!timezone) {
          var pad = function pad(number, length) {
            var str = '' + number;

            while (str.length < length) {
              str = '0' + str;
            }

            return str;
          };

          var offset = new Date().getTimezoneOffset();
          offset = (offset < 0 ? '+' : '-') + // Note the reversed sign!
          pad(parseInt(Math.abs(offset / 60)), 2) + pad(Math.abs(offset % 60), 2);
          return offset;
        }

        return timezone;
      };
      /**
       * Get the Week Number in the passed date
       *
       * @param {Date} date - Date object
       * @param {Number} weekStart A number which defines the first day of the week (0  = sunday , 1 = monday , ...)
       *
       * @returns {Number} the week number
       */


      var getWeekNumber = function getWeekNumber(date, weekStart) {
        var d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
        var dayNum = d.getUTCDay() - (weekStart - 1) || 7;
        d.setUTCDate(d.getUTCDate() + 4 - dayNum);
        var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);
      };
      /**
       * DateMask
       *
       * A javascript implementation for BBj dates masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var DateMask = /*#__PURE__*/function () {
        function DateMask() {
          _classCallCheck(this, DateMask);
        }

        _createClass(DateMask, null, [{
          key: "mask",

          /**
           * Mask date
           *
           * Mask the passed date with the passed mask
           *
           * @param {String} date date as a string
           * @param {String} mask mask as a string
           * @param {String} [locale=Browser's locale] the language to use ex(en-US). default is to the system language
           * @param {String} [timezone=System timezone] the time zone descriptor (e.g. America/Los_Angeles). default to the system
           *                          timezone
           *
           * @return {String} a date masked with the given mask
           */
          value: function mask(date, _mask, locale, timezone) {
            if (!date) return '';
            if (!_mask) return date;
            timezone = timezone || getTimezoneOrOffset();
            locale = locale || Intl.DateTimeFormat().resolvedOptions().locale || 'en-US'; // make sure we have a complete iso string

            date = date instanceof Date ? date : fixShortISO(date);
            var dateObject = Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_tz_utcToZonedTime__["a"
            /* default */
            ])(date, timezone);

            var translation = DateMask._buildTranslation({
              year: dateObject.getFullYear(),
              month: dateObject.getMonth() + 1,
              monthShort: new Intl.DateTimeFormat([locale], {
                month: 'short'
              }).format(dateObject),
              monthLong: new Intl.DateTimeFormat([locale], {
                month: 'long'
              }).format(dateObject),
              day: dateObject.getDate(),
              dayShort: new Intl.DateTimeFormat([locale], {
                weekday: 'short'
              }).format(dateObject),
              dayLong: new Intl.DateTimeFormat([locale], {
                weekday: 'long'
              }).format(dateObject),
              minutes: dateObject.getMinutes(),
              seconds: dateObject.getSeconds(),

              get hours24() {
                return dateObject.getHours();
              },

              get hours12() {
                return this.hours24 % 12 || 12;
              },

              dayOfYear: getDayOfYear(dateObject),
              dayOfWeek: dateObject.getDay() + 1,
              // Sunday = 1 in BBj but Sunday = 0 in JS
              weekNumber: getWeekNumber(dateObject, getWeekStartByLocale(locale)),
              locale: locale,
              timezone: timezone
            });

            var result = _mask;

            for (var k in translation) {
              result = result.replace(new RegExp('(%' + k + ')', 'g'), translation[k]);
            }

            return result;
          }
          /**
           * Get a map object which contains all possible forms of masks
           *
           * @param {Object} dateDetails date
           *
           * @return {Object} forms masks
           */

        }, {
          key: "_buildTranslation",
          value: function _buildTranslation(dateDetails) {
            return {
              // year
              Yz: dateDetails.year.toString().substr(-2),
              Ys: dateDetails.year,
              Yl: dateDetails.year,
              Yp: String.fromCharCode(dateDetails.year),
              Yd: dateDetails.year,
              Y: dateDetails.year,
              // month
              Mz: String(dateDetails.month).length == 1 ? '0' + dateDetails.month : dateDetails.month,
              Ms: dateDetails.monthShort,
              Ml: dateDetails.monthLong,
              Mp: String.fromCharCode(dateDetails.month),
              Md: dateDetails.month,
              M: dateDetails.month,
              // day
              Dz: String(dateDetails.day).length == 1 ? '0' + dateDetails.day : dateDetails.day,
              Ds: dateDetails.dayShort,
              Dl: dateDetails.dayLong,
              Dp: String.fromCharCode(dateDetails.day),
              Dd: dateDetails.day,
              D: dateDetails.day,
              // hour 24
              Hz: String(dateDetails.hours24).length == 1 ? '0' + dateDetails.hours24 : dateDetails.hours24,
              Hs: dateDetails.hours24,
              Hl: dateDetails.hours24,
              Hp: String.fromCharCode(dateDetails.hours24),
              Hd: dateDetails.hours24,
              H: dateDetails.hours24,
              // hour 12
              hz: String(dateDetails.hours12).length == 1 ? '0' + dateDetails.hours12 : dateDetails.hours12,
              hs: dateDetails.hours12,
              hl: dateDetails.hours12,
              hp: String.fromCharCode(dateDetails.hours12),
              hd: dateDetails.hours12,
              h: dateDetails.hours12,
              // minutes
              mz: String(dateDetails.minutes).length == 1 ? '0' + dateDetails.minutes : dateDetails.minutes,
              ms: dateDetails.minutes,
              ml: dateDetails.minutes,
              mp: String.fromCharCode(dateDetails.minutes),
              md: dateDetails.minutes,
              m: dateDetails.minutes,
              // seconds
              sz: String(dateDetails.seconds).length == 1 ? '0' + dateDetails.seconds : dateDetails.seconds,
              ss: dateDetails.seconds,
              sl: dateDetails.seconds,
              sp: String.fromCharCode(dateDetails.seconds),
              sd: dateDetails.seconds,
              s: dateDetails.seconds,
              // AM , PM
              PP: dateDetails.hours24 > 12 ? 'PM' : 'PM',
              P: dateDetails.hours24 > 12 ? 'PM' : 'AM',
              pp: dateDetails.hours24 > 12 ? 'pm' : 'am',
              p: dateDetails.hours24 > 12 ? 'pm' : 'am',
              // Day of Year
              Jz: String(dateDetails.dayOfYear).length == 1 ? '0' + dateDetails.dayOfYear : dateDetails.dayOfYear,
              Js: dateDetails.dayOfYear,
              Jl: dateDetails.dayOfYear,
              Jd: dateDetails.dayOfYear,
              J: dateDetails.dayOfYear,
              // Day Of Week
              Wz: String(dateDetails.dayOfWeek).length == 1 ? '0' + dateDetails.dayOfWeek : dateDetails.dayOfWeek,
              Ws: dateDetails.dayOfWeek,
              Wl: dateDetails.dayOfWeek,
              Wp: String.fromCharCode(dateDetails.dayOfWeek),
              Wd: dateDetails.dayOfWeek,
              W: dateDetails.dayOfWeek,
              // week number
              wz: String(dateDetails.weekNumber).length == 1 ? '0' + dateDetails.weekNumber : dateDetails.weekNumber,
              ws: dateDetails.weekNumber,
              wl: dateDetails.weekNumber,
              wp: String.fromCharCode(dateDetails.weekNumber),
              wd: dateDetails.weekNumber,
              w: dateDetails.weekNumber
            };
          }
        }]);

        return DateMask;
      }();
      /* harmony default export */


      __webpack_exports__["c"] = DateMask;
      /***/
    },
    /* 8 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = utcToZonedTime;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__ = __webpack_require__(3);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__ = __webpack_require__(10);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__toDate__ = __webpack_require__(13);
      /**
       * @name utcToZonedTime
       * @category Time Zone Helpers
       * @summary Get a date/time representing local time in a given time zone from the UTC date
       *
       * @description
       * Returns a date instance with values representing the local time in the time zone
       * specified of the UTC time from the date provided. In other words, when the new date
       * is formatted it will show the equivalent hours in the target time zone regardless
       * of the current system time zone.
       *
       * @param {Date|String|Number} date - the date with the relevant UTC time
       * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
       * @returns {Date} the new date with the equivalent time in the time zone
       * @throws {TypeError} 2 arguments required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // In June 10am UTC is 6am in New York (-04:00)
       * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
       * //=> Jun 25 2014 06:00:00
       */


      function utcToZonedTime(dirtyDate, timeZone, options) {
        var date = Object(__WEBPACK_IMPORTED_MODULE_2__toDate__["a"
        /* default */
        ])(dirtyDate, options); // This date has the UTC time values of the input date at the system time zone

        var utcDate = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds()); // We just need to apply the offset indicated by the time zone to this localized date

        var offsetMilliseconds = Object(__WEBPACK_IMPORTED_MODULE_0__lib_tzParseTimezone__["a"
        /* default */
        ])(timeZone, date);
        return offsetMilliseconds ? Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_subMilliseconds__["a"
        /* default */
        ])(utcDate, offsetMilliseconds) : utcDate;
      }
      /***/

    },
    /* 9 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = tzTokenizeDate;
      /**
       * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
       * `date` as it will be rendered in the `timeZone`.
       */

      function tzTokenizeDate(date, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      }

      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };

      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date);
        var filled = [];

        for (var i = 0; i < formatted.length; i++) {
          var pos = typeToPos[formatted[i].type];

          if (pos >= 0) {
            filled[pos] = parseInt(formatted[i].value, 10);
          }
        }

        return filled;
      }

      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, '');
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted); // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
        // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]

        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      } // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
      // to get deterministic local date/time output according to the `en-US` locale which
      // can be used to extract local time parts as necessary.


      var dtfCache = {};

      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
          var testDateFormatted = new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: 'America/New_York',
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }).format(new Date('2014-06-25T04:00:00.123Z'));
          var hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' || testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          }) : new Intl.DateTimeFormat('en-US', {
            hourCycle: 'h23',
            timeZone: timeZone,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
          });
        }

        return dtfCache[timeZone];
      }
      /***/

    },
    /* 10 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = subMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__ = __webpack_require__(11);
      /**
       * @name subMilliseconds
       * @category Millisecond Helpers
       * @summary Subtract the specified number of milliseconds from the given date.
       *
       * @description
       * Subtract the specified number of milliseconds from the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be subtracted
       * @returns {Date} the new date with the milliseconds subtracted
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
       * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:29.250
       */


      function subMilliseconds(dirtyDate, dirtyAmount) {
        if (arguments.length < 2) {
          throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
        }

        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return Object(__WEBPACK_IMPORTED_MODULE_1__addMilliseconds_index_js__["a"
        /* default */
        ])(dirtyDate, -amount);
      }
      /***/

    },
    /* 11 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = addMilliseconds;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__toDate_index_js__ = __webpack_require__(12);
      /**
       * @name addMilliseconds
       * @category Millisecond Helpers
       * @summary Add the specified number of milliseconds to the given date.
       *
       * @description
       * Add the specified number of milliseconds to the given date.
       *
       * ### v2.0.0 breaking changes:
       *
       * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
       *
       * @param {Date|Number} date - the date to be changed
       * @param {Number} amount - the amount of milliseconds to be added
       * @returns {Date} the new date with the milliseconds added
       * @throws {TypeError} 2 arguments required
       *
       * @example
       * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
       * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
       * //=> Thu Jul 10 2014 12:45:30.750
       */


      function addMilliseconds(dirtyDate, dirtyAmount) {
        if (arguments.length < 2) {
          throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
        }

        var timestamp = Object(__WEBPACK_IMPORTED_MODULE_1__toDate_index_js__["a"
        /* default */
        ])(dirtyDate).getTime();
        var amount = Object(__WEBPACK_IMPORTED_MODULE_0__lib_toInteger_index_js__["a"
        /* default */
        ])(dirtyAmount);
        return new Date(timestamp + amount);
      }
      /***/

    },
    /* 12 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       *
       * @param {Date|Number} argument - the value to convert
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       *
       * @example
       * // Clone the date:
       * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert the timestamp to date:
       * const result = toDate(1392098430000)
       * //=> Tue Feb 11 2014 11:30:30
       */

      function toDate(argument) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        var argStr = Object.prototype.toString.call(argument); // Clone the date

        if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || argStr === '[object Number]') {
          return new Date(argument);
        } else {
          if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
            // eslint-disable-next-line no-console
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

            console.warn(new Error().stack);
          }

          return new Date(NaN);
        }
      }
      /***/

    },
    /* 13 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = toDate;
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__ = __webpack_require__(0);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__ = __webpack_require__(14);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__ = __webpack_require__(3);

      var MILLISECONDS_IN_HOUR = 3600000;
      var MILLISECONDS_IN_MINUTE = 60000;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns = {
        dateTimeDelimeter: /[T ]/,
        plainTime: /:/,
        timeZoneDelimeter: /[Z ]/i,
        // year tokens
        YY: /^(\d{2})$/,
        YYY: [/^([+-]\d{2})$/, // 0 additional digits
        /^([+-]\d{3})$/, // 1 additional digit
        /^([+-]\d{4})$/ // 2 additional digits
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [/^([+-]\d{4})/, // 0 additional digits
        /^([+-]\d{5})/, // 1 additional digit
        /^([+-]\d{6})/ // 2 additional digits
        ],
        // date tokens
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        // timezone tokens (to identify the presence of a tz)
        timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      /**
       * @name toDate
       * @category Common Helpers
       * @summary Convert the given argument to an instance of Date.
       *
       * @description
       * Convert the given argument to an instance of Date.
       *
       * If the argument is an instance of Date, the function returns its clone.
       *
       * If the argument is a number, it is treated as a timestamp.
       *
       * If an argument is a string, the function tries to parse it.
       * Function accepts complete ISO 8601 formats as well as partial implementations.
       * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
       * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
       *
       * If the argument is none of the above, the function returns Invalid Date.
       *
       * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
       * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
       *
       * @param {Date|String|Number} argument - the value to convert
       * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
       * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
       * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
       * @returns {Date} the parsed date in the local time zone
       * @throws {TypeError} 1 argument required
       * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
       *
       * @example
       * // Convert string '2014-02-11T11:30:30' to date:
       * var result = toDate('2014-02-11T11:30:30')
       * //=> Tue Feb 11 2014 11:30:30
       *
       * @example
       * // Convert string '+02014101' to date,
       * // if the additional number of digits in the extended year format is 1:
       * var result = toDate('+02014101', {additionalDigits: 1})
       * //=> Fri Apr 11 2014 00:00:00
       */

      function toDate(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
        }

        if (argument === null) {
          return new Date(NaN);
        }

        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Object(__WEBPACK_IMPORTED_MODULE_0_date_fns_esm_lib_toInteger_index_js__["a"
        /* default */
        ])(options.additionalDigits);

        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError('additionalDigits must be 0, 1 or 2');
        } // Clone the date


        if (argument instanceof Date || _typeof(argument) === 'object' && Object.prototype.toString.call(argument) === '[object Date]') {
          // Prevent the date to lose the milliseconds when passed to new Date() in IE10
          return new Date(argument.getTime());
        } else if (typeof argument === 'number' || Object.prototype.toString.call(argument) === '[object Number]') {
          return new Date(argument);
        } else if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
          return new Date(NaN);
        }

        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date = parseDate(restDateString, year);

        if (isNaN(date)) {
          return new Date(NaN);
        }

        if (date) {
          var timestamp = date.getTime();
          var time = 0;
          var offset;

          if (dateStrings.time) {
            time = parseTime(dateStrings.time);

            if (isNaN(time)) {
              return new Date(NaN);
            }
          }

          if (dateStrings.timezone || options.timeZone) {
            offset = Object(__WEBPACK_IMPORTED_MODULE_2__lib_tzParseTimezone__["a"
            /* default */
            ])(dateStrings.timezone || options.timeZone, new Date(timestamp + time));

            if (isNaN(offset)) {
              return new Date(NaN);
            }
          } else {
            // get offset accurate to hour in timezones that change offset
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time));
            offset = Object(__WEBPACK_IMPORTED_MODULE_1_date_fns_esm_lib_getTimezoneOffsetInMilliseconds_index_js__["a"
            /* default */
            ])(new Date(timestamp + time + offset));
          }

          return new Date(timestamp + time + offset);
        } else {
          return new Date(NaN);
        }
      }

      function splitDateString(dateString) {
        var dateStrings = {};
        var array = dateString.split(patterns.dateTimeDelimeter);
        var timeString;

        if (patterns.plainTime.test(array[0])) {
          dateStrings.date = null;
          timeString = array[0];
        } else {
          dateStrings.date = array[0];
          timeString = array[1];
          dateStrings.timezone = array[2];

          if (patterns.timeZoneDelimeter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns.timeZoneDelimeter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
          }
        }

        if (timeString) {
          var token = patterns.timezone.exec(timeString);

          if (token) {
            dateStrings.time = timeString.replace(token[1], '');
            dateStrings.timezone = token[1];
          } else {
            dateStrings.time = timeString;
          }
        }

        return dateStrings;
      }

      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns.YYY[additionalDigits];
        var patternYYYYY = patterns.YYYYY[additionalDigits];
        var token; // YYYY or ±YYYYY

        token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);

        if (token) {
          var yearString = token[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        } // YY or ±YYY


        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);

        if (token) {
          var centuryString = token[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        } // Invalid ISO-formatted year


        return {
          year: null
        };
      }

      function parseDate(dateString, year) {
        // Invalid ISO-formatted year
        if (year === null) {
          return null;
        }

        var token;
        var date;
        var month;
        var week; // YYYY

        if (dateString.length === 0) {
          date = new Date(0);
          date.setUTCFullYear(year);
          return date;
        } // YYYY-MM


        token = patterns.MM.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;

          if (!validateDate(year, month)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month);
          return date;
        } // YYYY-DDD or YYYYDDD


        token = patterns.DDD.exec(dateString);

        if (token) {
          date = new Date(0);
          var dayOfYear = parseInt(token[1], 10);

          if (!validateDayOfYearDate(year, dayOfYear)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, 0, dayOfYear);
          return date;
        } // yyyy-MM-dd or YYYYMMDD


        token = patterns.MMDD.exec(dateString);

        if (token) {
          date = new Date(0);
          month = parseInt(token[1], 10) - 1;
          var day = parseInt(token[2], 10);

          if (!validateDate(year, month, day)) {
            return new Date(NaN);
          }

          date.setUTCFullYear(year, month, day);
          return date;
        } // YYYY-Www or YYYYWww


        token = patterns.Www.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;

          if (!validateWeekDate(year, week)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week);
        } // YYYY-Www-D or YYYYWwwD


        token = patterns.WwwD.exec(dateString);

        if (token) {
          week = parseInt(token[1], 10) - 1;
          var dayOfWeek = parseInt(token[2], 10) - 1;

          if (!validateWeekDate(year, week, dayOfWeek)) {
            return new Date(NaN);
          }

          return dayOfISOWeekYear(year, week, dayOfWeek);
        } // Invalid ISO-formatted date


        return null;
      }

      function parseTime(timeString) {
        var token;
        var hours;
        var minutes; // hh

        token = patterns.HH.exec(timeString);

        if (token) {
          hours = parseFloat(token[1].replace(',', '.'));

          if (!validateTime(hours)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR;
        } // hh:mm or hhmm


        token = patterns.HHMM.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseFloat(token[2].replace(',', '.'));

          if (!validateTime(hours, minutes)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
        } // hh:mm:ss or hhmmss


        token = patterns.HHMMSS.exec(timeString);

        if (token) {
          hours = parseInt(token[1], 10);
          minutes = parseInt(token[2], 10);
          var seconds = parseFloat(token[3].replace(',', '.'));

          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }

          return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
        } // Invalid ISO-formatted time


        return null;
      }

      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date = new Date(0);
        date.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date.setUTCDate(date.getUTCDate() + diff);
        return date;
      } // Validation functions


      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }

      function validateDate(year, month, date) {
        if (month < 0 || month > 11) {
          return false;
        }

        if (date != null) {
          if (date < 1) {
            return false;
          }

          var isLeapYear = isLeapYearIndex(year);

          if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }

          if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
            return false;
          }
        }

        return true;
      }

      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }

        var isLeapYear = isLeapYearIndex(year);

        if (isLeapYear && dayOfYear > 366) {
          return false;
        }

        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }

        return true;
      }

      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }

        if (day != null && (day < 0 || day > 6)) {
          return false;
        }

        return true;
      }

      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }

        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }

        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }

        return true;
      }
      /***/

    },
    /* 14 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (immutable) */

      __webpack_exports__["a"] = getTimezoneOffsetInMilliseconds;
      var MILLISECONDS_IN_MINUTE = 60000;
      /**
       * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
       * They usually appear for dates that denote time before the timezones were introduced
       * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
       * and GMT+01:00:00 after that date)
       *
       * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
       * which would lead to incorrect calculations.
       *
       * This function returns the timezone offset in milliseconds that takes seconds in account.
       */

      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime());
        var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        date.setSeconds(0, 0);
        var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
        return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
      }
      /***/

    },
    /* 15 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* unused harmony export getWeekStartByRegion */

      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return getWeekStartByLocale$1;
      });
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_0__api_js__ = __webpack_require__(16);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__langRegionMap_js__ = __webpack_require__(17);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__ = __webpack_require__(18);

      function getWeekStartByRegion$1(regionCode) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__api_js__["b"
        /* getWeekStartByRegion */
        ])(regionCode, __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__["a"
        /* default */
        ]);
      }

      function getWeekStartByLocale$1(locale) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__api_js__["a"
        /* getWeekStartByLocale */
        ])(locale, __WEBPACK_IMPORTED_MODULE_1__langRegionMap_js__["a"
        /* default */
        ], __WEBPACK_IMPORTED_MODULE_2__regionDayMap_js__["a"
        /* default */
        ]);
      }
      /***/

    },
    /* 16 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "b", function () {
        return getWeekStartByRegion;
      });
      /* harmony export (binding) */


      __webpack_require__.d(__webpack_exports__, "a", function () {
        return getWeekStartByLocale;
      });

      function getWeekStartByRegion(regionCode, regionDayMap) {
        var code = regionDayMap[typeof regionCode === 'string' ? regionCode.toUpperCase() : regionCode];
        return typeof code === 'number' ? code : 1;
      }

      function getWeekStartByLocale(locale, langRegionMap, regionDayMap) {
        if (locale) {
          var data = locale.toLowerCase().split(/[-_]/);
          var language = data[0];
          var country;

          if (data[1] && data[1].length === 4) {
            language += "_" + data[1];
            country = data[2];
          } else {
            country = data[1];
          }

          if (!country) {
            country = langRegionMap[language];
          }

          if (country) {
            return getWeekStartByRegion(country.match(/^\d+$/) ? Number(country) : country, regionDayMap);
          }
        }

        return 1;
      }
      /***/

    },
    /* 17 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var langRegionMap = {
        en: 'US',
        zh: 'CN',
        zh_hans: 'CN',
        hans: 'CN',
        wuu: 'CN',
        hsn: 'CN',
        hak: 'CN',
        nan: 'CN',
        gan: 'CN',
        hi: 'IN',
        te: 'IN',
        mr: 'IN',
        ta: 'IN',
        gu: 'IN',
        kn: 'IN',
        or: 'IN',
        ml: 'IN',
        pa_guru: 'IN',
        bho: 'IN',
        awa: 'IN',
        as: 'IN',
        mwr: 'IN',
        mai: 'IN',
        mag: 'IN',
        bgc: 'IN',
        hne: 'IN',
        dcc: 'IN',
        dz: 'BT',
        tn: 'BW',
        am: 'ET',
        om: 'ET',
        quc: 'GT',
        id: 'ID',
        jv: 'ID',
        su: 'ID',
        mad: 'ID',
        ms_arab: 'ID',
        ga: 'IE',
        he: 'IL',
        jam: 'JM',
        ja: 'JP',
        km: 'KH',
        ko: 'KR',
        lo: 'LA',
        mh: 'MH',
        my: 'MM',
        mt: 'MT',
        ne: 'NP',
        fil: 'PH',
        ceb: 'PH',
        ilo: 'PH',
        ur: 'PK',
        pa: 'PK',
        pa_arab: 'PK',
        arab: 'PK',
        lah: 'PK',
        ps: 'PK',
        sd: 'PK',
        sd_arab: 'PK',
        skr: 'PK',
        gn: 'PY',
        th: 'TH',
        tts: 'TH',
        aeb: 'TN',
        zh_hant: 'TW',
        hant: 'TW',
        sm: 'WS',
        zu: 'ZA',
        sn: 'ZW',
        arq: 'DZ',
        ar: 'EG',
        arz: 'EG',
        fa: 'IR',
        az_arab: 'IR',
        ary: 'MA',
        bn: 'BD',
        rkt: 'BD',
        dv: 'MV'
      };
      /* harmony default export */

      __webpack_exports__["a"] = langRegionMap;
      /***/
    },
    /* 18 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      var regionDayMap = {
        AG: 0,
        ATG: 0,
        28: 0,
        AR: 0,
        ARG: 0,
        32: 0,
        AS: 0,
        ASM: 0,
        16: 0,
        AU: 0,
        AUS: 0,
        36: 0,
        BR: 0,
        BRA: 0,
        76: 0,
        BS: 0,
        BHS: 0,
        44: 0,
        BT: 0,
        BTN: 0,
        64: 0,
        BW: 0,
        BWA: 0,
        72: 0,
        BZ: 0,
        BLZ: 0,
        84: 0,
        CA: 0,
        CAN: 0,
        124: 0,
        CN: 0,
        CHN: 0,
        156: 0,
        CO: 0,
        COL: 0,
        170: 0,
        DM: 0,
        DMA: 0,
        212: 0,
        DO: 0,
        DOM: 0,
        214: 0,
        ET: 0,
        ETH: 0,
        231: 0,
        GT: 0,
        GTM: 0,
        320: 0,
        GU: 0,
        GUM: 0,
        316: 0,
        HK: 0,
        HKG: 0,
        344: 0,
        HN: 0,
        HND: 0,
        340: 0,
        ID: 0,
        IDN: 0,
        360: 0,
        IE: 0,
        IRL: 0,
        372: 0,
        IL: 0,
        ISR: 0,
        376: 0,
        IN: 0,
        IND: 0,
        356: 0,
        JM: 0,
        JAM: 0,
        388: 0,
        JP: 0,
        JPN: 0,
        392: 0,
        KE: 0,
        KEN: 0,
        404: 0,
        KH: 0,
        KHM: 0,
        116: 0,
        KR: 0,
        KOR: 0,
        410: 0,
        LA: 0,
        LA0: 0,
        418: 0,
        MH: 0,
        MHL: 0,
        584: 0,
        MM: 0,
        MMR: 0,
        104: 0,
        MO: 0,
        MAC: 0,
        446: 0,
        MT: 0,
        MLT: 0,
        470: 0,
        MX: 0,
        MEX: 0,
        484: 0,
        MZ: 0,
        MOZ: 0,
        508: 0,
        NI: 0,
        NIC: 0,
        558: 0,
        NP: 0,
        NPL: 0,
        524: 0,
        NZ: 0,
        NZL: 0,
        554: 0,
        PA: 0,
        PAN: 0,
        591: 0,
        PE: 0,
        PER: 0,
        604: 0,
        PH: 0,
        PHL: 0,
        608: 0,
        PK: 0,
        PAK: 0,
        586: 0,
        PR: 0,
        PRI: 0,
        630: 0,
        PY: 0,
        PRY: 0,
        600: 0,
        SA: 0,
        SAU: 0,
        682: 0,
        SG: 0,
        SGP: 0,
        702: 0,
        SV: 0,
        SLV: 0,
        222: 0,
        TH: 0,
        THA: 0,
        764: 0,
        TN: 0,
        TUN: 0,
        788: 0,
        TT: 0,
        TTO: 0,
        780: 0,
        TW: 0,
        TWN: 0,
        158: 0,
        UM: 0,
        UMI: 0,
        581: 0,
        US: 0,
        USA: 0,
        840: 0,
        VE: 0,
        VEN: 0,
        862: 0,
        VI: 0,
        VIR: 0,
        850: 0,
        WS: 0,
        WSM: 0,
        882: 0,
        YE: 0,
        YEM: 0,
        887: 0,
        ZA: 0,
        ZAF: 0,
        710: 0,
        ZW: 0,
        ZWE: 0,
        716: 0,
        AE: 6,
        ARE: 6,
        784: 6,
        AF: 6,
        AFG: 6,
        4: 6,
        BH: 6,
        BHR: 6,
        48: 6,
        DJ: 6,
        DJI: 6,
        262: 6,
        DZ: 6,
        DZA: 6,
        12: 6,
        EG: 6,
        EGY: 6,
        818: 6,
        IQ: 6,
        IRQ: 6,
        368: 6,
        IR: 6,
        IRN: 6,
        364: 6,
        JO: 6,
        JOR: 6,
        400: 6,
        KW: 6,
        KWT: 6,
        414: 6,
        LY: 6,
        LBY: 6,
        434: 6,
        MA: 6,
        MAR: 6,
        504: 6,
        OM: 6,
        OMN: 6,
        512: 6,
        QA: 6,
        QAT: 6,
        634: 6,
        SD: 6,
        SDN: 6,
        729: 6,
        SY: 6,
        SYR: 6,
        760: 6,
        BD: 5,
        BGD: 5,
        50: 5,
        MV: 5,
        MDV: 5,
        462: 5
      };
      /* harmony default export */

      __webpack_exports__["a"] = regionDayMap;
      /***/
    },
    /* 19 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */


      var isNumberRegex = /^\d+$/;
      var isWhitespaceRegex = /\s/;
      var punctuationList = '!"#$%&\'()*+,-./:;<=>?@[]^_`{|}~';
      /**
       * Check if the given string is in lower case
       *
       * @param {String} str
       */

      var isLowerCase = function isLowerCase(str) {
        return str == str.toLowerCase() && str != str.toUpperCase();
      };
      /**
       * Check if the given string is in upper case
       *
       * @param {String} str
       */


      var isUpperCase = function isUpperCase(str) {
        return str == str.toUpperCase() && str != str.toLowerCase();
      };

      var passOrThrowError = function passOrThrowError(loose, ret, i, str) {
        if (!loose) {
          var _char = str.charAt(i);

          var pos = i + 1;
          throw {
            name: 'StringMaskError',
            message: "StringMaskError: error applying mask at position \"".concat(pos, "\" , char \"").concat(_char, "\""),
            pos: pos,
            "char": _char
          };
        } else ret[i] = ' ';
      };
      /**
       * NumberMask
       *
       * A javascript implementation for BBj numbers masking
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var StringMask = /*#__PURE__*/function () {
        function StringMask() {
          _classCallCheck(this, StringMask);
        }

        _createClass(StringMask, null, [{
          key: "mask",

          /**
           * Mask the given string with the given mask according to BBj rules
           *
           * @param {String} str the string to mask
           * @param {String} mask the mask to use for formatting
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           * 
           * @throws {MaskIsTooShortError}
           * @throws {StringMaskError}
           * @throws {MaskError}
           * 
           * @returns {String} the masked string
           */
          value: function mask(str, _mask) {
            var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            str = String(str);
            _mask = String(_mask);
            var maskLen = _mask.length;
            var strLen = str.length;

            if (strLen > maskLen) {
              if (loose) return str; // friendly silent fail
              else throw {
                  name: 'MaskIsTooShortError',
                  message: "MaskIsTooShortError: Mask is shorter than the passed string"
                };
            }

            var ret = new Array(maskLen);
            var pos = 0; // to keep track of the current position in the str

            var maskByte = '';

            for (var i = 0; i < maskLen; i++) {
              maskByte = _mask.charAt(i);

              switch (maskByte) {
                case 'X':
                  // match any character
                  ret[i] = pos < strLen ? str.charAt(pos) : ' ';
                  ++pos;
                  break;

                case 'A':
                  // match letter; force upper case
                  if (pos < strLen) {
                    var _byte = str.charAt(pos);

                    if (isUpperCase(_byte)) ret[i] = _byte;else if (isLowerCase(_byte)) ret[i] = _byte.toUpperCase();else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'a':
                  // match letter
                  if (pos < strLen) {
                    var _byte2 = str.charAt(pos);

                    if (isUpperCase(_byte2) || isLowerCase(_byte2)) ret[i] = _byte2;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case '0':
                  // match digit
                  if (pos < strLen) {
                    var _byte3 = str.charAt(pos);

                    if (isNumberRegex.test(_byte3)) ret[i] = _byte3;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'Z':
                  // match letter or digit; force upper case
                  if (pos < strLen) {
                    var _byte4 = str.charAt(pos);

                    if (isUpperCase(_byte4) || isNumberRegex.test(_byte4)) ret[i] = _byte4;else if (isLowerCase(_byte4)) ret[i] = _byte4.toUpperCase();else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                case 'z':
                  // match letter or digit
                  if (pos < strLen) {
                    var _byte5 = str.charAt(pos);

                    if (isUpperCase(_byte5) || isLowerCase(_byte5) || isNumberRegex.test(_byte5)) ret[i] = _byte5;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;
                  break;

                case 'U':
                  // match letter (force upper case), digit, whitespace or punctuation.
                  if (pos < strLen) {
                    var _byte6 = str.charAt(pos);

                    if (isLowerCase(_byte6)) ret[i] = _byte6.toUpperCase();else if (isUpperCase(_byte6) || isNumberRegex.test(_byte6) || isWhitespaceRegex.test(_byte6) || punctuationList.indexOf(_byte6) > -1) ret[i] = _byte6;else passOrThrowError(loose, ret, i, str);
                  } else ret[i] = ' ';

                  ++pos;
                  break;

                default:
                  ret[i] = maskByte;
                  break;
              }
            }

            if (pos < strLen) {
              if (!loose) {
                throw {
                  name: 'MaskError',
                  message: 'Mask cannot be applied'
                };
              }
            }

            return ret.join('');
          }
        }]);

        return StringMask;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = StringMask;
      /***/
    },
    /* 20 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__Types__ = __webpack_require__(21);
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /* harmony default export */


      __webpack_exports__["a"] = __WEBPACK_IMPORTED_MODULE_0__Types__["a"
      /* default */
      ];
      /***/
    },
    /* 21 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony import */

      var __WEBPACK_IMPORTED_MODULE_0__NumberMask__ = __webpack_require__(1);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_1__DateMask__ = __webpack_require__(2);
      /* harmony import */


      var __WEBPACK_IMPORTED_MODULE_2__StringMask__ = __webpack_require__(4);

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /*
       * This file is part of bbj-masks lib.
       * (c) Basis Europe <eu@basis.com>
       *
       * For the full copyright and license information, please view the LICENSE
       * file that was distributed with this source code.
       */

      /**
       * Types
       *
       * BBj masks factory
       *
       * @author Hyyan Abo Fakher <habofakher@basis.com>
       */


      var Types = /*#__PURE__*/function () {
        function Types() {
          _classCallCheck(this, Types);
        }

        _createClass(Types, null, [{
          key: "number",

          /**
           * Mask the given number with the given mask according to BBj rules
           *
           * @param {Number} number the number to format
           * @param {String} mask the mask to use for formatting
           * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
           * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
           * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
           *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           *
           * @returns {String} the masked number
           */
          value: function number(_number, mask) {
            var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
            var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
            var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
            var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
            return __WEBPACK_IMPORTED_MODULE_0__NumberMask__["a"
            /* default */
            ].mask(_number, mask, groupingSeparator, decimalSeparator, forceTrailingZeros, loose);
          }
          /**
           * Mask a date according to bbj masking rules
           *
           * @param {String} date date as a string
           * @param {String} mask mask as a string
           * @param {String} [locale=Browser's locale] the language to use ex(en-US). default is to the system language
           * @param {String} [timezone=System timezone] the time zone descriptor (e.g. America/Los_Angeles). default to the system
           *                          timezone
           *
           * @return {String} number masked with the given mask
           */

        }, {
          key: "date",
          value: function date(_date, mask, locale, timezone) {
            return __WEBPACK_IMPORTED_MODULE_1__DateMask__["c"
            /* default */
            ].mask(_date, mask, locale, timezone);
          }
          /**
           * Mask the given string with the given mask according to BBj rules
           *
           * @param {String} str the string to mask
           * @param {String} mask the mask to use for formatting
           * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
           *                anyway , otherwise it will stop at first error and throw it.
           *
           * @throws {MaskIsTooShortError}
           * @throws {StringMaskError}
           * @throws {MaskError}
           *
           * @returns {String} the masked string
           */

        }, {
          key: "string",
          value: function string(str, mask) {
            var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            return __WEBPACK_IMPORTED_MODULE_2__StringMask__["a"
            /* default */
            ].mask(str, mask, loose);
          }
        }]);

        return Types;
      }();
      /* harmony default export */


      __webpack_exports__["a"] = Types;
      /***/
    }
    /******/
    ])
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/flatpickr/dist/flatpickr.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/flatpickr/dist/flatpickr.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* flatpickr v4.6.6, @license MIT */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function () {
  'use strict';
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };

  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }

  var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
  var defaults = {
    _disable: [],
    _enable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enable: [],
    enableSeconds: false,
    enableTime: false,
    errorHandler: function errorHandler(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function getWeek(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.

      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.

      var week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.

      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: undefined,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    months: {
      shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function ordinal(nth) {
      var s = nth % 100;
      if (s > 3 && s < 21) return "th";

      switch (s % 10) {
        case 1:
          return "st";

        case 2:
          return "nd";

        case 3:
          return "rd";

        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };

  var pad = function pad(number, length) {
    if (length === void 0) {
      length = 2;
    }

    return ("000" + number).slice(length * -1);
  };

  var int = function int(bool) {
    return bool === true ? 1 : 0;
  };
  /* istanbul ignore next */


  function debounce(func, wait, immediate) {
    if (immediate === void 0) {
      immediate = false;
    }

    var timeout;
    return function () {
      var context = this,
          args = arguments;
      timeout !== null && clearTimeout(timeout);
      timeout = window.setTimeout(function () {
        timeout = null;
        if (!immediate) func.apply(context, args);
      }, wait);
      if (immediate && !timeout) func.apply(context, args);
    };
  }

  var arrayify = function arrayify(obj) {
    return obj instanceof Array ? obj : [obj];
  };

  function toggleClass(elem, className, bool) {
    if (bool === true) return elem.classList.add(className);
    elem.classList.remove(className);
  }

  function createElement(tag, className, content) {
    var e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== undefined) e.textContent = content;
    return e;
  }

  function clearNode(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function findParent(node, condition) {
    if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
    return undefined; // nothing found
  }

  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"),
        numInput = createElement("input", "numInput " + inputClassName),
        arrowUp = createElement("span", "arrowUp"),
        arrowDown = createElement("span", "arrowDown");

    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }

    if (opts !== undefined) for (var key in opts) {
      numInput.setAttribute(key, opts[key]);
    }
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }

  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }

      return event.target;
    } catch (error) {
      return event.target;
    }
  }

  var doNothing = function doNothing() {
    return undefined;
  };

  var monthToStr = function monthToStr(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  };

  var revFormat = {
    D: doNothing,
    F: function F(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function G(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    H: function H(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function J(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function K(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function M(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function S(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function U(_, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1000);
    },
    W: function W(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function Y(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function Z(_, ISODate) {
      return new Date(ISODate);
    },
    d: function d(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function h(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    i: function i(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function j(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function m(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function n(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function s(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function u(_, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function y(dateObj, year) {
      dateObj.setFullYear(2000 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "(\\w+)",
    F: "(\\w+)",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "(\\w+)",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "(\\w+)",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    // get the date in UTC
    Z: function Z(date) {
      return date.toISOString();
    },
    // weekday name, short, e.g. Thu
    D: function D(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    // full month name e.g. January
    F: function F(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    // padded hour 1-12
    G: function G(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    // hours with leading zero e.g. 03
    H: function H(date) {
      return pad(date.getHours());
    },
    // day (1-30) with ordinal suffix e.g. 1st, 2nd
    J: function J(date, locale) {
      return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    // AM/PM
    K: function K(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    // shorthand month e.g. Jan, Sep, Oct, etc
    M: function M(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    // seconds 00-59
    S: function S(date) {
      return pad(date.getSeconds());
    },
    // unix timestamp
    U: function U(date) {
      return date.getTime() / 1000;
    },
    W: function W(date, _, options) {
      return options.getWeek(date);
    },
    // full year e.g. 2016, padded (0001-9999)
    Y: function Y(date) {
      return pad(date.getFullYear(), 4);
    },
    // day in month, padded (01-30)
    d: function d(date) {
      return pad(date.getDate());
    },
    // hour from 1-12 (am/pm)
    h: function h(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    // minutes, padded with leading zero e.g. 09
    i: function i(date) {
      return pad(date.getMinutes());
    },
    // day in month (1-30)
    j: function j(date) {
      return date.getDate();
    },
    // weekday name, full, e.g. Thursday
    l: function l(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    // padded month number (01-12)
    m: function m(date) {
      return pad(date.getMonth() + 1);
    },
    // the month number (1-12)
    n: function n(date) {
      return date.getMonth() + 1;
    },
    // seconds 0-59
    s: function s(date) {
      return date.getSeconds();
    },
    // Unix Milliseconds
    u: function u(date) {
      return date.getTime();
    },
    // number of the day of the week
    w: function w(date) {
      return date.getDay();
    },
    // last two digits of year e.g. 16 for 2016
    y: function y(date) {
      return String(date.getFullYear()).substring(2);
    }
  };

  var createDateFormatter = function createDateFormatter(_a) {
    var _b = _a.config,
        config = _b === void 0 ? defaults : _b,
        _c = _a.l10n,
        l10n = _c === void 0 ? english : _c,
        _d = _a.isMobile,
        isMobile = _d === void 0 ? false : _d;
    return function (dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;

      if (config.formatDate !== undefined && !isMobile) {
        return config.formatDate(dateObj, frmt, locale);
      }

      return frmt.split("").map(function (c, i, arr) {
        return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
      }).join("");
    };
  };

  var createDateParser = function createDateParser(_a) {
    var _b = _a.config,
        config = _b === void 0 ? defaults : _b,
        _c = _a.l10n,
        l10n = _c === void 0 ? english : _c;
    return function (date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date) return undefined;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined // timestamp
      ) // create a copy
        parsedDate = new Date(date);else if (typeof date === "string") {
        // date string
        var format = givenFormat || (config || defaults).dateFormat;
        var datestr = String(date).trim();

        if (datestr === "today") {
          parsedDate = new Date();
          timeless = true;
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr) // datestrings w/ timezone
        ) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {
          parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
          var matched = void 0,
              ops = [];

          for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
            var token_1 = format[i];
            var isBackSlash = token_1 === "\\";
            var escaped = format[i - 1] === "\\" || isBackSlash;

            if (tokenRegex[token_1] && !escaped) {
              regexStr += tokenRegex[token_1];
              var match = new RegExp(regexStr).exec(date);

              if (match && (matched = true)) {
                ops[token_1 !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token_1],
                  val: match[++matchIndex]
                });
              }
            } else if (!isBackSlash) regexStr += "."; // don't really care


            ops.forEach(function (_a) {
              var fn = _a.fn,
                  val = _a.val;
              return parsedDate = fn(parsedDate, val, locale) || parsedDate;
            });
          }

          parsedDate = matched ? parsedDate : undefined;
        }
      }
      /* istanbul ignore next */

      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return undefined;
      }

      if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  };
  /**
   * Compute the difference in dates, measured in ms
   */


  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }

    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }

    return date1.getTime() - date2.getTime();
  }

  var isBetween = function isBetween(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };

  var duration = {
    DAY: 86400000
  };

  if (typeof Object.assign !== "function") {
    Object.assign = function (target) {
      var args = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }

      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }

      var _loop_1 = function _loop_1(source) {
        if (source) {
          Object.keys(source).forEach(function (key) {
            return target[key] = source[key];
          });
        }
      };

      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];

        _loop_1(source);
      }

      return target;
    };
  }

  var DEBOUNCED_CHANGE_MS = 300;

  function FlatpickrInstance(element, instanceConfig) {
    var self = {
      config: _assign(_assign({}, defaults), flatpickr.defaultConfig),
      l10n: english
    };
    self.parseDate = createDateParser({
      config: self.config,
      l10n: self.l10n
    });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear;
    self.close = close;
    self._createElement = createElement;
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.open = open;
    self.redraw = redraw;
    self.set = set;
    self.setDate = setDate;
    self.toggle = toggle;

    function setupHelperFunctions() {
      self.utils = {
        getDaysInMonth: function getDaysInMonth(month, yr) {
          if (month === void 0) {
            month = self.currentMonth;
          }

          if (yr === void 0) {
            yr = self.currentYear;
          }

          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
          return self.l10n.daysInMonth[month];
        }
      };
    }

    function init() {
      self.element = self.input = element;
      self.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self.isMobile) build();
      bindEvents();

      if (self.selectedDates.length || self.config.noCalendar) {
        if (self.config.enableTime) {
          setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);
        }

        updateValue(false);
      }

      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      /* TODO: investigate this further
                 Currently, there is weird positioning behavior in safari causing pages
        to scroll up. https://github.com/chmln/flatpickr/issues/563
                 However, most browsers are not Safari and positioning is expensive when used
        in scale. https://github.com/chmln/flatpickr/issues/1096
      */

      if (!self.isMobile && isSafari) {
        positionCalendar();
      }

      triggerEvent("onReady");
    }

    function bindToInstance(fn) {
      return fn.bind(self);
    }

    function setCalendarWidth() {
      var config = self.config;

      if (config.weekNumbers === false && config.showMonths === 1) {
        return;
      } else if (config.noCalendar !== true) {
        window.requestAnimationFrame(function () {
          if (self.calendarContainer !== undefined) {
            self.calendarContainer.style.visibility = "hidden";
            self.calendarContainer.style.display = "block";
          }

          if (self.daysContainer !== undefined) {
            var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
            self.daysContainer.style.width = daysWidth + "px";
            self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
            self.calendarContainer.style.removeProperty("visibility");
            self.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    /**
     * The handler for all events targeting the time inputs
     */


    function updateTime(e) {
      if (self.selectedDates.length === 0) {
        var defaultDate = self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date();

        var _a = getDefaultHours(),
            hours = _a.hours,
            minutes = _a.minutes,
            seconds = _a.seconds;

        defaultDate.setHours(hours, minutes, seconds, 0);
        self.setDate(defaultDate, false);
      }

      if (e !== undefined && e.type !== "blur") {
        timeWrapper(e);
      }

      var prevValue = self._input.value;
      setHoursFromInputs();
      updateValue();

      if (self._input.value !== prevValue) {
        self._debouncedChange();
      }
    }

    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
    }

    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;

        default:
          return hour % 12;
      }
    }
    /**
     * Syncs the selected date object time with user's time input
     */


    function setHoursFromInputs() {
      if (self.hourElement === undefined || self.minuteElement === undefined) return;
      var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
          minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
          seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

      if (self.amPM !== undefined) {
        hours = ampm2military(hours, self.amPM.textContent);
      }

      var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
      var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;

      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }

      if (limitMinHours) {
        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }

      setHours(hours, minutes, seconds);
    }
    /**
     * Syncs time input values with a date
     */


    function setHoursFromDate(dateObj) {
      var date = dateObj || self.latestSelectedDateObj;

      if (date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }

    function getDefaultHours() {
      var hours = self.config.defaultHour;
      var minutes = self.config.defaultMinute;
      var seconds = self.config.defaultSeconds;

      if (self.config.minDate !== undefined) {
        var minHr = self.config.minDate.getHours();
        var minMinutes = self.config.minDate.getMinutes();
        hours = Math.max(hours, minHr);
        if (hours === minHr) minutes = Math.max(minMinutes, minutes);
        if (hours === minHr && minutes === minMinutes) seconds = self.config.minDate.getSeconds();
      }

      if (self.config.maxDate !== undefined) {
        var maxHr = self.config.maxDate.getHours();
        var maxMinutes = self.config.maxDate.getMinutes();
        hours = Math.min(hours, maxHr);
        if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
        if (hours === maxHr && minutes === maxMinutes) seconds = self.config.maxDate.getSeconds();
      }

      return {
        hours: hours,
        minutes: minutes,
        seconds: seconds
      };
    }
    /**
     * Sets the hours, minutes, and optionally seconds
     * of the latest selected date object and the
     * corresponding time inputs
     * @param {Number} hours the hour. whether its military
     *                 or am-pm gets inferred from config
     * @param {Number} minutes the minutes
     * @param {Number} seconds the seconds (optional)
     */


    function setHours(hours, minutes, seconds) {
      if (self.latestSelectedDateObj !== undefined) {
        self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }

      if (!self.hourElement || !self.minuteElement || self.isMobile) return;
      self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self.minuteElement.value = pad(minutes);
      if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
      if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
    }
    /**
     * Handles the year input and incrementing events
     * @param {Event} event the keyup or increment event
     */


    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);

      if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    /**
     * Essentially addEventListener + tracking
     * @param {Element} element the element to addEventListener to
     * @param {String} event the event name
     * @param {Function} handler the event handler
     */


    function bind(element, event, handler, options) {
      if (event instanceof Array) return event.forEach(function (ev) {
        return bind(element, ev, handler, options);
      });
      if (element instanceof Array) return element.forEach(function (el) {
        return bind(el, event, handler, options);
      });
      element.addEventListener(event, handler, options);

      self._handlers.push({
        element: element,
        event: event,
        handler: handler,
        options: options
      });
    }

    function triggerChange() {
      triggerEvent("onChange");
    }
    /**
     * Adds all the necessary event listeners
     */


    function bindEvents() {
      if (self.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function (evt) {
          Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
            return bind(el, "click", self[evt]);
          });
        });
      }

      if (self.isMobile) {
        setupMobile();
        return;
      }

      var debouncedResize = debounce(onResize, 50);
      self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
        if (self.config.mode === "range") onMouseOver(getEventTarget(e));
      });
      bind(window.document.body, "keydown", onKeyDown);
      if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
      if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "click", documentClick);
      bind(window.document, "focus", documentClick, {
        capture: true
      });

      if (self.config.clickOpens === true) {
        bind(self._input, "focus", self.open);
        bind(self._input, "click", self.open);
      }

      if (self.daysContainer !== undefined) {
        bind(self.monthNav, "click", onMonthNavClick);
        bind(self.monthNav, ["keyup", "increment"], onYearInput);
        bind(self.daysContainer, "click", selectDate);
      }

      if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
        var selText = function selText(e) {
          return getEventTarget(e).select();
        };

        bind(self.timeContainer, ["increment"], updateTime);
        bind(self.timeContainer, "blur", updateTime, {
          capture: true
        });
        bind(self.timeContainer, "click", timeIncrement);
        bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
        if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
          return self.secondElement && self.secondElement.select();
        });

        if (self.amPM !== undefined) {
          bind(self.amPM, "click", function (e) {
            updateTime(e);
            triggerChange();
          });
        }
      }

      if (self.config.allowInput) bind(self._input, "blur", onBlur);
    }
    /**
     * Set the calendar view to a particular date.
     * @param {Date} jumpDate the date to set the view to
     * @param {boolean} triggerChange if change events should be triggered
     */


    function jumpToDate(jumpDate, triggerChange) {
      var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
      var oldYear = self.currentYear;
      var oldMonth = self.currentMonth;

      try {
        if (jumpTo !== undefined) {
          self.currentYear = jumpTo.getFullYear();
          self.currentMonth = jumpTo.getMonth();
        }
      } catch (e) {
        /* istanbul ignore next */
        e.message = "Invalid date supplied: " + jumpTo;
        self.config.errorHandler(e);
      }

      if (triggerChange && self.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }

      if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }

      self.redraw();
    }
    /**
     * The up/down arrow handler for time inputs
     * @param {Event} e the click event
     */


    function timeIncrement(e) {
      var eventTarget = getEventTarget(e);
      if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    /**
     * Increments/decrements the value of input associ-
     * ated with the up/down arrow by dispatching an
     * "increment" event on the input.
     *
     * @param {Event} e the click event
     * @param {Number} delta the diff (usually 1 or -1)
     * @param {Element} inputElem the input element
     */


    function incrementNumInput(e, delta, inputElem) {
      var target = e && getEventTarget(e);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }

    function build() {
      var fragment = window.document.createDocumentFragment();
      self.calendarContainer = createElement("div", "flatpickr-calendar");
      self.calendarContainer.tabIndex = -1;

      if (!self.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self.innerContainer = createElement("div", "flatpickr-innerContainer");

        if (self.config.weekNumbers) {
          var _a = buildWeeks(),
              weekWrapper = _a.weekWrapper,
              weekNumbers = _a.weekNumbers;

          self.innerContainer.appendChild(weekWrapper);
          self.weekNumbers = weekNumbers;
          self.weekWrapper = weekWrapper;
        }

        self.rContainer = createElement("div", "flatpickr-rContainer");
        self.rContainer.appendChild(buildWeekdays());

        if (!self.daysContainer) {
          self.daysContainer = createElement("div", "flatpickr-days");
          self.daysContainer.tabIndex = -1;
        }

        buildDays();
        self.rContainer.appendChild(self.daysContainer);
        self.innerContainer.appendChild(self.rContainer);
        fragment.appendChild(self.innerContainer);
      }

      if (self.config.enableTime) {
        fragment.appendChild(buildTime());
      }

      toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
      toggleClass(self.calendarContainer, "animate", self.config.animate === true);
      toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
      self.calendarContainer.appendChild(fragment);
      var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;

      if (self.config.inline || self.config.static) {
        self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

        if (self.config.inline) {
          if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
        }

        if (self.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
          wrapper.appendChild(self.element);
          if (self.altInput) wrapper.appendChild(self.altInput);
          wrapper.appendChild(self.calendarContainer);
        }
      }

      if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
    }

    function createDay(className, date, dayNumber, i) {
      var dateIsEnabled = isEnabled(date, true),
          dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i;
      dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

      if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
        self.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }

      if (dateIsEnabled) {
        dayElement.tabIndex = -1;

        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self.selectedDateElem = dayElement;

          if (self.config.mode === "range") {
            toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
            if (className === "nextMonthDay") dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }

      if (self.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
      }

      if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
        self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
      }

      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }

    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self.config.mode === "range") onMouseOver(targetNode);
    }

    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
      var endMonth = delta > 0 ? self.config.showMonths : -1;

      for (var m = startMonth; m != endMonth; m += delta) {
        var month = self.daysContainer.children[m];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;

        for (var i = startIndex; i != endIndex; i += delta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
        }
      }

      return undefined;
    }

    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
      var endMonth = delta > 0 ? self.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;

      for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
        var month = self.daysContainer.children[m];
        var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;

        for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
        }
      }

      self.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return undefined;
    }

    function focusOnDay(current, offset) {
      var dayFocused = isInView(document.activeElement || document.body);
      var startElem = current !== undefined ? current : dayFocused ? document.activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);

      if (startElem === undefined) {
        self._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }

    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self.utils.getDaysInMonth(month, year),
          days = window.document.createDocumentFragment(),
          isMultiMonth = self.config.showMonths > 1,
          prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
          nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth,
          dayIndex = 0; // prepend days from the ending of previous month

      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      } // Start at 1 since there is no 0th day


      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
      } // append days from the next month


      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      } //updateNavigationCurrentMonth();


      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }

    function buildDays() {
      if (self.daysContainer === undefined) {
        return;
      }

      clearNode(self.daysContainer); // TODO: week numbers for each month

      if (self.weekNumbers) clearNode(self.weekNumbers);
      var frag = document.createDocumentFragment();

      for (var i = 0; i < self.config.showMonths; i++) {
        var d = new Date(self.currentYear, self.currentMonth, 1);
        d.setMonth(self.currentMonth + i);
        frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
      }

      self.daysContainer.appendChild(frag);
      self.days = self.daysContainer.firstChild;

      if (self.config.mode === "range" && self.selectedDates.length === 1) {
        onMouseOver();
      }
    }

    function buildMonthSwitch() {
      if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;

      var shouldBuildMonth = function shouldBuildMonth(month) {
        if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
          return false;
        }

        return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
      };

      self.monthsDropdownContainer.tabIndex = -1;
      self.monthsDropdownContainer.innerHTML = "";

      for (var i = 0; i < 12; i++) {
        if (!shouldBuildMonth(i)) continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self.currentYear, i).getMonth().toString();
        month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
        month.tabIndex = -1;

        if (self.currentMonth === i) {
          month.selected = true;
        }

        self.monthsDropdownContainer.appendChild(month);
      }
    }

    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;

      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
        bind(self.monthsDropdownContainer, "change", function (e) {
          var target = getEventTarget(e);
          var selectedMonth = parseInt(target.value, 10);
          self.changeMonth(selectedMonth - self.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self.monthsDropdownContainer;
      }

      var yearInput = createNumberInput("cur-year", {
        tabindex: "-1"
      });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);

      if (self.config.minDate) {
        yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
      }

      if (self.config.maxDate) {
        yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
      }

      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container: container,
        yearElement: yearElement,
        monthElement: monthElement
      };
    }

    function buildMonths() {
      clearNode(self.monthNav);
      self.monthNav.appendChild(self.prevMonthNav);

      if (self.config.showMonths) {
        self.yearElements = [];
        self.monthElements = [];
      }

      for (var m = self.config.showMonths; m--;) {
        var month = buildMonth();
        self.yearElements.push(month.yearElement);
        self.monthElements.push(month.monthElement);
        self.monthNav.appendChild(month.container);
      }

      self.monthNav.appendChild(self.nextMonthNav);
    }

    function buildMonthNav() {
      self.monthNav = createElement("div", "flatpickr-months");
      self.yearElements = [];
      self.monthElements = [];
      self.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self.prevMonthNav.innerHTML = self.config.prevArrow;
      self.nextMonthNav = createElement("span", "flatpickr-next-month");
      self.nextMonthNav.innerHTML = self.config.nextArrow;
      buildMonths();
      Object.defineProperty(self, "_hidePrevMonthArrow", {
        get: function get() {
          return self.__hidePrevMonthArrow;
        },
        set: function set(bool) {
          if (self.__hidePrevMonthArrow !== bool) {
            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
            self.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self, "_hideNextMonthArrow", {
        get: function get() {
          return self.__hideNextMonthArrow;
        },
        set: function set(bool) {
          if (self.__hideNextMonthArrow !== bool) {
            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
            self.__hideNextMonthArrow = bool;
          }
        }
      });
      self.currentYearElement = self.yearElements[0];
      updateNavigationCurrentMonth();
      return self.monthNav;
    }

    function buildTime() {
      self.calendarContainer.classList.add("hasTime");
      if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
      self.timeContainer = createElement("div", "flatpickr-time");
      self.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self.l10n.hourAriaLabel
      });
      self.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self.l10n.minuteAriaLabel
      });
      self.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
      self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));
      self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);
      self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
      self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
      self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
      self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
      self.minuteElement.setAttribute("min", "0");
      self.minuteElement.setAttribute("max", "59");
      self.timeContainer.appendChild(hourInput);
      self.timeContainer.appendChild(separator);
      self.timeContainer.appendChild(minuteInput);
      if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

      if (self.config.enableSeconds) {
        self.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self.secondElement = secondInput.getElementsByTagName("input")[0];
        self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);
        self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
        self.secondElement.setAttribute("min", "0");
        self.secondElement.setAttribute("max", "59");
        self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self.timeContainer.appendChild(secondInput);
      }

      if (!self.config.time_24hr) {
        // add self.amPM if appropriate
        self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
        self.amPM.title = self.l10n.toggleTitle;
        self.amPM.tabIndex = -1;
        self.timeContainer.appendChild(self.amPM);
      }

      return self.timeContainer;
    }

    function buildWeekdays() {
      if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);

      for (var i = self.config.showMonths; i--;) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self.weekdayContainer.appendChild(container);
      }

      updateWeekdays();
      return self.weekdayContainer;
    }

    function updateWeekdays() {
      if (!self.weekdayContainer) {
        return;
      }

      var firstDayOfWeek = self.l10n.firstDayOfWeek;

      var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);

      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }

      for (var i = self.config.showMonths; i--;) {
        self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    /* istanbul ignore next */


    function buildWeeks() {
      self.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper: weekWrapper,
        weekNumbers: weekNumbers
      };
    }

    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }

      var delta = isOffset ? value : value - self.currentMonth;
      if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
      self.currentMonth += delta;

      if (self.currentMonth < 0 || self.currentMonth > 11) {
        self.currentYear += self.currentMonth > 11 ? 1 : -1;
        self.currentMonth = (self.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }

      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }

    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }

      if (toInitial === void 0) {
        toInitial = true;
      }

      self.input.value = "";
      if (self.altInput !== undefined) self.altInput.value = "";
      if (self.mobileInput !== undefined) self.mobileInput.value = "";
      self.selectedDates = [];
      self.latestSelectedDateObj = undefined;

      if (toInitial === true) {
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
      }

      if (self.config.enableTime === true) {
        var _a = getDefaultHours(),
            hours = _a.hours,
            minutes = _a.minutes,
            seconds = _a.seconds;

        setHours(hours, minutes, seconds);
      }

      self.redraw();
      if (triggerChangeEvent) // triggerChangeEvent is true (default) or an Event
        triggerEvent("onChange");
    }

    function close() {
      self.isOpen = false;

      if (!self.isMobile) {
        if (self.calendarContainer !== undefined) {
          self.calendarContainer.classList.remove("open");
        }

        if (self._input !== undefined) {
          self._input.classList.remove("active");
        }
      }

      triggerEvent("onClose");
    }

    function destroy() {
      if (self.config !== undefined) triggerEvent("onDestroy");

      for (var i = self._handlers.length; i--;) {
        var h = self._handlers[i];
        h.element.removeEventListener(h.event, h.handler, h.options);
      }

      self._handlers = [];

      if (self.mobileInput) {
        if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
        self.mobileInput = undefined;
      } else if (self.calendarContainer && self.calendarContainer.parentNode) {
        if (self.config.static && self.calendarContainer.parentNode) {
          var wrapper = self.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);

          if (wrapper.parentNode) {
            while (wrapper.firstChild) {
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            }

            wrapper.parentNode.removeChild(wrapper);
          }
        } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
      }

      if (self.altInput) {
        self.input.type = "text";
        if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
        delete self.altInput;
      }

      if (self.input) {
        self.input.type = self.input._type;
        self.input.classList.remove("flatpickr-input");
        self.input.removeAttribute("readonly");
      }

      ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
        try {
          delete self[k];
        } catch (_) {}
      });
    }

    function isCalendarElem(elem) {
      if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;
      return self.calendarContainer.contains(elem);
    }

    function documentClick(e) {
      if (self.isOpen && !self.config.inline) {
        var eventTarget_1 = getEventTarget(e);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || // web components
        // e.path is not present in all browsers. circumventing typechecks
        e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
        var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
        var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
          return elem.contains(eventTarget_1);
        });

        if (lostFocus && isIgnored) {
          if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) {
            updateTime();
          }

          self.close();

          if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) {
            self.clear(false);
            self.redraw();
          }
        }
      }
    }

    function changeYear(newYear) {
      if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
      var newYearNum = newYear,
          isNewYear = self.currentYear !== newYearNum;
      self.currentYear = newYearNum || self.currentYear;

      if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
        self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
      } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
        self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
      }

      if (isNewYear) {
        self.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }

    function isEnabled(date, timeless) {
      if (timeless === void 0) {
        timeless = true;
      }

      var dateToCheck = self.parseDate(date, undefined, timeless); // timeless

      if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
      if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;
      if (dateToCheck === undefined) return false;
      var bool = self.config.enable.length > 0,
          array = bool ? self.config.enable : self.config.disable;

      for (var i = 0, d = void 0; i < array.length; i++) {
        d = array[i];
        if (typeof d === "function" && d(dateToCheck) // disabled by function
        ) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) // disabled by date
          return bool;else if (typeof d === "string" && dateToCheck !== undefined) {
          // disabled by date string
          var parsed = self.parseDate(d, undefined, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if ( // disabled by range
        _typeof(d) === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
      }

      return !bool;
    }

    function isInView(elem) {
      if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
      return false;
    }

    function onBlur(e) {
      var isInput = e.target === self._input;

      if (isInput && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
        self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
      }
    }

    function onKeyDown(e) {
      // e.key                      e.keyCode
      // "Backspace"                        8
      // "Tab"                              9
      // "Enter"                           13
      // "Escape"     (IE "Esc")           27
      // "ArrowLeft"  (IE "Left")          37
      // "ArrowUp"    (IE "Up")            38
      // "ArrowRight" (IE "Right")         39
      // "ArrowDown"  (IE "Down")          40
      // "Delete"     (IE "Del")           46
      var eventTarget = getEventTarget(e);
      var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
      var allowInput = self.config.allowInput;
      var allowKeydown = self.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self.config.inline && isInput && !allowInput;

      if (e.keyCode === 13 && isInput) {
        if (allowInput) {
          self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
          return eventTarget.blur();
        } else {
          self.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);

        switch (e.keyCode) {
          case 13:
            if (isTimeObj) {
              e.preventDefault();
              updateTime();
              focusAndClose();
            } else selectDate(e);

            break;

          case 27:
            // escape
            e.preventDefault();
            focusAndClose();
            break;

          case 8:
          case 46:
            if (isInput && !self.config.allowInput) {
              e.preventDefault();
              self.clear();
            }

            break;

          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e.preventDefault();

              if (self.daysContainer !== undefined && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
                var delta_1 = e.keyCode === 39 ? 1 : -1;
                if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                  e.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self.hourElement) self.hourElement.focus();

            break;

          case 38:
          case 40:
            e.preventDefault();
            var delta = e.keyCode === 40 ? 1 : -1;

            if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
              if (e.ctrlKey) {
                e.stopPropagation();
                changeYear(self.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
            } else if (eventTarget === self.currentYearElement) {
              changeYear(self.currentYear - delta);
            } else if (self.config.enableTime) {
              if (!isTimeObj && self.hourElement) self.hourElement.focus();
              updateTime(e);

              self._debouncedChange();
            }

            break;

          case 9:
            if (isTimeObj) {
              var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
                return x;
              });
              var i = elems.indexOf(eventTarget);

              if (i !== -1) {
                var target = elems[i + (e.shiftKey ? -1 : 1)];
                e.preventDefault();

                (target || self._input).focus();
              }
            } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
              e.preventDefault();

              self._input.focus();
            }

            break;
        }
      }

      if (self.amPM !== undefined && eventTarget === self.amPM) {
        switch (e.key) {
          case self.l10n.amPM[0].charAt(0):
          case self.l10n.amPM[0].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;

          case self.l10n.amPM[1].charAt(0):
          case self.l10n.amPM[1].charAt(0).toLowerCase():
            self.amPM.textContent = self.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }

      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e);
      }
    }

    function onMouseOver(elem) {
      if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled"))) return;
      var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
          initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
          rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
          rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0,
          maxRange = 0;

      for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
        if (!isEnabled(new Date(t), true)) {
          containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
          if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
        }
      }

      for (var m = 0; m < self.config.showMonths; m++) {
        var month = self.daysContainer.children[m];

        var _loop_1 = function _loop_1(i, l) {
          var dayElem = month.children[i],
              date = dayElem.dateObj;
          var timestamp = date.getTime();
          var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;

          if (outOfRange) {
            dayElem.classList.add("notAllowed");
            ["inRange", "startRange", "endRange"].forEach(function (c) {
              dayElem.classList.remove(c);
            });
            return "continue";
          } else if (containsDisabled && !outOfRange) return "continue";

          ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
            dayElem.classList.remove(c);
          });

          if (elem !== undefined) {
            elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
            if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
          }
        };

        for (var i = 0, l = month.children.length; i < l; i++) {
          _loop_1(i, l);
        }
      }
    }

    function onResize() {
      if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
    }

    function open(e, positionElement) {
      if (positionElement === void 0) {
        positionElement = self._positionElement;
      }

      if (self.isMobile === true) {
        if (e) {
          e.preventDefault();
          var eventTarget = getEventTarget(e);
          eventTarget && eventTarget.blur();
        }

        if (self.mobileInput !== undefined) {
          self.mobileInput.focus();
          self.mobileInput.click();
        }

        triggerEvent("onOpen");
        return;
      }

      if (self._input.disabled || self.config.inline) return;
      var wasOpen = self.isOpen;
      self.isOpen = true;

      if (!wasOpen) {
        self.calendarContainer.classList.add("open");

        self._input.classList.add("active");

        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }

      if (self.config.enableTime === true && self.config.noCalendar === true) {
        if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
          setTimeout(function () {
            return self.hourElement.select();
          }, 50);
        }
      }
    }

    function minMaxDateSetter(type) {
      return function (date) {
        var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
        var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

        if (dateObj !== undefined) {
          self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }

        if (self.selectedDates) {
          self.selectedDates = self.selectedDates.filter(function (d) {
            return isEnabled(d);
          });
          if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
          updateValue();
        }

        if (self.daysContainer) {
          redraw();
          if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
          self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }

    function parseConfig() {
      var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

      var userConfig = _assign(_assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);

      var formats = {};
      self.config.parseDate = userConfig.parseDate;
      self.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self.config, "enable", {
        get: function get() {
          return self.config._enable;
        },
        set: function set(dates) {
          self.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self.config, "disable", {
        get: function get() {
          return self.config._disable;
        },
        set: function set(dates) {
          self.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";

      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }

      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }

      Object.defineProperty(self.config, "minDate", {
        get: function get() {
          return self.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self.config, "maxDate", {
        get: function get() {
          return self.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });

      var minMaxTimeSetter = function minMaxTimeSetter(type) {
        return function (val) {
          self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
        };
      };

      Object.defineProperty(self.config, "minTime", {
        get: function get() {
          return self.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self.config, "maxTime", {
        get: function get() {
          return self.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });

      if (userConfig.mode === "time") {
        self.config.noCalendar = true;
        self.config.enableTime = true;
      }

      Object.assign(self.config, formats, userConfig);

      for (var i = 0; i < boolOpts.length; i++) {
        // https://github.com/microsoft/TypeScript/issues/31663
        self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
      }

      HOOKS.filter(function (hook) {
        return self.config[hook] !== undefined;
      }).forEach(function (hook) {
        self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
      });
      self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      for (var i = 0; i < self.config.plugins.length; i++) {
        var pluginConf = self.config.plugins[i](self) || {};

        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
          } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
        }
      }

      if (!userConfig.altInputClass) {
        self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
      }

      triggerEvent("onParseConfig");
    }

    function getInputElem() {
      return self.config.wrap ? element.querySelector("[data-input]") : element;
    }

    function setupLocale() {
      if (_typeof(self.config.locale) !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
      self.l10n = _assign(_assign({}, flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
      tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";

      var userConfig = _assign(_assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));

      if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
        self.config.time_24hr = self.l10n.time_24hr;
      }

      self.formatDate = createDateFormatter(self);
      self.parseDate = createDateParser({
        config: self.config,
        l10n: self.l10n
      });
    }

    function positionCalendar(customPositionElement) {
      if (self.calendarContainer === undefined) return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
        return acc + child.offsetHeight;
      }, 0),
          calendarWidth = self.calendarContainer.offsetWidth,
          configPos = self.config.position.split(" "),
          configPosVertical = configPos[0],
          configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
          inputBounds = positionElement.getBoundingClientRect(),
          distanceFromBottom = window.innerHeight - inputBounds.bottom,
          showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
      if (self.config.inline) return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;

      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }

      toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self.calendarContainer, "rightMost", rightMost);
      if (self.config.static) return;
      self.calendarContainer.style.top = top + "px";

      if (!rightMost) {
        self.calendarContainer.style.left = left + "px";
        self.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self.calendarContainer.style.left = "auto";
        self.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet(); // some testing environments don't have css support

        if (doc === undefined) return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self.calendarContainer, "rightMost", false);
        toggleClass(self.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self.calendarContainer.style.left = centerLeft + "px";
        self.calendarContainer.style.right = "auto";
      }
    }

    function getDocumentStyleSheet() {
      var editableSheet = null;

      for (var i = 0; i < document.styleSheets.length; i++) {
        var sheet = document.styleSheets[i];

        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }

        editableSheet = sheet;
        break;
      }

      return editableSheet != null ? editableSheet : createStyleSheet();
    }

    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }

    function redraw() {
      if (self.config.noCalendar || self.isMobile) return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }

    function focusAndClose() {
      self._input.focus();

      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
        // hack - bugs in the way IE handles focus keeps the calendar open
        setTimeout(self.close, 0);
      } else {
        self.close();
      }
    }

    function selectDate(e) {
      e.preventDefault();
      e.stopPropagation();

      var isSelectable = function isSelectable(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      };

      var t = findParent(getEventTarget(e), isSelectable);
      if (t === undefined) return;
      var target = t;
      var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
      self.selectedDateElem = target;
      if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
      } else if (self.config.mode === "range") {
        if (self.selectedDates.length === 2) {
          self.clear(false, false);
        }

        self.latestSelectedDateObj = selectedDate;
        self.selectedDates.push(selectedDate); // unless selecting same date twice, sort ascendingly

        if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
          return a.getTime() - b.getTime();
        });
      }
      setHoursFromInputs();

      if (shouldChangeMonth) {
        var isNewYear = self.currentYear !== selectedDate.getFullYear();
        self.currentYear = selectedDate.getFullYear();
        self.currentMonth = selectedDate.getMonth();

        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }

        triggerEvent("onMonthChange");
      }

      updateNavigationCurrentMonth();
      buildDays();
      updateValue(); // maintain focus

      if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
        self.selectedDateElem && self.selectedDateElem.focus();
      }
      if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();

      if (self.config.closeOnSelect) {
        var single = self.config.mode === "single" && !self.config.enableTime;
        var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

        if (single || range) {
          focusAndClose();
        }
      }

      triggerChange();
    }

    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate]
    };

    function set(option, value) {
      if (option !== null && _typeof(option) === "object") {
        Object.assign(self.config, option);

        for (var key in option) {
          if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
            return x();
          });
        }
      } else {
        self.config[option] = value;
        if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
          return x();
        });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
      }

      self.redraw();
      updateValue(true);
    }

    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array) dates = inputDate.map(function (d) {
        return self.parseDate(d, format);
      });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
        switch (self.config.mode) {
          case "single":
          case "time":
            dates = [self.parseDate(inputDate, format)];
            break;

          case "multiple":
            dates = inputDate.split(self.config.conjunction).map(function (date) {
              return self.parseDate(date, format);
            });
            break;

          case "range":
            dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
              return self.parseDate(date, format);
            });
            break;
        }
      } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function (d) {
        return d instanceof Date && isEnabled(d, false);
      });
      if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
        return a.getTime() - b.getTime();
      });
    }

    function setDate(date, triggerChange, format) {
      if (triggerChange === void 0) {
        triggerChange = false;
      }

      if (format === void 0) {
        format = self.config.dateFormat;
      }

      if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
      setSelectedDate(date, format);
      self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
      self.redraw();
      jumpToDate(undefined, triggerChange);
      setHoursFromDate();

      if (self.selectedDates.length === 0) {
        self.clear(false);
      }

      updateValue(triggerChange);
      if (triggerChange) triggerEvent("onChange");
    }

    function parseDateRules(arr) {
      return arr.slice().map(function (rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self.parseDate(rule, undefined, true);
        } else if (rule && _typeof(rule) === "object" && rule.from && rule.to) return {
          from: self.parseDate(rule.from, undefined),
          to: self.parseDate(rule.to, undefined)
        };

        return rule;
      }).filter(function (x) {
        return x;
      }); // remove falsy values
    }

    function setupDates() {
      self.selectedDates = [];
      self.now = self.parseDate(self.config.now) || new Date(); // Workaround IE11 setting placeholder as the input's value

      var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
      if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
      self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
      if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
      if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
      if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
      self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
      self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
    }

    function setupInputs() {
      self.input = getInputElem();
      /* istanbul ignore next */

      if (!self.input) {
        self.config.errorHandler(new Error("Invalid input element specified"));
        return;
      } // hack: store previous type to restore it after destroy()


      self.input._type = self.input.type;
      self.input.type = "text";
      self.input.classList.add("flatpickr-input");
      self._input = self.input;

      if (self.config.altInput) {
        // replicate self.element
        self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
        self._input = self.altInput;
        self.altInput.placeholder = self.input.placeholder;
        self.altInput.disabled = self.input.disabled;
        self.altInput.required = self.input.required;
        self.altInput.tabIndex = self.input.tabIndex;
        self.altInput.type = "text";
        self.input.setAttribute("type", "hidden");
        if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
      }

      if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
      self._positionElement = self.config.positionElement || self._input;
    }

    function setupMobile() {
      var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
      self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
      self.mobileInput.tabIndex = 1;
      self.mobileInput.type = inputType;
      self.mobileInput.disabled = self.input.disabled;
      self.mobileInput.required = self.input.required;
      self.mobileInput.placeholder = self.input.placeholder;
      self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

      if (self.selectedDates.length > 0) {
        self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
      }

      if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
      if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
      if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
      self.input.type = "hidden";
      if (self.altInput !== undefined) self.altInput.type = "hidden";

      try {
        if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
      } catch (_a) {}

      bind(self.mobileInput, "change", function (e) {
        self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }

    function toggle(e) {
      if (self.isOpen === true) return self.close();
      self.open(e);
    }

    function triggerEvent(event, data) {
      // If the instance has been destroyed already, all hooks have been removed
      if (self.config === undefined) return;
      var hooks = self.config[event];

      if (hooks !== undefined && hooks.length > 0) {
        for (var i = 0; hooks[i] && i < hooks.length; i++) {
          hooks[i](self.selectedDates, self.input.value, self, data);
        }
      }

      if (event === "onChange") {
        self.input.dispatchEvent(createEvent("change")); // many front-end frameworks bind to the input event

        self.input.dispatchEvent(createEvent("input"));
      }
    }

    function createEvent(name) {
      var e = document.createEvent("Event");
      e.initEvent(name, true, true);
      return e;
    }

    function isDateSelected(date) {
      for (var i = 0; i < self.selectedDates.length; i++) {
        if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
      }

      return false;
    }

    function isDateInRange(date) {
      if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
      return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
    }

    function updateNavigationCurrentMonth() {
      if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
      self.yearElements.forEach(function (yearElement, i) {
        var d = new Date(self.currentYear, self.currentMonth, 1);
        d.setMonth(self.currentMonth + i);

        if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
          self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
        } else {
          self.monthsDropdownContainer.value = d.getMonth().toString();
        }

        yearElement.value = d.getFullYear().toString();
      });
      self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
      self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
    }

    function getDateStr(format) {
      return self.selectedDates.map(function (dObj) {
        return self.formatDate(dObj, format);
      }).filter(function (d, i, arr) {
        return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
      }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
    }
    /**
     * Updates the values of inputs associated with the calendar
     */


    function updateValue(triggerChange) {
      if (triggerChange === void 0) {
        triggerChange = true;
      }

      if (self.mobileInput !== undefined && self.mobileFormatStr) {
        self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
      }

      self.input.value = getDateStr(self.config.dateFormat);

      if (self.altInput !== undefined) {
        self.altInput.value = getDateStr(self.config.altFormat);
      }

      if (triggerChange !== false) triggerEvent("onValueUpdate");
    }

    function onMonthNavClick(e) {
      var eventTarget = getEventTarget(e);
      var isPrevMonth = self.prevMonthNav.contains(eventTarget);
      var isNextMonth = self.nextMonthNav.contains(eventTarget);

      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self.changeYear(self.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self.changeYear(self.currentYear - 1);
      }
    }

    function timeWrapper(e) {
      e.preventDefault();
      var isKeyDown = e.type === "keydown",
          eventTarget = getEventTarget(e),
          input = eventTarget;

      if (self.amPM !== undefined && eventTarget === self.amPM) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }

      var min = parseFloat(input.getAttribute("min")),
          max = parseFloat(input.getAttribute("max")),
          step = parseFloat(input.getAttribute("step")),
          curValue = parseInt(input.value, 10),
          delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;

      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self.hourElement,
            isMinuteElem = input === self.minuteElement;

        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
          if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
        } else if (newValue > max) {
          newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
          if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
        }

        if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
        }

        input.value = pad(newValue);
      }
    }

    init();
    return self;
  }
  /* istanbul ignore next */


  function _flatpickr(nodeList, config) {
    // static list
    var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
      return x instanceof HTMLElement;
    });
    var instances = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];

      try {
        if (node.getAttribute("data-fp-omit") !== null) continue;

        if (node._flatpickr !== undefined) {
          node._flatpickr.destroy();

          node._flatpickr = undefined;
        }

        node._flatpickr = FlatpickrInstance(node, config || {});
        instances.push(node._flatpickr);
      } catch (e) {
        console.error(e);
      }
    }

    return instances.length === 1 ? instances[0] : instances;
  }
  /* istanbul ignore next */


  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    // browser env
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
      return _flatpickr(this, config);
    };

    HTMLElement.prototype.flatpickr = function (config) {
      return _flatpickr([this], config);
    };
  }
  /* istanbul ignore next */


  var flatpickr = function flatpickr(selector, config) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config);
    } else {
      return _flatpickr(selector, config);
    }
  };
  /* istanbul ignore next */


  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: _assign({}, english),
    default: _assign({}, english)
  };

  flatpickr.localize = function (l10n) {
    flatpickr.l10ns.default = _assign(_assign({}, flatpickr.l10ns.default), l10n);
  };

  flatpickr.setDefaults = function (config) {
    flatpickr.defaultConfig = _assign(_assign({}, flatpickr.defaultConfig), config);
  };

  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  /* istanbul ignore next */

  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function (config) {
      return _flatpickr(this, config);
    };
  } // eslint-disable-next-line @typescript-eslint/camelcase


  Date.prototype.fp_incr = function (days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };

  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }

  return flatpickr;
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/jss/jss.js":
/*!*************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4!./node_modules/jss/jss.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * JSS v0.6 - JavaScript Stylesheets
 * https://github.com/Box9/jss
 *
 * Copyright (c) 2011, David Tang
 * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)
 */
var jss = function () {
  var adjSelAttrRegex = /((?:\.|#)[^\.\s#]+)((?:\.|#)[^\.\s#]+)/g;
  var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;
  var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;
  var singleColonForPseudoElements; // flag for older browsers

  function getSelectorsAndRules(sheet) {
    var rules = sheet.cssRules || sheet.rules || [];
    var results = {};

    for (var i = 0; i < rules.length; i++) {
      // Older browsers and FF report pseudo element selectors in an outdated format
      var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);

      if (!results[selectorText]) {
        results[selectorText] = [];
      }

      results[selectorText].push({
        sheet: sheet,
        index: i,
        style: rules[i].style
      });
    }

    return results;
  }

  function getRules(sheet, selector) {
    var rules = sheet.cssRules || sheet.rules || [];
    var results = []; // Browsers report selectors in lowercase

    selector = selector.toLowerCase();

    for (var i = 0; i < rules.length; i++) {
      var selectorText = rules[i].selectorText; // Note - certain rules (e.g. @rules) don't have selectorText

      if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {
        results.push({
          sheet: sheet,
          index: i,
          style: rules[i].style
        });
      }
    }

    return results;
  }

  function addRule(sheet, selector) {
    var rules = sheet.cssRules || sheet.rules || [];
    var index = rules.length;
    var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);

    if (!pseudoElementRule) {
      addRuleToSheet(sheet, selector, index);
    }

    return {
      sheet: sheet,
      index: index,
      style: rules[index].style
    };
  }

  ;

  function addRuleToSheet(sheet, selector, index) {
    if (sheet.insertRule) {
      sheet.insertRule(selector + ' { }', index);
    } else {
      sheet.addRule(selector, null, index);
    }
  } // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651


  function addPseudoElementRule(sheet, selector, rules, index) {
    var doubleColonSelector;
    var singleColonSelector;

    if (doubleColonPseudoElRegex.exec(selector)) {
      doubleColonSelector = selector;
      singleColonSelector = toSingleColonPseudoElements(selector);
    } else if (singleColonPseudoElRegex.exec(selector)) {
      doubleColonSelector = toDoubleColonPseudoElements(selector);
      singleColonSelector = selector;
    } else {
      return false; // Not dealing with a pseudo element
    }

    if (!singleColonForPseudoElements) {
      // Assume modern browser and then check if successful
      addRuleToSheet(sheet, doubleColonSelector, index);

      if (rules.length <= index) {
        singleColonForPseudoElements = true;
      }
    }

    if (singleColonForPseudoElements) {
      addRuleToSheet(sheet, singleColonSelector, index);
    }

    return true;
  }

  function toDoubleColonPseudoElements(selector) {
    return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {
      return submatch1 + '::' + submatch3;
    });
  }

  function toSingleColonPseudoElements(selector) {
    return selector.replace(doubleColonPseudoElRegex, function (match, submatch1, submatch2) {
      return ':' + submatch2;
    });
  }

  function removeRule(rule) {
    var sheet = rule.sheet;

    if (sheet.deleteRule) {
      sheet.deleteRule(rule.index);
    } else if (sheet.removeRule) {
      sheet.removeRule(rule.index);
    }
  }

  function extend(dest, src) {
    for (var key in src) {
      if (!src.hasOwnProperty(key)) continue;
      dest[key] = src[key];
    }

    return dest;
  }

  function aggregateStyles(rules) {
    var aggregate = {};

    for (var i = 0; i < rules.length; i++) {
      extend(aggregate, declaredProperties(rules[i].style));
    }

    return aggregate;
  }

  function declaredProperties(style) {
    var declared = {};

    for (var i = 0; i < style.length; i++) {
      declared[style[i]] = style[toCamelCase(style[i])];
    }

    return declared;
  } // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined
  // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1


  function swapAdjSelAttr(selector) {
    var swap = '';
    var lastIndex = 0;

    while ((match = adjSelAttrRegex.exec(selector)) != null) {
      if (match[0] === '') break;
      swap += selector.substring(lastIndex, match.index);
      swap += selector.substr(match.index + match[1].length, match[2].length);
      swap += selector.substr(match.index, match[1].length);
      lastIndex = match.index + match[0].length;
    }

    swap += selector.substr(lastIndex);
    return swap;
  }

  ; // FF and older browsers store rules with pseudo elements using single-colon syntax

  function swapPseudoElSyntax(selector) {
    if (doubleColonPseudoElRegex.exec(selector)) {
      return toSingleColonPseudoElements(selector);
    }

    return selector;
  }

  function setStyleProperties(rule, properties) {
    for (var key in properties) {
      var value = properties[key];
      var importantIndex = value.indexOf(' !important'); // Modern browsers seem to handle overrides fine, but IE9 doesn't

      rule.style.removeProperty(key);

      if (importantIndex > 0) {
        rule.style.setProperty(key, value.substr(0, importantIndex), 'important');
      } else {
        rule.style.setProperty(key, value);
      }
    }
  }

  function toCamelCase(str) {
    return str.replace(/-([a-z])/g, function (match, submatch) {
      return submatch.toUpperCase();
    });
  }

  function transformCamelCasedPropertyNames(oldProps) {
    var newProps = {};

    for (var key in oldProps) {
      newProps[unCamelCase(key)] = oldProps[key];
    }

    return newProps;
  }

  function unCamelCase(str) {
    return str.replace(/([A-Z])/g, function (match, submatch) {
      return '-' + submatch.toLowerCase();
    });
  }

  var Jss = function Jss(doc) {
    this.doc = doc;
    this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];
    this.sheets = this.doc.styleSheets || [];
  };

  Jss.prototype = {
    // Returns JSS rules (selector is optional)
    get: function get(selector) {
      if (!this.defaultSheet) {
        return {};
      }

      if (selector) {
        return aggregateStyles(getRules(this.defaultSheet, selector));
      }

      var rules = getSelectorsAndRules(this.defaultSheet);

      for (selector in rules) {
        rules[selector] = aggregateStyles(rules[selector]);
      }

      return rules;
    },
    // Returns all rules (selector is required)
    getAll: function getAll(selector) {
      var properties = {};

      for (var i = 0; i < this.sheets.length; i++) {
        extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));
      }

      return properties;
    },
    // Adds JSS rules for the selector based on the given properties
    set: function set(selector, properties) {
      if (!this.defaultSheet) {
        this.defaultSheet = this._createSheet();
      }

      properties = transformCamelCasedPropertyNames(properties);
      var rules = getRules(this.defaultSheet, selector);

      if (!rules.length) {
        rules = [addRule(this.defaultSheet, selector)];
      }

      for (var i = 0; i < rules.length; i++) {
        setStyleProperties(rules[i], properties);
      }
    },
    // Removes JSS rules (selector is optional)
    remove: function remove(selector) {
      if (!this.defaultSheet) return;

      if (!selector) {
        this._removeSheet(this.defaultSheet);

        delete this.defaultSheet;
        return;
      }

      var rules = getRules(this.defaultSheet, selector);

      for (var i = 0; i < rules.length; i++) {
        removeRule(rules[i]);
      }

      return rules.length;
    },
    _createSheet: function _createSheet() {
      var styleNode = this.doc.createElement('style');
      styleNode.type = 'text/css';
      styleNode.rel = 'stylesheet';
      this.head.appendChild(styleNode);
      return styleNode.sheet;
    },
    _removeSheet: function _removeSheet(sheet) {
      var node = sheet.ownerNode;
      node.parentNode.removeChild(node);
    }
  };
  var exports = new Jss(document);

  exports.forDocument = function (doc) {
    return new Jss(doc);
  };

  return exports;
}();

 true && module.exports && (module.exports = jss); // CommonJS support

/***/ }),

/***/ "./node_modules/bbj-masks/src/NumberMask/NumberMask.js":
/*!*************************************************************!*\
  !*** ./node_modules/bbj-masks/src/NumberMask/NumberMask.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * NumberMask
 *
 * A javascript implementation for BBj numbers masking
 *
 * @author Hyyan Abo Fakher <habofakher@basis.com>
 */
var NumberMask = /*#__PURE__*/function () {
  function NumberMask() {
    _classCallCheck(this, NumberMask);
  }

  _createClass(NumberMask, null, [{
    key: "mask",

    /**
     * Mask the given number with the given mask according to BBj rules
     *
     * @param {Number} number the number to format
     * @param {String} mask the mask to use for formatting
     * @param {String} [groupingSeparator=,] - a char which will be used as a grouping separator
     * @param {String} [decimalSeparator=.]  - a char which will be used as a decimal separator
     * @param {Boolean} [forceTrailingZeros=false] - Affects the output by switching the way a mask with "#" characters in the trailing positions is filled.
     *                                              for example, the function `NumberMask.mask(.10:"#.##")` returns ` .10` instead of ` .1 `
     * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
     *                anyway , otherwise it will stop at first error and throw it.
     * 
     * @throws {MaskError} only if loose is disabled
     * 
     * @returns {String} the masked number
     */
    value: function mask(number, _mask) {
      var groupingSeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ',';
      var decimalSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '.';
      var forceTrailingZeros = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var loose = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
      var maskLen = _mask.length;

      if (0 === maskLen) {
        if (loose) return str; // friendly silent fail
        else throw {
            name: 'MaskError',
            message: "MaskError: Mask is empty"
          };
      } // Get magnitude and precision of MASK


      var maskBeforeDecimal = 0;
      var maskAfterDecimal = 0;
      var foundDecimal = false;

      for (var i = 0; i < maskLen; ++i) {
        var m = _mask.charAt(i);

        if (m == '0' || m == '#') {
          if (foundDecimal) ++maskAfterDecimal;else ++maskBeforeDecimal;
        } else if (m == '.') foundDecimal = true;
      }

      var num = NumberMask._round(number, maskAfterDecimal);

      var bytes = NumberMask._toCharArray(num); // Get magnitude and precision of NUMBER


      var inLen = bytes.length;
      var numBeforeDecimal = 0;
      var numAfterDecimal = 0;
      foundDecimal = false;

      for (var _i = 0; _i < inLen; ++_i) {
        if (bytes[_i] == '.') foundDecimal = true;else {
          if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
        }
      } // always ignore mask overflow


      if (numBeforeDecimal > maskBeforeDecimal) {
        if (loose) return number.toString(); // friendly silent fail
        else throw {
            name: 'MaskError',
            message: "MaskError: Number is too large for mask"
          };
      } // round if mask is for a lower precision number


      if (numAfterDecimal > maskAfterDecimal) {
        num = NumberMask._round(num, maskAfterDecimal);
        bytes = NumberMask._toCharArray(num);
        inLen = bytes.length; // Get new magnitude and precision of NUMBER

        numBeforeDecimal = 0;
        numAfterDecimal = 0;
        foundDecimal = false;

        for (var _i2 = 0; _i2 < inLen; ++_i2) {
          if (bytes[_i2] == '.') foundDecimal = true;else {
            if (foundDecimal) ++numAfterDecimal;else ++numBeforeDecimal;
          }
        } // always ignore mask overflow


        if (numBeforeDecimal > maskBeforeDecimal) {
          if (loose) return number.toString(); // friendly silent fail
          else throw {
              name: 'MaskError',
              message: "MaskError: Number is too large for mask"
            };
        }
      }

      var fillByte = ' ',
          floatByte = ' ';
      var inPos = 0,
          outPos = 0,
          floatPos = 0;
      if (_mask.charAt(0) == '*') fillByte = '*';
      var fillInit = fillByte;
      var isNegative = NumberMask._getSign(num) < 0;
      var emitDecimal = inLen > 0 || _mask.indexOf('0') >= 0;
      var foundZero = false;
      var foundDigit = false;
      var currency = false;
      foundDecimal = false;
      var ret = new Array(maskLen);

      for (var maskPos = 0; maskPos < maskLen; ++maskPos) {
        var _m = _mask.charAt(maskPos);

        switch (_m) {
          case '0':
            --maskBeforeDecimal;

            if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
              ret[outPos] = bytes[inPos];
              ++inPos;
              foundDigit = true;
            } else {
              ret[outPos] = '0';
              foundZero = true;
            }

            ++outPos;
            break;

          case '#':
            --maskBeforeDecimal;

            if (maskBeforeDecimal < numBeforeDecimal && inPos < inLen) {
              ret[outPos] = bytes[inPos];
              ++inPos;
              foundDigit = true;
            } else {
              ret[outPos] = foundDecimal && forceTrailingZeros && NumberMask._getSign(num) != 0 ? '0' : fillByte;
              if (!foundDecimal) floatPos = maskPos;
            }

            ++outPos;
            break;

          case ',':
            if (foundZero || inPos > 0) ret[outPos] = groupingSeparator;else {
              ret[outPos] = fillByte;
              if (!foundDecimal) floatPos = maskPos;
            }
            ++outPos;
            break;

          case '-':
            if (!foundDigit && floatByte == ' ') {
              if (isNegative) floatByte = '-';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else ret[outPos] = isNegative ? '-' : fillByte;

            ++outPos;
            break;

          case '+':
            if (!foundDigit && floatByte == ' ') {
              floatByte = isNegative ? '-' : '+';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else ret[outPos] = isNegative ? '-' : '+';

            ++outPos;
            break;

          case '$':
            if (!foundDigit && floatByte == ' ') {
              floatByte = '$';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else {
              ret[outPos] = '$';
            }

            ++outPos;
            break;
          // case '&':
          //   currency = true
          //   if (!foundDigit && floatByte == ' ') {
          //     floatByte = '&'
          //     ret[outPos] = fillByte
          //     floatPos = foundDecimal ? -1 : maskPos
          //   } else {
          //     ret[outPos] = '&'
          //   }
          //   ++outPos
          //   break
          // case '@':
          //   currency = true
          //   if (!foundDigit && floatByte == ' ') {
          //     floatByte = '@'
          //     ret[outPos] = fillByte
          //     floatPos = foundDecimal ? -1 : maskPos
          //   } else {
          //     ret[outPos] = '@'
          //   }
          //   ++outPos
          //   break

          case '(':
            if (!foundDigit && floatByte == ' ') {
              if (isNegative) floatByte = '(';
              ret[outPos] = fillByte;
              floatPos = foundDecimal ? -1 : maskPos;
            } else {
              if (isNegative) {
                ret[outPos] = '(';
              } else {
                ret[outPos] = foundDecimal ? ' ' : fillByte;
              }
            }

            ++outPos;
            break;

          case ')':
            if (isNegative) {
              ret[outPos] = ')';
            } else {
              ret[outPos] = foundDecimal ? ' ' : fillByte;
            }

            ++outPos;
            break;

          case 'C':
            if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
              if (isNegative) {
                ret[outPos] = 'C';
                ret[outPos + 1] = 'R';
              } else {
                ret[outPos] = ' ';
                ret[outPos + 1] = ' ';
              }

              outPos += 2;
              ++maskPos;
            } else {
              ret[outPos] = 'C';
              ++outPos;
            }

            break;

          case 'D':
            if (maskPos < maskLen - 1 && _mask.charAt(maskPos + 1) == 'R') {
              if (isNegative) {
                ret[outPos] = 'C';
                ret[outPos + 1] = 'R';
              } else {
                ret[outPos] = 'D';
                ret[outPos + 1] = 'R';
              }

              outPos += 2;
              ++maskPos;
            } else {
              ret[outPos] = 'D';
              ++outPos;
            }

            break;

          case '*':
            ret[outPos] = '*';
            ++outPos;
            break;

          case '.':
            ret[outPos] = emitDecimal ? decimalSeparator : fillByte;
            fillByte = ' ';
            foundDecimal = true;
            ++inPos;
            ++outPos;
            break;

          case 'B':
            ret[outPos] = ' ';
            ++outPos;
            break;

          default:
            ret[outPos] = _m;
            ++outPos;
            break;
        }
      }

      if (floatByte != ' ') {
        if (floatPos < 0) floatPos = outPos;

        while (floatPos >= maskLen) {
          --floatPos;
        }

        if (ret[floatPos] == fillInit) ret[floatPos] = floatByte;
      }

      return ret.join('');
    }
  }, {
    key: "_shift",
    value: function _shift(number, precision, reverseShift) {
      if (reverseShift) precision = -precision;
      var numArray = ('' + number).split('e');
      return +(numArray[0] + 'e' + (numArray[1] ? +numArray[1] + precision : precision));
    }
  }, {
    key: "_round",
    value: function _round(number, precision) {
      return NumberMask._shift(Math.round(NumberMask._shift(number, precision, false)), precision, true);
    }
  }, {
    key: "_toCharArray",
    value: function _toCharArray(number) {
      var signum = NumberMask._getSign(number);

      var chars = [];

      if (signum !== 0) {
        var string = signum < 0 ? "".concat(-1 * number.toString()) : number.toString();
        if (string.length > 1 && string.charAt(0) == '0') string = string.substring(1); // The string contains only [0-9] and '.'

        chars = string.split('');
      }

      return chars;
    }
    /**
     * Returns the sign of a number
     *
     * @param {Number} x number
     * @returns {Number} A number representing the sign of the given argument.
     *                   If the argument is a positive number, negative number, positive zero
     *                   or negative zero, the function will return 1, -1, 0 or -0 respectively.
     *                   Otherwise, NaN is returned.
     */

  }, {
    key: "_getSign",
    value: function _getSign(x) {
      return (x > 0) - (x < 0) || +x;
    }
  }]);

  return NumberMask;
}();

var _default = NumberMask;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bbj-masks/src/NumberMask/index.js":
/*!********************************************************!*\
  !*** ./node_modules/bbj-masks/src/NumberMask/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _NumberMask = _interopRequireDefault(__webpack_require__(/*! ./NumberMask */ "./node_modules/bbj-masks/src/NumberMask/NumberMask.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _default = _NumberMask.default;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bbj-masks/src/StringMask/StringMask.js":
/*!*************************************************************!*\
  !*** ./node_modules/bbj-masks/src/StringMask/StringMask.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var isNumberRegex = /^\d+$/;
var isWhitespaceRegex = /\s/;
var punctuationList = '!"#$%&\'()*+,-./:;<=>?@[]^_`{|}~';
/**
 * Check if the given string is in lower case
 *
 * @param {String} str
 */

var isLowerCase = function isLowerCase(str) {
  return str == str.toLowerCase() && str != str.toUpperCase();
};
/**
 * Check if the given string is in upper case
 *
 * @param {String} str
 */


var isUpperCase = function isUpperCase(str) {
  return str == str.toUpperCase() && str != str.toLowerCase();
};

var passOrThrowError = function passOrThrowError(loose, ret, i, str) {
  if (!loose) {
    var char = str.charAt(i);
    var pos = i + 1;
    throw {
      name: 'StringMaskError',
      message: "StringMaskError: error applying mask at position \"".concat(pos, "\" , char \"").concat(char, "\""),
      pos: pos,
      char: char
    };
  } else ret[i] = ' ';
};
/**
 * NumberMask
 *
 * A javascript implementation for BBj numbers masking
 *
 * @author Hyyan Abo Fakher <habofakher@basis.com>
 */


var StringMask = /*#__PURE__*/function () {
  function StringMask() {
    _classCallCheck(this, StringMask);
  }

  _createClass(StringMask, null, [{
    key: "mask",

    /**
     * Mask the given string with the given mask according to BBj rules
     *
     * @param {String} str the string to mask
     * @param {String} mask the mask to use for formatting
     * @param {Boolean} [loose=true] when true , errors will be ignored and the method will try at apply the mask
     *                anyway , otherwise it will stop at first error and throw it.
     * 
     * @throws {MaskIsTooShortError}
     * @throws {StringMaskError}
     * @throws {MaskError}
     * 
     * @returns {String} the masked string
     */
    value: function mask(str, _mask) {
      var loose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      str = String(str);
      _mask = String(_mask);
      var maskLen = _mask.length;
      var strLen = str.length;

      if (strLen > maskLen) {
        if (loose) return str; // friendly silent fail
        else throw {
            name: 'MaskIsTooShortError',
            message: "MaskIsTooShortError: Mask is shorter than the passed string"
          };
      }

      var ret = new Array(maskLen);
      var pos = 0; // to keep track of the current position in the str

      var maskByte = '';

      for (var i = 0; i < maskLen; i++) {
        maskByte = _mask.charAt(i);

        switch (maskByte) {
          case 'X':
            // match any character
            ret[i] = pos < strLen ? str.charAt(pos) : ' ';
            ++pos;
            break;

          case 'A':
            // match letter; force upper case
            if (pos < strLen) {
              var byte = str.charAt(pos);
              if (isUpperCase(byte)) ret[i] = byte;else if (isLowerCase(byte)) ret[i] = byte.toUpperCase();else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'a':
            // match letter
            if (pos < strLen) {
              var _byte = str.charAt(pos);

              if (isUpperCase(_byte) || isLowerCase(_byte)) ret[i] = _byte;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case '0':
            // match digit
            if (pos < strLen) {
              var _byte2 = str.charAt(pos);

              if (isNumberRegex.test(_byte2)) ret[i] = _byte2;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'Z':
            // match letter or digit; force upper case
            if (pos < strLen) {
              var _byte3 = str.charAt(pos);

              if (isUpperCase(_byte3) || isNumberRegex.test(_byte3)) ret[i] = _byte3;else if (isLowerCase(_byte3)) ret[i] = _byte3.toUpperCase();else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          case 'z':
            // match letter or digit
            if (pos < strLen) {
              var _byte4 = str.charAt(pos);

              if (isUpperCase(_byte4) || isLowerCase(_byte4) || isNumberRegex.test(_byte4)) ret[i] = _byte4;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;
            break;

          case 'U':
            // match letter (force upper case), digit, whitespace or punctuation.
            if (pos < strLen) {
              var _byte5 = str.charAt(pos);

              if (isLowerCase(_byte5)) ret[i] = _byte5.toUpperCase();else if (isUpperCase(_byte5) || isNumberRegex.test(_byte5) || isWhitespaceRegex.test(_byte5) || punctuationList.indexOf(_byte5) > -1) ret[i] = _byte5;else passOrThrowError(loose, ret, i, str);
            } else ret[i] = ' ';

            ++pos;
            break;

          default:
            ret[i] = maskByte;
            break;
        }
      }

      if (pos < strLen) {
        if (!loose) {
          throw {
            name: 'MaskError',
            message: 'Mask cannot be applied'
          };
        }
      }

      return ret.join('');
    }
  }]);

  return StringMask;
}();

var _default = StringMask;
exports.default = _default;

/***/ }),

/***/ "./node_modules/bbj-masks/src/StringMask/index.js":
/*!********************************************************!*\
  !*** ./node_modules/bbj-masks/src/StringMask/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _StringMask = _interopRequireDefault(__webpack_require__(/*! ./StringMask */ "./node_modules/bbj-masks/src/StringMask/StringMask.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * This file is part of bbj-masks lib.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _default = _StringMask.default;
exports.default = _default;

/***/ }),

/***/ "./node_modules/deep-parse-json/index.js":
/*!***********************************************!*\
  !*** ./node_modules/deep-parse-json/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * [Recursively parses a stringified JSON]
 * @param  {[type]} jsonString [stringified json to parse]
 * @return {[type]}            [normalized Javascript object]
 */

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function deepParseJson(jsonString) {
  // if not stringified json rather a simple string value then JSON.parse will throw error
  // otherwise continue recursion
  if (typeof jsonString === 'string') {
    try {
      return deepParseJson(JSON.parse(jsonString));
    } catch (err) {
      return jsonString;
    }
  } else if (Array.isArray(jsonString)) {
    // if an array is received, map over the array and deepParse each value
    return jsonString.map(function (val) {
      return deepParseJson(val);
    });
  } else if (_typeof(jsonString) === 'object' && jsonString !== null) {
    // if an object is received then deepParse each element in the object
    // typeof null returns 'object' too, so we have to eliminate that
    return Object.keys(jsonString).reduce(function (obj, key) {
      obj[key] = deepParseJson(jsonString[key]);
      return obj;
    }, {});
  } else {
    // otherwise return whatever was received
    return jsonString;
  }
}

module.exports = {
  deepParseJson: deepParseJson
};

/***/ }),

/***/ "./node_modules/expose-loader/index.js?BBj.Masks!./node_modules/bbj-masks/dist/bbj-masks.js-exposed":
/*!*************************************************************************************************!*\
  !*** ./node_modules/expose-loader?BBj.Masks!./node_modules/bbj-masks/dist/bbj-masks.js-exposed ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["BBj"]) global["BBj"] = {};
module.exports = global["BBj"]["Masks"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./bbj-masks.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/bbj-masks/dist/bbj-masks.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?Basis.AgGridComponents!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js-exposed":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/expose-loader?Basis.AgGridComponents!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js-exposed ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["Basis"]) global["Basis"] = {};
module.exports = global["Basis"]["AgGridComponents"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./basis-aggrid-components.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?Basis.InputMasking!./node_modules/basis-input-masking/dist/basis-input-masking.js-exposed":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/expose-loader?Basis.InputMasking!./node_modules/basis-input-masking/dist/basis-input-masking.js-exposed ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {if(!global["Basis"]) global["Basis"] = {};
module.exports = global["Basis"]["InputMasking"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./basis-input-masking.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/basis-input-masking/dist/basis-input-masking.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?flatpickr!./node_modules/flatpickr/dist/flatpickr.js-exposed":
/*!*************************************************************************************************!*\
  !*** ./node_modules/expose-loader?flatpickr!./node_modules/flatpickr/dist/flatpickr.js-exposed ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["flatpickr"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./flatpickr.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/flatpickr/dist/flatpickr.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/expose-loader/index.js?jss!./node_modules/jss/jss.js-exposed":
/*!**************************************************************************!*\
  !*** ./node_modules/expose-loader?jss!./node_modules/jss/jss.js-exposed ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["jss"] = __webpack_require__(/*! -!./node_modules/babel-loader/lib??ref--4!./jss.js */ "./node_modules/babel-loader/lib/index.js?!./node_modules/jss/jss.js");
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/flatpickr/dist/flatpickr.css":
/*!***************************************************!*\
  !*** ./node_modules/flatpickr/dist/flatpickr.css ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../postcss-loader/src!./flatpickr.css */ "./node_modules/postcss-loader/src/index.js!./node_modules/flatpickr/dist/flatpickr.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(/*! ../../style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./node_modules/lodash-es/_Symbol.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/_Symbol.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var _Symbol = _root.default.Symbol;
var _default = _Symbol;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_apply.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/_apply.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

var _default = apply;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_arrayLikeKeys.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_arrayLikeKeys.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseTimes = _interopRequireDefault(__webpack_require__(/*! ./_baseTimes.js */ "./node_modules/lodash-es/_baseTimes.js"));

var _isArguments = _interopRequireDefault(__webpack_require__(/*! ./isArguments.js */ "./node_modules/lodash-es/isArguments.js"));

var _isArray = _interopRequireDefault(__webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js"));

var _isBuffer = _interopRequireDefault(__webpack_require__(/*! ./isBuffer.js */ "./node_modules/lodash-es/isBuffer.js"));

var _isIndex = _interopRequireDefault(__webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js"));

var _isTypedArray = _interopRequireDefault(__webpack_require__(/*! ./isTypedArray.js */ "./node_modules/lodash-es/isTypedArray.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = (0, _isArray.default)(value),
      isArg = !isArr && (0, _isArguments.default)(value),
      isBuff = !isArr && !isArg && (0, _isBuffer.default)(value),
      isType = !isArr && !isArg && !isBuff && (0, _isTypedArray.default)(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? (0, _baseTimes.default)(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    (0, _isIndex.default)(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

var _default = arrayLikeKeys;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_arrayMap.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_arrayMap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

var _default = arrayMap;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_assignValue.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_assignValue.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseAssignValue = _interopRequireDefault(__webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js"));

var _eq = _interopRequireDefault(__webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && (0, _eq.default)(objValue, value)) || value === undefined && !(key in object)) {
    (0, _baseAssignValue.default)(object, key, value);
  }
}

var _default = assignValue;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseAssignValue.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseAssignValue.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty = _interopRequireDefault(__webpack_require__(/*! ./_defineProperty.js */ "./node_modules/lodash-es/_defineProperty.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty.default) {
    (0, _defineProperty.default)(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

var _default = baseAssignValue;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseGetTag.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseGetTag.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js"));

var _getRawTag = _interopRequireDefault(__webpack_require__(/*! ./_getRawTag.js */ "./node_modules/lodash-es/_getRawTag.js"));

var _objectToString = _interopRequireDefault(__webpack_require__(/*! ./_objectToString.js */ "./node_modules/lodash-es/_objectToString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? (0, _getRawTag.default)(value) : (0, _objectToString.default)(value);
}

var _default = baseGetTag;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsArguments.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsArguments.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return (0, _isObjectLike.default)(value) && (0, _baseGetTag.default)(value) == argsTag;
}

var _default = baseIsArguments;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsNative.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsNative.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js"));

var _isMasked = _interopRequireDefault(__webpack_require__(/*! ./_isMasked.js */ "./node_modules/lodash-es/_isMasked.js"));

var _isObject = _interopRequireDefault(__webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js"));

var _toSource = _interopRequireDefault(__webpack_require__(/*! ./_toSource.js */ "./node_modules/lodash-es/_toSource.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!(0, _isObject.default)(value) || (0, _isMasked.default)(value)) {
    return false;
  }

  var pattern = (0, _isFunction.default)(value) ? reIsNative : reIsHostCtor;
  return pattern.test((0, _toSource.default)(value));
}

var _default = baseIsNative;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseIsTypedArray.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsTypedArray.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _isLength = _interopRequireDefault(__webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return (0, _isObjectLike.default)(value) && (0, _isLength.default)(value.length) && !!typedArrayTags[(0, _baseGetTag.default)(value)];
}

var _default = baseIsTypedArray;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseKeys.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isPrototype = _interopRequireDefault(__webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js"));

var _nativeKeys = _interopRequireDefault(__webpack_require__(/*! ./_nativeKeys.js */ "./node_modules/lodash-es/_nativeKeys.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!(0, _isPrototype.default)(object)) {
    return (0, _nativeKeys.default)(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

var _default = baseKeys;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseKeysIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseKeysIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObject = _interopRequireDefault(__webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js"));

var _isPrototype = _interopRequireDefault(__webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js"));

var _nativeKeysIn = _interopRequireDefault(__webpack_require__(/*! ./_nativeKeysIn.js */ "./node_modules/lodash-es/_nativeKeysIn.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!(0, _isObject.default)(object)) {
    return (0, _nativeKeysIn.default)(object);
  }

  var isProto = (0, _isPrototype.default)(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

var _default = baseKeysIn;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_basePropertyOf.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_basePropertyOf.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function (key) {
    return object == null ? undefined : object[key];
  };
}

var _default = basePropertyOf;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseRest.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseRest.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _identity = _interopRequireDefault(__webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js"));

var _overRest = _interopRequireDefault(__webpack_require__(/*! ./_overRest.js */ "./node_modules/lodash-es/_overRest.js"));

var _setToString = _interopRequireDefault(__webpack_require__(/*! ./_setToString.js */ "./node_modules/lodash-es/_setToString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return (0, _setToString.default)((0, _overRest.default)(func, start, _identity.default), func + '');
}

var _default = baseRest;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseSetToString.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_baseSetToString.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _constant = _interopRequireDefault(__webpack_require__(/*! ./constant.js */ "./node_modules/lodash-es/constant.js"));

var _defineProperty = _interopRequireDefault(__webpack_require__(/*! ./_defineProperty.js */ "./node_modules/lodash-es/_defineProperty.js"));

var _identity = _interopRequireDefault(__webpack_require__(/*! ./identity.js */ "./node_modules/lodash-es/identity.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty.default ? _identity.default : function (func, string) {
  return (0, _defineProperty.default)(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': (0, _constant.default)(string),
    'writable': true
  });
};
var _default = baseSetToString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseTimes.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseTimes.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

var _default = baseTimes;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js"));

var _arrayMap = _interopRequireDefault(__webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js"));

var _isArray = _interopRequireDefault(__webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js"));

var _isSymbol = _interopRequireDefault(__webpack_require__(/*! ./isSymbol.js */ "./node_modules/lodash-es/isSymbol.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol2.default ? _Symbol2.default.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if ((0, _isArray.default)(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return (0, _arrayMap.default)(value, baseToString) + '';
  }

  if ((0, _isSymbol.default)(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

var _default = baseToString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseUnary.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseUnary.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

var _default = baseUnary;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_baseValues.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_baseValues.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayMap = _interopRequireDefault(__webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return (0, _arrayMap.default)(props, function (key) {
    return object[key];
  });
}

var _default = baseValues;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_copyObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_copyObject.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assignValue = _interopRequireDefault(__webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js"));

var _baseAssignValue = _interopRequireDefault(__webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      (0, _baseAssignValue.default)(object, key, newValue);
    } else {
      (0, _assignValue.default)(object, key, newValue);
    }
  }

  return object;
}

var _default = copyObject;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_coreJsData.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_coreJsData.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect overreaching core-js shims. */
var coreJsData = _root.default['__core-js_shared__'];
var _default = coreJsData;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_createAssigner.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_createAssigner.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseRest = _interopRequireDefault(__webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js"));

var _isIterateeCall = _interopRequireDefault(__webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return (0, _baseRest.default)(function (object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;
    customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

    if (guard && (0, _isIterateeCall.default)(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }

    object = Object(object);

    while (++index < length) {
      var source = sources[index];

      if (source) {
        assigner(object, source, index, customizer);
      }
    }

    return object;
  });
}

var _default = createAssigner;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_customDefaultsAssignIn.js":
/*!***********************************************************!*\
  !*** ./node_modules/lodash-es/_customDefaultsAssignIn.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eq = _interopRequireDefault(__webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */

function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined || (0, _eq.default)(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
    return srcValue;
  }

  return objValue;
}

var _default = customDefaultsAssignIn;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_defineProperty.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_defineProperty.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getNative = _interopRequireDefault(__webpack_require__(/*! ./_getNative.js */ "./node_modules/lodash-es/_getNative.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defineProperty = function () {
  try {
    var func = (0, _getNative.default)(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

var _default = defineProperty;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_escapeHtmlChar.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_escapeHtmlChar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _basePropertyOf = _interopRequireDefault(__webpack_require__(/*! ./_basePropertyOf.js */ "./node_modules/lodash-es/_basePropertyOf.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to map characters to HTML entities. */
var htmlEscapes = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;'
};
/**
 * Used by `_.escape` to convert characters to HTML entities.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

var escapeHtmlChar = (0, _basePropertyOf.default)(htmlEscapes);
var _default = escapeHtmlChar;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_escapeStringChar.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_escapeStringChar.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to escape characters for inclusion in compiled string literals. */
var stringEscapes = {
  '\\': '\\',
  "'": "'",
  '\n': 'n',
  '\r': 'r',
  "\u2028": 'u2028',
  "\u2029": 'u2029'
};
/**
 * Used by `_.template` to escape characters for inclusion in compiled string literals.
 *
 * @private
 * @param {string} chr The matched character to escape.
 * @returns {string} Returns the escaped character.
 */

function escapeStringChar(chr) {
  return '\\' + stringEscapes[chr];
}

var _default = escapeStringChar;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_freeGlobal.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_freeGlobal.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
var _default = freeGlobal;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash-es/_getNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsNative = _interopRequireDefault(__webpack_require__(/*! ./_baseIsNative.js */ "./node_modules/lodash-es/_baseIsNative.js"));

var _getValue = _interopRequireDefault(__webpack_require__(/*! ./_getValue.js */ "./node_modules/lodash-es/_getValue.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = (0, _getValue.default)(object, key);
  return (0, _baseIsNative.default)(value) ? value : undefined;
}

var _default = getNative;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_getPrototype.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_getPrototype.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _overArg = _interopRequireDefault(__webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Built-in value references. */
var getPrototype = (0, _overArg.default)(Object.getPrototypeOf, Object);
var _default = getPrototype;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_getRawTag.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_getRawTag.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Symbol2 = _interopRequireDefault(__webpack_require__(/*! ./_Symbol.js */ "./node_modules/lodash-es/_Symbol.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol2.default ? _Symbol2.default.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

var _default = getRawTag;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_getValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_getValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _default = getValue;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_isIndex.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_isIndex.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

var _default = isIndex;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_isIterateeCall.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_isIterateeCall.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _eq = _interopRequireDefault(__webpack_require__(/*! ./eq.js */ "./node_modules/lodash-es/eq.js"));

var _isArrayLike = _interopRequireDefault(__webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js"));

var _isIndex = _interopRequireDefault(__webpack_require__(/*! ./_isIndex.js */ "./node_modules/lodash-es/_isIndex.js"));

var _isObject = _interopRequireDefault(__webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!(0, _isObject.default)(object)) {
    return false;
  }

  var type = _typeof(index);

  if (type == 'number' ? (0, _isArrayLike.default)(object) && (0, _isIndex.default)(index, object.length) : type == 'string' && index in object) {
    return (0, _eq.default)(object[index], value);
  }

  return false;
}

var _default = isIterateeCall;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_isMasked.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_isMasked.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _coreJsData = _interopRequireDefault(__webpack_require__(/*! ./_coreJsData.js */ "./node_modules/lodash-es/_coreJsData.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(_coreJsData.default && _coreJsData.default.keys && _coreJsData.default.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

var _default = isMasked;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_isPrototype.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_isPrototype.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

var _default = isPrototype;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _overArg = _interopRequireDefault(__webpack_require__(/*! ./_overArg.js */ "./node_modules/lodash-es/_overArg.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = (0, _overArg.default)(Object.keys, Object);
var _default = nativeKeys;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_nativeKeysIn.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_nativeKeysIn.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

var _default = nativeKeysIn;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_nodeUtil.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_nodeUtil.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _freeGlobal = _interopRequireDefault(__webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `exports`. */
var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && _freeGlobal.default.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

var _default = nodeUtil;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash-es/_objectToString.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_objectToString.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

var _default = objectToString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_overArg.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/_overArg.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

var _default = overArg;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_overRest.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_overRest.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apply = _interopRequireDefault(__webpack_require__(/*! ./_apply.js */ "./node_modules/lodash-es/_apply.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return (0, _apply.default)(func, this, otherArgs);
  };
}

var _default = overRest;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_reEscape.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_reEscape.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reEscape = /<%-([\s\S]+?)%>/g;
var _default = reEscape;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_reEvaluate.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_reEvaluate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reEvaluate = /<%([\s\S]+?)%>/g;
var _default = reEvaluate;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_reInterpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_reInterpolate.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to match template delimiters. */
var reInterpolate = /<%=([\s\S]+?)%>/g;
var _default = reInterpolate;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_root.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/_root.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _freeGlobal = _interopRequireDefault(__webpack_require__(/*! ./_freeGlobal.js */ "./node_modules/lodash-es/_freeGlobal.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `self`. */
var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = _freeGlobal.default || freeSelf || Function('return this')();
var _default = root;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_setToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/_setToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseSetToString = _interopRequireDefault(__webpack_require__(/*! ./_baseSetToString.js */ "./node_modules/lodash-es/_baseSetToString.js"));

var _shortOut = _interopRequireDefault(__webpack_require__(/*! ./_shortOut.js */ "./node_modules/lodash-es/_shortOut.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = (0, _shortOut.default)(_baseSetToString.default);
var _default = setToString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_shortOut.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_shortOut.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

var _default = shortOut;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/_toSource.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_toSource.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

var _default = toSource;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/assignInWith.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/assignInWith.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _copyObject = _interopRequireDefault(__webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js"));

var _createAssigner = _interopRequireDefault(__webpack_require__(/*! ./_createAssigner.js */ "./node_modules/lodash-es/_createAssigner.js"));

var _keysIn = _interopRequireDefault(__webpack_require__(/*! ./keysIn.js */ "./node_modules/lodash-es/keysIn.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = (0, _createAssigner.default)(function (object, source, srcIndex, customizer) {
  (0, _copyObject.default)(source, (0, _keysIn.default)(source), object, customizer);
});
var _default = assignInWith;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/attempt.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/attempt.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _apply = _interopRequireDefault(__webpack_require__(/*! ./_apply.js */ "./node_modules/lodash-es/_apply.js"));

var _baseRest = _interopRequireDefault(__webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js"));

var _isError = _interopRequireDefault(__webpack_require__(/*! ./isError.js */ "./node_modules/lodash-es/isError.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Attempts to invoke `func`, returning either the result or the caught error
 * object. Any additional arguments are provided to `func` when it's invoked.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Util
 * @param {Function} func The function to attempt.
 * @param {...*} [args] The arguments to invoke `func` with.
 * @returns {*} Returns the `func` result or error object.
 * @example
 *
 * // Avoid throwing errors for invalid selectors.
 * var elements = _.attempt(function(selector) {
 *   return document.querySelectorAll(selector);
 * }, '>_>');
 *
 * if (_.isError(elements)) {
 *   elements = [];
 * }
 */
var attempt = (0, _baseRest.default)(function (func, args) {
  try {
    return (0, _apply.default)(func, undefined, args);
  } catch (e) {
    return (0, _isError.default)(e) ? e : new Error(e);
  }
});
var _default = attempt;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/constant.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/constant.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

var _default = constant;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/eq.js":
/*!**************************************!*\
  !*** ./node_modules/lodash-es/eq.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

var _default = eq;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/escape.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/escape.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _escapeHtmlChar = _interopRequireDefault(__webpack_require__(/*! ./_escapeHtmlChar.js */ "./node_modules/lodash-es/_escapeHtmlChar.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to match HTML entities and HTML characters. */
var reUnescapedHtml = /[&<>"']/g,
    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
/**
 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
 * corresponding HTML entities.
 *
 * **Note:** No other characters are escaped. To escape additional
 * characters use a third-party library like [_he_](https://mths.be/he).
 *
 * Though the ">" character is escaped for symmetry, characters like
 * ">" and "/" don't need escaping in HTML and have no special meaning
 * unless they're part of a tag or unquoted attribute value. See
 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
 * (under "semi-related fun fact") for more details.
 *
 * When working with HTML you should always
 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
 * XSS vectors.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escape('fred, barney, & pebbles');
 * // => 'fred, barney, &amp; pebbles'
 */

function escape(string) {
  string = (0, _toString.default)(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, _escapeHtmlChar.default) : string;
}

var _default = escape;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/identity.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/identity.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var _default = identity;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isArguments.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArguments.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsArguments = _interopRequireDefault(__webpack_require__(/*! ./_baseIsArguments.js */ "./node_modules/lodash-es/_baseIsArguments.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = (0, _baseIsArguments.default)(function () {
  return arguments;
}()) ? _baseIsArguments.default : function (value) {
  return (0, _isObjectLike.default)(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
var _default = isArguments;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
var _default = isArray;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isArrayLike.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/isArrayLike.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(/*! ./isFunction.js */ "./node_modules/lodash-es/isFunction.js"));

var _isLength = _interopRequireDefault(__webpack_require__(/*! ./isLength.js */ "./node_modules/lodash-es/isLength.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && (0, _isLength.default)(value.length) && !(0, _isFunction.default)(value);
}

var _default = isArrayLike;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isBuffer.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _root = _interopRequireDefault(__webpack_require__(/*! ./_root.js */ "./node_modules/lodash-es/_root.js"));

var _stubFalse = _interopRequireDefault(__webpack_require__(/*! ./stubFalse.js */ "./node_modules/lodash-es/stubFalse.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `exports`. */
var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? _root.default.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || _stubFalse.default;
var _default = isBuffer;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash-es/isError.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/isError.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

var _isPlainObject = _interopRequireDefault(__webpack_require__(/*! ./isPlainObject.js */ "./node_modules/lodash-es/isPlainObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var domExcTag = '[object DOMException]',
    errorTag = '[object Error]';
/**
 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
 * `SyntaxError`, `TypeError`, or `URIError` object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
 * @example
 *
 * _.isError(new Error);
 * // => true
 *
 * _.isError(Error);
 * // => false
 */

function isError(value) {
  if (!(0, _isObjectLike.default)(value)) {
    return false;
  }

  var tag = (0, _baseGetTag.default)(value);
  return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !(0, _isPlainObject.default)(value);
}

var _default = isError;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/isFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _isObject = _interopRequireDefault(__webpack_require__(/*! ./isObject.js */ "./node_modules/lodash-es/isObject.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!(0, _isObject.default)(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = (0, _baseGetTag.default)(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var _default = isFunction;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isLength.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isLength.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

var _default = isLength;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

var _default = isObject;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isObjectLike.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isObjectLike.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

var _default = isObjectLike;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isPlainObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/isPlainObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _getPrototype = _interopRequireDefault(__webpack_require__(/*! ./_getPrototype.js */ "./node_modules/lodash-es/_getPrototype.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** `Object#toString` result references. */
var objectTag = '[object Object]';
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */

var objectCtorString = funcToString.call(Object);
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */

function isPlainObject(value) {
  if (!(0, _isObjectLike.default)(value) || (0, _baseGetTag.default)(value) != objectTag) {
    return false;
  }

  var proto = (0, _getPrototype.default)(value);

  if (proto === null) {
    return true;
  }

  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}

var _default = isPlainObject;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isSymbol.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isSymbol.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseGetTag = _interopRequireDefault(__webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js"));

var _isObjectLike = _interopRequireDefault(__webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || (0, _isObjectLike.default)(value) && (0, _baseGetTag.default)(value) == symbolTag;
}

var _default = isSymbol;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/isTypedArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash-es/isTypedArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseIsTypedArray = _interopRequireDefault(__webpack_require__(/*! ./_baseIsTypedArray.js */ "./node_modules/lodash-es/_baseIsTypedArray.js"));

var _baseUnary = _interopRequireDefault(__webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js"));

var _nodeUtil = _interopRequireDefault(__webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil.default && _nodeUtil.default.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? (0, _baseUnary.default)(nodeIsTypedArray) : _baseIsTypedArray.default;
var _default = isTypedArray;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/keys.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/keys.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayLikeKeys = _interopRequireDefault(__webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js"));

var _baseKeys = _interopRequireDefault(__webpack_require__(/*! ./_baseKeys.js */ "./node_modules/lodash-es/_baseKeys.js"));

var _isArrayLike = _interopRequireDefault(__webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return (0, _isArrayLike.default)(object) ? (0, _arrayLikeKeys.default)(object) : (0, _baseKeys.default)(object);
}

var _default = keys;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/keysIn.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/keysIn.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _arrayLikeKeys = _interopRequireDefault(__webpack_require__(/*! ./_arrayLikeKeys.js */ "./node_modules/lodash-es/_arrayLikeKeys.js"));

var _baseKeysIn = _interopRequireDefault(__webpack_require__(/*! ./_baseKeysIn.js */ "./node_modules/lodash-es/_baseKeysIn.js"));

var _isArrayLike = _interopRequireDefault(__webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return (0, _isArrayLike.default)(object) ? (0, _arrayLikeKeys.default)(object, true) : (0, _baseKeysIn.default)(object);
}

var _default = keysIn;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/stubFalse.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/stubFalse.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var _default = stubFalse;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/template.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/template.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assignInWith = _interopRequireDefault(__webpack_require__(/*! ./assignInWith.js */ "./node_modules/lodash-es/assignInWith.js"));

var _attempt = _interopRequireDefault(__webpack_require__(/*! ./attempt.js */ "./node_modules/lodash-es/attempt.js"));

var _baseValues = _interopRequireDefault(__webpack_require__(/*! ./_baseValues.js */ "./node_modules/lodash-es/_baseValues.js"));

var _customDefaultsAssignIn = _interopRequireDefault(__webpack_require__(/*! ./_customDefaultsAssignIn.js */ "./node_modules/lodash-es/_customDefaultsAssignIn.js"));

var _escapeStringChar = _interopRequireDefault(__webpack_require__(/*! ./_escapeStringChar.js */ "./node_modules/lodash-es/_escapeStringChar.js"));

var _isError = _interopRequireDefault(__webpack_require__(/*! ./isError.js */ "./node_modules/lodash-es/isError.js"));

var _isIterateeCall = _interopRequireDefault(__webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js"));

var _keys = _interopRequireDefault(__webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js"));

var _reInterpolate = _interopRequireDefault(__webpack_require__(/*! ./_reInterpolate.js */ "./node_modules/lodash-es/_reInterpolate.js"));

var _templateSettings = _interopRequireDefault(__webpack_require__(/*! ./templateSettings.js */ "./node_modules/lodash-es/templateSettings.js"));

var _toString = _interopRequireDefault(__webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** Used to match empty string literals in compiled template source. */
var reEmptyStringLeading = /\b__p \+= '';/g,
    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
/**
 * Used to match
 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
 */

var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
/** Used to ensure capturing order of template delimiters. */

var reNoMatch = /($^)/;
/** Used to match unescaped characters in compiled string literals. */

var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates a compiled template function that can interpolate data properties
 * in "interpolate" delimiters, HTML-escape interpolated data properties in
 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
 * properties may be accessed as free variables in the template. If a setting
 * object is given, it takes precedence over `_.templateSettings` values.
 *
 * **Note:** In the development build `_.template` utilizes
 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
 * for easier debugging.
 *
 * For more information on precompiling templates see
 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
 *
 * For more information on Chrome extension sandboxes see
 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category String
 * @param {string} [string=''] The template string.
 * @param {Object} [options={}] The options object.
 * @param {RegExp} [options.escape=_.templateSettings.escape]
 *  The HTML "escape" delimiter.
 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
 *  The "evaluate" delimiter.
 * @param {Object} [options.imports=_.templateSettings.imports]
 *  An object to import into the template as free variables.
 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
 *  The "interpolate" delimiter.
 * @param {string} [options.sourceURL='templateSources[n]']
 *  The sourceURL of the compiled template.
 * @param {string} [options.variable='obj']
 *  The data object variable name.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the compiled template function.
 * @example
 *
 * // Use the "interpolate" delimiter to create a compiled template.
 * var compiled = _.template('hello <%= user %>!');
 * compiled({ 'user': 'fred' });
 * // => 'hello fred!'
 *
 * // Use the HTML "escape" delimiter to escape data property values.
 * var compiled = _.template('<b><%- value %></b>');
 * compiled({ 'value': '<script>' });
 * // => '<b>&lt;script&gt;</b>'
 *
 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the internal `print` function in "evaluate" delimiters.
 * var compiled = _.template('<% print("hello " + user); %>!');
 * compiled({ 'user': 'barney' });
 * // => 'hello barney!'
 *
 * // Use the ES template literal delimiter as an "interpolate" delimiter.
 * // Disable support by replacing the "interpolate" delimiter.
 * var compiled = _.template('hello ${ user }!');
 * compiled({ 'user': 'pebbles' });
 * // => 'hello pebbles!'
 *
 * // Use backslashes to treat delimiters as plain text.
 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
 * compiled({ 'value': 'ignored' });
 * // => '<%- value %>'
 *
 * // Use the `imports` option to import `jQuery` as `jq`.
 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
 * compiled({ 'users': ['fred', 'barney'] });
 * // => '<li>fred</li><li>barney</li>'
 *
 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
 * compiled(data);
 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
 *
 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
 * compiled.source;
 * // => function(data) {
 * //   var __t, __p = '';
 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
 * //   return __p;
 * // }
 *
 * // Use custom template delimiters.
 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
 * var compiled = _.template('hello {{ user }}!');
 * compiled({ 'user': 'mustache' });
 * // => 'hello mustache!'
 *
 * // Use the `source` property to inline compiled templates for meaningful
 * // line numbers in error messages and stack traces.
 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
 *   var JST = {\
 *     "main": ' + _.template(mainText).source + '\
 *   };\
 * ');
 */

function template(string, options, guard) {
  // Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings = _templateSettings.default.imports._.templateSettings || _templateSettings.default;

  if (guard && (0, _isIterateeCall.default)(string, options, guard)) {
    options = undefined;
  }

  string = (0, _toString.default)(string);
  options = (0, _assignInWith.default)({}, options, settings, _customDefaultsAssignIn.default);
  var imports = (0, _assignInWith.default)({}, options.imports, settings.imports, _customDefaultsAssignIn.default),
      importsKeys = (0, _keys.default)(imports),
      importsValues = (0, _baseValues.default)(imports, importsKeys);
  var isEscaping,
      isEvaluating,
      index = 0,
      interpolate = options.interpolate || reNoMatch,
      source = "__p += '"; // Compile the regexp to match each delimiter.

  var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === _reInterpolate.default ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g'); // Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.

  var sourceURL = hasOwnProperty.call(options, 'sourceURL') ? '//# sourceURL=' + (options.sourceURL + '').replace(/[\r\n]/g, ' ') + '\n' : '';
  string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue); // Escape characters that can't be included in string literals.

    source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar.default); // Replace delimiters with snippets.

    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }

    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }

    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }

    index = offset + match.length; // The JS engine embedded in Adobe products needs `match` returned in
    // order to produce the correct `offset` value.

    return match;
  });
  source += "';\n"; // If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  // Like with sourceURL, we take care to not check the option's prototype,
  // as this configuration is a code injection vector.

  var variable = hasOwnProperty.call(options, 'variable') && options.variable;

  if (!variable) {
    source = 'with (obj) {\n' + source + '\n}\n';
  } // Cleanup code by stripping empty strings.


  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;'); // Frame code as the function body.

  source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
  var result = (0, _attempt.default)(function () {
    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
  }); // Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.

  result.source = source;

  if ((0, _isError.default)(result)) {
    throw result;
  }

  return result;
}

var _default = template;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/templateSettings.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/templateSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _escape = _interopRequireDefault(__webpack_require__(/*! ./escape.js */ "./node_modules/lodash-es/escape.js"));

var _reEscape = _interopRequireDefault(__webpack_require__(/*! ./_reEscape.js */ "./node_modules/lodash-es/_reEscape.js"));

var _reEvaluate = _interopRequireDefault(__webpack_require__(/*! ./_reEvaluate.js */ "./node_modules/lodash-es/_reEvaluate.js"));

var _reInterpolate = _interopRequireDefault(__webpack_require__(/*! ./_reInterpolate.js */ "./node_modules/lodash-es/_reInterpolate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * By default, the template delimiters used by lodash are like those in
 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
 * following template settings to use alternative delimiters.
 *
 * @static
 * @memberOf _
 * @type {Object}
 */
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'escape': _reEscape.default,

  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'evaluate': _reEvaluate.default,

  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  'interpolate': _reInterpolate.default,

  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  'variable': '',

  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  'imports': {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    '_': {
      'escape': _escape.default
    }
  }
};
var _default = templateSettings;
exports.default = _default;

/***/ }),

/***/ "./node_modules/lodash-es/toString.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/toString.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _baseToString = _interopRequireDefault(__webpack_require__(/*! ./_baseToString.js */ "./node_modules/lodash-es/_baseToString.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : (0, _baseToString.default)(value);
}

var _default = toString;
exports.default = _default;

/***/ }),

/***/ "./node_modules/postcss-loader/src/index.js!./node_modules/flatpickr/dist/flatpickr.css":
/*!*************************************************************************************!*\
  !*** ./node_modules/postcss-loader/src!./node_modules/flatpickr/dist/flatpickr.css ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".flatpickr-calendar {\n  background: transparent;\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  -webkit-animation: none;\n          animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 5px;\n  position: absolute;\n  width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-touch-action: manipulation;\n      touch-action: manipulation;\n  background: #fff;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n          box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n}\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 99999;\n}\n.flatpickr-calendar.animate.open {\n  -webkit-animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n          animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 2px;\n}\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 2px);\n}\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7) {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1) {\n  -webkit-box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n.flatpickr-calendar.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid #e6e6e6;\n}\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: '';\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.arrowRight:before,\n.flatpickr-calendar.rightMost:after,\n.flatpickr-calendar.arrowRight:after {\n  left: auto;\n  right: 22px;\n}\n.flatpickr-calendar.arrowCenter:before,\n.flatpickr-calendar.arrowCenter:after {\n  left: 50%;\n  right: 50%;\n}\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n}\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n}\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: #fff;\n}\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: #fff;\n}\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n.flatpickr-wrapper {\n  position: relative;\n  display: inline-block;\n}\n.flatpickr-months {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-months .flatpickr-month {\n  background: transparent;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n  height: 34px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  overflow: hidden;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  height: 34px;\n  padding: 10px;\n  z-index: 3;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-disabled,\n.flatpickr-months .flatpickr-next-month.flatpickr-disabled {\n  display: none;\n}\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  left: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  right: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: #959ea9;\n}\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  fill: #f64747;\n}\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n}\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  -webkit-transition: fill 0.1s;\n  transition: fill 0.1s;\n  fill: inherit;\n}\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n.numInputWrapper input {\n  width: 100%;\n}\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n.numInputWrapper input::-webkit-outer-spin-button,\n.numInputWrapper input::-webkit-inner-spin-button {\n  margin: 0;\n  -webkit-appearance: none;\n}\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid rgba(57,57,57,0.15);\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.numInputWrapper span:hover {\n  background: rgba(0,0,0,0.1);\n}\n.numInputWrapper span:active {\n  background: rgba(0,0,0,0.2);\n}\n.numInputWrapper span:after {\n  display: block;\n  content: \"\";\n  position: absolute;\n}\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid rgba(57,57,57,0.6);\n  top: 26%;\n}\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid rgba(57,57,57,0.6);\n  top: 40%;\n}\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n.numInputWrapper span svg path {\n  fill: rgba(0,0,0,0.5);\n}\n.numInputWrapper:hover {\n  background: rgba(0,0,0,0.05);\n}\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 7.48px 0 0 0;\n  line-height: 1;\n  height: 34px;\n  display: inline-block;\n  text-align: center;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n}\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0;\n  display: inline-block;\n}\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: rgba(0,0,0,0.5);\n  background: transparent;\n  pointer-events: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months {\n  appearance: menulist;\n  background: transparent;\n  border: none;\n  border-radius: 0;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: pointer;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  height: auto;\n  line-height: inherit;\n  margin: -1px 0 0 0;\n  outline: none;\n  padding: 0 0 0 0.5ch;\n  position: relative;\n  vertical-align: initial;\n  -webkit-box-sizing: border-box;\n  -webkit-appearance: menulist;\n  -moz-appearance: menulist;\n  width: auto;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:focus,\n.flatpickr-current-month .flatpickr-monthDropdown-months:active {\n  outline: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months .flatpickr-monthDropdown-month {\n  background-color: transparent;\n  outline: none;\n  padding: 0;\n}\n.flatpickr-weekdays {\n  background: transparent;\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  height: 28px;\n}\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: transparent;\n  color: rgba(0,0,0,0.54);\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-weight: bolder;\n}\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: start;\n  -webkit-align-items: flex-start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n  width: 307.875px;\n}\n.flatpickr-days:focus {\n  outline: 0;\n}\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n          flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-around;\n          justify-content: space-around;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n.dayContainer + .dayContainer {\n  -webkit-box-shadow: -1px 0 0 #e6e6e6;\n          box-shadow: -1px 0 0 #e6e6e6;\n}\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #393939;\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  -webkit-flex-basis: 14.2857143%;\n      -ms-flex-preferred-size: 14.2857143%;\n          flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 39px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  text-align: center;\n}\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: #e6e6e6;\n  border-color: #e6e6e6;\n}\n.flatpickr-day.today {\n  border-color: #959ea9;\n}\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: #959ea9;\n  background: #959ea9;\n  color: #fff;\n}\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: #569ff7;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  color: #fff;\n  border-color: #569ff7;\n}\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)) {\n  -webkit-box-shadow: -10px 0 0 #569ff7;\n          box-shadow: -10px 0 0 #569ff7;\n}\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n.flatpickr-day.inRange {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover {\n  cursor: not-allowed;\n  color: rgba(57,57,57,0.1);\n}\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n          box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n}\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n.flatpickr-weekwrapper {\n  float: left;\n}\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6;\n          box-shadow: 1px 0 0 #e6e6e6;\n}\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n.flatpickr-innerContainer {\n  display: block;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n}\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-time:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.flatpickr-time .numInputWrapper {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: #393939;\n}\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: #393939;\n}\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n.flatpickr-time input {\n  background: transparent;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  color: #393939;\n  font-size: 14px;\n  position: relative;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  float: left;\n  line-height: inherit;\n  color: #393939;\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-align-self: center;\n      -ms-flex-item-align: center;\n          align-self: center;\n}\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: #eee;\n}\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n@-webkit-keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n"

/***/ }),

/***/ "./node_modules/postcss-loader/src/index.js!./src/style/classes.css":
/*!*****************************************************************!*\
  !*** ./node_modules/postcss-loader/src!./src/style/classes.css ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "/*\r\n* This file is part of the BBjGridExWidget plugin.\r\n* (c) Basis Europe <eu@basis.com>\r\n*\r\n* For the full copyright and license information, please view the LICENSE\r\n* file that was distributed with this source code.\r\n*/\r\n\r\n.gw-alignment-cell-right,\r\n.gw-alignment-cell-right .ag-cell-value,\r\n.gw-alignment-cell-right .templateRenderer {\r\n  text-align: right;\r\n  -webkit-box-pack: end;\r\n      -ms-flex-pack: end;\r\n          justify-content: flex-end;\r\n  -webkit-box-flex: 1;\r\n      -ms-flex: 1;\r\n          flex: 1;\r\n}\r\n\r\n.gw-alignment-cell-center,\r\n.gw-alignment-cell-center .ag-cell-value,\r\n.gw-alignment-cell-center .templateRenderer {\r\n  text-align: center;\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n  -webkit-box-flex: 1;\r\n      -ms-flex: 1;\r\n          flex: 1;\r\n}\r\n\r\n.gw-alignment-cell-right .boolSwitch,\r\n.gw-alignment-cell-center .boolSwitch {\r\n  text-align: initial;\r\n}\r\n\r\n.gw-alignment-cell-center .boolSwitch__wrapper,\r\n.gw-alignment-cell-right .boolSwitch__wrapper {\r\n  width: auto;\r\n  height: auto;\r\n}\r\n\r\n.gw-alignment-cell-center .boolSwitch__wrapper {\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n}\r\n\r\n.gw-alignment-cell-right .boolSwitch__wrapper {\r\n  -webkit-box-pack: right;\r\n      -ms-flex-pack: right;\r\n          justify-content: right;\r\n}\r\n\r\n.gw-alignment-header-right .ag-header-cell-label {\r\n  -webkit-box-orient: horizontal;\r\n  -webkit-box-direction: reverse;\r\n      -ms-flex-direction: row-reverse;\r\n          flex-direction: row-reverse;\r\n}\r\n\r\n.gw-alignment-header-center .ag-header-cell-label {\r\n  display: -webkit-box;\r\n  display: -ms-flexbox;\r\n  display: flex;\r\n  -webkit-box-pack: center;\r\n      -ms-flex-pack: center;\r\n          justify-content: center;\r\n}\r\n\r\n.gw-alignment-header-center .ag-header-cell-text {\r\n  margin-left: -16px !important;\r\n}\r\n\r\n.gw-alignment-header-right .ag-cell-label-container,\r\n.gw-alignment-header-center .ag-cell-label-container {\r\n  -webkit-box-orient: horizontal;\r\n  -webkit-box-direction: normal;\r\n      -ms-flex-direction: row;\r\n          flex-direction: row;\r\n}\r\n\r\n.gw-tooltip {\r\n  position: absolute;\r\n  overflow: hidden;\r\n  pointer-events: none;\r\n  -webkit-transition: opacity 1s;\r\n  transition: opacity 1s;\r\n  border-radius: 3.1px;\r\n  padding: 10px;\r\n  -webkit-transition: opacity 260ms;\r\n  transition: opacity 260ms;\r\n}\r\n\r\n.gw-tooltip-light {\r\n  background-color: white;\r\n  -webkit-box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);\r\n          box-shadow: 0 0 6px rgba(0, 0, 0, 0.25);\r\n}\r\n\r\n.gw-tooltip-dark {\r\n  background-color: #1c1f20;\r\n  -webkit-box-shadow: 0 0 6px #5c5c5c;\r\n          box-shadow: 0 0 6px #5c5c5c;\r\n  color: white;\r\n}\r\n"

/***/ }),

/***/ "./node_modules/postcss-loader/src/index.js!./src/style/suggestion-editor.css":
/*!***************************************************************************!*\
  !*** ./node_modules/postcss-loader/src!./src/style/suggestion-editor.css ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ".autocompleteInputWrapper__input {\r\n  padding-left: 6px;\r\n  border: thin solid var(--ag-input-focus-border-color, rgba(33, 150, 243, 0.4));\r\n  border-radius: 3px;\r\n  background-color: var(--ag-background-color);\r\n  color: inherit;\r\n  outline: none;\r\n}\r\n\r\n.ag-theme-alpine .autocompleteInputWrapper__input,\r\n.ag-theme-balham .autocompleteInputWrapper__input,\r\n.ag-theme-material .autocompleteInputWrapper__input {\r\n  background-color: var(--ag-background-color, #fff);\r\n}\r\n\r\n.ag-theme-alpine-dark .autocompleteInputWrapper__input,\r\n.ag-theme-balham-dark .autocompleteInputWrapper__input {\r\n  background-color: var(--ag-background-color, #2d3436);\r\n}\r\n\r\n.autocomplete {\r\n  background-color: var(--ag-background-color, #fff);\r\n  z-index: 1000;\r\n  -webkit-box-sizing: border-box;\r\n          box-sizing: border-box;\r\n  border: thin solid var(--ag-input-focus-border-color, rgba(33, 150, 243, 0.4));\r\n  border-top: 0;\r\n  border-radius: 3px;\r\n  border-top-left-radius: 0;\r\n  border-top-right-radius: 0;\r\n  overflow: auto;\r\n  -webkit-box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);\r\n          box-shadow: 0px 3px 15px rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n.autocomplete.dark {\r\n  background-color: var(--ag-background-color, #2d3436);\r\n  color: var(--ag-data-color, var(--ag-foreground-color, #fff));\r\n}\r\n\r\n.autocomplete .suggestion-group {\r\n  background: #eee;\r\n  padding: 5px 6px;\r\n  font-weight: bold;\r\n}\r\n\r\n.autocomplete.dark .suggestion-group {\r\n  background: var(--ag-background-color, #181d1f);\r\n}\r\n\r\n.autocomplete .suggestion-item {\r\n  padding: 10px;\r\n  cursor: pointer;\r\n}\r\n\r\n.autocomplete .suggestion-item:hover {\r\n  background-color: var(--ag-row-hover-color, rgba(33, 150, 244, 0.1));\r\n}\r\n\r\n.autocomplete .suggestion-item.selected {\r\n  background-color: var(\r\n    --ag-selected-row-background-color,\r\n    rgba(33, 150, 243, 0.3)\r\n  );\r\n}\r\n\r\n.autocomplete .empty {\r\n  padding: 8px 6px;\r\n}\r\n\r\n.autocomplete-input-error {\r\n  -webkit-box-shadow: 0 -2px 0 #e91e63 inset;\r\n          box-shadow: 0 -2px 0 #e91e63 inset;\r\n}\r\n\r\n.autocomplete-input-success {\r\n  -webkit-box-shadow: 0 -2px 0 #4caf50 inset;\r\n          box-shadow: 0 -2px 0 #4caf50 inset;\r\n}\r\n"

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/api/cells.js":
/*!**************************!*\
  !*** ./src/api/cells.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_startEditingCell = gw_startEditingCell;
exports.gw_stopEditing = gw_stopEditing;
exports.gw_tabToNextCell = gw_tabToNextCell;
exports.gw_tabToPreviousCell = gw_tabToPreviousCell;
exports.gw_setFocusedCell = gw_setFocusedCell;
exports.gw_getRangeSelections = gw_getRangeSelections;
exports.gw_parseAddCellRange = gw_parseAddCellRange;
exports.gw_addCellRange = gw_addCellRange;
exports.gw_clearRangeSelection = gw_clearRangeSelection;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

var _utilities2 = __webpack_require__(/*! events/utilities */ "./src/events/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(/*! deep-parse-json */ "./node_modules/deep-parse-json/index.js"),
    deepParseJson = _require.deepParseJson;
/**
 * Start cell editing
 *
 * @param {String} id The grid's id
 * @param {String|number} row The row index or key
 * @param {String} colKey The column's key
 * @param {String|Number} keyPress  Key press
 * @param {String} charPress
 * @param {String} rowPinned Set to 'top' or 'bottom' to started editing a pinned row
 */


function gw_startEditingCell(id, row, colKey, keyPress, charPress, rowPinned) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var node = api.getRowNode(row) || api.getDisplayedRowAtIndex(row);
  options.api.startEditingCell({
    rowIndex: node.rowIndex,
    keyPress: Number(keyPress),
    colKey: colKey,
    charPress: charPress,
    rowPinned: rowPinned
  });
}
/**
 * Stop cell editing
 *
 * @param {String} id The grid's id
 * @param {Boolean} cancel when true cancel edits , save edits otherwise
 */


function gw_stopEditing(id, cancel) {
  (0, _utilities.gw_getGrid)(id).options.api.stopEditing(cancel);
}
/**
 * Navigates the grid focus to the next cell, as if tabbing.
 *
 * @param {String} id  the grid id
 */


function gw_tabToNextCell(id) {
  (0, _utilities.gw_getGrid)(id).options.api.tabToNextCell();
}
/**
 * Navigates the grid focus to the previous cell, as if shift-tabbing.
 *
 * @param {String} id  the grid id
 */


function gw_tabToPreviousCell(id) {
  (0, _utilities.gw_getGrid)(id).options.api.tabToPreviousCell();
}
/**
 * Set Focus on the given row and column
 *
 * @param {String} id The grid's id
 * @param {String|Number} row The row's index/id
 * @param {String} column The column id
 * @param {String} floating null, 'top', or 'bottom'.
 */


function gw_setFocusedCell(id, row, column) {
  var floating = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var options = (0, _utilities.gw_getGrid)(id).options; // ignore focus calls if editing

  if (options.api.getEditingCells().length > 0) {
    return;
  }

  var r, c, f;

  if (row == -1) {
    // try to retain the focus
    var lastFocusedCell = options.api.getFocusedCell();

    if (lastFocusedCell) {
      r = lastFocusedCell.rowIndex;
      c = lastFocusedCell.column.colId;
      f = lastFocusedCell.rowPinned;
    } else {
      r = 0;
      c = options.columnApi.getAllGridColumns()[0].colId;
      f = floating;
    }
  } else {
    r = !row ? 0 : Number.isInteger(+row) ? +row : options.api.getRowNode(row).rowIndex;
    c = column ? column : options.columnApi.getAllGridColumns()[0].colId;
    f = floating;
  }

  (0, _utilities.gw_getGrid)(id).options.api.setFocusedCell(r, c, f);
}
/**
 * Get Range Selections
 *
 * The method will create a range json model for each range which can be parsed in BBj side.
 *
 * @param {Number} id grid's id
 *
 * @returns {String} selected ranges as JSON
 */


function gw_getRangeSelections(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var context = options.context;
  var api = options.api;
  var ranges = api.getCellRanges();
  var model = api.getModel();
  var result = [];
  ranges.forEach(function (range) {
    // const start = gw_parseNode(model.getRow(range.startRow.rowIndex), options.context);
    // const end = gw_parseNode(model.getRow(range.endRow.rowIndex), options.context);
    //if (start !== false && end !== false) {
    var columns = range.columns.reduce(function (accumulator, current) {
      if ('ag-Grid-AutoColumn' !== current.colId) {
        accumulator.push(current.colId);
      }

      return accumulator;
    }, []).filter(Boolean);
    var starIndex = Math.min(range.startRow.rowIndex, range.endRow.rowIndex);
    var endIndex = Math.max(range.startRow.rowIndex, range.endRow.rowIndex);
    var rows = [];

    for (var rowIndex = starIndex; rowIndex <= endIndex; rowIndex++) {
      var node = model.getRow(rowIndex);

      if (node) {
        var parsedNode = (0, _utilities2.gw_parseNode)(node, context);

        if (parsedNode) {
          rows.push(parsedNode);
        }
      }
    }

    if (rows.length && columns.length) {
      result.push({
        r: rows,
        c: columns
      });
    } //}

  });
  return JSON.stringify(result);
}
/**
 * Parse the cells range in a format the grid can understand when it is passed
 * to `api.addCellRange`
 *
 * @param {Object} options The grid's options
 * @param {Object} range  bounded or unbounded range model
 */


function gw_parseAddCellRange(options, range) {
  var pr = deepParseJson(JSON.stringify(range));
  var start = !(pr.start || null) ? 0 : Number.isInteger(+pr.start) ? +pr.start : options.api.getRowNode(pr.start).rowIndex;
  var end = !(pr.end || null) ? options.rowData.length - 1 : Number.isInteger(+pr.end) ? +pr.end : options.api.getRowNode(pr.end).rowIndex;
  return {
    rowStartIndex: Math.abs(start),
    rowEndIndex: Math.abs(end),
    columns: pr.columns
  };
}
/**
 * Add new cell range
 *
 * @param {Number} id grid's id
 * @param {Object} range  bounded or unbounded range model
 */


function gw_addCellRange(id, range) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  options.api.addCellRange(gw_parseAddCellRange(options, range));
}
/**
 * Clears the selected range.
 *
 * @param {Number} id grid's id
 */


function gw_clearRangeSelection(id) {
  (0, _utilities.gw_getGrid)(id).options.api.clearRangeSelection();
}

/***/ }),

/***/ "./src/api/charts.js":
/*!***************************!*\
  !*** ./src/api/charts.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getChartToolbarItems = gw_getChartToolbarItems;
exports.gw_addChartRange = gw_addChartRange;
exports.gw_destroyChart = gw_destroyChart;

var _utilities = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

var _cells = __webpack_require__(/*! api/cells */ "./src/api/cells.js");

/* eslint-disable no-prototype-builtins */

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(/*! deep-parse-json */ "./node_modules/deep-parse-json/index.js"),
    deepParseJson = _require.deepParseJson;
/**
 * The array contains references to created charts from BBj.
 * Every reference is a ChartRef object which provides the application with the
 * destroyChart() method that is required when the application wants to dispose the chart.
 */

/**
 * Return the chart toolbar items defined in the grid's context
 *
 * @param {Object} params
 * @returns {Array} array of supported chart items
 */


function gw_getChartToolbarItems(params) {
  return params.api.gridOptionsWrapper.gridOptions.context.chartToolbarItems || [];
}
/**
 * Add new chart range
 *
 * @param {String} id grid's id
 * @param {Object} range  bounded or unbounded range model
 *
 * @return {String} a unique id for the generate chart
 */


function gw_addChartRange(id, range) {
  var grid = (0, _utilities.gw_getGrid)(id);
  var options = grid.options;
  var pr = deepParseJson(JSON.stringify(range));
  pr.cellRange = (0, _cells.gw_parseAddCellRange)(options, pr.cellRange);
  var ref = options.api.createRangeChart(pr);
  var uuid = (0, _utilities.gw_uuid)();
  grid.created_charts = grid.created_charts || {};
  grid.created_charts[uuid] = ref;
  return uuid;
}
/**
 * Destroy created charts
 *
 * Destroy already created chart by id or all created charts
 * when the `uuid` is omitted.
 *
 * @param {String} id grid's id
 * @param {String} uuid The chart's id
 */


function gw_destroyChart(id, uuid) {
  var grid = (0, _utilities.gw_getGrid)(id);

  if (uuid) {
    if (grid.hasOwnProperty('created_charts') && grid.created_charts.hasOwnProperty(uuid)) {
      grid.created_charts[uuid].destroyChart();
    }
  } else {
    if (grid.hasOwnProperty('created_charts')) {
      for (var i in grid.created_charts) {
        if (grid.created_charts.hasOwnProperty(i)) {
          var chart = grid.created_charts[i];
          chart.destroyChart();
        }
      }
    }
  }
}

/***/ }),

/***/ "./src/api/columns.js":
/*!****************************!*\
  !*** ./src/api/columns.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_extendColumnDefinitions = gw_extendColumnDefinitions;
exports.gw_setColumnDefinitions = gw_setColumnDefinitions;
exports.gw_sizeColumnsToFit = gw_sizeColumnsToFit;
exports.gw_autoSizeColumns = gw_autoSizeColumns;
exports.gw_ensureColumnVisible = gw_ensureColumnVisible;
exports.gw_setColumnWidth = gw_setColumnWidth;
exports.gw_pinColumn = gw_pinColumn;
exports.gw_moveColumn = gw_moveColumn;
exports.gw_isShowSelectionCheckbox = gw_isShowSelectionCheckbox;
exports.gw_isHeaderCheckboxSelection = gw_isHeaderCheckboxSelection;
exports.gw_addRowGroupColumn = gw_addRowGroupColumn;
exports.gw_removeRowGroupColumn = gw_removeRowGroupColumn;
exports.gw_getPivotMode = gw_getPivotMode;
exports.gw_setPivotMode = gw_setPivotMode;
exports.gw_addPivotColumns = gw_addPivotColumns;
exports.gw_removePivotColumns = gw_removePivotColumns;
exports.gw_addValueColumns = gw_addValueColumns;
exports.gw_removeValueColumns = gw_removeValueColumns;
exports.gw_setSortModel = gw_setSortModel;
exports.gw_refreshHeader = gw_refreshHeader;
exports.gw_setColumnVisible = gw_setColumnVisible;
exports.gw_addAlignedGrid = gw_addAlignedGrid;
exports.gw_removeAlignedGrid = gw_removeAlignedGrid;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

var _expression = __webpack_require__(/*! ../expression */ "./src/expression.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var _require = __webpack_require__(/*! deep-parse-json */ "./node_modules/deep-parse-json/index.js"),
    deepParseJson = _require.deepParseJson;
/**
 * Extend the column definitions
 *
 * Extend the column definitions with options which can not be handled in BBj
 * (ex: attaching callbacks)
 *
 * @param {Array} definitions array of column definitions
 */


function gw_extendColumnDefinitions(definitions) {
  var _loop = function _loop(i) {
    var def = definitions[i];
    def.checkboxSelection = def.checkboxSelection || gw_isShowSelectionCheckbox;
    def.headerCheckboxSelection = def.headerCheckboxSelection || gw_isHeaderCheckboxSelection;
    var tooltipValueGetterExpression = def.tooltipValueGetter;

    if (tooltipValueGetterExpression) {
      def.tooltipValueGetter = function (params) {
        return (0, _expression.gw_executeExpression)(tooltipValueGetterExpression, params);
      };
    }

    def.tooltipComponent = 'HTMLTooltip'; // eslint-disable-next-line no-prototype-builtins

    if (def.hasOwnProperty('editable') && typeof def.editable === 'string') {
      var editable = def.editable;

      def.editable = function (params) {
        return (0, _expression.gw_executeExpression)(editable, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('rowSpan') && typeof def.rowSpan === 'string') {
      var rowSpan = def.rowSpan;

      def.rowSpan = function (params) {
        return (0, _expression.gw_executeExpression)(rowSpan, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('colSpan') && typeof def.colSpan === 'string') {
      var colSpan = def.colSpan;

      def.colSpan = function (params) {
        return (0, _expression.gw_executeExpression)(colSpan, params);
      };
    } // eslint-disable-next-line no-prototype-builtins


    if (def.hasOwnProperty('children')) {
      gw_extendColumnDefinitions(def.children);
    }
  };

  for (var i in definitions) {
    _loop(i);
  }
}
/**
 * Update the column definitions
 *
 * @param {String} id The grid id
 * @param {Array} definitions array of column definitions
 */


function gw_setColumnDefinitions(id, definitions) {
  var grid = (0, _utilities.gw_getGrid)(id);
  var deepParsedDefinitions = deepParseJson(JSON.stringify(definitions));
  gw_extendColumnDefinitions(deepParsedDefinitions);
  grid.options.api.setColumnDefs(deepParsedDefinitions);
  grid.options.columnDefs = deepParsedDefinitions;
}
/**
 * Make the currently visible columns fit the screen
 *
 * @param {String} id The grid's id
 * @param {Number} the width to use to fit all columns in
 */


function gw_sizeColumnsToFit(id, width) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var columnsAPI = options.columnApi;

  if (width) {
    columnsAPI.sizeColumnsToFit(Number(width));
  } else {
    api.sizeColumnsToFit();
  }
}
/**
 * Work out the best width to fit the contents of the cells in the column.
 *
 * @param {String} id The grid's id
 * @param {Boolean} [skipHeader=false] when true indicate that the header content (headerName) should not be considered when
 *                             calculating the width of the column
 * @param {Array|null} [columns=null] an array of columns ids to auto size or null to auto size all columns
 */


function gw_autoSizeColumns(id) {
  var skipHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var options = (0, _utilities.gw_getGrid)(id).options;
  var columnsAPI = options.columnApi;

  if (!(columns && columns.length)) {
    var allColumnIds = [];
    columnsAPI.getAllColumns().forEach(function (column) {
      allColumnIds.push(column.colId);
    });
    columnsAPI.autoSizeColumns(allColumnIds, Boolean(skipHeader));
  } else {
    columnsAPI.autoSizeColumns(columns, Boolean(skipHeader));
  }
}
/**
 * Ensures the column is visible, scrolling the table if needed.
 *
 * @param {String} id  the grid's id
 * @param {String} columnId  the column id
 */


function gw_ensureColumnVisible(id, columnId) {
  (0, _utilities.gw_getGrid)(id).options.api.ensureColumnVisible(columnId);
}
/**
 * Set Column Width
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {Number|String} width The new column width
 */


function gw_setColumnWidth(id, columnId, width) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnWidth(columnId, Number(width));
}
/**
 * Pin Column
 *
 * Pin a column to a specific direction
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {String} pin The pin direction
 */


function gw_pinColumn(id, columnId, pin) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnPinned(columnId, pin);
}
/**
 * Move Column
 *
 * Move column to a specific index
 *
 * @param {String} id The grid id
 * @param {String} columnId The column id
 * @param {Number|String} toIndex The new column index
 */


function gw_moveColumn(id, columnId, toIndex) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.moveColumn(columnId, toIndex);
}
/**
 * Show / Hide selection checkbox based on the first column
 *
 * The function make sure that the selection checkbox is always shown on the
 * first column
 *
 * @param {Object} param
 *
 * @return {Boolean} true when first column , false if not the first column or if the
 *                   grid's `Context.showSelectionCheckbox` is false
 */


function gw_isShowSelectionCheckbox(param) {
  if (!param.context.showSelectionCheckbox) {
    return false;
  }

  var columns = param.columnApi.getAllDisplayedColumns();
  return columns[0] === param.column;
}
/**
 * Show / Hide header selection checkbox based on the first column
 *
 * The function make sure that the header selection checkbox is always shown on the
 * first column
 *
 * @param {Object} param
 *
 * @return {Boolean} true when first column , false if not the first column or if the
 *                   grid's `Context.showHeaderSelectionCheckbox` is false
 */


function gw_isHeaderCheckboxSelection(param) {
  var context = param.api.gridOptionsWrapper.gridOptions.context;

  if (!context.showHeaderSelectionCheckbox) {
    return false;
  }

  var columns = param.columnApi.getAllDisplayedColumns();
  return columns[0] === param.column;
}
/**
 * Enable row grouping for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 * @param {Boolean} set  When true , `setRowGroupColumns` will be used , `addRowGroupColumns` otherwise
 */


function gw_addRowGroupColumn(id, columns, set) {
  (0, _utilities.gw_getGrid)(id).options.columnApi[set ? 'setRowGroupColumns' : 'addRowGroupColumns'](columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable row grouping for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removeRowGroupColumn(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removeRowGroupColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}

function gw_getPivotMode(id) {
  return (0, _utilities.gw_getGrid)(id).options.columnApi.isPivotMode();
}
/**
 * Enable / disbale pivot mode
 *
 * @param {String} id the grid id
 * @param {Boolean} mode when true
 */


function gw_setPivotMode(id, mode) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setPivotMode(!!Number(mode));
}
/**
 * Enable pivot for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 * @param {Boolean} set  When true , `addPivotColumns` will be used , `setPivotColumns` otherwise
 */


function gw_addPivotColumns(id, columns, set) {
  (0, _utilities.gw_getGrid)(id).options.columnApi[set ? 'setPivotColumns' : 'addPivotColumns'](columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable pivot for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removePivotColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removePivotColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Enable value for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_addValueColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.addValueColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Disable value for columns
 *
 * @param {String} id the grid id
 * @param {String} columns  a comma separated string of columns
 */


function gw_removeValueColumns(id, columns) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.removeValueColumns(columns.split(',').map(function (i) {
    return i.trim();
  }));
}
/**
 * Set the column sorting model
 *
 * @param {String} id the grid id
 * @param {String} model model as json array
 */


function gw_setSortModel(id, model) {
  var asArray = JSON.parse(model);
  var parsedModel = [];
  asArray.forEach(function (i) {
    for (var key in i) {
      parsedModel.push({
        colId: key,
        sort: i[key]
      });
    }
  });
  (0, _utilities.gw_getGrid)(id).options.api.setSortModel(parsedModel);
}
/**
 * Redraws the header. Useful if a column name changes,
 * or something else that changes how the column header is displayed.
 *
 * @param {String} id grid's id
 */


function gw_refreshHeader(id) {
  (0, _utilities.gw_getGrid)(id).options.api.redrawRows();
}
/**
 * Update column viability
 *
 * @param {String} id grid's id
 * @param {String} columns  a comma separated list of column ids
 * @param {Boolean} visible true to make the columns visible , false to hide
 */


function gw_setColumnVisible(id, columns, visible) {
  (0, _utilities.gw_getGrid)(id).options.columnApi.setColumnsVisible(columns.split(','), Boolean(visible));
}
/**
 * Align two grid together
 *
 * @param {String} id The current grid's id
 * @param {String} gridId The target grid's id
 */


function gw_addAlignedGrid(id, gridId) {
  var currentGridOption = (0, _utilities.gw_getGrid)(id).options;

  var register = function register() {
    var targetGridOption = (0, _utilities.gw_getGrid)(gridId).options;
    currentGridOption.alignedGrids.push(targetGridOption);
  };

  try {
    register();
  } catch (err) {
    currentGridOption.alignedGrids.push(gridId);
    window.addEventListener("".concat(gridId, "-ready"), function () {
      var indexOf = currentGridOption.alignedGrids.indexOf(gridId);

      if (indexOf > -1) {
        currentGridOption.alignedGrids.splice(indexOf, 1);
        register();
      }
    });
  }
}
/**
 * Remove aligned grids
 *
 * @param {String} id The current grid's id
 * @param {String} gridId The target grid's id
 */


function gw_removeAlignedGrid(id, gridId) {
  var currentGridOption = (0, _utilities.gw_getGrid)(id).options;
  var alignedGrids = currentGridOption.alignedGrids;

  for (var x = 0; x < alignedGrids.length; x++) {
    var grid = alignedGrids[x];

    if (typeof grid === 'string' && grid === gridId || grid.context.id === gridId) {
      alignedGrids.splice(x, 1);
    }
  }
}

/***/ }),

/***/ "./src/api/context.js":
/*!****************************!*\
  !*** ./src/api/context.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_updateContext = gw_updateContext;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Update context
 *
 * @param {String} id The grid's id
 * @param {String} key The context's key to update
 * @param {String} value  The new context's value
 */
// export function gw_legacyUpdateContext(id, key, value) {
// 	gw_getGrid(id)
// 		.options
// 		.context[key] = JSON.parse(value);
// }

/**
 * Update context
 *
 * @param {String} id The grid's id
 * @param {Object} context The new context object
 */
function gw_updateContext(id, context) {
  (0, _utilities.gw_getGrid)(id).options.context = context;
}

/***/ }),

/***/ "./src/api/index.js":
/*!**************************!*\
  !*** ./src/api/index.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _init = __webpack_require__(/*! ./init.js */ "./src/api/init.js");

Object.keys(_init).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _init[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _init[key];
    }
  });
});

var _columns = __webpack_require__(/*! ./columns.js */ "./src/api/columns.js");

Object.keys(_columns).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _columns[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _columns[key];
    }
  });
});

var _rows = __webpack_require__(/*! ./rows.js */ "./src/api/rows.js");

Object.keys(_rows).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _rows[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _rows[key];
    }
  });
});

var _cells = __webpack_require__(/*! ./cells.js */ "./src/api/cells.js");

Object.keys(_cells).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _cells[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _cells[key];
    }
  });
});

var _state = __webpack_require__(/*! ./state.js */ "./src/api/state.js");

Object.keys(_state).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _state[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _state[key];
    }
  });
});

var _toolpanel = __webpack_require__(/*! ./toolpanel.js */ "./src/api/toolpanel.js");

Object.keys(_toolpanel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _toolpanel[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _toolpanel[key];
    }
  });
});

var _statusbar = __webpack_require__(/*! ./statusbar.js */ "./src/api/statusbar.js");

Object.keys(_statusbar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _statusbar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _statusbar[key];
    }
  });
});

var _overlays = __webpack_require__(/*! ./overlays.js */ "./src/api/overlays.js");

Object.keys(_overlays).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _overlays[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _overlays[key];
    }
  });
});

var _context = __webpack_require__(/*! ./context.js */ "./src/api/context.js");

Object.keys(_context).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _context[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _context[key];
    }
  });
});

var _charts = __webpack_require__(/*! ./charts.js */ "./src/api/charts.js");

Object.keys(_charts).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _charts[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _charts[key];
    }
  });
});

var _jss = __webpack_require__(/*! ./jss.js */ "./src/api/jss.js");

Object.keys(_jss).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _jss[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _jss[key];
    }
  });
});

var _utilities = __webpack_require__(/*! ./utilities.js */ "./src/api/utilities.js");

Object.keys(_utilities).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _utilities[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _utilities[key];
    }
  });
});

/***/ }),

/***/ "./src/api/init.js":
/*!*************************!*\
  !*** ./src/api/init.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_init = gw_init;

var _columns = __webpack_require__(/*! ./columns */ "./src/api/columns.js");

var _rows = __webpack_require__(/*! ./rows */ "./src/api/rows.js");

var _menus = __webpack_require__(/*! ./menus */ "./src/api/menus.js");

var _charts = __webpack_require__(/*! ./charts */ "./src/api/charts.js");

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

var _events = __webpack_require__(/*! events */ "./src/events/index.js");

var _template = _interopRequireDefault(__webpack_require__(/*! lodash-es/template */ "./node_modules/lodash-es/template.js"));

var _HTMLTooltip = _interopRequireDefault(__webpack_require__(/*! ../components/HTMLTooltip.js */ "./src/components/HTMLTooltip.js"));

var _SuggestionEditor = _interopRequireDefault(__webpack_require__(/*! ../components/SuggestionEditor.js */ "./src/components/SuggestionEditor.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(/*! deep-parse-json */ "./node_modules/deep-parse-json/index.js"),
    deepParseJson = _require.deepParseJson;

function gw_init(options, license, data) {
  if (agGrid.LicenseManager && license) {
    agGrid.LicenseManager.setLicenseKey(license);
  }

  var id = options.context.id;
  var container = (0, _utilities.gw_getDocument)().getElementById(id);
  var containerClone = container.cloneNode(true);
  container.parentNode.replaceChild(containerClone, container);
  container = containerClone; // we make the grid options available as soon as possible

  var grid = (0, _utilities.gw_addGrid)(id, {
    container: container,
    options: options
  }); // TODO: use ag grid destroy

  container.innerHTML = '';
  var parsedOptions = gw_parseOptions(options);
  parsedOptions.rowData = data;
  var instance = new agGrid.Grid(container, parsedOptions);
  grid.instance = instance;
  grid.options = parsedOptions;
  console.log("%c Grid [".concat(id, "] settings : "), 'background: #222; color: #bada55', parsedOptions);
}
/**
 * Parse Options
 *
 * Parse the grid options and return
 * an object which can be passed to the grid
 *
 * @param {Object} options Grid options as Json Object
 *
 * @return {Object} options object
 */


function gw_parseOptions(options) {
  var deepParsedOptions = deepParseJson(JSON.stringify(options));
  var id = deepParsedOptions.context.id;
  var getDataPathTemplate = deepParsedOptions.context.getDataPath || ''; // TODO: do we need to control this setting from BBj ?

  var debounceDuration = 250;

  var finalOptions = _objectSpread(_objectSpread({}, deepParsedOptions), {
    getDocument: function getDocument() {
      return (0, _utilities.gw_getDocument)();
    },
    onCellEditingStarted: function onCellEditingStarted(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onCellEditingStopped: function onCellEditingStopped(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onCellValueChanged: function onCellValueChanged(e) {
      (0, _events.gw_onCellEditingEvent)(id, e);
    },
    onRowEditingStarted: function onRowEditingStarted(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onRowValueChanged: function onRowValueChanged(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onRowEditingStopped: function onRowEditingStopped(e) {
      (0, _events.gw_onRowEditingEvent)(id, e);
    },
    onGridReady: function onGridReady(e) {
      (0, _events.gw_onReadyEvent)(id, e);
    },
    onFilterChanged: function onFilterChanged(e) {
      (0, _events.gw_onFilterChanged)(id, e);
    },
    getRowNodeId: function getRowNodeId(data) {
      return (0, _rows.gw_getRowNodeId)(id, data);
    },
    getContextMenuItems: function getContextMenuItems(params) {
      return (0, _menus.gw_getContextMenu)(id, params);
    },
    getChartToolbarItems: _charts.gw_getChartToolbarItems,
    popupParent: (0, _utilities.gw_getDocument)().body,
    onRowDoubleClicked: (0, _events.gw_debounce)(_events.gw_onRowDoubleClicked, debounceDuration),
    onRowClicked: (0, _events.gw_debounce)(_events.gw_onRowClicked, debounceDuration),
    onCellClicked: (0, _events.gw_debounce)(_events.gw_onCellClickEvent, debounceDuration),
    onCellDoubleClicked: (0, _events.gw_debounce)(_events.gw_onCellClickEvent, debounceDuration),
    onSelectionChanged: (0, _events.gw_debounce)(_events.gw_onSelectionChanged, debounceDuration),
    onRangeSelectionChanged: (0, _events.gw_debounce)(_events.gw_onRangeSelectionChanged, debounceDuration),
    components: {
      BooleanFilter: Basis.AgGridComponents.BooleanFilter,
      BooleanRenderer: Basis.AgGridComponents.BooleanRenderer,
      BooleanEditor: Basis.AgGridComponents.BooleanEditor,
      NumberEditor: Basis.AgGridComponents.NumberEditor,
      TextEditor: Basis.AgGridComponents.TextEditor,
      DateTimeEditor: Basis.AgGridComponents.DateTimeEditor,
      DateTimeFilter: Basis.AgGridComponents.DateTimeFilter,
      ImageRenderer: Basis.AgGridComponents.ImageRenderer,
      TemplateRenderer: Basis.AgGridComponents.TemplateRenderer,
      HTMLTooltip: _HTMLTooltip.default,
      SuggestionEditor: _SuggestionEditor.default
    },
    context: _objectSpread(_objectSpread({}, deepParsedOptions.context), {
      document: (0, _utilities.gw_getDocument)(),
      window: (0, _utilities.gw_getWindow)()
    }),
    alignedGrids: []
  });

  if ( // eslint-disable-next-line no-prototype-builtins
  finalOptions.context.hasOwnProperty('navigateToNextCell') && finalOptions.context.navigateToNextCell) {
    finalOptions.navigateToNextCell = function (params) {
      return (0, _rows.gw_navigateToNextRow)(id, params);
    };
  }

  if (getDataPathTemplate && finalOptions.treeData) {
    var getDataPathTemplateComplied = (0, _template.default)(getDataPathTemplate);

    finalOptions.getDataPath = function (data) {
      return getDataPathTemplateComplied({
        data: data
      });
    };
  } // extend the column definitions


  (0, _columns.gw_extendColumnDefinitions)(finalOptions.columnDefs);
  return finalOptions;
}

/***/ }),

/***/ "./src/api/jss.js":
/*!************************!*\
  !*** ./src/api/jss.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setStyle = gw_setStyle;
exports.gw_removeStyle = gw_removeStyle;

__webpack_require__(/*! expose-loader?jss!jss/jss.js */ "./node_modules/expose-loader/index.js?jss!./node_modules/jss/jss.js-exposed");

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Add new style
 *
 * Add new style to the document
 *
 * @param {String} selector css selector
 * @param {String} rules Json string for an array of rules
 */
function gw_setStyle(selector, rules) {
  jss.forDocument((0, _utilities.gw_getDocument)()).set(selector, JSON.parse(rules));
}
/**
 * Remove style
 *
 * Remove added style from thes document
 *
 * @param {String} selector css selector
 */


function gw_removeStyle(selector) {
  jss.forDocument((0, _utilities.gw_getDocument)()).remove(selector);
}

/***/ }),

/***/ "./src/api/menus.js":
/*!**************************!*\
  !*** ./src/api/menus.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getContextMenu = gw_getContextMenu;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

var _utilities2 = __webpack_require__(/*! events/utilities */ "./src/events/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_getContextMenu(gridId, params) {
  var buildContextMenuAction = function buildContextMenuAction(params, id) {
    return function () {
      var node = (0, _utilities2.gw_parseNodeFromEvent)(params);
      var colId = params.column.colId;
      var value = params.value;
      (0, _utilities2.gw_sendEvent)((0, _utilities.gw_getGrid)(gridId).options.context, {
        type: 'gw.contextmenu',
        detail: JSON.stringify({
          r: node,
          c: colId,
          v: value,
          i: id
        })
      }, id);
    };
  };

  var parseMenu = function parseMenu(menu) {
    menu.forEach(function (item) {
      if (typeof item === 'string') {
        return;
      }

      item['action'] = buildContextMenuAction(params, item.id);

      if (item['cssClasses'] && !Array.isArray(item['cssClasses'])) {
        item['cssClasses'] = item['cssClasses'].split(' ');
      }

      if (item['subMenu']) {
        item['subMenu'] = parseMenu(item['subMenu']);
      }
    });
    return menu;
  };

  return parseMenu((0, _utilities.gw_getGrid)(gridId).options.context.contextMenu);
}

/***/ }),

/***/ "./src/api/overlays.js":
/*!*****************************!*\
  !*** ./src/api/overlays.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_showLoadingOverlay = gw_showLoadingOverlay;
exports.gw_showNoRowsOverlay = gw_showNoRowsOverlay;
exports.gw_hideOverlay = gw_hideOverlay;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Show loading overlay
 *
 * @param {String} id the grid id
 */
function gw_showLoadingOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.showLoadingOverlay();
}
/**
 * Show 'no rows' overlay
 *
 * @param {String} id the grid id
 */


function gw_showNoRowsOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.showNoRowsOverlay();
}
/**
 * Clear all overlays
 *
 * @param {String} id the grid id
 */


function gw_hideOverlay(id) {
  (0, _utilities.gw_getGrid)(id).options.api.hideOverlay();
}

/***/ }),

/***/ "./src/api/rows.js":
/*!*************************!*\
  !*** ./src/api/rows.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setQuickFilter = gw_setQuickFilter;
exports.gw_expandAll = gw_expandAll;
exports.gw_collapseAll = gw_collapseAll;
exports.gw_ensureIndexVisible = gw_ensureIndexVisible;
exports.gw_navigateToNextRow = gw_navigateToNextRow;
exports.gw_getRowNodeId = gw_getRowNodeId;
exports.gw_setRowData = gw_setRowData;
exports.gw_updateRowData = gw_updateRowData;
exports.gw_setRowsHeight = gw_setRowsHeight;
exports.gw_setRowHeight = gw_setRowHeight;
exports.gw_resetRowHeights = gw_resetRowHeights;
exports.gw_setSelectedRows = gw_setSelectedRows;
exports.gw_selectAll = gw_selectAll;
exports.gw_deselectAll = gw_deselectAll;
exports.gw_getSelectedRows = gw_getSelectedRows;
exports.gw_getSelectedRow = gw_getSelectedRow;
exports.gw_getRow = gw_getRow;
exports.gw_getRows = gw_getRows;
exports.gw_redrawRows = gw_redrawRows;
exports.gw_setPinnedTopRowData = gw_setPinnedTopRowData;
exports.gw_setPinnedBottomRowData = gw_setPinnedBottomRowData;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

var _utilities2 = __webpack_require__(/*! events/utilities */ "./src/events/utilities.js");

var _expression = __webpack_require__(/*! ../expression */ "./src/expression.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setQuickFilter(id, filter) {
  (0, _utilities.gw_getGrid)(id).options.api.setQuickFilter(filter);
}

function gw_expandAll(id) {
  (0, _utilities.gw_getGrid)(id).options.api.expandAll();
}

function gw_collapseAll(id) {
  (0, _utilities.gw_getGrid)(id).options.api.collapseAll();
}
/**
 * Ensures the row index is visible by vertically scrolling the grid
 *
 * @param {String} id  the grid's id
 * @param {String|Number} index the row index or key
 * @param {String} position {'top', 'middle', 'bottom', undefined/null}
 */


function gw_ensureIndexVisible(id, index, position) {
  var api = (0, _utilities.gw_getGrid)(id).options.api;
  var node = api.getRowNode(index);

  if (node) {
    api.ensureNodeVisible(node, position);
  } else {
    api.ensureIndexVisible(Number(index), position);
  }
}

function gw_navigateToNextRow(id, params) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var previousCell = params.previousCellPosition;
  var suggestedNextCell = params.nextCellPosition;
  var KEY_UP = 38;
  var KEY_DOWN = 40;
  var KEY_LEFT = 37;
  var KEY_RIGHT = 39;

  switch (params.key) {
    case KEY_DOWN:
      // set selected cell on current cell + 1
      if (suggestedNextCell && !suggestedNextCell.rowPinned) {
        if (previousCell.rowPinned) {
          var row = options.api.getDisplayedRowAtIndex(options.api.getFirstDisplayedRow());

          if (row) {
            row.setSelected(true);
          }
        } else {
          options.api.forEachNode(function (node) {
            if (previousCell.rowIndex + 1 === node.rowIndex) {
              node.setSelected(true);
            }
          });
        }
      }

      return suggestedNextCell;

    case KEY_UP:
      // set selected cell on current cell - 1
      if (suggestedNextCell && !suggestedNextCell.rowPinned) {
        if (previousCell.rowPinned) {
          var _row = options.api.getDisplayedRowAtIndex(options.api.getLastDisplayedRow());

          if (_row) {
            _row.setSelected(true);
          }
        } else {
          options.api.forEachNode(function (node) {
            if (previousCell.rowIndex - 1 === node.rowIndex) {
              node.setSelected(true);
            }
          });
        }
      }

      return suggestedNextCell;

    case KEY_LEFT:
    case KEY_RIGHT:
      return suggestedNextCell;

    default:
      throw new Error('You have super strange keyboard');
  }
}
/**
 * Returns a row based on `getRowNodeId` config defined in the grid context
 *
 * @param {String} id the grid's id
 * @param {Object} data  the data row
 */


function gw_getRowNodeId(id, data) {
  return data[(0, _utilities.gw_getGrid)(id).options.context.getRowNodeId];
}
/**
 * Update the grid's data set
 *
 * @param {String} id the grid's id
 * @param {Object} json json object which contains the new dataset to update the grid
 */


function gw_setRowData(id, json) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  options.api.setRowData(json);
  options.rowData = json;
}
/**
 * Update the grid with a transaction object
 *
 * @param {String} id  the grid id
 * @param {Object} transaction
 */


function gw_updateRowData(id, transaction, batchUpdate) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (transaction.remove.length) {
    var items = [];
    transaction.remove.forEach(function (index) {
      items.push(options.api.getRowNode(index).data);
    });
    transaction.remove = items;
  }

  if (!batchUpdate) {
    options.api.applyTransaction(transaction);
  } else {
    options.api.applyTransactionAsync(transaction);
  }
}
/**
 * Set the height of all rows
 *
 * @param {String} id the grid id
 * @param {Number} height the row height
 */


function gw_setRowsHeight(id, height) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  api.forEachNode(function (row) {
    row.setRowHeight(height);
  });
  api.onRowHeightChanged();
}
/**
 * Set the given row height
 *
 * @param {String} id the grid id
 * @param {Number|String} index the row index or key
 * @param {Number} height the new height
 */


function gw_setRowHeight(id, index, height) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  var row = api.getRowNode(index) || api.getDisplayedRowAtIndex(index);

  if (row) {
    row.setRowHeight(height);
    options.api.onRowHeightChanged();
  } else {
    console.warn("Failed to set height for row ".concat(index, ". Row cannot be found"));
  }
}
/**
 * Reset the row height
 *
 * @param {String} id  the grid id
 */


function gw_resetRowHeights(id) {
  (0, _utilities.gw_getGrid)(id).options.api.resetRowHeights();
}
/**
 * Select row or more based on the row id or index
 *
 * @param {String} id the grid's id
 * @param {Array} rows an array of row keys and indexes to select
 */


function gw_setSelectedRows(id, rows) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var api = options.api;
  api.forEachNodeAfterFilterAndSort(function (node) {
    if (rows.indexOf(String(node.rowIndex)) > -1 || rows.indexOf(String(node.id)) > -1) {
      node.setSelected(true);
      node.expanded = true;
    }
  });
  api.onGroupExpandedOrCollapsed();
}

function gw_selectAll(id, filtered) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (1 === filtered) {
    options.api.selectAllFiltered();
  } else {
    options.api.selectAll();
  }
}

function gw_deselectAll(id, filtered) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  if (1 === filtered) {
    options.api.deselectAllFiltered();
  } else {
    options.api.deselectAll();
  }
}
/**
 * Get the current selected rows
 *
 * @param {Number} id grid's id
 *
 * @returns {String}  selected rows as JSON
 */


function gw_getSelectedRows(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var nodes = options.api.getSelectedNodes();
  var parsed = [];
  nodes.forEach(function (node) {
    parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
  });
  return JSON.stringify(parsed);
}
/**
 * Get the last selected row
 *
 * @param {Number} id grid's id
 *
 * @returns {String} selected row as JSON
 */


function gw_getSelectedRow(id) {
  var rows = JSON.parse(gw_getSelectedRows(id));

  if (rows.length) {
    return JSON.stringify(rows[rows.length - 1]);
  }

  return '';
}
/**
 * Get the row by its id or index
 *
 * @param {String} id grid's id
 * @param {String|Number} index
 *
 * @return {String} row as JSON
 */


function gw_getRow(id, index) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  return JSON.stringify((0, _utilities2.gw_parseNode)(options.api.getRowNode(index), options.context));
}
/**
 * Get rows from the grid
 *
 * @param {String} id The grid's id
 * @param {String} phase The rows phase
 * @param {String} filterExpression A filter expression
 *
 * @return {String} Json stringified array of rows
 */


function gw_getRows(id, phase, filterExpression) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var parsed = [];
  options.api[phase](function (node) {
    if (!node.group) {
      if (filterExpression) {
        var canProcess = (0, _expression.gw_executeExpression)(filterExpression, {
          value: node.data,
          context: options.context,
          oldValue: null,
          newValue: null,
          node: node,
          data: node.data,
          colDef: null,
          rowIndex: node.rowIndex,
          api: node.gridApi,
          columnApi: node.columnApi,
          getValue: function getValue() {
            return node.data;
          },
          column: null,
          columnGroup: // eslint-disable-next-line no-prototype-builtins
          node.hasOwnProperty('parent') && node.parent.hasOwnProperty('key') ? node.parent.key : ''
        });

        if (canProcess) {
          parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
        }
      } else {
        parsed.push((0, _utilities2.gw_parseNode)(node, options.context));
      }
    }
  });
  return JSON.stringify(parsed);
}
/**
 * Gets the grid to remove a row from the DOM and recreate it again from scratch.
 *
 * @param {String} id grid's id
 */


function gw_redrawRows(id) {
  (0, _utilities.gw_getGrid)(id).options.api.redrawRows();
}
/**
 * Pin an array of tow to the top of the grid
 *
 * @param {String} id the grid's id
 * @param {Array} data array of rows
 */


function gw_setPinnedTopRowData(id, data) {
  (0, _utilities.gw_getGrid)(id).options.api.setPinnedTopRowData(data);
}
/**
 * Pin an array of tow to the bottom of the grid
 *
 * @param {String} id the grid's id
 * @param {Array} data array of rows
 */


function gw_setPinnedBottomRowData(id, data) {
  (0, _utilities.gw_getGrid)(id).options.api.setPinnedBottomRowData(data);
}

/***/ }),

/***/ "./src/api/state.js":
/*!**************************!*\
  !*** ./src/api/state.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setState = gw_setState;
exports.gw_getState = gw_getState;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setState(id, state) {
  var options = (0, _utilities.gw_getGrid)(id).options;

  try {
    options.columnApi.setColumnState(state.columns);
    options.columnApi.setColumnGroupState(state.groups);
    options.api.setSortModel(state.sort);
    options.api.setFilterModel(state.filters);
  } catch (e) {
    console.warn('Failed to parse grid state from JSON', e);
  }
}

function gw_getState(id) {
  var options = (0, _utilities.gw_getGrid)(id).options;
  var columns = options.columnApi.getColumnState();
  var groups = options.columnApi.getColumnGroupState();
  var sort = options.api.getSortModel();
  var filters = options.api.getFilterModel();

  try {
    return JSON.stringify({
      columns: columns,
      groups: groups,
      sort: sort,
      filters: filters
    });
  } catch (e) {
    console.warn('Failed to convert the grid state to json', e);
  }
}

/***/ }),

/***/ "./src/api/statusbar.js":
/*!******************************!*\
  !*** ./src/api/statusbar.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setStatusbarComponentVisibility = gw_setStatusbarComponentVisibility;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setStatusbarComponentVisibility(id, key, visibility) {
  (0, _utilities.gw_getGrid)(id).options.api.getStatusPanel(key).setVisible(Boolean(visibility));
}

/***/ }),

/***/ "./src/api/toolpanel.js":
/*!******************************!*\
  !*** ./src/api/toolpanel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_setSideBarVisible = gw_setSideBarVisible;
exports.gw_openToolpanel = gw_openToolpanel;
exports.gw_closeToolpanel = gw_closeToolpanel;
exports.gw_setFunctionsReadOnly = gw_setFunctionsReadOnly;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
function gw_setSideBarVisible(id, value) {
  (0, _utilities.gw_getGrid)(id).options.api.setSideBarVisible(Boolean(value));
}

function gw_openToolpanel(gridId, toolpanelId) {
  (0, _utilities.gw_getGrid)(gridId).options.api.openToolPanel(toolpanelId);
}

function gw_closeToolpanel(gridId, toolpanelId) {
  (0, _utilities.gw_getGrid)(gridId).options.api.closeToolPanel(toolpanelId);
}

function gw_setFunctionsReadOnly(id, readonly) {
  (0, _utilities.gw_getGrid)(id).options.api.setFunctionsReadOnly(Boolean(readonly));
}

/***/ }),

/***/ "./src/api/utilities.js":
/*!******************************!*\
  !*** ./src/api/utilities.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_getDocument = gw_getDocument;
exports.gw_getWindow = gw_getWindow;
exports.gw_escape = gw_escape;
exports.gw_uuid = gw_uuid;
exports.gw_getGrid = gw_getGrid;
exports.gw_addGrid = gw_addGrid;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@Basis.AgGridComponents.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Get document
 *
 * Get the document instance according to the current BBj env
 *
 * @return {Object} Document instance
 */
function gw_getDocument() {
  return typeof $doc !== 'undefined' ? $doc : document;
}
/**
 * Get window
 *
 * Get the window instance according to the current BBj env
 *
 * @return {Object} Window instance
 */


function gw_getWindow() {
  return typeof $wnd !== 'undefined' ? $wnd : window;
}
/**
 * Escape Value
 *
 * Change null and undefined to empty string
 *
 * @param {*} value
 *
 * @return {String} escaped value
 */


function gw_escape(value) {
  return value !== null && value !== undefined ? value : '';
}
/**
 * Generate a unique uuid
 * @see https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 */


function gw_uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
/**
 * Get Grid
 *
 * Retrieve the grid instance from `window.BBjGridExWidget` array
 *
 * @param {String} id The grid's id
 *
 * @return {Object|null} The grid's instance ofr null
 * @throws TypeError when the grid instance is not found
 */


function gw_getGrid(id) {
  window.BBjGridExWidget = window.BBjGridExWidget || {};
  var grid = window.BBjGridExWidget[id] || null;

  if (!grid) {
    var registeredGrids = JSON.stringify(Object.keys(window.BBjGridExWidget)); //getFuncArgs(func).forEach((key, i) => argsObj[key] = args[i]);

    throw new TypeError("\n\n[Grid Not Found] The method asked for non-existent grid instance.\n-------------------------------------------------------------------\nRequired Grid Id : ".concat(id, "   \nRegistered Grids : ").concat(registeredGrids, "\n"));
  }

  return grid;
}
/**
 * Add Grid
 *
 * Store a new grid instance by in the `window.BBjGridExWidget` array
 *
 * @param {String} id The grid's id
 * @param {Object} options  The grid's options
 *
 * @return {Object} Stored grid
 */


function gw_addGrid(id, options) {
  window.BBjGridExWidget = window.BBjGridExWidget || {};
  window.BBjGridExWidget[id] = options;
  return gw_getGrid(id);
}

/***/ }),

/***/ "./src/components/HTMLTooltip.js":
/*!***************************************!*\
  !*** ./src/components/HTMLTooltip.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An improved tooltip component which supports HTML and behaves the same in both GUI and BUI
 *
 * @author Hyyan Abo Fakher
 */
var HTMLTooltip = /*#__PURE__*/function () {
  function HTMLTooltip() {
    _classCallCheck(this, HTMLTooltip);
  }

  _createClass(HTMLTooltip, [{
    key: "init",

    /**
     * Construct the component
     *
     * @param {Object} params the tooltip component params
     */
    value: function init(params) {
      var eGui = this.eGui = document.createElement('div');
      var tooltipValueGetter = params.colDef.tooltipValueGetter;
      var isHeader = params.rowIndex === undefined;
      var isGroupedHeader = isHeader && !!params.colDef.children; // eslint-disable-next-line no-prototype-builtins

      var data = !isHeader && !isGroupedHeader ? params.api.getDisplayedRowAtIndex(params.rowIndex).data : null;
      var theme = params.api.gridCore.eGridDiv.className.endsWith('dark') ? 'gw-tooltip-dark' : 'gw-tooltip-light';
      var tooltipField = params.colDef.tooltipField ? // eslint-disable-next-line no-prototype-builtins
      data && data.hasOwnProperty(params.colDef.tooltipField) ? data[params.colDef.tooltipField] : null : null;

      var passedParams = _objectSpread(_objectSpread(_objectSpread({}, params), {
        data: data
      }), {
        isHeader: isHeader,
        isGroupedHeader: isGroupedHeader,
        tooltipField: tooltipField
      });

      eGui.classList.add('gw-tooltip', theme);
      eGui.innerHTML = isHeader || isGroupedHeader ? params.value : tooltipField ? tooltipField : tooltipValueGetter ? tooltipValueGetter(passedParams) : params.value;
    }
    /**
     * Get the gui Instance
     *
     * @return {HTMLElement}
     */

  }, {
    key: "getGui",
    value: function getGui() {
      return this.eGui;
    }
  }]);

  return HTMLTooltip;
}();

var _default = HTMLTooltip;
exports.default = _default;

/***/ }),

/***/ "./src/components/SuggestionEditor.js":
/*!********************************************!*\
  !*** ./src/components/SuggestionEditor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _autocompleter = _interopRequireDefault(__webpack_require__(/*! autocompleter */ "./node_modules/autocompleter/autocomplete.js"));

var _template = _interopRequireDefault(__webpack_require__(/*! lodash-es/template */ "./node_modules/lodash-es/template.js"));

var _utilities = __webpack_require__(/*! events/utilities */ "./src/events/utilities.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * An autocomplete cell editor written specifically to BBjGridExWidget
 *
 * @author Hyyan Abo Fakher
 */
var SuggestionEditor = /*#__PURE__*/function () {
  function SuggestionEditor() {
    _classCallCheck(this, SuggestionEditor);
  }

  _createClass(SuggestionEditor, [{
    key: "init",

    /**
     * Initialize the component
     *
     * @param {Object} params
     *
     * @return void
     */
    value: function init(params) {
      var pattern = params.textPattern || null;
      var required = params.textRequired || false;
      var title = params.textTitle || null;
      var debounceWaitMs = params.debounceWaitMs || 250;
      var startValue;
      this._focusAfterAttached = params.cellStartedEdit;

      if (this._focusAfterAttached) {
        var keyPressBackspaceOrDelete = params.keyPress == 32 || params.keyPress == 46; // space // delete

        if (keyPressBackspaceOrDelete) {
          startValue = '';
        } else if (params.charPress) {
          startValue = params.charPress;
        } else {
          startValue = params.value;

          if (params.keyPress != 113) {
            //F2
            this._highlightAllOnFocus = true;
          }
        }
      } else {
        startValue = params.value;
      }

      this._params = params;
      this._gui = document.createElement('div');
      this._gui.className = 'autocompleteInputWrapper ag-cell-edit-wrapper';
      this._gui.tabIndex = '0';
      this._gui.innerHTML =
      /* html */
      "\n    <div class=\"ag-cell-editor ag-labeled ag-label-align-left ag-text-field ag-input-field\">\n      <div class=\"ag-wrapper ag-input-wrapper ag-text-field-input-wrapper\">\n      </div>\n    </div>\n    "; // input

      this._input = document.createElement('input');
      this._input.className = 'autocompleteInputWrapper__input ag-cell-edit-input ag-input-field-input ag-text-field-input';
      this._input.type = 'text';
      this._input.value = startValue;
      this._input.tabIndex = 0;

      this._gui.querySelector('.ag-input-wrapper').appendChild(this._input);

      if (pattern !== null) {
        this._input.setAttribute('pattern', pattern);
      }

      if (required === true) {
        this._input.setAttribute('required', 'required');
      }

      if (title !== null && title !== 'default') {
        this._input.title = title;
      }

      this._onChange = this._onChange.bind(this);

      this._input.addEventListener('input', this._onChange);

      this._input.addEventListener('change', this._onChange); // setup the autocomplete component


      this._renderItemTemplate = this._params.itemTemplate ? (0, _template.default)(this._params.itemTemplate) : '';
      this._renderGroupTemplate = this._params.groupTemplate ? (0, _template.default)(this._params.groupTemplate) : '';
      this._autocomplete = (0, _autocompleter.default)({
        input: this._input,
        debounceWaitMs: debounceWaitMs,
        // without this option enabled , the list wont be closed in GUI
        preventSubmit: true,
        fetch: this._onAutocompleteFetch.bind(this),
        onSelect: this._onAutocompleteSelect.bind(this),
        renderGroup: this._onAutocompleteRenderGroup.bind(this),
        render: this._onAutocompleteRenderItem.bind(this),
        customize: this._onAutocompleteCustomize.bind(this),
        emptyMsg: this._params.emptyMessage || null,
        minLength: this._params.minLength || 2,
        showOnFocus: this._params.showOnFocus || false,
        className: params.api.gridCore.eGridDiv.className.endsWith('dark') ? 'dark' : 'light'
      });
    }
    /**
     * Return the DOM element of the component, this is what the grid puts into the cell
     *
     * @return {HTMLElement}
     */

  }, {
    key: "getGui",
    value: function getGui() {
      return this._gui;
    }
    /**
     * Gets called once after GUI is attached to DOM.
     *
     * Make sure container is always focused to listen to key changes
     */

  }, {
    key: "afterGuiAttached",
    value: function afterGuiAttached() {
      if (this._highlightAllOnFocus) {
        this._input.select();
      } else {
        if (this._focusAfterAttached) {
          this.focusIn();
        }
      }
    }
    /**
     * Get The component value
     *
     * @return {Number}
     */

  }, {
    key: "getValue",
    value: function getValue() {
      return this._input.value;
    }
    /**
     * If doing full row edit, then gets called when tabbing into the cell.
     */

  }, {
    key: "focusIn",
    value: function focusIn() {
      this._input.focus();
    }
    /**
     * Gets called once when editing is finished (eg if enter is pressed).
     *
     * @returns {Boolean} true when the result of the edit will be ignored. false otherwise
     */

  }, {
    key: "isCancelAfterEnd",
    value: function isCancelAfterEnd() {
      var _this = this;

      var allowCustomValues = this._params.allowCustomValues || false;

      var isValid = this._validateInput(this._input);

      if (isValid && allowCustomValues === false && this._lastFetchedData) {
        var filteredItems = this._lastFetchedData.filter(function (x) {
          return x.value === _this._input.value;
        });

        isValid = filteredItems.length === 1;
      }

      return !isValid;
    }
    /**
     * Gets called when the component is destroyed.
     *
     * Clear the registered event listeners and destroy the autocomplete
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._input.removeEventListener('input', this._onChange);

      this._input.removeEventListener('change', this._onChange);

      this._autocomplete.destroy();
    }
    /**
     * This method will be called to prepare suggestions and then pass them to autocomplete.
     *
     * @param {String} text the text in the input field
     * @param {Function} update a callback function that must be called after suggestions are prepared
     *
     * @returns {Boolean} false when the request is ignored , false otherwise
     */

  }, {
    key: "_onAutocompleteFetch",
    value: function _onAutocompleteFetch(text, update) {
      var _this2 = this;

      var suppressSuggestionOnInvalidInput = this._params.suppressSuggestionOnInvalidInput || false;

      var isValid = this._validateInput(this._input);

      if (suppressSuggestionOnInvalidInput && !isValid) {
        return false;
      }

      var id = this._params.eventId;
      document.addEventListener(id, function (event) {
        _this2._lastFetchedData = event.detail;
        update(event.detail);
      });
      window.basisDispatchCustomEvent(this._params.eGridCell, {
        type: 'gw.suggestion',
        detail: JSON.stringify({
          id: id,
          text: text,
          column: this._params.colDef.field,
          row: (0, _utilities.gw_parseNode)(this._params.node, this._params.api.gridOptionsWrapper.gridOptions.context)
        })
      });
      return true;
    }
    /**
     * This method will be called when user choose an item in autocomplete.
     *
     * @param {Object} item The selected item
     */

  }, {
    key: "_onAutocompleteSelect",
    value: function _onAutocompleteSelect(item) {
      this._input.value = item.value;
    }
    /**
     * This overrides the rendering function of autocomplete items.
     *
     * It will be called for each suggestion
     *
     * @param {Object} item suggestion object
     * @param {String} currentValue The current input field value
     *
     * @returns {HTMLElement}
     */

  }, {
    key: "_onAutocompleteRenderItem",
    value: function _onAutocompleteRenderItem(item, currentValue) {
      var div = document.createElement('div');
      div.className = 'suggestion-item';

      if (this._renderItemTemplate) {
        div.innerHTML = this._renderItemTemplate({
          item: item,
          currentValue: currentValue
        });
      } else {
        div.innerHTML = item.label;
      }

      return div;
    }
    /**
     * This overrides the rendering function of autocomplete groups.
     *
     * It will be called for each group
     *
     * @param {String} groupName The group name
     * @param {String} currentValue The current input field value
     *
     * @returns {HTMLElement}
     */

  }, {
    key: "_onAutocompleteRenderGroup",
    value: function _onAutocompleteRenderGroup(groupName, currentValue) {
      var div = document.createElement('div');
      div.className = 'suggestion-group';

      if (this._renderGroupTemplate) {
        div.innerHTML = this._renderGroupTemplate({
          groupName: groupName,
          currentValue: currentValue
        });
      } else {
        div.innerHTML = groupName;
      }

      return div;
    }
    /**
     * Hook on the autocomplete container render and change the width and the
     * height according to the options
     *
     * @param {HTMLElement} input
     * @param {HTMLElement} inputRect
     * @param {HTMLElement} container
     * @param {String} maxHeight
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: "_onAutocompleteCustomize",
    value: function _onAutocompleteCustomize(input, inputRect, container, maxHeight) {
      if (this._params.width) {
        container.style.width = "".concat(this._params.width, "px");
      }

      if (this._params.height) {
        container.style.height = "".concat(this._params.height, "px");
      }
    }
    /**
     * List to the input changes and validate it
     *
     * @param {Event} The event object
     *
     * @returns {Boolean} true when valid , false otherwise
     */

  }, {
    key: "_onChange",
    value: function _onChange(event) {
      return this._validateInput(event.target);
    }
    /**
     * Do validate the given input element
     *
     * @param {HTMLInputElement} input input element
     *
     * @return {Boolean} true when valid , false otherwise
     */

  }, {
    key: "_validateInput",
    value: function _validateInput(input) {
      var isValid = input.checkValidity();

      if (!isValid) {
        input.classList.add('autocomplete-input-error');
        input.classList.remove('autocomplete-input-success');
      } else {
        input.classList.remove('autocomplete-input-error');
        input.classList.add('autocomplete-input-success');
      }

      return isValid;
    }
  }]);

  return SuggestionEditor;
}();

var _default = SuggestionEditor;
exports.default = _default;

/***/ }),

/***/ "./src/events/constants.js":
/*!*********************************!*\
  !*** ./src/events/constants.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GW_EVENT_READY = exports.GW_EVENT_FILTER_CHANGED = exports.GW_EVENT_KEYPRESS = exports.GW_EVENT_RANGE_SELECTION_CHANGED = exports.GW_EVENT_GRID_STATE_CHANGE = exports.GW_EVENT_ROW_VALUE_CHANGED = exports.GW_EVENT_ROW_EDITING_STOPPED = exports.GW_EVENT_ROW_EDITING_STARTED = exports.GW_EVENT_CELL_VALUE_CHANGED = exports.GW_EVENT_CELL_EDITING_STOPPED = exports.GW_EVENT_CELL_EDITING_STARTED = exports.GW_EVENT_CELL_DOUBLE_CLICK = exports.GW_EVENT_CELL_CLICK = exports.GW_EVENT_ROW_DOUBLE_CLICK = exports.GW_EVENT_ROW_CLICK = exports.GW_EVENT_ROW_SELECT = void 0;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
// selection constants
var GW_EVENT_ROW_SELECT = 69;
exports.GW_EVENT_ROW_SELECT = GW_EVENT_ROW_SELECT;
var GW_EVENT_ROW_CLICK = 5011;
exports.GW_EVENT_ROW_CLICK = GW_EVENT_ROW_CLICK;
var GW_EVENT_ROW_DOUBLE_CLICK = 52;
exports.GW_EVENT_ROW_DOUBLE_CLICK = GW_EVENT_ROW_DOUBLE_CLICK;
var GW_EVENT_CELL_CLICK = 5001;
exports.GW_EVENT_CELL_CLICK = GW_EVENT_CELL_CLICK;
var GW_EVENT_CELL_DOUBLE_CLICK = 5002; // editing constants

exports.GW_EVENT_CELL_DOUBLE_CLICK = GW_EVENT_CELL_DOUBLE_CLICK;
var GW_EVENT_CELL_EDITING_STARTED = 5003;
exports.GW_EVENT_CELL_EDITING_STARTED = GW_EVENT_CELL_EDITING_STARTED;
var GW_EVENT_CELL_EDITING_STOPPED = 5004;
exports.GW_EVENT_CELL_EDITING_STOPPED = GW_EVENT_CELL_EDITING_STOPPED;
var GW_EVENT_CELL_VALUE_CHANGED = 5005;
exports.GW_EVENT_CELL_VALUE_CHANGED = GW_EVENT_CELL_VALUE_CHANGED;
var GW_EVENT_ROW_EDITING_STARTED = 5006;
exports.GW_EVENT_ROW_EDITING_STARTED = GW_EVENT_ROW_EDITING_STARTED;
var GW_EVENT_ROW_EDITING_STOPPED = 5007;
exports.GW_EVENT_ROW_EDITING_STOPPED = GW_EVENT_ROW_EDITING_STOPPED;
var GW_EVENT_ROW_VALUE_CHANGED = 5012; // state constants

exports.GW_EVENT_ROW_VALUE_CHANGED = GW_EVENT_ROW_VALUE_CHANGED;
var GW_EVENT_GRID_STATE_CHANGE = 5008; // range selection

exports.GW_EVENT_GRID_STATE_CHANGE = GW_EVENT_GRID_STATE_CHANGE;
var GW_EVENT_RANGE_SELECTION_CHANGED = 5009; // keyboard events

exports.GW_EVENT_RANGE_SELECTION_CHANGED = GW_EVENT_RANGE_SELECTION_CHANGED;
var GW_EVENT_KEYPRESS = 5010; // filters

exports.GW_EVENT_KEYPRESS = GW_EVENT_KEYPRESS;
var GW_EVENT_FILTER_CHANGED = 5013; // ready

exports.GW_EVENT_FILTER_CHANGED = GW_EVENT_FILTER_CHANGED;
var GW_EVENT_READY = 5014;
exports.GW_EVENT_READY = GW_EVENT_READY;

/***/ }),

/***/ "./src/events/editing.js":
/*!*******************************!*\
  !*** ./src/events/editing.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onCellEditingEvent = gw_onCellEditingEvent;
exports.gw_onRowEditingEvent = gw_onRowEditingEvent;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _utilities2 = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CELL_EDITING_EVENTS_MAP = {
  cellEditingStarted: _constants.GW_EVENT_CELL_EDITING_STARTED,
  cellEditingStopped: _constants.GW_EVENT_CELL_EDITING_STOPPED,
  cellValueChanged: _constants.GW_EVENT_CELL_VALUE_CHANGED
};
var ROW_EDITING_EVENTS_MAP = {
  rowEditingStarted: _constants.GW_EVENT_ROW_EDITING_STARTED,
  rowEditingStopped: _constants.GW_EVENT_ROW_EDITING_STOPPED,
  rowValueChanged: _constants.GW_EVENT_ROW_VALUE_CHANGED
};
/**
 * An handler for the grid `cellEditingStarted` , `cellEditingStopped` and
 * `cellValueChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.cellEditingStarted
 * @listens agGrid.cellEditingStopped
 * @listens agGrid.cellValueChanged
 *
 * @fires gw.cellEditingStarted
 * @fires gw.cellEditingStopped
 * @fires gw.cellValueChanged
 */

function gw_onCellEditingEvent(id, e) {
  var value = e.hasOwnProperty('newValue') ? (0, _utilities2.gw_escape)(e.newValue) : (0, _utilities2.gw_escape)(e.value);
  var oldValue = e.hasOwnProperty('oldValue') ? (0, _utilities2.gw_escape)(e.oldValue) : e.hasOwnProperty('newValue') ? (0, _utilities2.gw_escape)(e.newValue) : (0, _utilities2.gw_escape)(e.value);

  if (value == oldValue && e.type === 'cellValueChanged') {
    return;
  }

  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);
  var type = e.type;
  var colId = e.column.colId;

  if (parsed) {
    (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
      type: "gw.".concat(type),
      detail: JSON.stringify({
        r: _objectSpread(_objectSpread({}, parsed), {
          cr: e.data
        }),
        // row (we always include the client row data)
        v: value,
        // new value
        o: oldValue,
        // old value
        c: colId // column

      })
    }, CELL_EDITING_EVENTS_MAP[type]);
  }
}
/**
 * An handler for the grid `rowEditingStarted` , `rowEditingStopped` and `rowValueChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.rowEditingStarted
 * @listens agGrid.rowEditingStopped
 * @listens agGrid.rowValueChanged
 *
 * @fires gw.rowEditingStarted
 * @fires gw.rowEditingStopped
 * @fires gw.rowValueChanged
 */


function gw_onRowEditingEvent(id, e) {
  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);

  if (parsed) {
    var type = e.type;
    (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
      type: "gw.".concat(e.type),
      detail: JSON.stringify(_objectSpread(_objectSpread({}, parsed), {
        cr: e.data
      })) // row (we always include the client row data)

    }, ROW_EDITING_EVENTS_MAP[type]);
  }
}

/***/ }),

/***/ "./src/events/filters.js":
/*!*******************************!*\
  !*** ./src/events/filters.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onFilterChanged = gw_onFilterChanged;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An handler for the grid `filterChanged` event
 *
 * @param {String} the grid's id
 * @param {Object} e The event's payload
 *
 * @listens agGrid.filterChanged
 * @fires gw.filterChanged
 */
function gw_onFilterChanged(id, e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.filterChanged',
    detail: {}
  }, _constants.GW_EVENT_FILTER_CHANGED);
}

/***/ }),

/***/ "./src/events/index.js":
/*!*****************************!*\
  !*** ./src/events/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "gw_onRowClicked", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRowClicked;
  }
});
Object.defineProperty(exports, "gw_onRowDoubleClicked", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRowDoubleClicked;
  }
});
Object.defineProperty(exports, "gw_onSelectionChanged", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onSelectionChanged;
  }
});
Object.defineProperty(exports, "gw_onCellClickEvent", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onCellClickEvent;
  }
});
Object.defineProperty(exports, "gw_onRangeSelectionChanged", {
  enumerable: true,
  get: function get() {
    return _selections.gw_onRangeSelectionChanged;
  }
});
Object.defineProperty(exports, "gw_onCellEditingEvent", {
  enumerable: true,
  get: function get() {
    return _editing.gw_onCellEditingEvent;
  }
});
Object.defineProperty(exports, "gw_onRowEditingEvent", {
  enumerable: true,
  get: function get() {
    return _editing.gw_onRowEditingEvent;
  }
});
Object.defineProperty(exports, "gw_onReadyEvent", {
  enumerable: true,
  get: function get() {
    return _ready.gw_onReadyEvent;
  }
});
Object.defineProperty(exports, "gw_debounce", {
  enumerable: true,
  get: function get() {
    return _utilities.gw_debounce;
  }
});
Object.defineProperty(exports, "gw_onFilterChanged", {
  enumerable: true,
  get: function get() {
    return _filters.gw_onFilterChanged;
  }
});

var _selections = __webpack_require__(/*! ./selections */ "./src/events/selections.js");

var _editing = __webpack_require__(/*! ./editing */ "./src/events/editing.js");

var _ready = __webpack_require__(/*! ./ready */ "./src/events/ready.js");

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _filters = __webpack_require__(/*! ./filters */ "./src/events/filters.js");

/***/ }),

/***/ "./src/events/keyboard.js":
/*!********************************!*\
  !*** ./src/events/keyboard.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onKeydown = gw_onKeydown;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

var _utilities2 = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Compose a model of the keydown event and send it to BBj
 *
 * @param {String} id  the grid's id
 * @param {Event} keydownEvent keydown event
 */
function gw_onKeydown(id, keydownEvent) {
  (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
    type: "gw.keypress",
    detail: JSON.stringify({
      c: keydownEvent.key,
      kc: keydownEvent.which || Number(keydownEvent.keyCode),
      ak: keydownEvent.altKey,
      sk: keydownEvent.shiftKey,
      ck: keydownEvent.ctrlKey
    })
  }, _constants.GW_EVENT_KEYPRESS);
}

/***/ }),

/***/ "./src/events/ready.js":
/*!*****************************!*\
  !*** ./src/events/ready.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onReadyEvent = gw_onReadyEvent;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _state = __webpack_require__(/*! ./state */ "./src/events/state.js");

var _keyboard = __webpack_require__(/*! ./keyboard */ "./src/events/keyboard.js");

var _utilities2 = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * On Ready Event
 *
 * The method will ignore first ready event and then register a debounced state
 * callback to send state events to BBj
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.gridReady
 * @fires gw.ready
 */
// eslint-disable-next-line no-unused-vars
function gw_onReadyEvent(id, _e) {
  var grid = (0, _utilities2.gw_getGrid)(id);
  (0, _utilities.gw_sendEvent)(grid.options.context, {
    type: 'gw.gridReady',
    detail: {}
  }, _constants.GW_EVENT_READY); // register state debounce monitor

  var stateDebounce = (0, _utilities.gw_debounce)(function (changeEvent) {
    (0, _state.gw_onStateChanged)(id, changeEvent);
  }, 500);
  ['sortChanged', 'filterChanged', 'columnVisible', 'columnPinned', 'columnResized', 'columnMoved', 'newColumnsLoaded', 'gridColumnsChanged', 'displayedColumnsChanged', 'virtualColumnsChanged', 'columnEverythingChanged', //'gridSizeChanged',
  'expandOrCollapseAll' //'toolPanelVisibleChanged'
  ].forEach(function (event) {
    grid.options.api.addEventListener(event, stateDebounce);
  }); // collect key downs information to be reported with other events

  grid.container.addEventListener('keydown', function (keydownEvent) {
    grid.keys = {
      c: keydownEvent.key,
      kc: keydownEvent.which || Number(keydownEvent.keyCode),
      ak: keydownEvent.altKey,
      sk: keydownEvent.shiftKey,
      ck: keydownEvent.ctrlKey
    };
  }); // clear collect keydown information

  grid.container.addEventListener('keyup', // eslint-disable-next-line no-unused-vars
  (0, _utilities.gw_debounce)(function (_e) {
    grid.keys = null;
  }, 250)); // register keyboard debounce monitor

  grid.container.addEventListener('keydown', (0, _utilities.gw_debounce)(function (keydownEvent) {
    (0, _keyboard.gw_onKeydown)(id, keydownEvent);
  }, 500));
  window.dispatchEvent(new CustomEvent("".concat(id, "-ready"), {
    detail: grid
  }));
}

/***/ }),

/***/ "./src/events/selections.js":
/*!**********************************!*\
  !*** ./src/events/selections.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onRowDoubleClicked = gw_onRowDoubleClicked;
exports.gw_onRowClicked = gw_onRowClicked;
exports.gw_onSelectionChanged = gw_onSelectionChanged;
exports.gw_onRangeSelectionChanged = gw_onRangeSelectionChanged;
exports.gw_onCellClickEvent = gw_onCellClickEvent;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _utilities2 = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var CELL_CLICKING_EVENTS_MAP = {
  cellClicked: _constants.GW_EVENT_CELL_CLICK,
  cellDoubleClicked: _constants.GW_EVENT_CELL_DOUBLE_CLICK
};
/**
 * An handler for the grid `rowDoubleClicked` event
 *
 * The function will send a bbj event with `GW_NODE` as payload
 *
 * @param {Object} e The event's payload
 *
 * @listens agGrid.rowDoubleClicked
 * @fires gw.rowDoubleClick
 */

function gw_onRowDoubleClicked(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowDoubleClick',
    detail: JSON.stringify({
      k: (0, _utilities2.gw_getGrid)(context.id).keys
    })
  }, _constants.GW_EVENT_ROW_DOUBLE_CLICK);
}
/**
 * A handler for the grid `rowClicked` event
 *
 * @param {Object} e  The event payload
 *
 * @listens agGrid.rowClicked
 * @fires gw.rowClick
 */


function gw_onRowClicked(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowClick',
    detail: JSON.stringify({
      k: (0, _utilities2.gw_getGrid)(context.id).keys
    })
  }, _constants.GW_EVENT_ROW_CLICK);
}
/**
 * A handler for the grid `selectionChanged` event
 *
 * @param {Object} e  The event payload
 *
 * @listens agGrid.selectionChanged
 * @fires gw.rowSelect
 */


function gw_onSelectionChanged(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rowSelect',
    detail: ''
  }, _constants.GW_EVENT_ROW_SELECT);
}
/**
 * A handler for the grid `rangeSelectionChanged` event
 *
 * @param {Object} e
 *
 * @listens agGrid.rangeSelectionChanged
 * @fires gw.rangeSelection
 */


function gw_onRangeSelectionChanged(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  (0, _utilities.gw_sendEvent)(context, {
    type: 'gw.rangeSelection',
    detail: ''
  }, _constants.GW_EVENT_RANGE_SELECTION_CHANGED);
}
/**
 * A handler for the grid `cellClickEvent` & `cellDoubleClicked` event
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.cellClickEvent
 * @listens agGrid.cellDoubleClicked
 *
 * @fires gw.cellClicked
 * @fires gw.cellDoubleClicked
 */


function gw_onCellClickEvent(e) {
  var context = e.api.gridOptionsWrapper.gridOptions.context;
  var id = context.id;
  var parsed = (0, _utilities.gw_parseNodeFromEvent)(e);

  if (parsed) {
    var type = e.type;
    (0, _utilities.gw_sendEvent)(context, {
      type: "gw.".concat(e.type),
      detail: JSON.stringify({
        r: parsed,
        // row
        v: (0, _utilities2.gw_escape)(e.value),
        // new value
        o: (0, _utilities2.gw_escape)(e.value),
        // odl value
        c: e.column.colId,
        // columns
        k: (0, _utilities2.gw_getGrid)(id).keys
      })
    }, CELL_CLICKING_EVENTS_MAP[type]);
  }
}

/***/ }),

/***/ "./src/events/state.js":
/*!*****************************!*\
  !*** ./src/events/state.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_onStateChanged = gw_onStateChanged;

var _utilities = __webpack_require__(/*! ./utilities */ "./src/events/utilities.js");

var _utilities2 = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

var _constants = __webpack_require__(/*! ./constants */ "./src/events/constants.js");

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * An handler for the grid `stateChanged` events
 *
 * @param {String} id The grid's id
 * @param {Object} e  The event payload
 *
 * @listens agGrid.stateChanged
 * @listens agGrid.rowEditingStopped
 *
 * @fires gw.stateChanged
 */
// eslint-disable-next-line no-unused-vars
function gw_onStateChanged(id, _e) {
  (0, _utilities.gw_sendEvent)((0, _utilities2.gw_getGrid)(id).options.context, {
    type: 'gw.stateChanged',
    detail: []
  }, _constants.GW_EVENT_GRID_STATE_CHANGE);
}

/***/ }),

/***/ "./src/events/utilities.js":
/*!*********************************!*\
  !*** ./src/events/utilities.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_debounce = gw_debounce;
exports.gw_sendEvent = gw_sendEvent;
exports.gw_parseNode = gw_parseNode;
exports.gw_parseNodeFromEvent = gw_parseNodeFromEvent;

var _utilities = __webpack_require__(/*! api/utilities */ "./src/api/utilities.js");

/* eslint-disable no-prototype-builtins */

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/** https://davidwalsh.name/javascript-debounce-function */
function gw_debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
}
/**
 * Send an event to BBj side
 *
 * @param {Array} context the grid's context
 * @param {*} payload the event payload
 * @param {String} eventId the event's id
 */


function gw_sendEvent(context) {
  var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var eventId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var registeredInterests = context.interests || [];

  if (registeredInterests.includes(eventId)) {
    var div = (0, _utilities.gw_getDocument)().getElementById("".concat(context.id)); // bui or webapp

    if ([5, 6].indexOf(context.platform) > -1) {
      var htmlviewId = "htmlview-".concat(context.id);
      var container = (0, _utilities.gw_getDocument)().getElementsByClassName(htmlviewId)[0];

      if (typeof container.basisDispatchCustomEvent === 'function') {
        container.basisDispatchCustomEvent(div, payload);
      } else {
        window.basisDispatchCustomEvent(div, payload);
      }
    } else {
      window.basisDispatchCustomEvent(div, payload);
    }
  }
}
/**
 * @typedef {Object} BBjGridExWidgetRow
 *
 * @property {number} id
 * @property {number} index
 * @property {number} parentKey
 * @property {number} childIndex
 * @property {boolean} selected
 */

/**
 * Parse a node as BBjGridExWidgetRow
 *
 * @param {Object} node ag grid node
 * @param {Object} context  ag grid context
 *
 * @returns {BBjGridExWidgetRow|Boolean} object formatted as BBjGridExWidgetRow.
 *                                       false if the node is for group node
 */


function gw_parseNode(node, context) {
  if (true === node.group) {
    return false;
  } // we do not manage groups


  var getRowNodeId = node.rowPinned ? '__ROW_INDEX' : context.getRowNodeId;
  return {
    i: context.hasOwnProperty('getRowNodeId') && node.data[getRowNodeId] ? node.data[getRowNodeId] : node.id,
    // id
    x: node.rowIndex,
    // index
    p: node.hasOwnProperty('parent') && node.parent.hasOwnProperty('key') ? node.parent.key : '',
    // parent key
    c: node.rowPinned ? -1 : node.childIndex,
    //childIndex
    s: Boolean(node.selected),
    // selected
    // client row
    cr: context.hasOwnProperty('includeClientRowData') && context['includeClientRowData'] === true ? node.data : null,
    pp: node.rowPinned // pin position

  };
}
/**
 * Parse node from event
 *
 * Parse node in the paSsed event as BBjGridExWidgetRow
 *
 * @param {Object} e
 *
 * @returns {BBjGridExWidgetRow}
 */


function gw_parseNodeFromEvent(e) {
  return gw_parseNode(e.node, e.context);
}

/***/ }),

/***/ "./src/expression.js":
/*!***************************!*\
  !*** ./src/expression.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gw_compileExpression = gw_compileExpression;
exports.gw_executeExpression = gw_executeExpression;

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/**
 * Build a js function from the given expression
 *
 * @param {String} expression
 *
 * @return {Function}
 */
function gw_compileExpression(expression) {
  // Check to see if the expression cache has been initialized
  if (typeof gw_compileExpression.expressionCache == 'undefined') {
    gw_compileExpression.expressionCache = [];
  } // check cache first


  if (gw_compileExpression.expressionCache[expression]) {
    return gw_compileExpression.expressionCache[expression];
  } // if not found in cache, return the function


  var functionBody = null; // if the expression has the 'return' word in it, then use as is,
  // if not, then wrap it with return and ';' to make a function

  if (expression.indexOf('return') >= 0) {
    functionBody = expression;
  } else {
    functionBody = 'return ' + expression + ';';
  }

  var theFunction = new Function('x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, columnApi, getValue, column, columnGroup', functionBody); // store in cache

  gw_compileExpression.expressionCache[expression] = theFunction;
  return theFunction;
}
/**
 * Build and executed an expression with the passed params
 *
 * @param {String} expression
 * @param {Object} params
 *
 * @return mixed
 */


function gw_executeExpression(expression, params) {
  try {
    var javaScriptFunction = gw_compileExpression(expression); // the params don't have all these values, rather we add every possible
    // value a params can have, which makes whatever is in the params available.

    var result = javaScriptFunction(params.value, params.context, params.oldValue, params.newValue, params.value, params.node, params.data, params.colDef, params.rowIndex, params.api, params.columnApi, params.getValue, params.column, params.columnGroup);
    return result;
  } catch (e) {
    // the expression failed, which can happen, as it's the client that
    // provides the expression. so print a nice message
    console.log('Processing of the expression failed');
    console.log('Expression = ' + expression);
    console.log('Params =', params);
    console.log('Exception = ' + e);
    return null;
  }
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(/*! expose-loader?BBj.Masks!bbj-masks/dist/bbj-masks.js */ "./node_modules/expose-loader/index.js?BBj.Masks!./node_modules/bbj-masks/dist/bbj-masks.js-exposed");

__webpack_require__(/*! expose-loader?Basis.InputMasking!basis-input-masking/dist/basis-input-masking.js */ "./node_modules/expose-loader/index.js?Basis.InputMasking!./node_modules/basis-input-masking/dist/basis-input-masking.js-exposed");

__webpack_require__(/*! expose-loader?flatpickr!flatpickr/dist/flatpickr.js */ "./node_modules/expose-loader/index.js?flatpickr!./node_modules/flatpickr/dist/flatpickr.js-exposed");

__webpack_require__(/*! expose-loader?Basis.AgGridComponents!basis-aggrid-components/dist/basis-aggrid-components.js */ "./node_modules/expose-loader/index.js?Basis.AgGridComponents!./node_modules/basis-aggrid-components/dist/basis-aggrid-components.js-exposed");

var _polyfills = __webpack_require__(/*! ./polyfills.js */ "./src/polyfills.js");

Object.keys(_polyfills).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _polyfills[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _polyfills[key];
    }
  });
});

var _api = __webpack_require__(/*! ./api */ "./src/api/index.js");

Object.keys(_api).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _api[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _api[key];
    }
  });
});

/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
__webpack_require__(/*! flatpickr/dist/flatpickr.css */ "./node_modules/flatpickr/dist/flatpickr.css");

__webpack_require__(/*! ./style/classes.css */ "./src/style/classes.css");

__webpack_require__(/*! ./style/suggestion-editor.css */ "./src/style/suggestion-editor.css");

/***/ }),

/***/ "./src/polyfills.js":
/*!**************************!*\
  !*** ./src/polyfills.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * This file is part of the BBjGridExWidget plugin.
 * (c) Basis Europe <eu@basis.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

/** https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent  */
// eslint-disable-next-line no-extra-semi
;

(function () {
  if (typeof window.CustomEvent === 'function') {
    return false;
  } //If not IE


  function CustomEvent(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: undefined
    };
    var evt = document.createEvent('CustomEvent');
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  }

  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();

/***/ }),

/***/ "./src/style/classes.css":
/*!*******************************!*\
  !*** ./src/style/classes.css ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/postcss-loader/src!./classes.css */ "./node_modules/postcss-loader/src/index.js!./src/style/classes.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/style/suggestion-editor.css":
/*!*****************************************!*\
  !*** ./src/style/suggestion-editor.css ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/postcss-loader/src!./suggestion-editor.css */ "./node_modules/postcss-loader/src/index.js!./src/style/suggestion-editor.css");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = function() {
                return window.parent.document.head
              };

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./src/index.js */"./src/index.js");


/***/ })

/******/ })));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL2F1dG9jb21wbGV0ZS50cyIsIndlYnBhY2s6Ly8vL3dlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2s6Ly8vd2VicGFjazovd2VicGFjay9ib290c3RyYXAgMGJhZTA1OWUyYjVmZTI2YzViMTAiLCJ3ZWJwYWNrOi8vLy9zcmMvQ29tcG9uZW50L2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvYXV0b2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9vdmVycmlkZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL3ByaXZhdGUvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcm9vdC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXEuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3RvSW50ZWdlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhblN3aXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9UZW1wbGF0ZVJlbmRlcmVyL2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLyh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL3JlYWRvbmx5LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS91dGNUb1pvbmVkVGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vX2xpYi90elBhcnNlVGltZXpvbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvRXZlbnRzTWl4aW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvRGF0ZVRpbWVJbnB1dC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuRWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5FZGl0b3IvQm9vbGVhbkVkaXRvci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Db21wb25lbnQvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5Td2l0Y2gvQm9vbGVhblN3aXRjaC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL2xhenktaW5pdGlhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuU3dpdGNoL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhblN3aXRjaC9zdHlsZS5zY3NzPzc2YTMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5SZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuUmVuZGVyZXIvQm9vbGVhblJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5GaWx0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvQm9vbGVhbkZpbHRlci9Cb29sZWFuRmlsdGVyLmpzIiwid2VicGFjazovLy8vc3JjL0Jvb2xlYW5GaWx0ZXIvc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vL3NyYy9Cb29sZWFuRmlsdGVyL3N0eWxlLnNjc3M/MGQ1ZSIsIndlYnBhY2s6Ly8vL3NyYy9OdW1iZXJFZGl0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvTnVtYmVyRWRpdG9yL051bWJlckVkaXRvci5qcyIsIndlYnBhY2s6Ly8vL3NyYy9OdW1iZXJFZGl0b3Ivc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vL3NyYy9OdW1iZXJFZGl0b3Ivc3R5bGUuc2Nzcz9hYTBlIiwid2VicGFjazovLy8vc3JjL1RleHRFZGl0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dEVkaXRvci9UZXh0RWRpdG9yLmpzIiwid2VicGFjazovLy8vc3JjL1RleHRFZGl0b3Ivc3R5bGUuc2NzcyIsIndlYnBhY2s6Ly8vL3NyYy9UZXh0RWRpdG9yL3N0eWxlLnNjc3M/MDkxYiIsIndlYnBhY2s6Ly8vL3NyYy9UZW1wbGF0ZVJlbmRlcmVyL1RlbXBsYXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hc3NpZ25JbldpdGguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RvU291cmNlLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZVN0cmluZ0NoYXIuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVByb3BlcnR5T2YuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUV2YWx1YXRlLmpzIiwid2VicGFjazovLy8vc3JjL0ltYWdlUmVuZGVyZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9zcmMvSW1hZ2VSZW5kZXJlci9JbWFnZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRmlsdGVyL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRmlsdGVyL0RhdGVUaW1lRmlsdGVyLmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS9fbGliL3R6VG9rZW5pemVEYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdWJNaWxsaXNlY29uZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vdG9EYXRlL2luZGV4LmpzIiwid2VicGFjazovLy8vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS90b0RhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL3NyYy9FdmVudHNNaXhpbi9FdmVudHNNaXhpbi5qcyIsIndlYnBhY2s6Ly8vL3NyYy9EYXRlVGltZUlucHV0L0RhdGVUaW1lSW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvRGF0ZVRpbWVJbnB1dC9zdHlsZS5zY3NzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lSW5wdXQvc3R5bGUuc2Nzcz80ZjY3Iiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRmlsdGVyL3N0eWxlLnNjc3MiLCJ3ZWJwYWNrOi8vLy9zcmMvRGF0ZVRpbWVGaWx0ZXIvc3R5bGUuc2Nzcz83NmZiIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL0RhdGVUaW1lRWRpdG9yL0RhdGVUaW1lRWRpdG9yLmpzIiwid2VicGFjazovLy93ZWJwYWNrOi93ZWJwYWNrL2Jvb3RzdHJhcCBmZDdmNjA0MjE5MmUxMjMyY2Y2NSIsIndlYnBhY2s6Ly8vd2VicGFjazovZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImJiai1tYXNrcy9zcmMvU3RyaW5nTWFza1wiLFwiY29tbW9uanMyXCI6XCJiYmotbWFza3Mvc3JjL1N0cmluZ01hc2tcIixcImFtZFwiOlwiYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrXCIsXCJyb290XCI6W1wiQkJqXCIsXCJNYXNrc1wiLFwiU3RyaW5nTWFza1wiXX0iLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dElucHV0L2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL1RleHRJbnB1dC9UZXh0SW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy9zcmMvVGV4dElucHV0L3Rvb2xzLmpzIiwid2VicGFjazovLy8vc3JjL051bWJlcklucHV0L2luZGV4LmpzIiwid2VicGFjazovLy8vc3JjL051bWJlcklucHV0L051bWJlcklucHV0LmpzIiwid2VicGFjazovLy93ZWJwYWNrOi9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiYmJqLW1hc2tzL3NyYy9OdW1iZXJNYXNrXCIsXCJjb21tb25qczJcIjpcImJiai1tYXNrcy9zcmMvTnVtYmVyTWFza1wiLFwiYW1kXCI6XCJiYmotbWFza3Mvc3JjL051bWJlck1hc2tcIixcInJvb3RcIjpbXCJCQmpcIixcIk1hc2tzXCIsXCJOdW1iZXJNYXNrXCJdfSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmJqLW1hc2tzL2Rpc3QvYmJqLW1hc2tzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy9qc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jiai1tYXNrcy9zcmMvTnVtYmVyTWFzay9OdW1iZXJNYXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYmotbWFza3Mvc3JjL051bWJlck1hc2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jiai1tYXNrcy9zcmMvU3RyaW5nTWFzay9TdHJpbmdNYXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iYmotbWFza3Mvc3JjL1N0cmluZ01hc2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXAtcGFyc2UtanNvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmJqLW1hc2tzL2Rpc3QvYmJqLW1hc2tzLmpzLWV4cG9zZWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Jhc2lzLWFnZ3JpZC1jb21wb25lbnRzL2Rpc3QvYmFzaXMtYWdncmlkLWNvbXBvbmVudHMuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzaXMtaW5wdXQtbWFza2luZy9kaXN0L2Jhc2lzLWlucHV0LW1hc2tpbmcuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmpzLWV4cG9zZWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzcy9qc3MuanMtZXhwb3NlZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmNzcz8wOTQ3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VQcm9wZXJ0eU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVBc3NpZ25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZUh0bWxDaGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2VzY2FwZVN0cmluZ0NoYXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXROYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fcmVFdmFsdWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUludGVycG9sYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hc3NpZ25JbldpdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9hdHRlbXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VzY2FwZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lkZW50aXR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmxhdHBpY2tyL2Rpc3QvZmxhdHBpY2tyLmNzcyIsIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGUvY2xhc3Nlcy5jc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlL3N1Z2dlc3Rpb24tZWRpdG9yLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9jZWxscy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2NoYXJ0cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL2NvbHVtbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9jb250ZXh0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9pbml0LmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvanNzLmpzIiwid2VicGFjazovLy8uL3NyYy9hcGkvbWVudXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9vdmVybGF5cy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3Jvd3MuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwaS9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3N0YXR1c2Jhci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3Rvb2xwYW5lbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBpL3V0aWxpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9IVE1MVG9vbHRpcC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9TdWdnZXN0aW9uRWRpdG9yLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvZWRpdGluZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzL2ZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzL2tleWJvYXJkLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvcmVhZHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy9zZWxlY3Rpb25zLmpzIiwid2VicGFjazovLy8uL3NyYy9ldmVudHMvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V2ZW50cy91dGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2V4cHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wb2x5ZmlsbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlL2NsYXNzZXMuY3NzPzA1NTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL3N0eWxlL3N1Z2dlc3Rpb24tZWRpdG9yLmNzcz8zZjI0Il0sIm5hbWVzIjpbIkNvbXBvbmVudCIsImRlZmluZVByb3BlcnR5IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJmbiIsIm1hcFN0b3JlIiwic3VwZXJTdG9yZSIsImJpbmQiLCJkZXNjcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJrbGFzcyIsImtleXMiLCJnZXRPd25LZXlzIiwiaSIsImwiLCJrZXkiLCJkZXNjIiwiYXV0b2JpbmRNZXRob2QiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJjb25zdHJ1Y3RvciIsInRhcmdldCIsImdldCIsImdldEJvdW5kU3VwZXIiLCJib3VuZEZuIiwid3JpdGFibGUiLCJzZXQiLCJjcmVhdGVEZWZhdWx0U2V0dGVyIiwiYXJncyIsImF1dG9iaW5kQ2xhc3MiLCJoYW5kbGUiLCJHRU5FUklDX0ZVTkNUSU9OX0VSUk9SIiwiRlVOQ1RJT05fUkVHRVhQIiwiU3ludGF4RXJyb3JSZXBvcnRlciIsImRlc2NyaXB0b3IiLCJ0b3BpYyIsIm5hbWUiLCJwYXJhbXMiLCJwYXJlbnRLbGFzcyIsImNoaWxkS2xhc3MiLCJwYXJlbnREZXNjcmlwdG9yIiwiY2hpbGREZXNjcmlwdG9yIiwiY29uZGl0aW9uIiwibXNnIiwicmVwb3J0ZXIiLCJwYXJlbnQiLCJjaGlsZCIsInBhcmVudFZhbHVlVHlwZSIsImNoaWxkVmFsdWVUeXBlIiwiaXNGdW5jdGlvbk92ZXJVbmRlZmluZWQiLCJjaGVja0Z1bmN0aW9uU2lnbmF0dXJlcyIsInBhcmVudEhhc0dldHRlciIsImNoaWxkSGFzR2V0dGVyIiwicGFyZW50SGFzU2V0dGVyIiwiY2hpbGRIYXNTZXR0ZXIiLCJwYXJlbnRUeXBlIiwiZ2V0RGVzY3JpcHRvclR5cGUiLCJjaGlsZFR5cGUiLCJjaGVja0RhdGFEZXNjcmlwdG9ycyIsImNoZWNrQWNjZXNzb3JEZXNjcmlwdG9ycyIsInN1Z2dlc3Rpb25UcmFuc2Zvcm1zIiwic3VnZ2VzdGlvbiIsInN1cGVyS2xhc3MiLCJzdXBlckRlc2NyaXB0b3IiLCJzdWdnZXN0ZWRLZXkiLCJmaW5kUG9zc2libGVBbHRlcm5hdGl2ZXMiLCJjaGVja0Rlc2NyaXB0b3JzIiwiZGVjb3JhdGUiLCJtb2R1bGUiLCJsaXN0IiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJpdGVtIiwibW9kdWxlcyIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJpZCIsIm1lZGlhUXVlcnkiLCJjc3NNYXBwaW5nIiwidXNlU291cmNlTWFwIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJiYXNlNjQiLCJidG9hIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJKU09OIiwiZGF0YSIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsIlN5bWJvbCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpc0Rlc2NyaXB0b3IiLCJlbnRyeUFyZ3MiLCJoYW5kbGVEZXNjcmlwdG9yIiwiQXJyYXkiLCJNZXRhIiwibGF6eUluaXRpYWxpemUiLCJNRVRBX0tFWSIsIm9iaiIsIm5ld1ZhbHVlIiwid2FybiIsImNvbnNvbGUiLCJzZWVuRGVwcmVjYXRpb25zIiwidHlwZSIsImlzT2JqZWN0Iiwicm9vdCIsImZyZWVTZWxmIiwic2VsZiIsImZyZWVHbG9iYWwiLCJGdW5jdGlvbiIsIm90aGVyIiwiZXEiLCJpc0xlbmd0aCIsImlzRnVuY3Rpb24iLCJpc0FycmF5TGlrZSIsImRpcnR5TnVtYmVyIiwibnVtYmVyIiwiTnVtYmVyIiwiaXNOYU4iLCJNYXRoIiwicmVxdWlyZWQiLCJCb29sZWFuU3dpdGNoIiwiVGVtcGxhdGVSZW5kZXJlciIsIm9iamVjdCIsImJhc2VBc3NpZ25WYWx1ZSIsImZ1bmMiLCJnZXROYXRpdmUiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsInRhZyIsImdsb2JhbCIsImciLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiaWRlbnRpdHkiLCJiYXNlUmVzdCIsImFwcGx5IiwiaXNJbmRleCIsImluZGV4IiwiaXNJdGVyYXRlZUNhbGwiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJsZW5ndGgiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwiaXNBcnIiLCJpc0FycmF5IiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzQnVmZmVyIiwiaXNUeXBlIiwiaXNUeXBlZEFycmF5Iiwic2tpcEluZGV4ZXMiLCJyZXN1bHQiLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJhcnJheUxpa2VLZXlzIiwib3JpZ2luYWxNb2R1bGUiLCJDdG9yIiwicHJvdG8iLCJpc1Byb3RvdHlwZSIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiaXNQbGFpbk9iamVjdCIsImlzRXJyb3IiLCJ0cmFuc2Zvcm0iLCJvdmVyQXJnIiwiYXJyYXkiLCJpdGVyYXRlZSIsImFycmF5TWFwIiwicmVJbnRlcnBvbGF0ZSIsImJhc2VUb1N0cmluZyIsInRvU3RyaW5nIiwiZGF0ZSIsInRvRGF0ZSIsInV0Y0RhdGUiLCJvZmZzZXRNaWxsaXNlY29uZHMiLCJ0elBhcnNlVGltZXpvbmUiLCJzdWJNaWxsaXNlY29uZHMiLCJNSUxMSVNFQ09ORFNfSU5fSE9VUiIsIk1JTExJU0VDT05EU19JTl9NSU5VVEUiLCJwYXR0ZXJucyIsInRpbWV6b25lIiwidGltZXpvbmVaIiwidGltZXpvbmVISCIsInRpbWV6b25lSEhNTSIsInRpbWV6b25lSUFOQSIsInRva2VuIiwiaG91cnMiLCJwYXJzZUludCIsInZhbGlkYXRlVGltZXpvbmUiLCJhYnNvbHV0ZU9mZnNldCIsIm1pbnV0ZXMiLCJ0b2tlbnMiLCJ0elRva2VuaXplRGF0ZSIsImFzVVRDIiwiRGF0ZSIsInRpbWVzdGFtcFdpdGhNc1plcm9lZCIsIkV2ZW50c01peGluIiwiRGF0ZVRpbWVJbnB1dCIsIkJvb2xlYW5FZGl0b3IiLCJCb29sZWFuIiwiU3RyaW5nIiwia2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSIsInN3aXRjaGVyIiwidHJ1ZVZhbHVlIiwiZmFsc2VWYWx1ZSIsInZhbHVlQXNTdHJpbmciLCJfZ3VpIiwiZmFsbGJhY2siLCJvcHRpb24iLCJBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnIiwiY29udGV4dCIsIndpbiIsImRvYyIsImluaXRpYWxWYWx1ZSIsImxpc3RlbmVyIiwiYm9vbFN3aXRjaCIsImRvY3VtZW50IiwibGFiZWwiLCJlIiwib3ZlcnJpZGUiLCJhdXRvYmluZCIsImluaXRpYWxpemVyIiwicmV0IiwicmVxdWlyZSIsIm9wdGlvbnMiLCJ3aW5kb3ciLCJ1cGRhdGUiLCJsb2NhdGlvbiIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJ1bnF1b3RlZE9yaWdVcmwiLCJuZXdVcmwiLCJCb29sZWFuUmVuZGVyZXIiLCJpc0luaXQiLCJib29sZWFuVHJ1ZVJlbmRlclZhbHVlIiwiYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUiLCJib29sZWFuVHJ1ZVZhbHVlIiwiYm9vbGVhbkZhbHNlVmFsdWUiLCJCb29sZWFuRmlsdGVyIiwidG9UaXRsZUNhc2UiLCJ3b3JkIiwic3RyaXBIVE1MIiwidG1wIiwiX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbiIsInRyYW5zbGF0ZSIsImlzQ2xlYXJGaWx0ZXIiLCJpc1Jlc2V0QnV0dG9uIiwiaXNBcHBseUJ1dHRvbiIsInJlc2V0IiwiYm9keSIsImFwcGx5RmlsdGVyUGFuZWwiLCJtb2RlbCIsImZpbHRlclR5cGUiLCJmaWx0ZXJUZXh0QXNTdHJpbmciLCJOdW1iZXJFZGl0b3IiLCJtaW4iLCJtYXgiLCJzdGVwIiwibWFzayIsInN0YXJ0VmFsdWUiLCJncm91cGluZ1NlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3IiLCJmb3JjZVRyYWlsaW5nWmVyb3MiLCJCYXNpcyIsImVsZW1lbnRzIiwib25VcGRhdGUiLCJvbkludmFsaWQiLCJfb25OdW1iZXJJbnB1dEludmFsaWQiLCJjYXN0ZWQiLCJyZXRWYWx1ZSIsImV2ZW50IiwiaXNWYWxpZCIsIl9tYXNrZWQiLCJ1bm1hc2tlZCIsImVycm9yIiwiaW5wdXQiLCJpc05hdmlnYXRpb25LZXkiLCJUZXh0RWRpdG9yIiwicGF0dGVybiIsInRpdGxlIiwiX29uVGV4dElucHV0SW52YWxpZCIsInRlbXBsYXRlIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc1RlbXBsYXRlIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJzZXR0aW5ncyIsInRlbXBsYXRlU2V0dGluZ3MiLCJndWFyZCIsInN0cmluZyIsImFzc2lnbkluV2l0aCIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiYmFzZVZhbHVlcyIsImludGVycG9sYXRlIiwic291cmNlIiwicmVEZWxpbWl0ZXJzIiwiUmVnRXhwIiwic291cmNlVVJMIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzY2FwZVN0cmluZ0NoYXIiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwib2Zmc2V0IiwibWF0Y2giLCJ2YXJpYWJsZSIsImF0dGVtcHQiLCJjcmVhdGVBc3NpZ25lciIsImNvcHlPYmplY3QiLCJrZXlzSW4iLCJpc05ldyIsInByb3BzIiwiY3VzdG9taXplciIsImFzc2lnblZhbHVlIiwib2JqVmFsdWUiLCJnZXRWYWx1ZSIsImJhc2VJc05hdGl2ZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsImZ1bmNUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJpc01hc2tlZCIsInRvU291cmNlIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsIm1hc2tTcmNLZXkiLCJ1aWQiLCJjb3JlSnNEYXRhIiwic291cmNlcyIsImFzc2lnbmVyIiwibmF0aXZlTWF4Iiwic3RhcnQiLCJvdGhlckFyZ3MiLCJzaG9ydE91dCIsImJhc2VTZXRUb1N0cmluZyIsImNvbnN0YW50IiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsImFyZ3VtZW50cyIsImJhc2VLZXlzSW4iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImJhc2VJc0FyZ3VtZW50cyIsImFyZ3NUYWciLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwic3R1YkZhbHNlIiwibm9kZUlzVHlwZWRBcnJheSIsIm5vZGVVdGlsIiwiYmFzZVVuYXJ5IiwiYmFzZUlzVHlwZWRBcnJheSIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiZnJlZVByb2Nlc3MiLCJ0eXBlcyIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJvYmplY3RDdG9yU3RyaW5nIiwiZ2V0UHJvdG90eXBlIiwic3RyaW5nRXNjYXBlcyIsImJhc2VLZXlzIiwibmF0aXZlS2V5cyIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsImVzY2FwZSIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsImVzY2FwZUh0bWxDaGFyIiwiaHRtbEVzY2FwZXMiLCJiYXNlUHJvcGVydHlPZiIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImlzU3ltYm9sIiwic3ltYm9sVGFnIiwiSW1hZ2VSZW5kZXJlciIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsImltYWdlTGlzdCIsIkRhdGVUaW1lRmlsdGVyIiwiVE9LRU5TIiwiVE9LRU5fRVFVQUwiLCJUT0tFTl9OT1RfRVFVQUwiLCJUT0tFTl9MRVNTIiwiVE9LRU5fR1JFQVRFUiIsIlRPS0VOX1JBTkdFIiwiVE9LRU5fQU5EIiwiVE9LRU5fT1IiLCJDb25kaXRpb25QYW5lbCIsIndpdGhFdmVudHNNaXhpbiIsIl9maWx0ZXJUaW1lSW5wdXQiLCJfZmlsdGVyVG9EYXRlVGltZUlucHV0IiwiX2ZpbHRlck9wdGlvbnMiLCJfZGVmYXVsdE9wdGlvbiIsIm9wdGlvbnNUcmFuc2xhdGlvbnMiLCJzZWxlY3QiLCJzdGF0ZSIsImd1aSIsImZpbHRlck9wdGlvbnMiLCJzZWxlY3RFbCIsImZpbHRlcklucHV0IiwiZmlsdGVyVG9JbnB1dCIsImV2dCIsImVsIiwiZmlsdGVyRGF0ZVRvIiwiT05fQ09ORElUSU9OX0NIQU5HRUQiLCJyZWFkb25seSIsImZpbHRlciIsImZpbHRlclRvIiwiSm9pbkNvbmRpdGlvblBhbmVsIiwiX2ZpcnN0Q29uZGl0aW9uUGFuZWwiLCJfc2Vjb25kQ29uZGl0aW9uUGFuZWwiLCJfb3BlcmF0b3JQYW5lbCIsIl9wYXJhbXMiLCJpZE9uZSIsImlkVHdvIiwic3VwcHJlc3NBbmRPckNvbmRpdGlvbiIsInNlY29uZENvbmRpdGlvbkd1aSIsIm9wZXJhdG9yUGFuZWxHdWkiLCJPTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VEIiwiY29uZGl0aW9uMSIsImNvbmRpdGlvbjIiLCJvcGVyYXRvciIsIl9Kb2luQ29uZGl0aW9uUGFuZWwiLCJfc3RhdGUiLCJfZG9lc0ZpbHRlclBhc3NPcHRpb25zIiwiZW5hYmxlVGltZSIsImluUmFuZ2VJbmNsdXNpdmUiLCJ2YWx1ZUdldHRlciIsImRvZXNQYXNzRmlyc3RDb25kaXRpb24iLCJkb2VzUGFzc1NlY29uZENvbmRpdGlvbiIsImNsb25lIiwiZGF0ZVRpbWVNYXNrIiwibG9jYWxlIiwiSW50bCIsIkJCaiIsImZpcnN0Q29uZGl0aW9uQXNTdHJpbmciLCJzZWNvbmRDb25kaXRpb25Bc1N0cmluZyIsIm9wZXJhdG9yQXNTdHJpbmciLCJwYXNzZWQiLCJ1dGNUb1pvbmVkVGltZSIsImlzQXBwbHlCdXR0b25BY3RpdmUiLCJkdGYiLCJnZXREYXRlVGltZUZvcm1hdCIsInBhcnRzT2Zmc2V0IiwiaGFja3lPZmZzZXQiLCJ0eXBlVG9Qb3MiLCJ5ZWFyIiwibW9udGgiLCJkYXkiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiZm9ybWF0dGVkIiwiZmlsbGVkIiwicG9zIiwicGFyc2VkIiwiZHRmQ2FjaGUiLCJ0ZXN0RGF0ZUZvcm1hdHRlZCIsImhvdXIxMiIsInRpbWVab25lIiwiaG91ckN5Y2xlU3VwcG9ydGVkIiwiaG91ckN5Y2xlIiwicmVxdWlyZWRBcmdzIiwiYW1vdW50IiwidG9JbnRlZ2VyIiwiYWRkTWlsbGlzZWNvbmRzIiwidGltZXN0YW1wIiwiYXJnU3RyIiwiYXJndW1lbnQiLCJERUZBVUxUX0FERElUSU9OQUxfRElHSVRTIiwiZGF0ZVRpbWVEZWxpbWV0ZXIiLCJwbGFpblRpbWUiLCJ0aW1lWm9uZURlbGltZXRlciIsIllZIiwiWVlZIiwiWVlZWSIsIllZWVlZIiwiTU0iLCJEREQiLCJNTUREIiwiV3d3IiwiV3d3RCIsIkhIIiwiSEhNTSIsIkhITU1TUyIsImRpcnR5T3B0aW9ucyIsImFkZGl0aW9uYWxEaWdpdHMiLCJkYXRlU3RyaW5ncyIsInNwbGl0RGF0ZVN0cmluZyIsInBhcnNlWWVhclJlc3VsdCIsInBhcnNlWWVhciIsInJlc3REYXRlU3RyaW5nIiwicGFyc2VEYXRlIiwidGltZSIsInBhcnNlVGltZSIsImdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMiLCJkYXRlU3RyaW5nIiwidGltZVN0cmluZyIsInBhdHRlcm5ZWVkiLCJwYXR0ZXJuWVlZWVkiLCJ5ZWFyU3RyaW5nIiwiY2VudHVyeVN0cmluZyIsInZhbGlkYXRlRGF0ZSIsImRheU9mWWVhciIsInZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSIsIndlZWsiLCJ2YWxpZGF0ZVdlZWtEYXRlIiwiZGF5T2ZJU09XZWVrWWVhciIsImRheU9mV2VlayIsInBhcnNlRmxvYXQiLCJ2YWxpZGF0ZVRpbWUiLCJzZWNvbmRzIiwiZm91cnRoT2ZKYW51YXJ5RGF5IiwiZGlmZiIsIkRBWVNfSU5fTU9OVEgiLCJEQVlTX0lOX01PTlRIX0xFQVBfWUVBUiIsImlzTGVhcFllYXIiLCJpc0xlYXBZZWFySW5kZXgiLCJkaXJ0eURhdGUiLCJiYXNlVGltZXpvbmVPZmZzZXQiLCJoYXNOZWdhdGl2ZVVUQ09mZnNldCIsIm1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0IiwiZ2V0RGF0ZU1pbGxpc2Vjb25kc1BhcnQiLCJoYW5kbGVycyIsImhhbmRsZXIiLCJpc0VkaXRvciIsInBpY2tlciIsInNlbGVjdGVkRGF0ZSIsInRpbWVfMjRociIsImVuYWJsZVNlY29uZHMiLCJub0NhbGVuZGFyIiwiZGF0ZUZvcm1hdCIsImZsYXRwaWNrciIsIndyYXAiLCJhbGxvd0lucHV0Iiwib25DaGFuZ2UiLCJmb3JtYXREYXRlIiwibWF4RGF0ZSIsIm1pbkRhdGUiLCJkZWZhdWx0SG91ciIsImRlZmF1bHRNaW51dGUiLCJkaXNhYmxlTW9iaWxlIiwid2Vla051bWJlcnMiLCJmb3JtYXQiLCJkYXRlVGltZUZvcm1hdHRlciIsImV4cHJlc3Npb24iLCJzZWxlY3RlZERhdGVzIiwid2Vla0RheXNTaG9ydCIsIndlZWtEYXlzTG9uZyIsIndlZWtkYXkiLCJtb250aHNTaG9ydCIsIm1vbnRoc0xvbmciLCJ3ZWVrZGF5cyIsInNob3J0aGFuZCIsImxvbmdoYW5kIiwibW9udGhzIiwiZGF5c0luTW9udGgiLCJmaXJzdERheU9mV2VlayIsIm9yZGluYWwiLCJyYW5nZVNlcGFyYXRvciIsIndlZWtBYmJyZXZpYXRpb24iLCJzY3JvbGxUaXRsZSIsInRvZ2dsZVRpdGxlIiwiYW1QTSIsInllYXJBcmlhTGFiZWwiLCJob3VyQXJpYUxhYmVsIiwibWludXRlQXJpYUxhYmVsIiwiT05fREFURV9DSEFOR0VEIiwiRGF0ZVRpbWVFZGl0b3IiLCJfaW5wdXQiLCJfdmFsdWUiLCJUZXh0SW5wdXQiLCJjc3NDbGFzc0Vycm9yIiwiY3NzQ2xhc3NTdWNjZXNzIiwicGFyZW50Q2xhc3MiLCJpc1dyYXBwZWQiLCJpbnB1dElkIiwiaW5wdXROYW1lIiwib3JpZ2luYWxQYXR0ZXJuIiwiZGVmYXVsdFBhdHRlcm4iLCJnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzayIsInVubWFza0lucHV0IiwibWFza0lmTm90TWFza2VkIiwidW5tYXNrIiwidGV4dElucHV0IiwiZXZlbnRUeXBlIiwia2V5Q29kZSIsImtleUNvbnRlbnQiLCJpbnNlcnRQb3NpdGlvbiIsImZpbmRDYXJldFBvc2l0aW9uIiwibWFza0Vycm9yIiwic2VsZWN0aW9uU3RhcnQiLCJ1bm1hc2tlZFZhbHVlIiwiU3RyaW5nTWFzayIsInNldFRpbWVvdXQiLCJwb3NpdGlvbiIsInZhbHVlTWFza2VkIiwidmFsdWVVbm1hc2tlZCIsIlNVUFBPUlRFRF9NQVNLUyIsIklTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEIiwiZXZhbCIsImlzTWFza2VkVmFsdWUiLCJjYWNoZUtleSIsIm1hc2tBc0FycnkiLCJyZWdleCIsImMiLCJtYXNrQXNBcnJheSIsIm1hc2tlZFZhbHVlQXNBcnJheSIsIm1hc2tlZFZhbHVlIiwiZWxIYXNNYXNrIiwiTnVtYmVySW5wdXQiLCJjb3VudERlY2ltYWxzIiwic3BsaXQiLCJhY3R1YWxJbnB1dCIsImFjdHVhbElucHV0SWQiLCJhY3R1YWxJbnB1dE5hbWUiLCJhY3R1YWxJbnB1dFN0ZXAiLCJhY3R1YWxJbnB1dE1heCIsImFjdHVhbElucHV0TWluIiwiYWN0dWFsSW5wdXRHcm91cGluZ1NlcGFyYXRvciIsImFjdHVhbElucHV0RGVjaW1hbFNlcGFyYXRvciIsImFjdHVhbElucHV0Rm9yY2VUcmFpbGluZ1plcm9zIiwiYWN0dWFsSW5wdXRNYXNrIiwiYWN0dWFsSW5wdXRDbGFzc2VzIiwiYWN0dWFsSW5wdXRSZXF1aXJlZCIsInVubWFza2VkSW5wdXQiLCJOdW1iZXJNYXNrIiwiZGVjaW1hbHMiLCJ3cmFwcGVyIiwicmVzdG9yZSIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiZmFjdG9yeSIsImRlZmluZSIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJjYWxsIiwibSIsImQiLCJnZXR0ZXIiLCJvIiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsInByb3BlcnR5IiwicHJvdG90eXBlIiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiTmFOIiwiY2VpbCIsImZsb29yIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19OdW1iZXJNYXNrX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3R6VG9rZW5pemVEYXRlX2luZGV4X2pzX18iLCJ0aW1lem9uZVN0cmluZyIsImV4ZWMiLCJVVEMiLCJnZXRUaW1lIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19TdHJpbmdNYXNrX18iLCJVdGlscyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fU3RyaW5nTWFza19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19UeXBlc19fIiwiRGF0ZXMiLCJnZXREYXlPZlllYXIiLCJnZXRXZWVrTnVtYmVyIiwiZ2V0V2Vla1N0YXJ0QnlMb2NhbGUiLCJJU19EQVRFX1JFR0VYIiwiSVNfVElNRV9SRUdFWCIsImZpeFNob3J0SVNPIiwiZ2V0VGltZXpvbmVPck9mZnNldCIsIl9jbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJfZGVmaW5lUHJvcGVydGllcyIsIl9jcmVhdGVDbGFzcyIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9tYXNrIiwidW5kZWZpbmVkIiwibG9vc2UiLCJtYXNrTGVuIiwic3RyIiwibWVzc2FnZSIsIm1hc2tCZWZvcmVEZWNpbWFsIiwibWFza0FmdGVyRGVjaW1hbCIsImZvdW5kRGVjaW1hbCIsImNoYXJBdCIsIm51bSIsIl9yb3VuZCIsImJ5dGVzIiwiX3RvQ2hhckFycmF5IiwiaW5MZW4iLCJudW1CZWZvcmVEZWNpbWFsIiwibnVtQWZ0ZXJEZWNpbWFsIiwiX2kiLCJfaTIiLCJmaWxsQnl0ZSIsImZsb2F0Qnl0ZSIsImluUG9zIiwib3V0UG9zIiwiZmxvYXRQb3MiLCJmaWxsSW5pdCIsImlzTmVnYXRpdmUiLCJfZ2V0U2lnbiIsImVtaXREZWNpbWFsIiwiaW5kZXhPZiIsImZvdW5kWmVybyIsImZvdW5kRGlnaXQiLCJjdXJyZW5jeSIsIm1hc2tQb3MiLCJfbSIsImpvaW4iLCJfc2hpZnQiLCJwcmVjaXNpb24iLCJyZXZlcnNlU2hpZnQiLCJudW1BcnJheSIsInJvdW5kIiwic2lnbnVtIiwiY2hhcnMiLCJjb25jYXQiLCJzdWJzdHJpbmciLCJ4IiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2RhdGVfZm5zX3R6X3V0Y1RvWm9uZWRUaW1lX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfd2Vla3N0YXJ0X18iLCJnZXRGdWxsWWVhciIsImdldFRpbWV6b25lT2Zmc2V0Iiwib25lRGF5IiwidGVzdCIsIkRhdGVUaW1lRm9ybWF0IiwicmVzb2x2ZWRPcHRpb25zIiwicGFkIiwiYWJzIiwid2Vla1N0YXJ0IiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiZGF5TnVtIiwiZ2V0VVRDRGF5Iiwic2V0VVRDRGF0ZSIsImdldFVUQ0RhdGUiLCJ5ZWFyU3RhcnQiLCJnZXRVVENGdWxsWWVhciIsIkRhdGVNYXNrIiwiZGF0ZU9iamVjdCIsInRyYW5zbGF0aW9uIiwiX2J1aWxkVHJhbnNsYXRpb24iLCJtb250aFNob3J0IiwibW9udGhMb25nIiwiZGF5U2hvcnQiLCJkYXlMb25nIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJob3VyczI0IiwiZ2V0SG91cnMiLCJob3VyczEyIiwiZ2V0RGF5Iiwid2Vla051bWJlciIsImsiLCJyZXBsYWNlIiwiZGF0ZURldGFpbHMiLCJZeiIsInN1YnN0ciIsIllzIiwiWWwiLCJZcCIsImZyb21DaGFyQ29kZSIsIllkIiwiWSIsIk16IiwiTXMiLCJNbCIsIk1wIiwiTWQiLCJNIiwiRHoiLCJEcyIsIkRsIiwiRHAiLCJEZCIsIkQiLCJIeiIsIkhzIiwiSGwiLCJIcCIsIkhkIiwiSCIsImh6IiwiaHMiLCJobCIsImhwIiwiaGQiLCJoIiwibXoiLCJtcyIsIm1sIiwibXAiLCJtZCIsInN6Iiwic3MiLCJzbCIsInNwIiwic2QiLCJQUCIsIlAiLCJwcCIsIkp6IiwiSnMiLCJKbCIsIkpkIiwiSiIsIld6IiwiV3MiLCJXbCIsIldwIiwiV2QiLCJXIiwid3oiLCJ3cyIsIndsIiwid3AiLCJ3ZCIsInciLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2xpYl90elBhcnNlVGltZXpvbmVfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fc3ViTWlsbGlzZWNvbmRzX18iLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3RvRGF0ZV9fIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENIb3VycyIsImdldFVUQ01pbnV0ZXMiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWlsbGlzZWNvbmRzIiwiZm9ybWF0VG9QYXJ0cyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19hZGRNaWxsaXNlY29uZHNfaW5kZXhfanNfXyIsImRpcnR5QW1vdW50IiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX190b0RhdGVfaW5kZXhfanNfXyIsIkVycm9yIiwic3RhY2siLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZGF0ZV9mbnNfZXNtX2xpYl90b0ludGVnZXJfaW5kZXhfanNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fbGliX2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHNfaW5kZXhfanNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fbGliX3R6UGFyc2VUaW1lem9uZV9fIiwiUmFuZ2VFcnJvciIsInNsaWNlIiwic2V0VVRDRnVsbFllYXIiLCJpc29XZWVrWWVhciIsInNldFNlY29uZHMiLCJnZXRXZWVrU3RhcnRCeUxvY2FsZSQxIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19hcGlfanNfXyIsIl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbGFuZ1JlZ2lvbk1hcF9qc19fIiwiX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19yZWdpb25EYXlNYXBfanNfXyIsImdldFdlZWtTdGFydEJ5UmVnaW9uJDEiLCJyZWdpb25Db2RlIiwiZ2V0V2Vla1N0YXJ0QnlSZWdpb24iLCJyZWdpb25EYXlNYXAiLCJjb2RlIiwidG9VcHBlckNhc2UiLCJsYW5nUmVnaW9uTWFwIiwidG9Mb3dlckNhc2UiLCJsYW5ndWFnZSIsImNvdW50cnkiLCJlbiIsInpoIiwiemhfaGFucyIsImhhbnMiLCJ3dXUiLCJoc24iLCJoYWsiLCJuYW4iLCJnYW4iLCJoaSIsInRlIiwibXIiLCJ0YSIsImd1Iiwia24iLCJvciIsInBhX2d1cnUiLCJiaG8iLCJhd2EiLCJhcyIsIm13ciIsIm1haSIsIm1hZyIsImJnYyIsImhuZSIsImRjYyIsImR6IiwidG4iLCJhbSIsIm9tIiwicXVjIiwianYiLCJzdSIsIm1hZCIsIm1zX2FyYWIiLCJnYSIsImhlIiwiamFtIiwiamEiLCJrbSIsImtvIiwibG8iLCJtaCIsIm15IiwibXQiLCJuZSIsImZpbCIsImNlYiIsImlsbyIsInVyIiwicGEiLCJwYV9hcmFiIiwiYXJhYiIsImxhaCIsInBzIiwic2RfYXJhYiIsInNrciIsImduIiwidGgiLCJ0dHMiLCJhZWIiLCJ6aF9oYW50IiwiaGFudCIsInNtIiwienUiLCJzbiIsImFycSIsImFyIiwiYXJ6IiwiZmEiLCJhel9hcmFiIiwiYXJ5IiwiYm4iLCJya3QiLCJkdiIsIkFHIiwiQVRHIiwiQVIiLCJBUkciLCJBUyIsIkFTTSIsIkFVIiwiQVVTIiwiQlIiLCJCUkEiLCJCUyIsIkJIUyIsIkJUIiwiQlROIiwiQlciLCJCV0EiLCJCWiIsIkJMWiIsIkNBIiwiQ0FOIiwiQ04iLCJDSE4iLCJDTyIsIkNPTCIsIkRNIiwiRE1BIiwiRE8iLCJET00iLCJFVCIsIkVUSCIsIkdUIiwiR1RNIiwiR1UiLCJHVU0iLCJISyIsIkhLRyIsIkhOIiwiSE5EIiwiSUQiLCJJRE4iLCJJRSIsIklSTCIsIklMIiwiSVNSIiwiSU4iLCJJTkQiLCJKTSIsIkpBTSIsIkpQIiwiSlBOIiwiS0UiLCJLRU4iLCJLSCIsIktITSIsIktSIiwiS09SIiwiTEEiLCJMQTAiLCJNSCIsIk1ITCIsIk1NUiIsIk1PIiwiTUFDIiwiTVQiLCJNTFQiLCJNWCIsIk1FWCIsIk1aIiwiTU9aIiwiTkkiLCJOSUMiLCJOUCIsIk5QTCIsIk5aIiwiTlpMIiwiUEEiLCJQQU4iLCJQRSIsIlBFUiIsIlBIIiwiUEhMIiwiUEsiLCJQQUsiLCJQUiIsIlBSSSIsIlBZIiwiUFJZIiwiU0EiLCJTQVUiLCJTRyIsIlNHUCIsIlNWIiwiU0xWIiwiVEgiLCJUSEEiLCJUTiIsIlRVTiIsIlRUIiwiVFRPIiwiVFciLCJUV04iLCJVTSIsIlVNSSIsIlVTIiwiVVNBIiwiVkUiLCJWRU4iLCJWSSIsIlZJUiIsIldTIiwiV1NNIiwiWUUiLCJZRU0iLCJaQSIsIlpBRiIsIlpXIiwiWldFIiwiQUUiLCJBUkUiLCJBRiIsIkFGRyIsIkJIIiwiQkhSIiwiREoiLCJESkkiLCJEWiIsIkRaQSIsIkVHIiwiRUdZIiwiSVEiLCJJUlEiLCJJUiIsIklSTiIsIkpPIiwiSk9SIiwiS1ciLCJLV1QiLCJMWSIsIkxCWSIsIk1BIiwiTUFSIiwiT00iLCJPTU4iLCJRQSIsIlFBVCIsIlNEIiwiU0ROIiwiU1kiLCJTWVIiLCJCRCIsIkJHRCIsIk1WIiwiTURWIiwiaXNOdW1iZXJSZWdleCIsImlzV2hpdGVzcGFjZVJlZ2V4IiwicHVuY3R1YXRpb25MaXN0IiwiaXNMb3dlckNhc2UiLCJpc1VwcGVyQ2FzZSIsInBhc3NPclRocm93RXJyb3IiLCJfY2hhciIsInN0ckxlbiIsIm1hc2tCeXRlIiwiX2J5dGUiLCJfYnl0ZTIiLCJfYnl0ZTMiLCJfYnl0ZTQiLCJfYnl0ZTUiLCJfYnl0ZTYiLCJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1R5cGVzX18iLCJUeXBlcyIsIl9udW1iZXIiLCJfZGF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsIl9fc3ByZWFkQXJyYXlzIiwiaWwiLCJyIiwiYSIsImoiLCJqbCIsIkhPT0tTIiwiZGVmYXVsdHMiLCJfZGlzYWJsZSIsIl9lbmFibGUiLCJhbGxvd0ludmFsaWRQcmVsb2FkIiwiYWx0Rm9ybWF0IiwiYWx0SW5wdXQiLCJhbHRJbnB1dENsYXNzIiwiYW5pbWF0ZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImFyaWFEYXRlRm9ybWF0IiwiYXV0b0ZpbGxEZWZhdWx0VGltZSIsImNsaWNrT3BlbnMiLCJjbG9zZU9uU2VsZWN0IiwiY29uanVuY3Rpb24iLCJkZWZhdWx0U2Vjb25kcyIsImRpc2FibGUiLCJlbmFibGUiLCJlcnJvckhhbmRsZXIiLCJlcnIiLCJnZXRXZWVrIiwiZ2l2ZW5EYXRlIiwic2V0SG91cnMiLCJzZXREYXRlIiwid2VlazEiLCJob3VySW5jcmVtZW50IiwiaWdub3JlZEZvY3VzRWxlbWVudHMiLCJpbmxpbmUiLCJtaW51dGVJbmNyZW1lbnQiLCJtb2RlIiwibW9udGhTZWxlY3RvclR5cGUiLCJuZXh0QXJyb3ciLCJub3ciLCJvbkNsb3NlIiwib25EYXlDcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbktleURvd24iLCJvbk1vbnRoQ2hhbmdlIiwib25PcGVuIiwib25QYXJzZUNvbmZpZyIsIm9uUmVhZHkiLCJvblZhbHVlVXBkYXRlIiwib25ZZWFyQ2hhbmdlIiwib25QcmVDYWxlbmRhclBvc2l0aW9uIiwicGx1Z2lucyIsInBvc2l0aW9uRWxlbWVudCIsInByZXZBcnJvdyIsInNob3J0aGFuZEN1cnJlbnRNb250aCIsInNob3dNb250aHMiLCJzdGF0aWMiLCJlbmdsaXNoIiwibnRoIiwibW9udGhBcmlhTGFiZWwiLCJpbnQiLCJib29sIiwiZGVib3VuY2UiLCJ3YWl0IiwiaW1tZWRpYXRlIiwidGltZW91dCIsImNsZWFyVGltZW91dCIsImFycmF5aWZ5IiwidG9nZ2xlQ2xhc3MiLCJlbGVtIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50IiwiY2xlYXJOb2RlIiwibm9kZSIsImZpcnN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImZpbmRQYXJlbnQiLCJwYXJlbnROb2RlIiwiY3JlYXRlTnVtYmVySW5wdXQiLCJpbnB1dENsYXNzTmFtZSIsIm9wdHMiLCJudW1JbnB1dCIsImFycm93VXAiLCJhcnJvd0Rvd24iLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImdldEV2ZW50VGFyZ2V0IiwiY29tcG9zZWRQYXRoIiwicGF0aCIsImRvTm90aGluZyIsIm1vbnRoVG9TdHIiLCJtb250aE51bWJlciIsInJldkZvcm1hdCIsIkYiLCJkYXRlT2JqIiwibW9udGhOYW1lIiwic2V0TW9udGgiLCJHIiwiSyIsInNob3J0TW9udGgiLCJTIiwiVSIsIl8iLCJ1bml4U2Vjb25kcyIsIndlZWtOdW0iLCJzZXRGdWxsWWVhciIsIloiLCJJU09EYXRlIiwic2V0TWludXRlcyIsInUiLCJ1bml4TWlsbFNlY29uZHMiLCJ5IiwidG9rZW5SZWdleCIsImZvcm1hdHMiLCJ0b0lTT1N0cmluZyIsImNyZWF0ZURhdGVGb3JtYXR0ZXIiLCJfYSIsIl9iIiwiY29uZmlnIiwiX2MiLCJsMTBuIiwiX2QiLCJpc01vYmlsZSIsImZybXQiLCJvdmVycmlkZUxvY2FsZSIsIm1hcCIsImFyciIsImNyZWF0ZURhdGVQYXJzZXIiLCJnaXZlbkZvcm1hdCIsInRpbWVsZXNzIiwiY3VzdG9tTG9jYWxlIiwicGFyc2VkRGF0ZSIsImRhdGVPcmlnIiwidG9GaXhlZCIsImRhdGVzdHIiLCJ0cmltIiwibWF0Y2hlZCIsIm9wcyIsIm1hdGNoSW5kZXgiLCJyZWdleFN0ciIsInRva2VuXzEiLCJpc0JhY2tTbGFzaCIsImVzY2FwZWQiLCJ2YWwiLCJmb3JFYWNoIiwiY29tcGFyZURhdGVzIiwiZGF0ZTEiLCJkYXRlMiIsImlzQmV0d2VlbiIsInRzIiwidHMxIiwidHMyIiwiZHVyYXRpb24iLCJEQVkiLCJfbG9vcF8xIiwiYXJnc18xIiwiREVCT1VOQ0VEX0NIQU5HRV9NUyIsIkZsYXRwaWNrckluc3RhbmNlIiwiZWxlbWVudCIsImluc3RhbmNlQ29uZmlnIiwiZGVmYXVsdENvbmZpZyIsIl9oYW5kbGVycyIsInBsdWdpbkVsZW1lbnRzIiwibG9hZGVkUGx1Z2lucyIsIl9iaW5kIiwiX3NldEhvdXJzRnJvbURhdGUiLCJzZXRIb3Vyc0Zyb21EYXRlIiwiX3Bvc2l0aW9uQ2FsZW5kYXIiLCJwb3NpdGlvbkNhbGVuZGFyIiwiY2hhbmdlTW9udGgiLCJjaGFuZ2VZZWFyIiwiY2xlYXIiLCJjbG9zZSIsIl9jcmVhdGVFbGVtZW50IiwiZGVzdHJveSIsImlzRW5hYmxlZCIsImp1bXBUb0RhdGUiLCJvcGVuIiwicmVkcmF3IiwidG9nZ2xlIiwic2V0dXBIZWxwZXJGdW5jdGlvbnMiLCJ1dGlscyIsImdldERheXNJbk1vbnRoIiwieXIiLCJjdXJyZW50TW9udGgiLCJjdXJyZW50WWVhciIsImluaXQiLCJpc09wZW4iLCJwYXJzZUNvbmZpZyIsInNldHVwTG9jYWxlIiwic2V0dXBJbnB1dHMiLCJzZXR1cERhdGVzIiwiYnVpbGQiLCJiaW5kRXZlbnRzIiwibGF0ZXN0U2VsZWN0ZWREYXRlT2JqIiwidXBkYXRlVmFsdWUiLCJzZXRDYWxlbmRhcldpZHRoIiwiaXNTYWZhcmkiLCJ0cmlnZ2VyRXZlbnQiLCJiaW5kVG9JbnN0YW5jZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbGVuZGFyQ29udGFpbmVyIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiZGlzcGxheSIsImRheXNDb250YWluZXIiLCJkYXlzV2lkdGgiLCJkYXlzIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsIndlZWtXcmFwcGVyIiwicmVtb3ZlUHJvcGVydHkiLCJ1cGRhdGVUaW1lIiwiZGVmYXVsdERhdGUiLCJnZXREZWZhdWx0SG91cnMiLCJ0aW1lV3JhcHBlciIsInByZXZWYWx1ZSIsInNldEhvdXJzRnJvbUlucHV0cyIsIl9kZWJvdW5jZWRDaGFuZ2UiLCJhbXBtMm1pbGl0YXJ5IiwibWlsaXRhcnkyYW1wbSIsImhvdXJFbGVtZW50IiwibWludXRlRWxlbWVudCIsInNlY29uZEVsZW1lbnQiLCJsaW1pdE1pbkhvdXJzIiwibWluVGltZSIsIm1pbkRhdGVIYXNUaW1lIiwibGltaXRNYXhIb3VycyIsIm1heFRpbWUiLCJtYXhEYXRlSGFzVGltZSIsIm1pbkhyIiwibWluTWludXRlcyIsIm1heEhyIiwibWF4TWludXRlcyIsIm9uWWVhcklucHV0IiwiZXZlbnRUYXJnZXQiLCJkZWx0YSIsImV2IiwiYWRkRXZlbnRMaXN0ZW5lciIsInB1c2giLCJ0cmlnZ2VyQ2hhbmdlIiwicXVlcnlTZWxlY3RvckFsbCIsInNldHVwTW9iaWxlIiwiZGVib3VuY2VkUmVzaXplIiwib25SZXNpemUiLCJvbk1vdXNlT3ZlciIsIm9udG91Y2hzdGFydCIsImRvY3VtZW50Q2xpY2siLCJjYXB0dXJlIiwibW9udGhOYXYiLCJvbk1vbnRoTmF2Q2xpY2siLCJzZWxlY3REYXRlIiwidGltZUNvbnRhaW5lciIsInNlbFRleHQiLCJ0aW1lSW5jcmVtZW50Iiwib25CbHVyIiwianVtcERhdGUiLCJqdW1wVG8iLCJvbGRZZWFyIiwib2xkTW9udGgiLCJidWlsZE1vbnRoU3dpdGNoIiwiaW5jcmVtZW50TnVtSW5wdXQiLCJjb250YWlucyIsImlucHV0RWxlbSIsImNyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsInRhYkluZGV4IiwiYnVpbGRNb250aE5hdiIsImlubmVyQ29udGFpbmVyIiwiYnVpbGRXZWVrcyIsInJDb250YWluZXIiLCJidWlsZFdlZWtkYXlzIiwiYnVpbGREYXlzIiwiYnVpbGRUaW1lIiwiY3VzdG9tQXBwZW5kIiwiYXBwZW5kVG8iLCJub2RlVHlwZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwiY3JlYXRlRGF5IiwiZGF5TnVtYmVyIiwiZGF0ZUlzRW5hYmxlZCIsImRheUVsZW1lbnQiLCIkaSIsInRvZGF5RGF0ZUVsZW0iLCJpc0RhdGVTZWxlY3RlZCIsInNlbGVjdGVkRGF0ZUVsZW0iLCJpc0RhdGVJblJhbmdlIiwiaW5zZXJ0QWRqYWNlbnRIVE1MIiwiZm9jdXNPbkRheUVsZW0iLCJ0YXJnZXROb2RlIiwiZm9jdXMiLCJnZXRGaXJzdEF2YWlsYWJsZURheSIsInN0YXJ0TW9udGgiLCJlbmRNb250aCIsImNoaWxkcmVuIiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiZ2V0TmV4dEF2YWlsYWJsZURheSIsImN1cnJlbnQiLCJnaXZlbk1vbnRoIiwibG9vcERlbHRhIiwibnVtTW9udGhEYXlzIiwiZm9jdXNPbkRheSIsImRheUZvY3VzZWQiLCJpc0luVmlldyIsImFjdGl2ZUVsZW1lbnQiLCJzdGFydEVsZW0iLCJidWlsZE1vbnRoRGF5cyIsImZpcnN0T2ZNb250aCIsInByZXZNb250aERheXMiLCJpc011bHRpTW9udGgiLCJwcmV2TW9udGhEYXlDbGFzcyIsIm5leHRNb250aERheUNsYXNzIiwiZGF5SW5kZXgiLCJkYXlDb250YWluZXIiLCJmcmFnIiwic2hvdWxkQnVpbGRNb250aCIsIm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyIiwiaW5uZXJIVE1MIiwic2VsZWN0ZWQiLCJidWlsZE1vbnRoIiwiY29udGFpbmVyIiwibW9udGhOYXZGcmFnbWVudCIsIm1vbnRoRWxlbWVudCIsInNlbGVjdGVkTW9udGgiLCJ5ZWFySW5wdXQiLCJ0YWJpbmRleCIsInllYXJFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJkaXNhYmxlZCIsImJ1aWxkTW9udGhzIiwicHJldk1vbnRoTmF2IiwieWVhckVsZW1lbnRzIiwibW9udGhFbGVtZW50cyIsIm5leHRNb250aE5hdiIsIl9faGlkZVByZXZNb250aEFycm93IiwiX19oaWRlTmV4dE1vbnRoQXJyb3ciLCJjdXJyZW50WWVhckVsZW1lbnQiLCJ1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoIiwic2VwYXJhdG9yIiwiaG91cklucHV0IiwibWludXRlSW5wdXQiLCJzZWNvbmRJbnB1dCIsImdldEF0dHJpYnV0ZSIsIndlZWtkYXlDb250YWluZXIiLCJ1cGRhdGVXZWVrZGF5cyIsInNwbGljZSIsImlzT2Zmc2V0IiwiX2hpZGVQcmV2TW9udGhBcnJvdyIsIl9oaWRlTmV4dE1vbnRoQXJyb3ciLCJ0cmlnZ2VyQ2hhbmdlRXZlbnQiLCJ0b0luaXRpYWwiLCJtb2JpbGVJbnB1dCIsIl9pbml0aWFsRGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJsYXN0Q2hpbGQiLCJfdHlwZSIsInJlbW92ZUF0dHJpYnV0ZSIsImlzQ2FsZW5kYXJFbGVtIiwiZXZlbnRUYXJnZXRfMSIsImlzQ2FsZW5kYXJFbGVtZW50IiwiaXNJbnB1dCIsImxvc3RGb2N1cyIsInJlbGF0ZWRUYXJnZXQiLCJpc0lnbm9yZWQiLCJzb21lIiwibmV3WWVhciIsIm5ld1llYXJOdW0iLCJpc05ld1llYXIiLCJkYXRlVG9DaGVjayIsImZyb20iLCJ0byIsImFsbG93S2V5ZG93biIsImFsbG93SW5saW5lS2V5ZG93biIsImJsdXIiLCJpc1RpbWVPYmoiLCJwcmV2ZW50RGVmYXVsdCIsImZvY3VzQW5kQ2xvc2UiLCJkZWx0YV8xIiwiY3RybEtleSIsInN0b3BQcm9wYWdhdGlvbiIsImVsZW1zIiwic2hpZnRLZXkiLCJob3ZlckRhdGUiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImluaXRpYWxEYXRlIiwicmFuZ2VTdGFydERhdGUiLCJyYW5nZUVuZERhdGUiLCJjb250YWluc0Rpc2FibGVkIiwibWluUmFuZ2UiLCJtYXhSYW5nZSIsImRheUVsZW0iLCJvdXRPZlJhbmdlIiwiX3Bvc2l0aW9uRWxlbWVudCIsImNsaWNrIiwid2FzT3BlbiIsIm1pbk1heERhdGVTZXR0ZXIiLCJpbnZlcnNlRGF0ZU9iaiIsImJvb2xPcHRzIiwidXNlckNvbmZpZyIsInBhcnNlIiwic3RyaW5naWZ5IiwiZGF0YXNldCIsImRhdGVzIiwicGFyc2VEYXRlUnVsZXMiLCJ0aW1lTW9kZSIsImRlZmF1bHREYXRlRm9ybWF0IiwiZGVmYXVsdEFsdEZvcm1hdCIsIl9taW5EYXRlIiwiX21heERhdGUiLCJtaW5NYXhUaW1lU2V0dGVyIiwiX21pblRpbWUiLCJfbWF4VGltZSIsImhvb2siLCJwbHVnaW5Db25mIiwiZ2V0SW5wdXRFbGVtIiwicXVlcnlTZWxlY3RvciIsImwxMG5zIiwiZGVmYXVsdCIsImN1c3RvbVBvc2l0aW9uRWxlbWVudCIsImNhbGVuZGFySGVpZ2h0IiwicmVkdWNlIiwiYWNjIiwib2Zmc2V0SGVpZ2h0IiwiY2FsZW5kYXJXaWR0aCIsImNvbmZpZ1BvcyIsImNvbmZpZ1Bvc1ZlcnRpY2FsIiwiY29uZmlnUG9zSG9yaXpvbnRhbCIsImlucHV0Qm91bmRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZGlzdGFuY2VGcm9tQm90dG9tIiwiaW5uZXJIZWlnaHQiLCJib3R0b20iLCJzaG93T25Ub3AiLCJ0b3AiLCJwYWdlWU9mZnNldCIsImxlZnQiLCJwYWdlWE9mZnNldCIsImlzQ2VudGVyIiwiaXNSaWdodCIsInJpZ2h0IiwicmlnaHRNb3N0IiwiY2VudGVyTW9zdCIsImdldERvY3VtZW50U3R5bGVTaGVldCIsImJvZHlXaWR0aCIsImNlbnRlckxlZnQiLCJjZW50ZXJCZWZvcmUiLCJjZW50ZXJBZnRlciIsImNlbnRlckluZGV4IiwiY3NzUnVsZXMiLCJjZW50ZXJTdHlsZSIsImluc2VydFJ1bGUiLCJlZGl0YWJsZVNoZWV0Iiwic3R5bGVTaGVldHMiLCJzaGVldCIsImNyZWF0ZVN0eWxlU2hlZXQiLCJoZWFkIiwibXNNYXhUb3VjaFBvaW50cyIsImlzU2VsZWN0YWJsZSIsInNob3VsZENoYW5nZU1vbnRoIiwic2VsZWN0ZWRJbmRleCIsInNvcnQiLCJiIiwic2luZ2xlIiwicmFuZ2UiLCJDQUxMQkFDS1MiLCJzZXRTZWxlY3RlZERhdGUiLCJpbnB1dERhdGUiLCJydWxlIiwicHJlbG9hZGVkRGF0ZSIsIm5vZGVOYW1lIiwicGxhY2Vob2xkZXIiLCJpbnB1dFR5cGUiLCJtb2JpbGVGb3JtYXRTdHIiLCJkZWZhdWx0VmFsdWUiLCJob29rcyIsImluaXRFdmVudCIsImdldERhdGVTdHIiLCJkT2JqIiwiaXNQcmV2TW9udGgiLCJpc05leHRNb250aCIsImlzS2V5RG93biIsImN1clZhbHVlIiwid2hpY2giLCJpc0hvdXJFbGVtIiwiaXNNaW51dGVFbGVtIiwiX2ZsYXRwaWNrciIsIm5vZGVMaXN0Iiwibm9kZXMiLCJIVE1MRWxlbWVudCIsImluc3RhbmNlcyIsIkhUTUxDb2xsZWN0aW9uIiwiTm9kZUxpc3QiLCJzZWxlY3RvciIsIk5vZGUiLCJsb2NhbGl6ZSIsInNldERlZmF1bHRzIiwialF1ZXJ5IiwiZnBfaW5jciIsImpzcyIsImFkalNlbEF0dHJSZWdleCIsImRvdWJsZUNvbG9uUHNldWRvRWxSZWdleCIsInNpbmdsZUNvbG9uUHNldWRvRWxSZWdleCIsInNpbmdsZUNvbG9uRm9yUHNldWRvRWxlbWVudHMiLCJnZXRTZWxlY3RvcnNBbmRSdWxlcyIsInJ1bGVzIiwicmVzdWx0cyIsInNlbGVjdG9yVGV4dCIsInRvRG91YmxlQ29sb25Qc2V1ZG9FbGVtZW50cyIsImdldFJ1bGVzIiwic3dhcEFkalNlbEF0dHIiLCJzd2FwUHNldWRvRWxTeW50YXgiLCJhZGRSdWxlIiwicHNldWRvRWxlbWVudFJ1bGUiLCJhZGRQc2V1ZG9FbGVtZW50UnVsZSIsImFkZFJ1bGVUb1NoZWV0IiwiZG91YmxlQ29sb25TZWxlY3RvciIsInNpbmdsZUNvbG9uU2VsZWN0b3IiLCJ0b1NpbmdsZUNvbG9uUHNldWRvRWxlbWVudHMiLCJzdWJtYXRjaDEiLCJzdWJtYXRjaDIiLCJzdWJtYXRjaDMiLCJyZW1vdmVSdWxlIiwiZGVsZXRlUnVsZSIsImV4dGVuZCIsImRlc3QiLCJzcmMiLCJhZ2dyZWdhdGVTdHlsZXMiLCJhZ2dyZWdhdGUiLCJkZWNsYXJlZFByb3BlcnRpZXMiLCJkZWNsYXJlZCIsInRvQ2FtZWxDYXNlIiwic3dhcCIsImxhc3RJbmRleCIsInNldFN0eWxlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJpbXBvcnRhbnRJbmRleCIsInNldFByb3BlcnR5Iiwic3VibWF0Y2giLCJ0cmFuc2Zvcm1DYW1lbENhc2VkUHJvcGVydHlOYW1lcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJ1bkNhbWVsQ2FzZSIsIkpzcyIsInNoZWV0cyIsImRlZmF1bHRTaGVldCIsImdldEFsbCIsIl9jcmVhdGVTaGVldCIsIl9yZW1vdmVTaGVldCIsInN0eWxlTm9kZSIsInJlbCIsIm93bmVyTm9kZSIsImZvckRvY3VtZW50IiwiY2hhciIsImJ5dGUiLCJkZWVwUGFyc2VKc29uIiwianNvblN0cmluZyIsInRoaXNBcmciLCJ0b1N0cmluZ1RhZyIsInNyY1ZhbHVlIiwiY2hyIiwiSUVfUFJPVE8iLCJwcm9jZXNzIiwiYmluZGluZyIsImFyZyIsInNyY0luZGV4IiwiZXZhbHVhdGUiLCJlc2NhcGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJjc3MiLCJwcm90b2NvbCIsImhvc3QiLCJwYXRobmFtZSIsImZ1bGxNYXRjaCIsIm9yaWdVcmwiLCIkMSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiZ3dfc3RhcnRFZGl0aW5nQ2VsbCIsInJvdyIsImNvbEtleSIsImtleVByZXNzIiwiY2hhclByZXNzIiwicm93UGlubmVkIiwiYXBpIiwiZ2V0Um93Tm9kZSIsImdldERpc3BsYXllZFJvd0F0SW5kZXgiLCJzdGFydEVkaXRpbmdDZWxsIiwicm93SW5kZXgiLCJnd19zdG9wRWRpdGluZyIsImNhbmNlbCIsInN0b3BFZGl0aW5nIiwiZ3dfdGFiVG9OZXh0Q2VsbCIsInRhYlRvTmV4dENlbGwiLCJnd190YWJUb1ByZXZpb3VzQ2VsbCIsInRhYlRvUHJldmlvdXNDZWxsIiwiZ3dfc2V0Rm9jdXNlZENlbGwiLCJjb2x1bW4iLCJmbG9hdGluZyIsImdldEVkaXRpbmdDZWxscyIsImYiLCJsYXN0Rm9jdXNlZENlbGwiLCJnZXRGb2N1c2VkQ2VsbCIsImNvbElkIiwiY29sdW1uQXBpIiwiZ2V0QWxsR3JpZENvbHVtbnMiLCJpc0ludGVnZXIiLCJzZXRGb2N1c2VkQ2VsbCIsImd3X2dldFJhbmdlU2VsZWN0aW9ucyIsInJhbmdlcyIsImdldENlbGxSYW5nZXMiLCJnZXRNb2RlbCIsImNvbHVtbnMiLCJhY2N1bXVsYXRvciIsInN0YXJJbmRleCIsInN0YXJ0Um93IiwiZW5kUm93Iiwicm93cyIsImdldFJvdyIsInBhcnNlZE5vZGUiLCJnd19wYXJzZUFkZENlbGxSYW5nZSIsInByIiwiZW5kIiwicm93RGF0YSIsInJvd1N0YXJ0SW5kZXgiLCJyb3dFbmRJbmRleCIsImd3X2FkZENlbGxSYW5nZSIsImFkZENlbGxSYW5nZSIsImd3X2NsZWFyUmFuZ2VTZWxlY3Rpb24iLCJjbGVhclJhbmdlU2VsZWN0aW9uIiwiZ3dfZ2V0Q2hhcnRUb29sYmFySXRlbXMiLCJncmlkT3B0aW9uc1dyYXBwZXIiLCJncmlkT3B0aW9ucyIsImNoYXJ0VG9vbGJhckl0ZW1zIiwiZ3dfYWRkQ2hhcnRSYW5nZSIsImdyaWQiLCJjZWxsUmFuZ2UiLCJyZWYiLCJjcmVhdGVSYW5nZUNoYXJ0IiwidXVpZCIsImNyZWF0ZWRfY2hhcnRzIiwiZ3dfZGVzdHJveUNoYXJ0IiwiZGVzdHJveUNoYXJ0IiwiY2hhcnQiLCJnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyIsImRlZmluaXRpb25zIiwiZGVmIiwiY2hlY2tib3hTZWxlY3Rpb24iLCJnd19pc1Nob3dTZWxlY3Rpb25DaGVja2JveCIsImhlYWRlckNoZWNrYm94U2VsZWN0aW9uIiwiZ3dfaXNIZWFkZXJDaGVja2JveFNlbGVjdGlvbiIsInRvb2x0aXBWYWx1ZUdldHRlckV4cHJlc3Npb24iLCJ0b29sdGlwVmFsdWVHZXR0ZXIiLCJ0b29sdGlwQ29tcG9uZW50IiwiZWRpdGFibGUiLCJyb3dTcGFuIiwiY29sU3BhbiIsImd3X3NldENvbHVtbkRlZmluaXRpb25zIiwiZGVlcFBhcnNlZERlZmluaXRpb25zIiwic2V0Q29sdW1uRGVmcyIsImNvbHVtbkRlZnMiLCJnd19zaXplQ29sdW1uc1RvRml0IiwiY29sdW1uc0FQSSIsInNpemVDb2x1bW5zVG9GaXQiLCJnd19hdXRvU2l6ZUNvbHVtbnMiLCJza2lwSGVhZGVyIiwiYWxsQ29sdW1uSWRzIiwiZ2V0QWxsQ29sdW1ucyIsImF1dG9TaXplQ29sdW1ucyIsImd3X2Vuc3VyZUNvbHVtblZpc2libGUiLCJjb2x1bW5JZCIsImVuc3VyZUNvbHVtblZpc2libGUiLCJnd19zZXRDb2x1bW5XaWR0aCIsInNldENvbHVtbldpZHRoIiwiZ3dfcGluQ29sdW1uIiwicGluIiwic2V0Q29sdW1uUGlubmVkIiwiZ3dfbW92ZUNvbHVtbiIsInRvSW5kZXgiLCJtb3ZlQ29sdW1uIiwicGFyYW0iLCJzaG93U2VsZWN0aW9uQ2hlY2tib3giLCJnZXRBbGxEaXNwbGF5ZWRDb2x1bW5zIiwic2hvd0hlYWRlclNlbGVjdGlvbkNoZWNrYm94IiwiZ3dfYWRkUm93R3JvdXBDb2x1bW4iLCJnd19yZW1vdmVSb3dHcm91cENvbHVtbiIsInJlbW92ZVJvd0dyb3VwQ29sdW1ucyIsImd3X2dldFBpdm90TW9kZSIsImlzUGl2b3RNb2RlIiwiZ3dfc2V0UGl2b3RNb2RlIiwic2V0UGl2b3RNb2RlIiwiZ3dfYWRkUGl2b3RDb2x1bW5zIiwiZ3dfcmVtb3ZlUGl2b3RDb2x1bW5zIiwicmVtb3ZlUGl2b3RDb2x1bW5zIiwiZ3dfYWRkVmFsdWVDb2x1bW5zIiwiYWRkVmFsdWVDb2x1bW5zIiwiZ3dfcmVtb3ZlVmFsdWVDb2x1bW5zIiwicmVtb3ZlVmFsdWVDb2x1bW5zIiwiZ3dfc2V0U29ydE1vZGVsIiwiYXNBcnJheSIsInBhcnNlZE1vZGVsIiwic2V0U29ydE1vZGVsIiwiZ3dfcmVmcmVzaEhlYWRlciIsInJlZHJhd1Jvd3MiLCJnd19zZXRDb2x1bW5WaXNpYmxlIiwidmlzaWJsZSIsInNldENvbHVtbnNWaXNpYmxlIiwiZ3dfYWRkQWxpZ25lZEdyaWQiLCJncmlkSWQiLCJjdXJyZW50R3JpZE9wdGlvbiIsInJlZ2lzdGVyIiwidGFyZ2V0R3JpZE9wdGlvbiIsImFsaWduZWRHcmlkcyIsImd3X3JlbW92ZUFsaWduZWRHcmlkIiwiZ3dfdXBkYXRlQ29udGV4dCIsImd3X2luaXQiLCJsaWNlbnNlIiwiYWdHcmlkIiwiTGljZW5zZU1hbmFnZXIiLCJzZXRMaWNlbnNlS2V5IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb250YWluZXJDbG9uZSIsImNsb25lTm9kZSIsInJlcGxhY2VDaGlsZCIsInBhcnNlZE9wdGlvbnMiLCJnd19wYXJzZU9wdGlvbnMiLCJHcmlkIiwibG9nIiwiZGVlcFBhcnNlZE9wdGlvbnMiLCJnZXREYXRhUGF0aFRlbXBsYXRlIiwiZ2V0RGF0YVBhdGgiLCJkZWJvdW5jZUR1cmF0aW9uIiwiZmluYWxPcHRpb25zIiwiZ2V0RG9jdW1lbnQiLCJvbkNlbGxFZGl0aW5nU3RhcnRlZCIsIm9uQ2VsbEVkaXRpbmdTdG9wcGVkIiwib25DZWxsVmFsdWVDaGFuZ2VkIiwib25Sb3dFZGl0aW5nU3RhcnRlZCIsIm9uUm93VmFsdWVDaGFuZ2VkIiwib25Sb3dFZGl0aW5nU3RvcHBlZCIsIm9uR3JpZFJlYWR5Iiwib25GaWx0ZXJDaGFuZ2VkIiwiZ2V0Um93Tm9kZUlkIiwiZ2V0Q29udGV4dE1lbnVJdGVtcyIsImdldENoYXJ0VG9vbGJhckl0ZW1zIiwicG9wdXBQYXJlbnQiLCJvblJvd0RvdWJsZUNsaWNrZWQiLCJnd19vblJvd0RvdWJsZUNsaWNrZWQiLCJvblJvd0NsaWNrZWQiLCJnd19vblJvd0NsaWNrZWQiLCJvbkNlbGxDbGlja2VkIiwiZ3dfb25DZWxsQ2xpY2tFdmVudCIsIm9uQ2VsbERvdWJsZUNsaWNrZWQiLCJvblNlbGVjdGlvbkNoYW5nZWQiLCJnd19vblNlbGVjdGlvbkNoYW5nZWQiLCJvblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCIsImd3X29uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkIiwiY29tcG9uZW50cyIsIkFnR3JpZENvbXBvbmVudHMiLCJIVE1MVG9vbHRpcCIsIlN1Z2dlc3Rpb25FZGl0b3IiLCJuYXZpZ2F0ZVRvTmV4dENlbGwiLCJ0cmVlRGF0YSIsImdldERhdGFQYXRoVGVtcGxhdGVDb21wbGllZCIsImd3X3NldFN0eWxlIiwiZ3dfcmVtb3ZlU3R5bGUiLCJnd19nZXRDb250ZXh0TWVudSIsImJ1aWxkQ29udGV4dE1lbnVBY3Rpb24iLCJkZXRhaWwiLCJ2IiwicGFyc2VNZW51IiwibWVudSIsImNvbnRleHRNZW51IiwiZ3dfc2hvd0xvYWRpbmdPdmVybGF5Iiwic2hvd0xvYWRpbmdPdmVybGF5IiwiZ3dfc2hvd05vUm93c092ZXJsYXkiLCJzaG93Tm9Sb3dzT3ZlcmxheSIsImd3X2hpZGVPdmVybGF5IiwiaGlkZU92ZXJsYXkiLCJnd19zZXRRdWlja0ZpbHRlciIsInNldFF1aWNrRmlsdGVyIiwiZ3dfZXhwYW5kQWxsIiwiZXhwYW5kQWxsIiwiZ3dfY29sbGFwc2VBbGwiLCJjb2xsYXBzZUFsbCIsImd3X2Vuc3VyZUluZGV4VmlzaWJsZSIsImVuc3VyZU5vZGVWaXNpYmxlIiwiZW5zdXJlSW5kZXhWaXNpYmxlIiwiZ3dfbmF2aWdhdGVUb05leHRSb3ciLCJwcmV2aW91c0NlbGwiLCJwcmV2aW91c0NlbGxQb3NpdGlvbiIsInN1Z2dlc3RlZE5leHRDZWxsIiwibmV4dENlbGxQb3NpdGlvbiIsIktFWV9VUCIsIktFWV9ET1dOIiwiS0VZX0xFRlQiLCJLRVlfUklHSFQiLCJnZXRGaXJzdERpc3BsYXllZFJvdyIsInNldFNlbGVjdGVkIiwiZm9yRWFjaE5vZGUiLCJnZXRMYXN0RGlzcGxheWVkUm93IiwiZ3dfZ2V0Um93Tm9kZUlkIiwiZ3dfc2V0Um93RGF0YSIsImpzb24iLCJzZXRSb3dEYXRhIiwiZ3dfdXBkYXRlUm93RGF0YSIsInRyYW5zYWN0aW9uIiwiYmF0Y2hVcGRhdGUiLCJpdGVtcyIsImFwcGx5VHJhbnNhY3Rpb24iLCJhcHBseVRyYW5zYWN0aW9uQXN5bmMiLCJnd19zZXRSb3dzSGVpZ2h0IiwiaGVpZ2h0Iiwic2V0Um93SGVpZ2h0Iiwib25Sb3dIZWlnaHRDaGFuZ2VkIiwiZ3dfc2V0Um93SGVpZ2h0IiwiZ3dfcmVzZXRSb3dIZWlnaHRzIiwicmVzZXRSb3dIZWlnaHRzIiwiZ3dfc2V0U2VsZWN0ZWRSb3dzIiwiZm9yRWFjaE5vZGVBZnRlckZpbHRlckFuZFNvcnQiLCJleHBhbmRlZCIsIm9uR3JvdXBFeHBhbmRlZE9yQ29sbGFwc2VkIiwiZ3dfc2VsZWN0QWxsIiwiZmlsdGVyZWQiLCJzZWxlY3RBbGxGaWx0ZXJlZCIsInNlbGVjdEFsbCIsImd3X2Rlc2VsZWN0QWxsIiwiZGVzZWxlY3RBbGxGaWx0ZXJlZCIsImRlc2VsZWN0QWxsIiwiZ3dfZ2V0U2VsZWN0ZWRSb3dzIiwiZ2V0U2VsZWN0ZWROb2RlcyIsImd3X2dldFNlbGVjdGVkUm93IiwiZ3dfZ2V0Um93IiwiZ3dfZ2V0Um93cyIsInBoYXNlIiwiZmlsdGVyRXhwcmVzc2lvbiIsImdyb3VwIiwiY2FuUHJvY2VzcyIsIm9sZFZhbHVlIiwiY29sRGVmIiwiZ3JpZEFwaSIsImNvbHVtbkdyb3VwIiwiZ3dfcmVkcmF3Um93cyIsImd3X3NldFBpbm5lZFRvcFJvd0RhdGEiLCJzZXRQaW5uZWRUb3BSb3dEYXRhIiwiZ3dfc2V0UGlubmVkQm90dG9tUm93RGF0YSIsInNldFBpbm5lZEJvdHRvbVJvd0RhdGEiLCJnd19zZXRTdGF0ZSIsInNldENvbHVtblN0YXRlIiwic2V0Q29sdW1uR3JvdXBTdGF0ZSIsImdyb3VwcyIsInNldEZpbHRlck1vZGVsIiwiZmlsdGVycyIsImd3X2dldFN0YXRlIiwiZ2V0Q29sdW1uU3RhdGUiLCJnZXRDb2x1bW5Hcm91cFN0YXRlIiwiZ2V0U29ydE1vZGVsIiwiZ2V0RmlsdGVyTW9kZWwiLCJnd19zZXRTdGF0dXNiYXJDb21wb25lbnRWaXNpYmlsaXR5IiwiZ2V0U3RhdHVzUGFuZWwiLCJzZXRWaXNpYmxlIiwiZ3dfc2V0U2lkZUJhclZpc2libGUiLCJzZXRTaWRlQmFyVmlzaWJsZSIsImd3X29wZW5Ub29scGFuZWwiLCJ0b29scGFuZWxJZCIsIm9wZW5Ub29sUGFuZWwiLCJnd19jbG9zZVRvb2xwYW5lbCIsImNsb3NlVG9vbFBhbmVsIiwiZ3dfc2V0RnVuY3Rpb25zUmVhZE9ubHkiLCJzZXRGdW5jdGlvbnNSZWFkT25seSIsImd3X2dldERvY3VtZW50IiwiJGRvYyIsImd3X2dldFdpbmRvdyIsIiR3bmQiLCJnd19lc2NhcGUiLCJnd191dWlkIiwicmFuZG9tIiwiZ3dfZ2V0R3JpZCIsIkJCakdyaWRFeFdpZGdldCIsInJlZ2lzdGVyZWRHcmlkcyIsImd3X2FkZEdyaWQiLCJlR3VpIiwiaXNIZWFkZXIiLCJpc0dyb3VwZWRIZWFkZXIiLCJ0aGVtZSIsImdyaWRDb3JlIiwiZUdyaWREaXYiLCJlbmRzV2l0aCIsInRvb2x0aXBGaWVsZCIsInBhc3NlZFBhcmFtcyIsInRleHRQYXR0ZXJuIiwidGV4dFJlcXVpcmVkIiwidGV4dFRpdGxlIiwiZGVib3VuY2VXYWl0TXMiLCJfZm9jdXNBZnRlckF0dGFjaGVkIiwiY2VsbFN0YXJ0ZWRFZGl0IiwiX2hpZ2hsaWdodEFsbE9uRm9jdXMiLCJfb25DaGFuZ2UiLCJfcmVuZGVySXRlbVRlbXBsYXRlIiwiaXRlbVRlbXBsYXRlIiwiX3JlbmRlckdyb3VwVGVtcGxhdGUiLCJncm91cFRlbXBsYXRlIiwiX2F1dG9jb21wbGV0ZSIsInByZXZlbnRTdWJtaXQiLCJmZXRjaCIsIl9vbkF1dG9jb21wbGV0ZUZldGNoIiwib25TZWxlY3QiLCJfb25BdXRvY29tcGxldGVTZWxlY3QiLCJyZW5kZXJHcm91cCIsIl9vbkF1dG9jb21wbGV0ZVJlbmRlckdyb3VwIiwicmVuZGVyIiwiX29uQXV0b2NvbXBsZXRlUmVuZGVySXRlbSIsImN1c3RvbWl6ZSIsIl9vbkF1dG9jb21wbGV0ZUN1c3RvbWl6ZSIsImVtcHR5TXNnIiwiZW1wdHlNZXNzYWdlIiwibWluTGVuZ3RoIiwic2hvd09uRm9jdXMiLCJmb2N1c0luIiwiYWxsb3dDdXN0b21WYWx1ZXMiLCJfdmFsaWRhdGVJbnB1dCIsIl9sYXN0RmV0Y2hlZERhdGEiLCJmaWx0ZXJlZEl0ZW1zIiwidGV4dCIsInN1cHByZXNzU3VnZ2VzdGlvbk9uSW52YWxpZElucHV0IiwiZXZlbnRJZCIsImJhc2lzRGlzcGF0Y2hDdXN0b21FdmVudCIsImVHcmlkQ2VsbCIsImZpZWxkIiwiY3VycmVudFZhbHVlIiwiZGl2IiwiZ3JvdXBOYW1lIiwiaW5wdXRSZWN0IiwibWF4SGVpZ2h0IiwiY2hlY2tWYWxpZGl0eSIsIkdXX0VWRU5UX1JPV19TRUxFQ1QiLCJHV19FVkVOVF9ST1dfQ0xJQ0siLCJHV19FVkVOVF9ST1dfRE9VQkxFX0NMSUNLIiwiR1dfRVZFTlRfQ0VMTF9DTElDSyIsIkdXX0VWRU5UX0NFTExfRE9VQkxFX0NMSUNLIiwiR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUQVJURUQiLCJHV19FVkVOVF9DRUxMX0VESVRJTkdfU1RPUFBFRCIsIkdXX0VWRU5UX0NFTExfVkFMVUVfQ0hBTkdFRCIsIkdXX0VWRU5UX1JPV19FRElUSU5HX1NUQVJURUQiLCJHV19FVkVOVF9ST1dfRURJVElOR19TVE9QUEVEIiwiR1dfRVZFTlRfUk9XX1ZBTFVFX0NIQU5HRUQiLCJHV19FVkVOVF9HUklEX1NUQVRFX0NIQU5HRSIsIkdXX0VWRU5UX1JBTkdFX1NFTEVDVElPTl9DSEFOR0VEIiwiR1dfRVZFTlRfS0VZUFJFU1MiLCJHV19FVkVOVF9GSUxURVJfQ0hBTkdFRCIsIkdXX0VWRU5UX1JFQURZIiwiQ0VMTF9FRElUSU5HX0VWRU5UU19NQVAiLCJjZWxsRWRpdGluZ1N0YXJ0ZWQiLCJjZWxsRWRpdGluZ1N0b3BwZWQiLCJjZWxsVmFsdWVDaGFuZ2VkIiwiUk9XX0VESVRJTkdfRVZFTlRTX01BUCIsInJvd0VkaXRpbmdTdGFydGVkIiwicm93RWRpdGluZ1N0b3BwZWQiLCJyb3dWYWx1ZUNoYW5nZWQiLCJnd19vbkNlbGxFZGl0aW5nRXZlbnQiLCJjciIsImd3X29uUm93RWRpdGluZ0V2ZW50IiwiZ3dfb25GaWx0ZXJDaGFuZ2VkIiwiZ3dfb25LZXlkb3duIiwia2V5ZG93bkV2ZW50Iiwia2MiLCJhayIsImFsdEtleSIsInNrIiwiY2siLCJnd19vblJlYWR5RXZlbnQiLCJfZSIsInN0YXRlRGVib3VuY2UiLCJjaGFuZ2VFdmVudCIsIkN1c3RvbUV2ZW50IiwiQ0VMTF9DTElDS0lOR19FVkVOVFNfTUFQIiwiY2VsbENsaWNrZWQiLCJjZWxsRG91YmxlQ2xpY2tlZCIsImd3X29uU3RhdGVDaGFuZ2VkIiwiZ3dfZGVib3VuY2UiLCJsYXRlciIsImNhbGxOb3ciLCJnd19zZW5kRXZlbnQiLCJwYXlsb2FkIiwicmVnaXN0ZXJlZEludGVyZXN0cyIsImludGVyZXN0cyIsImluY2x1ZGVzIiwicGxhdGZvcm0iLCJodG1sdmlld0lkIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImd3X3BhcnNlTm9kZSIsImNoaWxkSW5kZXgiLCJnd19wYXJzZU5vZGVGcm9tRXZlbnQiLCJnd19jb21waWxlRXhwcmVzc2lvbiIsImV4cHJlc3Npb25DYWNoZSIsImZ1bmN0aW9uQm9keSIsInRoZUZ1bmN0aW9uIiwiZ3dfZXhlY3V0ZUV4cHJlc3Npb24iLCJqYXZhU2NyaXB0RnVuY3Rpb24iLCJidWJi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QUEwQztBQUN4QyxZQUFJSCxPQUFPLElBQVBBLFNBQW9CQSxPQUFPLEdBQVBBLEtBQWVBLE9BQU8sR0FBOUMsRUFBSUEsQ0FBSixFQUFzRDtBQUNwRDtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FDL0VGOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUllTTs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7O0FDVmY7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJZUM7OztBQUFBQTtBQUFmO0FBQWVBOzs7Ozs7Ozs7QUNWZjtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDTkE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJZUM7OztBQUFBQTtBQUFmO0FBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1VBQ01BLGE7Ozs7Ozs7Ozs7Ozs7O0FBQ0o7QUFDRjtBQUNBOytCQUNPOUssTSxFQUFRO0FBQUE7O0FBQ1gsZ0JBQUlBLE1BQU0sQ0FBTkEsYUFBSixNQUE4QjtBQUM1Qiw0QkFBYytLLE9BQU8sQ0FBQy9LLE1BQU0sQ0FBNUIsUUFBcUIsQ0FBckI7QUFERixtQkFFTyxJQUFJQSxNQUFNLENBQU5BLGNBQUosTUFBK0I7QUFDcEMsNEJBQWMrSyxPQUFPLENBQUMvSyxNQUFNLENBQTVCLFNBQXFCLENBQXJCO0FBQ0Q7O0FBRUQsOEJBQWtCLFVBQ2hCLDJDQUEyQyxDQUQ3QyxJQUM2QyxDQUEzQyxDQURnQixDQUFsQjtBQUlBLCtCQUFtQixVQUNqQiw0Q0FBNEMsQ0FEOUMsS0FDOEMsQ0FBNUMsQ0FEaUIsQ0FBbkI7QUFJQSxvQ0FBd0IsK0NBR3RCLGdCQUhGLENBR0UsQ0FIc0IsQ0FBeEI7QUFLQSxxQ0FBeUIsZ0RBR3ZCLGlCQUhGLENBR0UsQ0FIdUIsQ0FBekI7QUFNQSw4QkFBa0Isb0JBQW9CLGFBQUM7QUFBQSxxQkFBSWdMLE1BQU0sQ0FBVixDQUFVLENBQVY7QUFBdkMsYUFBa0IsQ0FBbEI7QUFDQSwrQkFBbUIscUJBQXFCLGFBQUM7QUFBQSxxQkFBSUEsTUFBTSxDQUFWLENBQVUsQ0FBVjtBQUF6QyxhQUFtQixDQUFuQjtBQUVBLHNDQUEwQmhMLE1BQU0sQ0FBaEM7O0FBQ0EsZ0JBQUksS0FBSixvQkFBNkI7QUFDM0Isa0JBQUlpTCx5QkFBeUIsR0FDM0JqTCxNQUFNLENBQU5BLGtCQUF5QkEsTUFBTSxDQUFOQSxZQUZBLEVBQzNCLENBRDJCLENBRXNCOztBQUVqRCw2Q0FBK0I7QUFDN0I7QUFERixxQkFFTyxJQUFJQSxNQUFNLENBQU5BLGNBQUosTUFBK0I7QUFDcEMsOEJBQWNBLE1BQU0sQ0FBcEI7QUFESyxxQkFFQTtBQUNMLDhCQUFjQSxNQUFNLENBQXBCO0FBQ0Q7QUFWSCxtQkFXTztBQUNMLDRCQUFjQSxNQUFNLENBQXBCO0FBQ0Q7O0FBRUQsMEJBQWMsbUJBQ1osS0FEWSxRQUVaLEtBRlksWUFHWixLQUhGLFdBQWMsQ0FBZDtBQU1BLDZCQUFpQixJQUFJNEY7QUFBSjtBQUFJQSxhQUFKLENBQWtCLEtBQWxCLFFBQStCLG9CQUFZO0FBQzFELG1CQUFJLENBQUosU0FBYyxLQUFJLENBQUosY0FDWnNGLFFBQVEsQ0FESSxTQUNaQSxFQURZLEVBRVosS0FBSSxDQUZRLFlBR1osS0FBSSxDQUhOLFdBQWMsQ0FBZDtBQURGLGFBQWlCLENBQWpCOztBQU9BO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7bUNBQ1c7QUFDUCxtQkFBTyxlQUFQLE1BQU8sRUFBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUNZO0FBQ1I7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBOzs7OzZDQUNxQjtBQUNqQixnQkFBSSxLQUFKLG9CQUE2QjtBQUMzQjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O3FDQUNhO0FBQ1QsbUJBQU8sY0FBYyxLQUFkLG1CQUFzQyxLQUE3QztBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztvQ0FDWTtBQUNSO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O29DQUNZO0FBQ1I7O0FBQ0E7O0FBQ0E7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBQ2E7QUFDVDs7QUFDQTtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozt3Q0FDZ0J0TSxLLEVBQU91TSxTLEVBQVdDLFUsRUFBWTtBQUMxQyxnQkFBTUMsYUFBYSxHQUFHTCxNQUFNLENBQTVCLEtBQTRCLENBQTVCO0FBRUEsbUJBQU9HLFNBQVMsQ0FBVEEseUJBQW1DLENBQW5DQSxXQUVIQyxVQUFVLENBQVZBLHlCQUFvQyxDQUFwQ0EsWUFGSjtBQUtEOzs7O1FBN0l5QjFOO0FBQUFBO0FBQUFBLE87QUFnSmJvTjs7O0FBQUFBLGlDQUFmLGFBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzS2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztVQUNNcE4sUzs7OztlQU1KNE4sSSxHQUFPLEk7Ozs7OztBQUVQO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7K0JBQ0t0TCxNLEVBQVE7QUFDWHdFLG1CQUFPLENBQVBBLGVBQ0ssaUJBRExBO0FBR0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O21DQUNXO0FBQ1AsbUJBQU8sS0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7Ozs7b0NBQ1ksQ0FDUjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7b0NBQ1l6RSxJLEVBQU1DLE0sRUFBeUI7QUFBQSxnQkFBakJ1TCxRQUFpQix1RUFBTixJQUFNO0FBQ3ZDOztBQUVBLGdCQUFJdkwsTUFBTSxJQUFJQSxNQUFNLENBQU5BLGVBQVZBLElBQVVBLENBQVZBLElBQXlDQSxNQUFNLENBQU5BLElBQU0sQ0FBTkEsS0FBN0MsTUFBb0U7QUFDbEV3TCxvQkFBTSxHQUFHeEwsTUFBTSxDQUFmd0wsSUFBZSxDQUFmQTtBQURGLG1CQUVPO0FBQ0w7QUFDQSxrQkFDRXhMLE1BQU0sQ0FBTkEsNEJBQ0FBLE1BQU0sQ0FBTkEsc0JBREFBLElBQ0FBLENBREFBLElBRUFBLE1BQU0sQ0FBTkEsaUJBSEYsTUFJRTtBQUNBd0wsc0JBQU0sR0FBR3hMLE1BQU0sQ0FBTkEsT0FBVHdMLElBQVN4TCxDQUFUd0w7QUFMRixxQkFNTztBQUNMO0FBQ0Esb0JBQUlDLHlCQUF5QixHQUE3Qjs7QUFDQSxvQkFBSXpMLE1BQU0sQ0FBTkEsZUFBSixTQUFJQSxDQUFKLEVBQXNDO0FBQ3BDeUwsMkNBQXlCLEdBQ3ZCekwsTUFBTSxDQUFOQSxxQ0FBNENBLE1BQU0sQ0FBTkEsUUFEOUN5TDtBQUVEOztBQUVELG9CQUNFQSx5QkFBeUIsSUFDekJBLHlCQUF5QixDQUF6QkEsZUFBeUN6TCxNQUFNLENBQU5BLE9BRHpDeUwsS0FDQUEsQ0FEQUEsSUFFQUEseUJBQXlCLENBQUN6TCxNQUFNLENBQU5BLE9BQTFCeUwsS0FBeUIsQ0FBekJBLGdCQUZBQSxJQUVBQSxDQUZBQSxJQUdBQSx5QkFBeUIsQ0FBQ3pMLE1BQU0sQ0FBTkEsT0FBMUJ5TCxLQUF5QixDQUF6QkEsV0FKRixNQUtFO0FBQ0FELHdCQUFNLEdBQUdDLHlCQUF5QixDQUFDekwsTUFBTSxDQUFOQSxPQUExQnlMLEtBQXlCLENBQXpCQSxDQUFURCxJQUFTQyxDQUFURDtBQU5GLHVCQU9PLElBQ0xDLHlCQUF5QixJQUN6QkEseUJBQXlCLENBQXpCQSxlQURBQSxJQUNBQSxDQURBQSxJQUVBQSx5QkFBeUIsQ0FBekJBLElBQXlCLENBQXpCQSxLQUhLLE1BSUw7QUFDQUQsd0JBQU0sR0FBR0MseUJBQXlCLENBQWxDRCxJQUFrQyxDQUFsQ0E7QUFMSyx1QkFNQTtBQUNMO0FBQ0Esc0JBQU1FLE9BQU8sR0FBRzFMLE1BQU0sQ0FBdEI7O0FBQ0Esc0JBQ0UwTCxPQUFPLElBQ1BBLE9BQU8sQ0FBUEEsZUFEQUEsSUFDQUEsQ0FEQUEsSUFFQUEsT0FBTyxDQUFQQSxJQUFPLENBQVBBLEtBSEYsTUFJRTtBQUNBRiwwQkFBTSxHQUFHRSxPQUFPLENBQWhCRixJQUFnQixDQUFoQkE7QUFMRix5QkFNTztBQUNMO0FBQ0FBLDBCQUFNLEdBQU5BO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsbUJBQU8seUNBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lDQUNTeEwsTSxFQUFRO0FBQ2IsZ0JBQU0yTCxHQUFHLEdBQUcsOENBQVo7O0FBRUEsZ0JBQUksQ0FBSixLQUFVO0FBQ1Isb0JBQU0sVUFBTiw2Q0FBTSxDQUFOO0FBQ0Q7O0FBRUQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2lDQUNTM0wsTSxFQUFRO0FBQ2IsZ0JBQU00TCxHQUFHLEdBQUcsa0RBQVo7O0FBRUEsZ0JBQUksQ0FBSixLQUFVO0FBQ1Isb0JBQU0sVUFBTiwrQ0FBTSxDQUFOO0FBQ0Q7O0FBRUQ7QUFDRDs7Ozs7QUFHWWxPOzs7QUFBQUEsaUNBQWYsU0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqS2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztVQUNNa0ksYTs7OztBQUNKO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0UsaUNBQW1EO0FBQUE7O0FBQUEsY0FBdkNpRyxZQUF1Qyx1RUFBeEIsS0FBd0I7QUFBQSxjQUFqQkMsUUFBaUIsdUVBQU4sSUFBTTs7QUFBQTs7QUFDakQ7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBSmlEO0FBS2xEO0FBRUQ7QUFDRjtBQUNBOzs7OzsrQkFFTzlMLE0sRUFBUTtBQUNYO0FBQ0EsNEJBQWdCLG1CQUFoQixJQUFnQixDQUFoQjtBQUNBLDhCQUFrQixxQkFBbEIsSUFBa0IsQ0FBbEI7QUFFQSx3QkFBWSxrQ0FBWixLQUFZLENBQVo7QUFDQTtBQUNBLGlDQUFxQixDQUFyQjtBQUVBO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7bUNBQ1c7QUFDUCxnQkFBTTRMLEdBQUcsR0FBRyxZQUFZLEtBQXhCLE9BQVksQ0FBWjtBQUVBLGdCQUFNRyxVQUFVLEdBQUdDLFFBQVEsQ0FBUkEsY0FBbkIsS0FBbUJBLENBQW5CO0FBQ0FELHNCQUFVLENBQVZBLFlBSk8sWUFJUEEsQ0FKTyxDQU1QOztBQUNBLDBCQUFjSCxHQUFHLENBQUhBLGNBQWQsT0FBY0EsQ0FBZDtBQUNBLDBDQUF1QmxHLElBQUksQ0FBM0IsTUFBdUJBLEVBQXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQXNCLEtBQXRCLFNBQXNCLEVBQXRCO0FBQ0EsbUNBQXVCLEtBQXZCLFVBQXVCLEVBQXZCO0FBQ0EsbUNBZE8sR0FjUCxDQWRPLENBZ0JQOztBQUNBLGdCQUFNdUcsS0FBSyxHQUFHRCxRQUFRLENBQVJBLGNBQWQsT0FBY0EsQ0FBZDtBQUNBQyxpQkFBSyxDQUFMQTtBQUNBQSxpQkFBSyxDQUFMQSxLQUFLLENBQUxBLEdBQVksWUFBWkE7QUFDQUEsaUJBQUssQ0FBTEE7QUFBa0I7QUFwQlgsdUhBb0JQQSxDQXBCTyxDQXlCUDs7QUFDQUYsc0JBQVUsQ0FBVkEsWUFBdUIsS0FBdkJBO0FBQ0FBLHNCQUFVLENBQVZBO0FBRUFBLHNCQUFVLENBQVZBLDBCQUFxQyxLQUFyQ0E7O0FBQ0Esa0RBQXNDLEtBQXRDOztBQUVBO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBRVk7QUFDUixnQkFBTUEsVUFBVSxHQUFHLHdCQUFuQixhQUFtQixDQUFuQjs7QUFDQUEsc0JBQVUsQ0FBVkEsNkJBQXdDLEtBQXhDQTs7QUFDQSxxREFBeUMsS0FBekM7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztrQ0FDVTtBQUNOOztBQUNBO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O3NDQUNjRCxRLEVBQVU7QUFDcEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7d0NBQ2dCO0FBQ1osbUJBQU8sS0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztxQ0FDYWxOLEssRUFBTztBQUNoQjs7QUFDQSxnQkFBSSxLQUFKLFFBQWlCO0FBQ2Y7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztzQ0FDYztBQUNWLG1CQUFPLEtBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OzttQ0FDVztBQUNQLDRCQUFnQixDQUFDLEtBQWpCLFNBQWlCLEVBQWpCO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O3NDQUNjQSxLLEVBQU87QUFDakI7O0FBQ0EsZ0JBQUksS0FBSixRQUFpQjtBQUNmO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7dUNBQ2U7QUFDWCxtQkFBTyxLQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzttQ0FHV3NOLEMsRUFBRztBQUNWLGdCQUFJLEtBQUosV0FBb0I7QUFDbEI7QUFDRDs7QUFFRDs7QUFFQSxnQkFBSSxLQUFKLFdBQW9CO0FBQ2xCO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBRWFBLEMsRUFBRztBQUNaLGdCQUFJLEtBQUosV0FBb0I7QUFDbEI7QUFDRDs7QUFFRCxnQkFBTXpOLEdBQUcsR0FBR3lOLENBQUMsQ0FBREEsU0FBV0EsQ0FBQyxDQUxaLE9BS1osQ0FMWSxDQU9aOztBQUNBLGdCQUFJek4sR0FBRyxJQUFQLElBQWU7QUFDYjs7QUFDQSxrQkFBSSxLQUFKLFdBQW9CO0FBQ2xCO0FBQ0Q7O0FBQ0R5TixlQUFDLENBQURBO0FBTEYsY0FPQTtBQVBBLGlCQVFLLElBQUl6TixHQUFHLElBQVAsSUFBZTtBQUNsQjs7QUFDQSxvQkFBSSxLQUFKLFdBQW9CO0FBQ2xCO0FBQ0Q7O0FBQ0R5TixpQkFBQyxDQUFEQTtBQUxHLGdCQU9MO0FBUEssbUJBUUEsSUFBSXpOLEdBQUcsSUFBUCxJQUFlO0FBQ2xCOztBQUNBLHNCQUFJLEtBQUosV0FBb0I7QUFDbEI7QUFDRDs7QUFDRHlOLG1CQUFDLENBQURBO0FBQ0Q7QUFDRjs7OztRQXROeUJ4TztBQUFBQTtBQUFBQSxPLHlEQWlCekJ5TztBQUFBQTtBQUFBQSxPLHlJQXNEQUE7QUFBQUE7QUFBQUEsTyw2SUF5RkFDO0FBQUFBO0FBQUFBLE8sZ0pBc0JBQTtBQUFBQTtBQUFBQSxPO0FBbUNZeEc7O0FBQUFBLGlDQUFmLGFBQWVBOzs7Ozs7OztBQzVPZjs7QUFBQTtBQUFBOztBQUFBOztVQUNRakksYyxHQUFtQkMsTSxDQUFuQkQsYzs7QUFFUix5REFBbUQ7QUFBQSxZQUN6Q2tCLFlBRHlDLEdBQ1FnQixVQURSO0FBQUEsWUFDM0JmLFVBRDJCLEdBQ1FlLFVBRFI7QUFBQSxZQUNmd00sV0FEZSxHQUNReE0sVUFEUjtBQUFBLFlBQ0ZqQixLQURFLEdBQ1FpQixVQURSO0FBRWpELGVBQU87QUFDTGhCLHNCQUFZLEVBRFA7QUFFTEMsb0JBQVUsRUFGTDtBQUlMRyxhQUpLLGlCQUlDO0FBQ0o7QUFDQTtBQUNBLGdCQUFJLFNBQUosUUFBcUI7QUFDbkI7QUFDRDs7QUFFRCxnQkFBTXFOLEdBQUcsR0FBR0QsV0FBVyxHQUFHQSxXQUFXLENBQVhBLEtBQUgsSUFBR0EsQ0FBSCxHQUF2QjtBQUVBMU8sMEJBQWMsWUFBWTtBQUN4QmtCLDBCQUFZLEVBRFk7QUFFeEJDLHdCQUFVLEVBRmM7QUFHeEJNLHNCQUFRLEVBSGdCO0FBSXhCUixtQkFBSyxFQUFFME47QUFKaUIsYUFBWixDQUFkM087QUFPQTtBQXBCRztBQXVCTDBCLGFBQUcsRUFBRUM7QUFBQUE7QUFBQUEsYUFBbUIsR0FBbkJBO0FBdkJBLFNBQVA7QUF5QkQ7O0FBRWMsZ0NBQWlDO0FBQUEsMENBQU5DLElBQU07QUFBTkEsY0FBTSxNQUFOQSxHQUFNLGVBQU5BO0FBQU07O0FBQzlDLGVBQU91QztBQUFBQTtBQUFBQSxXQUFRLGdCQUFSQSxFQUFQLElBQU9BLENBQVA7Ozs7Ozs7OztBQ2hDRixVQUFJRyxPQUFPLEdBQUdzSyxtQkFBTyxDQUFyQixFQUFxQixDQUFyQjs7QUFFQSxVQUFHLG1CQUFILFVBQWdDdEssT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBRCxZQUFYRSxFQUFXLENBQUQsQ0FBVkE7QUFFaEM7QUFDQTtBQUlBLFVBQUl1SyxPQUFPLEdBQUc7QUFBQyxlQUFNO0FBQVAsT0FBZDtBQUVBQSxhQUFPLENBQVBBOztBQUNBQSxhQUFPLENBQVBBLGFBQXFCLFlBQVc7QUFDaEIsZUFBT0MsTUFBTSxDQUFOQSxnQkFBUDtBQURoQkQ7O0FBSUEsVUFBSUUsTUFBTSxHQUFHSCxtQkFBTyxDQUFQQSxDQUFPLENBQVBBLFVBQWIsT0FBYUEsQ0FBYjs7QUFFQSxVQUFHdEssT0FBTyxDQUFWLFFBQW1CRixNQUFNLENBQU5BLFVBQWlCRSxPQUFPLENBQXhCRjs7QUFFbkIsaUJBQWUsRTs7Ozs7Ozs7QUNyQmYsaUNBQTJCLG1CQUFPLENBQUMsQ0FBRCxDQUFQLENBQXVELEtBQXZELENBQTNCLEMsQ0FDQTtBQUdBOztBQUNBLG9CQUFjLFFBQWQsRUFBdUIseW9EQUF2QixFQUErcEQsRUFBL3BELEcsQ0FFQTs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQUEsWUFBTSxDQUFOQSxVQUFpQixlQUFlO0FBQzlCO0FBQ0EsWUFBSTRLLFFBQVEsR0FBRyxpQ0FBaUNGLE1BQU0sQ0FBdEQ7O0FBRUEsWUFBSSxDQUFKLFVBQWU7QUFDYixnQkFBTSxVQUFOLGtDQUFNLENBQU47QUFMNEIsVUFRL0I7OztBQUNBLFlBQUksUUFBUSxlQUFaLFVBQXFDO0FBQ25DO0FBQ0E7O0FBRUQsWUFBSUcsT0FBTyxHQUFHRCxRQUFRLENBQVJBLGtCQUEyQkEsUUFBUSxDQUFqRDtBQUNBLFlBQUlFLFVBQVUsR0FBR0QsT0FBTyxHQUFHRCxRQUFRLENBQVJBLDhCQWRHLEdBY0hBLENBQTNCLENBZDhCLENBZ0IvQjs7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdDLFlBQUlHLFFBQVEsR0FBRyxHQUFHLENBQUgsK0RBQW1FLDhCQUE2QjtBQUM5RztBQUNBLGNBQUlDLGVBQWUsR0FBRyxPQUFPLENBQVAsMkJBRUEsaUJBQWU7QUFBRTtBQUZqQixpQ0FHQSxpQkFBZTtBQUFFO0FBTHVFLFdBRXhGLENBQXRCLENBRjhHLENBTzlHOztBQUNBLGNBQUkseURBQUosZUFBSSxDQUFKLEVBQStFO0FBQzdFO0FBVDRHLFlBWTlHOzs7QUFDQTs7QUFFQSxjQUFJQSxlQUFlLENBQWZBLGtCQUFKLEdBQXlDO0FBQ3RDO0FBQ0ZDLGtCQUFNLEdBQU5BO0FBRkQsaUJBR08sSUFBSUQsZUFBZSxDQUFmQSxpQkFBSixHQUF3QztBQUM5QztBQUNBQyxrQkFBTSxHQUFHSixPQUFPLEdBRjhCLGVBRTlDSSxDQUY4QyxDQUVWO0FBRjlCLGlCQUdBO0FBQ047QUFDQUEsa0JBQU0sR0FBR0gsVUFBVSxHQUFHRSxlQUFlLENBQWZBLGlCQUZoQixFQUVnQkEsQ0FBdEJDLENBRk0sQ0FFc0Q7QUF2QmlELFlBMEI5Rzs7O0FBQ0EsaUJBQU8sU0FBUy9KLElBQUksQ0FBSkEsVUFBVCxNQUFTQSxDQUFULEdBQVA7QUFyRThCLFNBMENoQixDQUFmLENBMUMrQixDQXdFL0I7O0FBQ0E7QUF6RURsQjs7Ozs7Ozs7O0FDZEE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJZWtMOzs7QUFBQUE7QUFBZjtBQUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztVQUNNQSxlOzs7O0FBQ0o7QUFDRjtBQUNBOzs7QUFDRSxtQ0FBYztBQUFBOztBQUFBOztBQUNaLDhCQURZLElBQ1osRUFEWSxDQUdaOztBQUNBLHVCQUFZakIsUUFBUSxDQUFSQSxjQUFaLE1BQVlBLENBQVo7QUFDQTtBQUNBO0FBTlk7QUFRYjtBQUVEO0FBQ0Y7QUFDQTs7Ozs7K0JBQ09oTSxNLEVBQVE7QUFDWDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O21DQUNXO0FBQ1AsbUJBQU8sS0FBUDtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUNZO0FBQ1IsZ0JBQUksS0FBSixXQUFvQjtBQUNsQjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7Ozs7a0NBQ1FBLE0sRUFBUWtOLE0sRUFBUTtBQUN0QixnQkFBSXRPLEtBQUssR0FBR29CLE1BQU0sQ0FBTkEsaUJBQXdCQSxNQUFNLENBQTlCQSxpQkFBZ0RBLE1BQU0sQ0FBbEU7O0FBRUEsZ0JBQUlwQixLQUFLLEtBQUxBLFFBQWtCLGlCQUF0QixhQUFvRDtBQUNsRDtBQURGLG1CQUVPO0FBQ0xBLG1CQUFLLEdBQUdvTSxNQUFNLENBQWRwTSxLQUFjLENBQWRBO0FBQ0Esa0JBQU11TyxzQkFBc0IsR0FBR25DLE1BQU0sQ0FDbkMsaURBREYsUUFDRSxDQURtQyxDQUFyQztBQUdBLGtCQUFNb0MsdUJBQXVCLEdBQUdwQyxNQUFNLENBQ3BDLGtEQURGLFFBQ0UsQ0FEb0MsQ0FBdEM7QUFHQSxrQkFBTXFDLGdCQUFnQixHQUFHLFVBQ2YsMkNBQTJDLENBRDVCLElBQzRCLENBQTNDLENBRGUsTUFFbEIsYUFBQztBQUFBLHVCQUFJckMsTUFBTSxDQUFWLENBQVUsQ0FBVjtBQUZSLGVBQXlCLENBQXpCO0FBR0Esa0JBQU1zQyxpQkFBaUIsR0FBRyxVQUNoQiw0Q0FBNEMsQ0FENUIsS0FDNEIsQ0FBNUMsQ0FEZ0IsTUFFbkIsYUFBQztBQUFBLHVCQUFJdEMsTUFBTSxDQUFWLENBQVUsQ0FBVjtBQWJILGVBV3FCLENBQTFCLENBWEssQ0FlTDs7QUFDQSxrQkFBSXFDLGdCQUFnQixDQUFoQkEsaUJBQWtDLENBQXRDLEdBQTBDO0FBQ3hDLG9CQUNFLENBQUNGLHNCQUFzQixDQUF2QixVQUNBQSxzQkFBc0IsS0FGeEIsVUFHRTtBQUNBLHNCQUFNakMsUUFBUSxHQUFHLGtCQUFqQixNQUFpQixDQUFqQjs7QUFDQUEsMEJBQVEsQ0FBUkE7QUFDQTs7QUFDQSx3Q0FBc0JBLFFBQVEsQ0FBOUIsTUFBc0JBLEVBQXRCO0FBUEYsdUJBUU87QUFDTDtBQUNEO0FBWEgsZ0JBYUE7QUFiQSxtQkFjSyxJQUFJb0MsaUJBQWlCLENBQWpCQSxpQkFBbUMsQ0FBdkMsR0FBMkM7QUFDOUMsc0JBQ0UsQ0FBQ0YsdUJBQXVCLENBQXhCLFVBQ0FBLHVCQUF1QixLQUZ6QixVQUdFO0FBQ0Esd0JBQU1sQyxTQUFRLEdBQUcsa0JBQWpCLE1BQWlCLENBQWpCOztBQUNBQSw2QkFBUSxDQUFSQTs7QUFDQTs7QUFDQSwwQ0FBc0JBLFNBQVEsQ0FBOUIsTUFBc0JBLEVBQXRCO0FBUEYseUJBUU87QUFDTDtBQUNEO0FBWEUsdUJBWUU7QUFDTDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3VDQUNlbEwsTSxFQUFRO0FBQ25CLGdCQUFJLENBQUMsS0FBTCxXQUFxQjtBQUNuQiwrQkFBaUIsSUFBSTRGO0FBQXJCO0FBQXFCQSxlQUFKLEVBQWpCOztBQUNBOztBQUNBO0FBQ0Q7O0FBRUQsbUJBQU8sS0FBUDtBQUNEOzs7O1FBcEgyQmxJO0FBQUFBO0FBQUFBLE87QUF1SGZ1UDs7O0FBQUFBLGlDQUFmLGVBQWVBOzs7Ozs7OztBQ3BKZjs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUllTTs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBTUEsVUFBTUMsV0FBVyxHQUFHLFNBQWRBLFdBQWMsU0FBVTtBQUM1QixlQUFPLE1BQU0sQ0FBTiw2QkFHQSxnQkFBSTtBQUFBLGlCQUFJQyxJQUFJLENBQUpBLDBCQUErQkEsSUFBSSxDQUFKQSxNQUFuQyxDQUFtQ0EsQ0FBbkM7QUFISixnQkFBUCxHQUFPLENBQVA7QUFERjs7QUFRQSxVQUFNQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxPQUFRO0FBQ3hCLFlBQU1DLEdBQUcsR0FBRzNCLFFBQVEsQ0FBUkEsY0FBWixLQUFZQSxDQUFaO0FBQ0EyQixXQUFHLENBQUhBO0FBQ0EsZUFBT0EsR0FBRyxDQUFIQSxlQUFtQkEsR0FBRyxDQUF0QkEsYUFBUDtBQUhGO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztVQUNNSixhOzs7O0FBQ0o7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFRTtBQUNGO0FBQ0E7OztBQUNFLGlDQUFjO0FBQUE7O0FBQUE7O0FBQ1o7QUFEWSxnQkFKZEsseUJBSWMsR0FKYyxFQUlkO0FBR1osdUJBQVk1QixRQUFRLENBQVJBLGNBQVosS0FBWUEsQ0FBWjtBQUNBO0FBQ0E7QUFMWTtBQU1iO0FBRUQ7QUFDRjtBQUNBOzs7OzsrQkFFT2hNLE0sRUFBUTtBQUNYLGdCQUFNNk4sU0FBUyxHQUFHN04sTUFBTSxDQUFOQSx1QkFBbEIsaUJBQWtCQSxFQUFsQjtBQUNBLGdCQUFNOE4sYUFBYSxHQUFHLHNDQUF0QixLQUFzQixDQUF0QjtBQUNBLGdCQUFNQyxhQUFhLEdBQUcsc0NBQXRCLEtBQXNCLENBQXRCO0FBQ0EsZ0JBQU1DLGFBQWEsR0FBRyxzQ0FBdEIsS0FBc0IsQ0FBdEI7QUFFQSw4QkFBa0IsVUFDUiwyQ0FBMkMsQ0FEbkMsSUFDbUMsQ0FBM0MsQ0FEUSxNQUVYLGFBQUM7QUFBQSxxQkFBSWhELE1BQU0sQ0FBVixDQUFVLENBQVY7QUFGUixhQUFrQixDQUFsQjtBQUlBLCtCQUFtQixVQUNULDRDQUE0QyxDQURuQyxLQUNtQyxDQUE1QyxDQURTLE1BRVosYUFBQztBQUFBLHFCQUFJQSxNQUFNLENBQVYsQ0FBVSxDQUFWO0FBRlIsYUFBbUIsQ0FBbkI7QUFJQSxrQ0FBc0JBLE1BQU0sQ0FDMUIsK0NBQStDLGdCQURqRCxDQUNpRCxDQUEvQyxDQUQwQixDQUE1QjtBQUlBLG1DQUF1QkEsTUFBTSxDQUMzQixnREFBZ0QsaUJBRGxELENBQ2tELENBQWhELENBRDJCLENBQTdCO0FBSUEsNkNBQWlDLG1EQUcvQjtBQUNFLHNCQUFNNkMsU0FBUyxnQkFFYkwsV0FBVyxDQUFDeEMsTUFBTSxDQUFDLEtBSHZCLGNBR3NCLENBQVAsQ0FGRSxDQURqQjtBQUtFLHVCQUFPNkMsU0FBUyxpQkFFZEwsV0FBVyxDQUFDeEMsTUFBTSxDQUFDLEtBUHZCLGVBT3NCLENBQVAsQ0FGRyxDQUxsQjtBQVNFaUQsbUJBQUssRUFBRUosU0FBUyxpQkFFZEEsU0FBUyxnQkFGSyxjQUVMLENBRks7QUFUbEIsYUFIK0IsQ0FBakM7QUFtQkE7QUFDQTtBQUVBLGtDQUFzQiwrQkE1Q1gsYUE0Q1csQ0FBdEIsQ0E1Q1csQ0E4Q1g7O0FBQ0EsZ0JBQU1LLElBQUksR0FBR2xDLFFBQVEsQ0FBUkEsY0FBYixLQUFhQSxDQUFiO0FBQ0FrQyxnQkFBSSxDQUFKQTtBQUNBQSxnQkFBSSxDQUFKQTtBQUNBQSxnQkFBSSxDQUFKQTtBQUFpQjtBQUFqQkEsa2NBT2MsK0JBUGRBLE1BT2MsQ0FQZEEsb2FBZWMsK0JBZmRBLE9BZWMsQ0FmZEEsOERBbUJRO0FBQ0k7QUFESiw0YkFNWSwrQkFOWiw0RUFuQlJBO0FBaUNBQSxnQkFBSSxDQUFKQSwyQkFBZ0MsS0FBaENBOztBQUVBLGtDQXJGVyxJQXFGWCxFQXJGVyxDQXVGWDs7O0FBQ0EsZ0JBQU1DLGdCQUFnQixHQUFHbkMsUUFBUSxDQUFSQSxjQUF6QixLQUF5QkEsQ0FBekI7QUFDQW1DLDRCQUFnQixDQUFoQkE7QUFDQUEsNEJBQWdCLENBQWhCQTtBQUE2QjtBQUE3QkEsb0dBQ3lFLGtCQUR6RUEsMkNBRWtDTixTQUFTLGdCQUYzQ00sY0FFMkMsQ0FGM0NBLG9HQU15RSxrQkFOekVBLDJDQU9rQ04sU0FBUyxnQkFQM0NNLGNBTzJDLENBUDNDQSxvR0FXeUUsa0JBWHpFQSwyQ0FZa0NOLFNBQVMsZ0JBWjNDTSxjQVkyQyxDQVozQ0E7O0FBa0JBLGdCQUFJTCxhQUFhLElBQWJBLGlCQUFKLGVBQXFEO0FBQ25ESyw4QkFBZ0IsQ0FBaEJBO0FBQ0Q7O0FBRURBLDRCQUFnQixDQUFoQkEsMEJBRUUsS0FGRkE7O0FBS0E7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztvQ0FFWTtBQUNSLGtHQUVpQyxLQUZqQzs7QUFJQSxxR0FFZ0MsS0FGaEM7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3lDQUNpQm5PLE0sRUFBUTtBQUNyQjtBQUNBLGdCQUFNcEIsS0FBSyxHQUFHb00sTUFBTSxFQUNsQjtBQUNBLCtEQUNJLCtCQURKLE1BQ0ksQ0FESixHQUVJLHlCQUpOLE1BSU0sQ0FKYyxDQUFwQjtBQU9BLG1CQUFPLDhCQUNILGlDQUFpQyxDQUQ5QixJQUVILGtDQUFrQyxDQUZ0QztBQUdEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OzsyQ0FDbUI7QUFDZixtQkFDRSw2QkFDQSxxQkFEQSxhQUVBLHFCQUhGO0FBS0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBQ2E7QUFDVCxnQkFBSSxDQUFDLEtBQUwsY0FBSyxFQUFMLEVBQTRCO0FBQzFCO0FBQ0Q7O0FBRUQsZ0JBQU1vRCxLQUFLLEdBQUc7QUFBRXhQLG1CQUFLLEVBQUUsS0FBVDtBQUEyQnlQLHdCQUFVLEVBQUU7QUFBdkMsYUFBZDtBQUNBO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7bUNBQ1dELEssRUFBTztBQUNkO0FBQ0EsK0JBQW1CQSxLQUFLLElBQUlBLEtBQUssQ0FBTEEsZUFBVEEsT0FBU0EsQ0FBVEEsR0FBeUNBLEtBQUssQ0FBOUNBLFFBQW5CO0FBRUEsZ0JBQU1FLGtCQUFrQixHQUFHdEQsTUFBTSxDQUFDLEtBQWxDLFdBQWlDLENBQWpDOztBQUNBLGdCQUFNa0QsSUFBSSxHQUFHLHdCQUFiLHNCQUFhLENBQWI7O0FBQ0FBLGdCQUFJLENBQUpBLGdEQUFxRCxhQUFLO0FBQ3hELGtCQUFJM1AsQ0FBQyxDQUFEQSxTQUFKLG9CQUFtQztBQUNqQ0EsaUJBQUMsQ0FBREE7QUFERixxQkFFTztBQUNMQSxpQkFBQyxDQUFEQTtBQUNEO0FBTEgyUDtBQU9EO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OzsyQ0FDbUJFLEssRUFBTztBQUN0QixnQkFBSSxDQUFKLE9BQVk7QUFDVjtBQUNEOztBQUVELG1CQUFPVixTQUFTLENBQ2RVLEtBQUssQ0FBTEEsbUJBQ0ksK0JBREpBLE1BQ0ksQ0FESkEsR0FFSSwrQkFITixPQUdNLENBSFUsQ0FBaEI7QUFLRDtBQUVEO0FBQ0Y7QUFDQTs7OztrQ0FDVTtBQUNOLGdCQUFNRixJQUFJLEdBQUcsd0JBQWIsc0JBQWEsQ0FBYjs7QUFDQUEsZ0JBQUksQ0FBSkEsZ0RBQXFELGFBQUs7QUFDeEQzUCxlQUFDLENBQURBO0FBREYyUDtBQUlBQSxnQkFBSSxDQUFKQTtBQUNBQSxnQkFBSSxDQUFKQTs7QUFDQSxnQkFBSTtBQUNGQSxrQkFBSSxDQUFKQTtBQURGLGNBRUUsVUFBVTtBQUNWO0FBQ0Q7O0FBRUQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7eUNBQ2lCRixhLEVBQWU5QixDLEVBQUc7QUFDL0IsZ0JBQU1sTixNQUFNLEdBQUdrTixDQUFDLENBQWhCO0FBQ0EsK0JBQW1CbE4sTUFBTSxDQUF6Qjs7QUFFQSxnQkFBTWtQLElBQUksR0FBRyx3QkFBYixzQkFBYSxDQUFiOztBQUVBLHNCQUFVO0FBQ1Isa0JBQUlsUCxNQUFNLENBQU5BLG1CQUFKLFlBQUlBLENBQUosRUFBNkM7QUFDM0NrUCxvQkFBSSxDQUFKQTtBQUNBQSxvQkFBSSxDQUFKQTs7QUFDQSxvQkFBSTtBQUNGQSxzQkFBSSxDQUFKQTtBQURGLGtCQUVFLFVBQVU7QUFDVjtBQUNEO0FBUEgscUJBUU8sSUFBSWxQLE1BQU0sQ0FBTkEsbUJBQUosYUFBSUEsQ0FBSixFQUE4QztBQUNuRGtQLG9CQUFJLENBQUpBO0FBQ0FBLG9CQUFJLENBQUpBOztBQUNBLG9CQUFJO0FBQ0ZBLHNCQUFJLENBQUpBO0FBREYsa0JBRUUsVUFBVTtBQUNWO0FBQ0Q7QUFQSSxxQkFRQTtBQUNMQSxvQkFBSSxDQUFKQTtBQUNBQSxvQkFBSSxDQUFKQTs7QUFDQSxvQkFBSTtBQUNGQSxzQkFBSSxDQUFKQTtBQURGLGtCQUVFLFVBQVU7QUFDVjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxnQkFBSSxVQUFKLGVBQTZCO0FBQzNCO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7dURBRStCaEMsQyxFQUFHO0FBQzlCLGdCQUFNbE4sTUFBTSxHQUFHa04sQ0FBQyxDQUFoQjs7QUFFQSxnQkFBSWxOLE1BQU0sQ0FBTkEsYUFBSixVQUFrQztBQUNoQyxrQkFBSUEsTUFBTSxDQUFOQSxtQkFBSixPQUFJQSxDQUFKLEVBQXdDO0FBQ3RDOztBQUNBO0FBRkYscUJBR08sSUFBSUEsTUFBTSxDQUFOQSxtQkFBSixPQUFJQSxDQUFKLEVBQXdDO0FBQzdDO0FBREsscUJBRUEsSUFBSUEsTUFBTSxDQUFOQSxtQkFBSixPQUFJQSxDQUFKLEVBQXdDO0FBQzdDO0FBQ0Q7QUFDRjtBQUNGOzs7O1FBdFV5QnRCO0FBQUFBO0FBQUFBLE8saUVBcUJ6QnlPO0FBQUFBO0FBQUFBLE8seUlBNEhBQTtBQUFBQTtBQUFBQSxPLGlLQXVLQUM7QUFBQUE7QUFBQUEsTztBQWlCWW1COztBQUFBQSxpQ0FBZixhQUFlQTs7Ozs7OztBQ3JYZixVQUFJdEwsT0FBTyxHQUFHc0ssbUJBQU8sQ0FBckIsRUFBcUIsQ0FBckI7O0FBRUEsVUFBRyxtQkFBSCxVQUFnQ3RLLE9BQU8sR0FBRyxDQUFDLENBQUNGLE9BQUQsWUFBWEUsRUFBVyxDQUFELENBQVZBO0FBRWhDO0FBQ0E7QUFJQSxVQUFJdUssT0FBTyxHQUFHO0FBQUMsZUFBTTtBQUFQLE9BQWQ7QUFFQUEsYUFBTyxDQUFQQTs7QUFDQUEsYUFBTyxDQUFQQSxhQUFxQixZQUFXO0FBQ2hCLGVBQU9DLE1BQU0sQ0FBTkEsZ0JBQVA7QUFEaEJEOztBQUlBLFVBQUlFLE1BQU0sR0FBR0gsbUJBQU8sQ0FBUEEsQ0FBTyxDQUFQQSxVQUFiLE9BQWFBLENBQWI7O0FBRUEsVUFBR3RLLE9BQU8sQ0FBVixRQUFtQkYsTUFBTSxDQUFOQSxVQUFpQkUsT0FBTyxDQUF4QkY7O0FBRW5CLGlCQUFlLEU7Ozs7Ozs7O0FDckJmLGlDQUEyQixtQkFBTyxDQUFDLENBQUQsQ0FBUCxDQUF1RCxLQUF2RCxDQUEzQixDLENBQ0E7QUFHQTs7QUFDQSxvQkFBYyxRQUFkLEVBQXVCLHlMQUF2QixFQUErTSxFQUEvTSxHLENBRUE7Ozs7Ozs7OztBQ1BBOztBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSWV3TTs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7VUFDTUEsWTs7Ozs7Ozs7Ozs7Ozs7QUFDSjtBQUNGO0FBQ0E7K0JBRU92TyxNLEVBQVE7QUFDWCxnQkFBTXdPLEdBQUcsR0FBRyxpQ0FBWixNQUFZLENBQVo7QUFDQSxnQkFBTUMsR0FBRyxHQUFHLGlDQUFaLE1BQVksQ0FBWjtBQUNBLGdCQUFNQyxJQUFJLEdBQUcsa0NBQWIsTUFBYSxDQUFiO0FBQ0EsZ0JBQU1DLElBQUksR0FBRyw2QkFBYixNQUFhLENBQWI7QUFFQTtBQUVBLHVDQUEyQjNPLE1BQU0sQ0FBakM7O0FBQ0EsZ0JBQUksS0FBSixxQkFBOEI7QUFDNUIsa0JBQUlpTCx5QkFBeUIsR0FDM0JqTCxNQUFNLENBQU5BLGtCQUF5QkEsTUFBTSxDQUFOQSxZQUZDLEVBQzVCLENBRDRCLENBRXFCOztBQUVqRCw2Q0FBK0I7QUFDN0I0TywwQkFBVSxHQUFWQTtBQURGLHFCQUVPLElBQUk1TyxNQUFNLENBQVYsV0FBc0I7QUFDM0I0TywwQkFBVSxHQUFHNU8sTUFBTSxDQUFuQjRPO0FBREsscUJBRUE7QUFDTEEsMEJBQVUsR0FBRzVPLE1BQU0sQ0FBbkI0Tzs7QUFDQSxvQkFBSTVPLE1BQU0sQ0FBTkEsWUFBSixLQUE0QjtBQUMxQjtBQUNBO0FBQ0Q7QUFDRjtBQWRILG1CQWVPO0FBQ0w0Tyx3QkFBVSxHQUFHNU8sTUFBTSxDQUFuQjRPO0FBekJTLGNBNEJYOzs7QUFDQSwyQkE3QlcsTUE2QlgsQ0E3QlcsQ0ErQlg7O0FBQ0Esd0JBQVk1QyxRQUFRLENBQVJBLGNBQVosT0FBWUEsQ0FBWjtBQUNBO0FBQ0E7QUFDQTtBQUFzQjtBQW5DWCw2TkFtQ1gsQ0FuQ1csQ0EwQ1g7O0FBQ0EscUNBQXlCdEcsSUFBSSxDQUFKQSwrQkEzQ2QsRUEyQ2NBLENBQXpCLENBM0NXLENBNkNLOztBQUNoQiwwQkFBY3NHLFFBQVEsQ0FBUkEsY0FBZCxPQUFjQSxDQUFkO0FBQ0E7QUFDQSwwQ0FBdUIsS0FBdkI7QUFDQSwrQkFBbUIyQyxJQUFJLFlBQXZCO0FBQ0E7QUFDQSxtQ0FuRFcsQ0FtRFgsQ0FuRFcsQ0FxRFg7O0FBQ0EscUVBQXlELEtBQXpEOztBQUVBLGdCQUFJSCxHQUFHLEtBQVAsTUFBa0I7QUFDaEJHLGtCQUFJLEdBQUksMEJBQUosTUFBc0Msa0JBQTFDQTtBQUNEOztBQUVELGdCQUFJRixHQUFHLEtBQVAsTUFBa0I7QUFDaEJFLGtCQUFJLEdBQUksMEJBQUosTUFBc0Msa0JBQTFDQTtBQUNEOztBQUVELGdCQUFJRCxJQUFJLEtBQVIsTUFBbUI7QUFDakJDLGtCQUFJLEdBQUksMkJBQUosT0FBd0MsbUJBQTVDQTtBQWpFUyxjQW9FWDs7O0FBQ0Esc0JBQVU7QUFDUixrQkFBTUUsaUJBQWlCLEdBQUcsa0RBR3hCLGlDQUhGLE1BR0UsQ0FId0IsQ0FBMUI7QUFLQSxrQkFBTUMsZ0JBQWdCLEdBQUcsaURBR3ZCLG1DQUhGLE1BR0UsQ0FIdUIsQ0FBekI7QUFLQSxrQkFBTUMsa0JBQWtCLEdBQUcsMkNBQTNCLE1BQTJCLENBQTNCOztBQUtBLGtCQUFJRixpQkFBaUIsS0FBckIsTUFBZ0M7QUFDOUI7QUFDRDs7QUFFRCxrQkFBSUMsZ0JBQWdCLEtBQXBCLE1BQStCO0FBQzdCO0FBQ0Q7O0FBRUQsa0JBQUlDLGtCQUFrQixLQUF0QixNQUFpQztBQUMvQjtBQUNEOztBQUVEO0FBQ0Esa0NBQW9CLElBQUlDLEtBQUssQ0FBTEEsYUFBSixZQUFtQztBQUNyREMsd0JBQVEsRUFBRSxDQUFDLEtBRDBDLE1BQzNDLENBRDJDO0FBRXJEO0FBQ0FDLHdCQUFRLEVBQUUsS0FIMkM7QUFJckRDLHlCQUFTLEVBQUUsS0FBS0M7QUFKcUMsZUFBbkMsQ0FBcEI7QUE3QkYsbUJBbUNPO0FBQ0wsc0RBQXdDLEtBQXhDOztBQUNBLG9EQUFzQyxLQUF0Qzs7QUFDQSxxREFBdUMsS0FBdkM7QUFDRDs7QUFFRCxrREFBc0MsS0E5RzNCLG1CQThHWCxFQTlHVyxDQWdIWDs7O0FBQ0E7QUFDQSxnQ0FBb0JULElBQUksSUFBSUEsSUFBSSxDQUFoQztBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUVZO0FBQ1IsZ0JBQUksQ0FBQyxLQUFMLGNBQXdCO0FBQ3RCLHlEQUEyQyxLQUEzQzs7QUFDQSx1REFBeUMsS0FBekM7O0FBQ0Esd0RBQTBDLEtBQTFDO0FBSEYsbUJBSU87QUFDTDtBQUNEOztBQUVELHFEQUF5QyxLQUF6QztBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs2Q0FDcUI7QUFDakIsZ0JBQUksQ0FBQyxLQUFMLGNBQXdCO0FBQ3RCLGtDQUFvQixLQUFwQjtBQUNEOztBQUVELGdCQUFJLEtBQUosc0JBQStCO0FBQzdCO0FBREYsbUJBRU87QUFDTCxrQkFBSSxLQUFKLHFCQUE4QjtBQUM1QjtBQUNEO0FBQ0Y7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBQ2E7QUFDVCxnQkFBTVUsTUFBTSxHQUFHN0osTUFBTSxDQUFDLEtBQXRCLGFBQXFCLENBQXJCO0FBQ0EsZ0JBQU04SixRQUFRLEdBQUc3SixLQUFLLENBQUxBLE1BQUssQ0FBTEEsR0FBZ0IsS0FBaEJBLGdCQUFqQjtBQUNBLG1CQUFPLCtCQUErQix3QkFBdEMsUUFBc0MsQ0FBdEM7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztvQ0FDWTtBQUNSLGdCQUFJLENBQUMsS0FBTCxjQUF3QjtBQUN0QjtBQURGLG1CQUVPO0FBQ0w7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztvQ0FDWTtBQUNSO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBRVk4SixLLEVBQU87QUFDZixnQkFBTUMsT0FBTyxHQUFHLG9CQUFvQkQsS0FBSyxDQUF6QyxNQUFnQixDQUFoQjs7QUFDQSx5QkFBYTtBQUNYLG1DQUFxQixZQUFyQjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsrQ0FFdUJFLE8sRUFBU0MsUSxFQUFVO0FBQ3RDO0FBQ0EsaUJBRnNDLE9BRXRDLEdBRnNDLENBR3RDOztBQUNBLGdCQUFJLEtBQUosZ0NBQXlDO0FBQ3ZDLHFDQUF1QixLQUF2Qjs7QUFDQTtBQUNEO0FBQ0Y7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Z0RBRXdCQyxLLEVBQU9DLEssRUFBTztBQUNsQyxpQkFEa0MsT0FDbEMsR0FEa0MsQ0FFbEM7O0FBQ0EsaUNBQXFCLGFBQXJCOztBQUNBLGdCQUFJLGlCQUFKLFVBQStCO0FBQzdCQSxtQkFBSyxDQUFMQTtBQURGLG1CQUVPO0FBQ0xBLG1CQUFLLENBQUxBLGtCQUF3QkQsS0FBSyxDQUE3QkM7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs4Q0FFc0IxRCxDLEVBQUc7QUFDckIsZ0JBQU16TixHQUFHLEdBQUc4USxLQUFLLENBQUxBLFNBQWVBLEtBQUssQ0FBaEM7QUFFQSxnQkFBTU0sZUFBZSxHQUNuQixHQUFHLEtBQUgsTUFBYztBQUNkcFIsZUFBRyxLQURILE1BQ2M7QUFDZEEsZUFBRyxLQUZILE1BRWM7QUFDZEEsZUFBRyxLQUhILE1BR2M7QUFDZEEsZUFBRyxLQUpILE1BSWM7QUFDZEEsZUFBRyxLQUxILE1BS2M7QUFDZEEsZUFBRyxLQU5ILE1BTWM7QUFDZEEsZUFBRyxLQVBILE1BT2M7QUFDZEEsZUFBRyxLQVpnQixFQUdyQixDQUhxQixDQVlSOztBQUViLGlDQUFxQjtBQUNuQjhRLG1CQUFLLENBRGMsZUFDbkJBLEdBRG1CLENBRW5COztBQUNBO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7NENBRW9CQSxLLEVBQU87QUFDdkIsZ0JBQU1DLE9BQU8sR0FBRyxvQkFBb0JELEtBQUssQ0FBekMsTUFBZ0IsQ0FBaEI7O0FBRUEsZ0JBQUksQ0FBSixTQUFjO0FBQ1o7QUFDRDs7QUFFRCxnQkFBTTlRLEdBQUcsR0FBRzhRLEtBQUssQ0FBTEEsU0FBZUEsS0FBSyxDQUFoQzs7QUFFQSxnQkFBSTlRLEdBQUcsSUFBSEEsTUFBYUEsR0FBRyxJQUFwQixJQUE0QjtBQUMxQjtBQUNBLG1DQUFxQixZQUFyQjtBQUNBOFEsbUJBQUssQ0FBTEE7QUFIRixtQkFJTyxJQUFJOVEsR0FBRyxJQUFIQSxNQUFhQSxHQUFHLEtBQXBCLEdBQTRCO0FBQ2pDO0FBQ0EsbUNBQXFCLFlBQXJCO0FBZnFCLGNBa0J2Qjs7O0FBQ0EsZ0JBQUksS0FBSixnQ0FBeUM7QUFDdkMscUNBQXVCLEtBQXZCOztBQUNBO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3lDQUNpQm1SLEssRUFBTztBQUNwQixnQkFBTUosT0FBTyxHQUFHSSxLQUFLLENBQXJCLGFBQWdCQSxFQUFoQjs7QUFFQSxnQkFBSSxDQUFKLFNBQWM7QUFDWkEsbUJBQUssQ0FBTEE7QUFDQUEsbUJBQUssQ0FBTEEsaUJBRlksa0JBRVpBLEVBRlksQ0FHWjs7QUFDQSxtQ0FBcUIsYUFBckI7QUFKRixtQkFLTztBQUNMQSxtQkFBSyxDQUFMQTtBQUNBQSxtQkFBSyxDQUFMQTtBQUNEOztBQUVEO0FBQ0Q7Ozs7UUF6VHdCbFM7QUFBQUE7QUFBQUEsTyx5REFJeEJ5TztBQUFBQTtBQUFBQSxPLHlJQXlIQUE7QUFBQUE7QUFBQUEsTyw4SUFrRUFDO0FBQUFBO0FBQUFBLE8sMkpBZUFBO0FBQUFBO0FBQUFBLE8sdUtBZ0JBQTtBQUFBQTtBQUFBQSxPLHNLQWlCQUE7QUFBQUE7QUFBQUEsTyxrS0EyQkFBO0FBQUFBO0FBQUFBLE87QUFrRFltQzs7QUFBQUEsaUNBQWYsWUFBZUE7Ozs7Ozs7QUN6VmYsVUFBSXRNLE9BQU8sR0FBR3NLLG1CQUFPLENBQXJCLEVBQXFCLENBQXJCOztBQUVBLFVBQUcsbUJBQUgsVUFBZ0N0SyxPQUFPLEdBQUcsQ0FBQyxDQUFDRixPQUFELFlBQVhFLEVBQVcsQ0FBRCxDQUFWQTtBQUVoQztBQUNBO0FBSUEsVUFBSXVLLE9BQU8sR0FBRztBQUFDLGVBQU07QUFBUCxPQUFkO0FBRUFBLGFBQU8sQ0FBUEE7O0FBQ0FBLGFBQU8sQ0FBUEEsYUFBcUIsWUFBVztBQUNoQixlQUFPQyxNQUFNLENBQU5BLGdCQUFQO0FBRGhCRDs7QUFJQSxVQUFJRSxNQUFNLEdBQUdILG1CQUFPLENBQVBBLENBQU8sQ0FBUEEsVUFBYixPQUFhQSxDQUFiOztBQUVBLFVBQUd0SyxPQUFPLENBQVYsUUFBbUJGLE1BQU0sQ0FBTkEsVUFBaUJFLE9BQU8sQ0FBeEJGOztBQUVuQixpQkFBZSxFOzs7Ozs7OztBQ3JCZixpQ0FBMkIsbUJBQU8sQ0FBQyxDQUFELENBQVAsQ0FBdUQsS0FBdkQsQ0FBM0IsQyxDQUNBO0FBR0E7O0FBQ0Esb0JBQWMsUUFBZCxFQUF1QixxM0JBQXZCLEVBQTI0QixFQUEzNEIsRyxDQUVBOzs7Ozs7Ozs7QUNQQTs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUllK047OztBQUFBQTtBQUFmO0FBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1VBQ01BLFU7Ozs7Ozs7Ozs7Ozs7O0FBQ0o7QUFDRjtBQUNBOytCQUVPOVAsTSxFQUFRO0FBQ1gsZ0JBQU0rUCxPQUFPLEdBQUcsOEJBQWhCLE1BQWdCLENBQWhCO0FBQ0EsZ0JBQU1wSyxRQUFRLEdBQUcsK0JBQWpCLE1BQWlCLENBQWpCO0FBQ0EsZ0JBQU1nSixJQUFJLEdBQUcsMkJBQWIsTUFBYSxDQUFiO0FBQ0EsZ0JBQU1xQixLQUFLLEdBQUcsNEJBQWQsTUFBYyxDQUFkO0FBRUE7QUFFQSx1Q0FBMkJoUSxNQUFNLENBQWpDOztBQUNBLGdCQUFJLEtBQUoscUJBQThCO0FBQzVCLGtCQUFJaUwseUJBQXlCLEdBQzNCakwsTUFBTSxDQUFOQSxrQkFBeUJBLE1BQU0sQ0FBTkEsWUFGQyxFQUM1QixDQUQ0QixDQUVxQjs7QUFFakQsNkNBQStCO0FBQzdCNE8sMEJBQVUsR0FBVkE7QUFERixxQkFFTyxJQUFJNU8sTUFBTSxDQUFWLFdBQXNCO0FBQzNCNE8sMEJBQVUsR0FBRzVPLE1BQU0sQ0FBbkI0TztBQURLLHFCQUVBO0FBQ0xBLDBCQUFVLEdBQUc1TyxNQUFNLENBQW5CNE87O0FBQ0Esb0JBQUk1TyxNQUFNLENBQU5BLFlBQUosS0FBNEI7QUFDMUI7QUFDQTtBQUNEO0FBQ0Y7QUFkSCxtQkFlTztBQUNMNE8sd0JBQVUsR0FBRzVPLE1BQU0sQ0FBbkI0TztBQUNEOztBQUVEO0FBRUEsd0JBQVk1QyxRQUFRLENBQVJBLGNBQVosS0FBWUEsQ0FBWjtBQUNBO0FBQ0E7QUFDQTtBQUFzQjtBQWpDWCw2TkFpQ1gsQ0FqQ1csQ0F3Q1g7O0FBQ0EsMEJBQWNBLFFBQVEsQ0FBUkEsY0FBZCxPQUFjQSxDQUFkO0FBQ0E7QUFFQSwwQ0FBdUJ0RyxJQUFJLENBQUpBLCtCQTVDWixFQTRDWUEsQ0FBdkIsRUE1Q1csQ0E4Q087O0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxxRUFBeUQsS0FBekQ7O0FBRUEsZ0JBQUlxSyxPQUFPLEtBQVgsTUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxnQkFBSXBLLFFBQVEsS0FBWixNQUF1QjtBQUNyQjtBQUNEOztBQUVELGdCQUFJcUssS0FBSyxLQUFULE1BQW9CO0FBQ2xCLGtCQUFJQSxLQUFLLEtBQVQsV0FBeUI7QUFDdkI7QUFDRDtBQUhILG1CQUlPLFVBQVU7QUFDZjtBQWxFUyxjQXFFWDs7O0FBQ0Esc0JBQVU7QUFDUjtBQUNBLGdDQUFrQixJQUFJaEIsS0FBSyxDQUFMQSxhQUFKLFVBQWlDO0FBQ2pEQyx3QkFBUSxFQUFFLENBQUMsS0FEc0MsTUFDdkMsQ0FEdUM7QUFFakRyRCxtQkFBRyxFQUFFLFlBRjRDLE1BRTVDLENBRjRDO0FBR2pEc0Qsd0JBQVEsRUFBRSxLQUh1QztBQUlqREMseUJBQVMsRUFBRSxLQUFLYztBQUppQyxlQUFqQyxDQUFsQjtBQUZGLG1CQVFPO0FBQ0wsc0RBQXdDLEtBQXhDOztBQUNBLG9EQUFzQyxLQUF0Qzs7QUFDQSxvREFBc0MsS0FBdEM7O0FBQ0EscURBQXVDLEtBQXZDO0FBQ0Q7O0FBRUQsa0RBQXNDLEtBckYzQixtQkFxRlgsRUFyRlcsQ0F1Rlg7OztBQUNBO0FBQ0EsZ0NBQW9CdEIsSUFBSSxJQUFJQSxJQUFJLENBQWhDO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBRVk7QUFDUixnQkFBSSxDQUFDLEtBQUwsY0FBd0I7QUFDdEIseURBQTJDLEtBQTNDOztBQUNBLHVEQUF5QyxLQUF6Qzs7QUFDQSx1REFBeUMsS0FBekM7O0FBQ0Esd0RBQTBDLEtBQTFDO0FBSkYsbUJBS087QUFDTDtBQUNEOztBQUVELHFEQUF5QyxLQUF6QztBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs2Q0FDcUI7QUFDakIsZ0JBQUksQ0FBQyxLQUFMLGNBQXdCO0FBQ3RCLGtDQUFvQixLQUFwQjtBQUNEOztBQUVELGdCQUFJLEtBQUosc0JBQStCO0FBQzdCO0FBREYsbUJBRU87QUFDTCxrQkFBSSxLQUFKLHFCQUE4QjtBQUM1QjtBQUNEO0FBQ0Y7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBQ2E7QUFDVCxtQkFBTyx3QkFBd0IsS0FBL0IsYUFBTyxDQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBQ1k7QUFDUjtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztvQ0FDWTtBQUNSO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs2Q0FFcUJjLE8sRUFBU0MsUSxFQUFVRSxLLEVBQU87QUFDM0M7QUFDQUEsaUJBQUssQ0FBTEE7QUFDQSxpQkFIMkMsT0FHM0MsR0FIMkMsQ0FJM0M7O0FBQ0EsZ0JBQUksS0FBSixnQ0FBeUM7QUFDdkMscUNBQXVCLEtBQXZCOztBQUNBO0FBQ0Q7QUFDRjtBQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs4Q0FFc0JELEssRUFBT0MsSyxFQUFPO0FBQ2hDLGlCQURnQyxPQUNoQyxHQURnQyxDQUVoQzs7QUFDQSxpQ0FBcUIsYUFBckI7O0FBQ0EsZ0JBQUksaUJBQUosVUFBK0I7QUFDN0JBLG1CQUFLLENBQUxBO0FBQ0Q7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7OENBRXNCMUQsQyxFQUFHO0FBQ3JCLGdCQUFNek4sR0FBRyxHQUFHOFEsS0FBSyxDQUFMQSxTQUFlQSxLQUFLLENBQWhDO0FBRUEsZ0JBQU1NLGVBQWUsR0FDbkIsR0FBRyxLQUFILE1BQWM7QUFDZHBSLGVBQUcsS0FESCxNQUNjO0FBQ2RBLGVBQUcsS0FGSCxNQUVjO0FBQ2RBLGVBQUcsS0FISCxNQUdjO0FBQ2RBLGVBQUcsS0FKSCxNQUljO0FBQ2RBLGVBQUcsS0FMSCxNQUtjO0FBQ2RBLGVBQUcsS0FOSCxNQU1jO0FBQ2RBLGVBQUcsS0FQSCxNQU9jO0FBQ2RBLGVBQUcsS0FaZ0IsRUFHckIsQ0FIcUIsQ0FZUjs7QUFFYixpQ0FBcUI7QUFDbkI4USxtQkFBSyxDQURjLGVBQ25CQSxHQURtQixDQUVuQjs7QUFDQTtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7OzRDQUVvQkEsSyxFQUFPO0FBQ3ZCLGdCQUFNQyxPQUFPLEdBQUcsb0JBQW9CRCxLQUFLLENBQXpDLE1BQWdCLENBQWhCOztBQUVBLGdCQUFJLENBQUosU0FBYztBQUNaO0FBQ0Q7O0FBRUQsZ0JBQU05USxHQUFHLEdBQUc4USxLQUFLLENBQUxBLFNBQWVBLEtBQUssQ0FBaEM7O0FBRUEsZ0JBQUk5USxHQUFHLElBQUhBLE1BQWFBLEdBQUcsS0FBcEIsR0FBNEI7QUFDMUI7QUFDQSxtQ0FBcUIsWUFBckI7QUFYcUIsY0FjdkI7OztBQUNBLGdCQUFJLEtBQUosZ0NBQXlDO0FBQ3ZDLHFDQUF1QixLQUF2Qjs7QUFDQTtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBRVk4USxLLEVBQU87QUFDZixnQkFBTUMsT0FBTyxHQUFHLG9CQUFvQkQsS0FBSyxDQUF6QyxNQUFnQixDQUFoQjs7QUFDQSx5QkFBYTtBQUNYLG1DQUFxQixZQUFyQjtBQUNEO0FBQ0Y7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt5Q0FDaUJLLEssRUFBTztBQUNwQixnQkFBTUosT0FBTyxHQUFHSSxLQUFLLENBQXJCLGFBQWdCQSxFQUFoQjs7QUFFQSxnQkFBSSxDQUFKLFNBQWM7QUFDWkEsbUJBQUssQ0FBTEE7QUFDQUEsbUJBQUssQ0FBTEEsaUJBRlksa0JBRVpBLEVBRlksQ0FHWjs7QUFDQSxtQ0FBcUIsYUFBckI7QUFKRixtQkFLTztBQUNMQSxtQkFBSyxDQUFMQTtBQUNBQSxtQkFBSyxDQUFMQTtBQUNEOztBQUVEO0FBQ0Q7Ozs7UUF0UnNCbFM7QUFBQUE7QUFBQUEsTyx5REFJdEJ5TztBQUFBQTtBQUFBQSxPLHlJQWdHQUE7QUFBQUE7QUFBQUEsTyx1SkFpRUFDO0FBQUFBO0FBQUFBLE8sbUtBaUJBQTtBQUFBQTtBQUFBQSxPLG9LQWVBQTtBQUFBQTtBQUFBQSxPLGtLQTJCQUE7QUFBQUE7QUFBQUEsTyx3SkF5QkFBO0FBQUFBO0FBQUFBLE87QUFnQ1kwRDs7QUFBQUEsaUNBQWYsVUFBZUE7Ozs7Ozs7QUNuVGYsVUFBSTdOLE9BQU8sR0FBR3NLLG1CQUFPLENBQXJCLEVBQXFCLENBQXJCOztBQUVBLFVBQUcsbUJBQUgsVUFBZ0N0SyxPQUFPLEdBQUcsQ0FBQyxDQUFDRixPQUFELFlBQVhFLEVBQVcsQ0FBRCxDQUFWQTtBQUVoQztBQUNBO0FBSUEsVUFBSXVLLE9BQU8sR0FBRztBQUFDLGVBQU07QUFBUCxPQUFkO0FBRUFBLGFBQU8sQ0FBUEE7O0FBQ0FBLGFBQU8sQ0FBUEEsYUFBcUIsWUFBVztBQUNoQixlQUFPQyxNQUFNLENBQU5BLGdCQUFQO0FBRGhCRDs7QUFJQSxVQUFJRSxNQUFNLEdBQUdILG1CQUFPLENBQVBBLENBQU8sQ0FBUEEsVUFBYixPQUFhQSxDQUFiOztBQUVBLFVBQUd0SyxPQUFPLENBQVYsUUFBbUJGLE1BQU0sQ0FBTkEsVUFBaUJFLE9BQU8sQ0FBeEJGOztBQUVuQixpQkFBZSxFOzs7Ozs7OztBQ3JCZixpQ0FBMkIsbUJBQU8sQ0FBQyxDQUFELENBQVAsQ0FBdUQsS0FBdkQsQ0FBM0IsQyxDQUNBO0FBR0E7O0FBQ0Esb0JBQWMsUUFBZCxFQUF1QiwrMUJBQXZCLEVBQXEzQixFQUFyM0IsRyxDQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1VBQ004RCxnQjs7OztBQUNKO0FBQ0Y7QUFDQTs7O0FBQ0Usb0NBQWM7QUFBQTs7QUFBQTs7QUFDWiw4QkFEWSxJQUNaLEVBRFksQ0FHWjs7QUFDQSx1QkFBWW1HLFFBQVEsQ0FBUkEsY0FBWixLQUFZQSxDQUFaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSWTtBQVNiO0FBRUQ7QUFDRjtBQUNBOzs7OzsrQkFDT2hNLE0sRUFBUTtBQUNYO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7bUNBQ1c7QUFDUCxtQkFBTyxLQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O2tDQUNVQSxNLEVBQVFrTixNLEVBQVE7QUFDdEIsd0JBQVk7QUFDVix1Q0FBeUJnRDtBQUFBQTtBQUFBQSxpQkFDdkIseUNBREYsRUFDRSxDQUR1QkEsQ0FBekI7QUFHRDs7QUFFRDs7QUFFQSxnQkFBSSxPQUFPLEtBQVAsc0JBQUosWUFBa0Q7QUFDaERqTyxxQkFBTyxHQUFHLHVCQUF1QjtBQUFFakMsc0JBQU0sRUFBTkE7QUFBRixlQUF2QixDQUFWaUM7QUFERixtQkFFTztBQUNMQSxxQkFBTyxHQUFHakMsTUFBTSxDQUFOQSxpQkFBd0JBLE1BQU0sQ0FBOUJBLGlCQUFnREEsTUFBTSxDQUFoRWlDO0FBQ0Q7O0FBRUQ7QUFFQTtBQUNEOzs7O1FBdkQ0QnZFO0FBQUFBO0FBQUFBLE87QUEwRGhCbUk7OztBQUFBQSxpQ0FBZixnQkFBZUE7Ozs7Ozs7O0FDaEZmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBWUE7OztBQUNBLFVBQUlzSyxvQkFBb0IsR0FBeEI7QUFBQSxVQUNJQyxtQkFBbUIsR0FEdkI7QUFBQSxVQUVJQyxxQkFBcUIsR0FGekI7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFJQyxZQUFZLEdBQWhCO0FBRUE7O0FBQ0EsVUFBSUMsU0FBUyxHQUFiO0FBRUE7O0FBQ0EsVUFBSUMsaUJBQWlCLEdBQXJCO0FBRUE7O0FBQ0EsVUFBSXBKLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxnREFBMEM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBSXFKLFFBQVEsR0FBR0M7QUFBQUE7QUFBQUEsd0NBQStDQTtBQUE5RDtBQUE4REEsU0FBOUQ7O0FBRUEsWUFBSUMsS0FBSyxJQUFJM0o7QUFBQUE7QUFBQUEsV0FBYyxNQUFkQSxFQUFjLE9BQWRBLEVBQWIsS0FBYUEsQ0FBYixFQUFxRDtBQUNuRHdGLGlCQUFPLEdBQVBBO0FBQ0Q7O0FBQ0RvRSxjQUFNLEdBQUcxSDtBQUFBQTtBQUFBQSxXQUFUMEgsTUFBUzFILENBQVQwSDtBQUNBcEUsZUFBTyxHQUFHcUU7QUFBQUE7QUFBQUEsV0FBWSxFQUFaQSxFQUFZLE9BQVpBLEVBQVksUUFBWkEsRUFBb0NDO0FBQTlDdEU7QUFBOENzRSxTQUFwQ0QsQ0FBVnJFO0FBRUEsWUFBSXVFLE9BQU8sR0FBR0Y7QUFBQUE7QUFBQUEsV0FBWSxFQUFaQSxFQUFpQnJFLE9BQU8sQ0FBWixPQUFacUUsRUFBa0NKLFFBQVEsQ0FBOUIsT0FBWkksRUFBb0RDO0FBQWxFO0FBQWtFQSxTQUFwREQsQ0FBZDtBQUFBLFlBQ0lHLFdBQVcsR0FBRzNTO0FBQUFBO0FBQUFBLFdBRGxCLE9BQ2tCQSxDQURsQjtBQUFBLFlBRUk0UyxhQUFhLEdBQUdDO0FBQUFBO0FBQUFBLFdBQVUsT0FBVkEsRUFGcEIsV0FFb0JBLENBRnBCO0FBSUE7QUFBQTtBQUFBLFlBRUluSyxLQUFLLEdBRlQ7QUFBQSxZQUdJb0ssV0FBVyxHQUFHM0UsT0FBTyxDQUFQQSxlQUhsQjtBQUFBLFlBSUk0RSxNQUFNLEdBcEI4QixVQWdCeEMsQ0FoQndDLENBc0J4Qzs7QUFDQSxZQUFJQyxZQUFZLEdBQUdDLE1BQU0sQ0FDdkIsQ0FBQzlFLE9BQU8sQ0FBUEEsVUFBRCwwQkFDQTJFLFdBQVcsQ0FEWCxlQUVBLENBQUNBLFdBQVcsS0FBS25JO0FBQWhCbUk7QUFBZ0JuSSxTQUFoQm1JLGtCQUFELFdBRkEsZUFHQSxDQUFDM0UsT0FBTyxDQUFQQSxZQUFELFdBSEEsU0FEdUIsTUF2QmUsR0F1QmYsQ0FBekIsQ0F2QndDLENBOEJ4QztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxZQUFJK0UsU0FBUyxHQUFHbEssY0FBYyxDQUFkQSw2QkFDWCxtQkFDQSxDQUFDbUYsT0FBTyxDQUFQQSxZQUFELHVCQURBLEdBQ0EsQ0FEQSxHQURXbkYsT0FBaEI7QUFNQXVKLGNBQU0sQ0FBTkEsc0JBQTZCLHdGQUF1RjtBQUNsSFksMEJBQWdCLEtBQUtBLGdCQUFnQixHQUQ2RSxlQUNsRyxDQUFoQkEsQ0FEa0gsQ0FHbEg7O0FBQ0FKLGdCQUFNLElBQUlSLE1BQU0sQ0FBTkEsZ0RBQXVEYTtBQUppRDtBQUlqREEsV0FBdkRiLENBQVZRLENBSmtILENBTWxIOztBQUNBLDJCQUFpQjtBQUNmTSxzQkFBVSxHQUFWQTtBQUNBTixrQkFBTSxJQUFJLDRCQUFWQTtBQUNEOztBQUNELDZCQUFtQjtBQUNqQk8sd0JBQVksR0FBWkE7QUFDQVAsa0JBQU0sSUFBSSx5QkFBVkE7QUFDRDs7QUFDRCxnQ0FBc0I7QUFDcEJBLGtCQUFNLElBQUksc0NBQVZBO0FBQ0Q7O0FBQ0RySyxlQUFLLEdBQUc2SyxNQUFNLEdBQUdDLEtBQUssQ0FsQjRGLE1Ba0JsSDlLLENBbEJrSCxDQW9CbEg7QUFDQTs7QUFDQTtBQXRCRjZKO0FBeUJBUSxjQUFNLElBakVrQyxNQWlFeENBLENBakV3QyxDQW1FeEM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsWUFBSVUsUUFBUSxHQUFHekssY0FBYyxDQUFkQSw2QkFBNENtRixPQUFPLENBQWxFOztBQUNBLFlBQUksQ0FBSixVQUFlO0FBQ2I0RSxnQkFBTSxHQUFHLDRCQUFUQTtBQXpFc0MsVUEyRXhDOzs7QUFDQUEsY0FBTSxHQUFHLENBQUNPLFlBQVksR0FBR1AsTUFBTSxDQUFOQSw4QkFBSCxFQUFHQSxDQUFILEdBQWIsMEVBNUUrQixLQTRFL0IsQ0FBVEEsQ0E1RXdDLENBZ0Z4Qzs7QUFDQUEsY0FBTSxHQUFHLGVBQWVVLFFBQVEsSUFBdkIsb0JBQ05BLFFBQVEsUUFERixpREFNTkosVUFBVSx3QkFOSixPQVVOQyxZQUFZLEdBQ1Qsb0NBRFMsMERBVk4sa0JBQVRQO0FBa0JBLFlBQUlySixNQUFNLEdBQUdnSztBQUFBQTtBQUFBQSxXQUFRLFlBQVc7QUFDOUIsaUJBQU8vTSxRQUFRLGNBQWN1TSxTQUFTLEdBQVRBLFlBQXRCdk0sTUFBUSxDQUFSQSxrQkFBUCxhQUFPQSxDQUFQO0FBcEdzQyxTQW1HM0IrTSxDQUFiLENBbkd3QyxDQXdHeEM7QUFDQTs7QUFDQWhLLGNBQU0sQ0FBTkE7O0FBQ0EsWUFBSVc7QUFBQUE7QUFBQUEsV0FBSixNQUFJQSxDQUFKLEVBQXFCO0FBQ25CO0FBQ0Q7O0FBQ0Q7QUFDRDtBQUVjd0g7OztBQUFBQSxpQ0FBZixRQUFlQTs7Ozs7Ozs7QUM1UGY7O0FBQUE7QUFBQTs7O0FBQUE7QUFBQTs7O0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJVyxZQUFZLEdBQUdtQjtBQUFBQTtBQUFBQSxTQUFlLGdEQUErQztBQUMvRUM7QUFBQUE7QUFBQUEsV0FBVSxNQUFWQSxFQUFtQkM7QUFBQUE7QUFBQUEsV0FBVCxNQUFTQSxDQUFuQkQsRUFBVSxNQUFWQTtBQURGLE9BQW1CRCxDQUFuQjtBQUllbkI7O0FBQUFBLGlDQUFmLFlBQWVBOzs7Ozs7OztBQ3JDZjs7QUFBQTtBQUFBOzs7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSw2REFBdUQ7QUFDckQsWUFBSXNCLEtBQUssR0FBRyxDQUFaO0FBQ0FyTSxjQUFNLEtBQUtBLE1BQU0sR0FBakJBLEVBQU0sQ0FBTkE7QUFFQSxZQUFJaUIsS0FBSyxHQUFHLENBQVo7QUFBQSxZQUNJSSxNQUFNLEdBQUdpTCxLQUFLLENBRGxCOztBQUdBLGVBQU8sVUFBUCxRQUF5QjtBQUN2QixjQUFJM1QsR0FBRyxHQUFHMlQsS0FBSyxDQUFmLEtBQWUsQ0FBZjtBQUVBLGNBQUk5TixRQUFRLEdBQUcrTixVQUFVLEdBQ3JCQSxVQUFVLENBQUN2TSxNQUFNLENBQVAsR0FBTyxDQUFQLEVBQWNzTCxNQUFNLENBQXBCLEdBQW9CLENBQXBCLGVBRFcsTUFDWCxDQURXLEdBQXpCOztBQUlBLGNBQUk5TSxRQUFRLEtBQVosV0FBNEI7QUFDMUJBLG9CQUFRLEdBQUc4TSxNQUFNLENBQWpCOU0sR0FBaUIsQ0FBakJBO0FBQ0Q7O0FBQ0QscUJBQVc7QUFDVHlCO0FBQUFBO0FBQUFBLGVBQWUsTUFBZkEsRUFBZSxHQUFmQTtBQURGLGlCQUVPO0FBQ0x1TTtBQUFBQTtBQUFBQSxlQUFXLE1BQVhBLEVBQVcsR0FBWEE7QUFDRDtBQUNGOztBQUNEO0FBQ0Q7QUFFY0w7OztBQUFBQSxpQ0FBZixVQUFlQTs7Ozs7Ozs7QUN2Q2Y7O0FBQUE7QUFBQTs7O0FBQUE7QUFHQTs7O0FBQ0EsVUFBSTdLLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsK0NBQXlDO0FBQ3ZDLFlBQUltTCxRQUFRLEdBQUd6TSxNQUFNLENBQXJCLEdBQXFCLENBQXJCOztBQUNBLFlBQUksRUFBRXVCLGNBQWMsQ0FBZEEscUJBQW9DbkM7QUFBQUE7QUFBQUEsV0FBRSxRQUFGQSxFQUF0QyxLQUFzQ0EsQ0FBdEMsS0FDQ3RHLEtBQUssS0FBTEEsYUFBdUIsRUFBRUgsR0FBRyxJQURqQyxNQUM0QixDQUQ1QixFQUMrQztBQUM3Q3NIO0FBQUFBO0FBQUFBLGFBQWUsTUFBZkEsRUFBZSxHQUFmQTtBQUNEO0FBQ0Y7QUFFY3VNOzs7QUFBQUEsaUNBQWYsV0FBZUE7Ozs7Ozs7O0FDM0JmOztBQUFBO0FBQUE7OztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0Esc0NBQWdDO0FBQzlCLFlBQUkxVCxLQUFLLEdBQUc0VDtBQUFBQTtBQUFBQSxXQUFRLE1BQVJBLEVBQVosR0FBWUEsQ0FBWjtBQUNBLGVBQU9DO0FBQUFBO0FBQUFBLDRCQUFQO0FBQ0Q7QUFFY3hNOzs7QUFBQUEsaUNBQWYsU0FBZUE7Ozs7Ozs7O0FDaEJmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFVBQUl5TSxZQUFZLEdBQWhCO0FBRUE7O0FBQ0EsVUFBSUMsWUFBWSxHQUFoQjtBQUVBOztBQUNBLFVBQUlDLFNBQVMsR0FBRzVOLFFBQVEsQ0FBeEI7QUFBQSxVQUNJb0MsV0FBVyxHQUFHeEosTUFBTSxDQUR4QjtBQUdBOztBQUNBLFVBQUlpVixZQUFZLEdBQUdELFNBQVMsQ0FBNUI7QUFFQTs7QUFDQSxVQUFJdkwsY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7O0FBQ0EsVUFBSTBMLFVBQVUsR0FBR3hCLE1BQU0sQ0FBQyxNQUN0QnVCLFlBQVksQ0FBWkEscUhBRHNCLE9BQ3RCQSxDQURzQixHQUF4QixHQUF1QixDQUF2QjtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsbUNBQTZCO0FBQzNCLFlBQUksQ0FBQ2xPO0FBQUFBO0FBQUFBLFdBQUQsS0FBQ0EsQ0FBRCxJQUFvQm9PO0FBQUFBO0FBQUFBLFdBQXhCLEtBQXdCQSxDQUF4QixFQUF5QztBQUN2QztBQUNEOztBQUNELFlBQUloRCxPQUFPLEdBQUczSztBQUFBQTtBQUFBQSxpQ0FBZDtBQUNBLGVBQU8ySyxPQUFPLENBQVBBLEtBQWFpRDtBQUFBQTtBQUFBQSxXQUFwQixLQUFvQkEsQ0FBYmpELENBQVA7QUFDRDtBQUVjMEM7OztBQUFBQSxpQ0FBZixZQUFlQTs7Ozs7Ozs7QUM5Q2Y7O0FBQUE7QUFFQTs7O0FBQ0EsVUFBSXJMLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFJNkwsb0JBQW9CLEdBQUc3TCxXQUFXLENBQXRDO0FBRUE7O0FBQ0EsVUFBSS9ELGNBQWMsR0FBR0M7QUFBQUE7QUFBQUEsVUFBU0E7QUFBQUE7QUFBQUEsUUFBSCxXQUFOQSxHQUFyQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGdDQUEwQjtBQUN4QixZQUFJNFAsS0FBSyxHQUFHN0wsY0FBYyxDQUFkQSxZQUFaLGNBQVlBLENBQVo7QUFBQSxZQUNJZixHQUFHLEdBQUcxSCxLQUFLLENBRGYsY0FDZSxDQURmOztBQUdBLFlBQUk7QUFDRkEsZUFBSyxDQUFMQSxjQUFLLENBQUxBO0FBQ0EsY0FBSThRLFFBQVEsR0FBWjtBQUZGLFVBR0UsVUFBVSxDQUFFOztBQUVkLFlBQUkzSCxNQUFNLEdBQUdrTCxvQkFBb0IsQ0FBcEJBLEtBQWIsS0FBYUEsQ0FBYjs7QUFDQSxzQkFBYztBQUNaLHFCQUFXO0FBQ1RyVSxpQkFBSyxDQUFMQSxjQUFLLENBQUxBO0FBREYsaUJBRU87QUFDTCxtQkFBT0EsS0FBSyxDQUFaLGNBQVksQ0FBWjtBQUNEO0FBQ0Y7O0FBQ0Q7QUFDRDtBQUVjMkU7OztBQUFBQSxpQ0FBZixTQUFlQTs7Ozs7Ozs7QUM3Q2Y7O0FBQ0EsVUFBSTZELFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQUlxVixvQkFBb0IsR0FBRzdMLFdBQVcsQ0FBdEM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxxQ0FBK0I7QUFDN0IsZUFBTzZMLG9CQUFvQixDQUFwQkEsS0FBUCxLQUFPQSxDQUFQO0FBQ0Q7QUFFY3pQOzs7QUFBQUEsaUNBQWYsY0FBZUE7Ozs7Ozs7O0FDckJmOztBQUFBO0FBRUE7OztBQUNBLFVBQUkyUCxVQUFVLEdBQUksWUFBVztBQUMzQixZQUFJQyxHQUFHLEdBQUcsY0FBY0M7QUFBQUE7QUFBQUEsYUFBY0E7QUFBQUE7QUFBQUEsVUFBZEEsUUFBaUNBO0FBQUFBO0FBQUFBLGVBQWpDQSxZQUF4QixFQUFVLENBQVY7QUFDQSxlQUFPRCxHQUFHLEdBQUksbUJBQUosTUFBVjtBQUZGLE9BQWtCLEVBQWxCO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLDhCQUF3QjtBQUN0QixlQUFPLENBQUMsQ0FBRCxjQUFpQkQsVUFBVSxJQUFsQztBQUNEO0FBRWNKOzs7QUFBQUEsaUNBQWYsUUFBZUE7Ozs7Ozs7O0FDbkJmOztBQUFBO0FBRUE7OztBQUNBLFVBQUlNLFVBQVUsR0FBR3pPO0FBQUFBO0FBQUFBLFFBQWpCLG9CQUFpQkEsQ0FBakI7QUFFZXlPOztBQUFBQSxpQ0FBZixVQUFlQTs7Ozs7Ozs7QUNMZjs7QUFDQSxVQUFJVCxTQUFTLEdBQUc1TixRQUFRLENBQXhCO0FBRUE7O0FBQ0EsVUFBSTZOLFlBQVksR0FBR0QsU0FBUyxDQUE1QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLDhCQUF3QjtBQUN0QixZQUFJNU0sSUFBSSxJQUFSLE1BQWtCO0FBQ2hCLGNBQUk7QUFDRixtQkFBTzZNLFlBQVksQ0FBWkEsS0FBUCxJQUFPQSxDQUFQO0FBREYsWUFFRSxVQUFVLENBQUU7O0FBQ2QsY0FBSTtBQUNGLG1CQUFRN00sSUFBSSxHQUFaO0FBREYsWUFFRSxVQUFVLENBQUU7QUFDZjs7QUFDRDtBQUNEO0FBRWNnTjs7O0FBQUFBLGlDQUFmLFFBQWVBOzs7Ozs7OztBQ3pCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHFDQUErQjtBQUM3QixlQUFPbE4sTUFBTSxJQUFOQSxtQkFBNkJBLE1BQU0sQ0FBMUMsR0FBMEMsQ0FBMUM7QUFDRDtBQUVjME07OztBQUFBQSxpQ0FBZixRQUFlQTs7Ozs7Ozs7QUNaZjs7QUFBQTtBQUFBOzs7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSx3Q0FBa0M7QUFDaEMsZUFBTzVMO0FBQUFBO0FBQUFBLFdBQVMsMkJBQTBCO0FBQ3hDLGNBQUlHLEtBQUssR0FBRyxDQUFaO0FBQUEsY0FDSUksTUFBTSxHQUFHbU0sT0FBTyxDQURwQjtBQUFBLGNBRUlqQixVQUFVLEdBQUdsTCxNQUFNLEdBQU5BLElBQWFtTSxPQUFPLENBQUNuTSxNQUFNLEdBQTNCQSxDQUFvQixDQUFwQkEsR0FGakI7QUFBQSxjQUdJd0osS0FBSyxHQUFHeEosTUFBTSxHQUFOQSxJQUFhbU0sT0FBTyxDQUFwQm5NLENBQW9CLENBQXBCQSxHQUhaO0FBS0FrTCxvQkFBVSxHQUFJa0IsUUFBUSxDQUFSQSxjQUF1QixxQkFBeEIsVUFBQ0EsSUFDVHBNLE1BQU0sSUFERSxVQUFDb00sSUFBZGxCOztBQUlBLGNBQUkxQixLQUFLLElBQUkzSjtBQUFBQTtBQUFBQSxhQUFlc00sT0FBTyxDQUFSLENBQVEsQ0FBdEJ0TSxFQUEyQnNNLE9BQU8sQ0FBcEIsQ0FBb0IsQ0FBbEN0TSxFQUFiLEtBQWFBLENBQWIsRUFBNEQ7QUFDMURxTCxzQkFBVSxHQUFHbEwsTUFBTSxHQUFOQSxnQkFBYmtMO0FBQ0FsTCxrQkFBTSxHQUFOQTtBQUNEOztBQUNEckIsZ0JBQU0sR0FBR2xJLE1BQU0sQ0FBZmtJLE1BQWUsQ0FBZkE7O0FBQ0EsaUJBQU8sVUFBUCxRQUF5QjtBQUN2QixnQkFBSXNMLE1BQU0sR0FBR2tDLE9BQU8sQ0FBcEIsS0FBb0IsQ0FBcEI7O0FBQ0Esd0JBQVk7QUFDVkMsc0JBQVEsd0JBQVJBLFVBQVEsQ0FBUkE7QUFDRDtBQUNGOztBQUNEO0FBckJGLFNBQU8zTSxDQUFQO0FBdUJEO0FBRWNvTDs7O0FBQUFBLGlDQUFmLGNBQWVBOzs7Ozs7OztBQ3BDZjs7QUFBQTtBQUVBOzs7QUFDQSxVQUFJd0IsU0FBUyxHQUFHOU4sSUFBSSxDQUFwQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxnREFBMEM7QUFDeEMrTixhQUFLLEdBQUdELFNBQVMsQ0FBQ0MsS0FBSyxLQUFMQSxZQUF1QnpOLElBQUksQ0FBSkEsU0FBdkJ5TixJQUFELE9BQWpCQSxDQUFpQixDQUFqQkE7QUFDQSxlQUFPLFlBQVc7QUFDaEIsY0FBSWxVLElBQUksR0FBUjtBQUFBLGNBQ0l3SCxLQUFLLEdBQUcsQ0FEWjtBQUFBLGNBRUlJLE1BQU0sR0FBR3FNLFNBQVMsQ0FBQ2pVLElBQUksQ0FBSkEsU0FBRCxPQUZ0QixDQUVzQixDQUZ0QjtBQUFBLGNBR0lzSixLQUFLLEdBQUc1RSxLQUFLLENBSGpCLE1BR2lCLENBSGpCOztBQUtBLGlCQUFPLFVBQVAsUUFBeUI7QUFDdkI0RSxpQkFBSyxDQUFMQSxLQUFLLENBQUxBLEdBQWV0SixJQUFJLENBQUNrVSxLQUFLLEdBQXpCNUssS0FBbUIsQ0FBbkJBO0FBQ0Q7O0FBQ0Q5QixlQUFLLEdBQUcsQ0FBUkE7QUFDQSxjQUFJMk0sU0FBUyxHQUFHelAsS0FBSyxDQUFDd1AsS0FBSyxHQUEzQixDQUFxQixDQUFyQjs7QUFDQSxpQkFBTyxVQUFQLE9BQXdCO0FBQ3RCQyxxQkFBUyxDQUFUQSxLQUFTLENBQVRBLEdBQW1CblUsSUFBSSxDQUF2Qm1VLEtBQXVCLENBQXZCQTtBQUNEOztBQUNEQSxtQkFBUyxDQUFUQSxLQUFTLENBQVRBLEdBQW1CL0ssU0FBUyxDQUE1QitLLEtBQTRCLENBQTVCQTtBQUNBLGlCQUFPN007QUFBQUE7QUFBQUEsYUFBSyxJQUFMQSxFQUFLLElBQUxBLEVBQVAsU0FBT0EsQ0FBUDtBQWZGO0FBaUJEO0FBRWNIOzs7QUFBQUEsaUNBQWYsUUFBZUE7Ozs7Ozs7O0FDbkNmOztBQUFBO0FBQUE7OztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSUQsV0FBVyxHQUFHa047QUFBQUE7QUFBQUEsU0FBU0M7QUFBM0I7QUFBMkJBLE9BQVRELENBQWxCO0FBRWVsTjs7QUFBQUEsaUNBQWYsV0FBZUE7Ozs7Ozs7O0FDYmY7O0FBQUE7QUFBQTs7O0FBQUE7QUFBQTs7O0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJbU4sZUFBZSxHQUFHLENBQUNqVztBQUFEO0FBQUNBLE9BQUQsR0FBa0JnSjtBQUFsQjtBQUFrQkEsT0FBbEIsR0FBNkIsd0JBQXVCO0FBQ3hFLGVBQU9oSjtBQUFBQTtBQUFBQSxXQUFjLElBQWRBLEVBQWMsVUFBZEEsRUFBaUM7QUFDdEMsMEJBRHNDO0FBRXRDLHdCQUZzQztBQUd0QyxtQkFBU2tXO0FBQUFBO0FBQUFBLGFBSDZCLE1BRzdCQSxDQUg2QjtBQUl0QyxzQkFBWTtBQUowQixTQUFqQ2xXLENBQVA7QUFERjtBQVNlaVc7O0FBQUFBLGlDQUFmLGVBQWVBOzs7Ozs7OztBQ3JCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSwrQkFBeUI7QUFDdkIsZUFBTyxZQUFXO0FBQ2hCO0FBREY7QUFHRDtBQUVjQzs7O0FBQUFBLGlDQUFmLFFBQWVBOzs7Ozs7OztBQ3pCZjs7QUFDQSxVQUFJQyxTQUFTLEdBQWI7QUFBQSxVQUNJQyxRQUFRLEdBRFo7QUFHQTs7QUFDQSxVQUFJQyxTQUFTLEdBQUd0SixJQUFJLENBQXBCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLDhCQUF3QjtBQUN0QixZQUFJdUosS0FBSyxHQUFUO0FBQUEsWUFDSUMsVUFBVSxHQURkO0FBR0EsZUFBTyxZQUFXO0FBQ2hCLGNBQUlDLEtBQUssR0FBR0gsU0FBWjtBQUFBLGNBQ0lJLFNBQVMsR0FBR0wsUUFBUSxJQUFJSSxLQUFLLEdBRGpDLFVBQ3dCLENBRHhCO0FBR0FELG9CQUFVLEdBQVZBOztBQUNBLGNBQUlFLFNBQVMsR0FBYixHQUFtQjtBQUNqQixnQkFBSSxXQUFKLFdBQTBCO0FBQ3hCLHFCQUFPQyxTQUFTLENBQWhCLENBQWdCLENBQWhCO0FBQ0Q7QUFISCxpQkFJTztBQUNMSixpQkFBSyxHQUFMQTtBQUNEOztBQUNELGlCQUFPak8sSUFBSSxDQUFKQSxpQkFBUCxTQUFPQSxDQUFQO0FBWkY7QUFjRDtBQUVjMk47OztBQUFBQSxpQ0FBZixRQUFlQTs7Ozs7Ozs7QUNwQ2Y7O0FBQUE7QUFBQTs7O0FBQUE7QUFBQTs7O0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSw4QkFBd0I7QUFDdEIsZUFBT3RPO0FBQUFBO0FBQUFBLHFCQUFzQjZDO0FBQUFBO0FBQUFBLFdBQWEsTUFBYkEsRUFBdEI3QyxJQUFzQjZDLENBQXRCN0MsR0FBb0RpUDtBQUFBQTtBQUFBQSxXQUEzRCxNQUEyREEsQ0FBM0Q7QUFDRDtBQUVjcEM7OztBQUFBQSxpQ0FBZixNQUFlQTs7Ozs7Ozs7QUMvQmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHNDQUFnQztBQUM5QixZQUFJbkwsS0FBSyxHQUFHLENBQVo7QUFBQSxZQUNJZ0IsTUFBTSxHQUFHOUQsS0FBSyxDQURsQixDQUNrQixDQURsQjs7QUFHQSxlQUFPLFVBQVAsR0FBb0I7QUFDbEI4RCxnQkFBTSxDQUFOQSxLQUFNLENBQU5BLEdBQWdCZSxRQUFRLENBQXhCZixLQUF3QixDQUF4QkE7QUFDRDs7QUFDRDtBQUNEO0FBRWNDOzs7QUFBQUEsaUNBQWYsU0FBZUE7Ozs7Ozs7O0FDbkJmOztBQUFBO0FBQUE7OztBQUFBO0FBR0E7OztBQUNBLFVBQUlaLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7O0FBQ0EsVUFBSW1OLG9CQUFvQixHQUFHbk4sV0FBVyxDQUF0QztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxVQUFJSyxXQUFXLEdBQUc7QUFBQTtBQUFBLFNBQWdCLFlBQVc7QUFBRTtBQUE3QixPQUFnQixFQUFoQixJQUFzRCtNO0FBQXREO0FBQXNEQSxPQUF0RCxHQUF3RSxpQkFBZ0I7QUFDeEcsZUFBTzlRO0FBQUFBO0FBQUFBLHFCQUF1QjJELGNBQWMsQ0FBZEEsWUFBdkIzRCxRQUF1QjJELENBQXZCM0QsSUFDTCxDQUFDNlEsb0JBQW9CLENBQXBCQSxZQURILFFBQ0dBLENBREg7QUFERjtBQUtlOU07O0FBQUFBLGlDQUFmLFdBQWVBOzs7Ozs7OztBQ25DZjs7QUFBQTtBQUFBOzs7QUFBQTtBQUdBOzs7QUFDQSxVQUFJZ04sT0FBTyxHQUFYO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0Esc0NBQWdDO0FBQzlCLGVBQU8vUTtBQUFBQTtBQUFBQSxxQkFBdUJEO0FBQUFBO0FBQUFBLHFCQUE5QjtBQUNEO0FBRWMrUTs7O0FBQUFBLGlDQUFmLGVBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkZjs7O0FBQ0EsWUFBSUUsV0FBVyxHQUFHLGtFQUF5QyxDQUFDQyxPQUFPLENBQWpELFlBQWxCO0FBRUE7O0FBQ0EsWUFBSUMsVUFBVSxHQUFHRixXQUFXLElBQUkseUNBQWZBLHNCQUFzRCxDQUFDM1MsTUFBTSxDQUE3RDJTLFlBQWpCO0FBRUE7O0FBQ0EsWUFBSUcsYUFBYSxHQUFHRCxVQUFVLElBQUlBLFVBQVUsQ0FBVkEsWUFBbEM7QUFFQTs7QUFDQSxZQUFJRSxNQUFNLEdBQUdELGFBQWEsR0FBR2pRO0FBQUFBO0FBQUFBLFVBQUgsU0FBMUI7QUFFQTs7QUFDQSxZQUFJbVEsY0FBYyxHQUFHRCxNQUFNLEdBQUdBLE1BQU0sQ0FBVCxXQUEzQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsWUFBSW5OLFFBQVEsR0FBR29OLGNBQWMsSUFBSUM7QUFBakM7QUFBaUNBLFNBQWpDO0FBRWVyTjs7QUFBQUEsbUNBQWYsUUFBZUE7Ozs7Ozs7Ozs7QUNyQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsMkJBQXFCO0FBQ25CO0FBQ0Q7QUFFY3FOOzs7QUFBQUEsaUNBQWYsU0FBZUE7Ozs7Ozs7O0FDakJmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBSUE7OztBQUNBLFVBQUlDLGdCQUFnQixHQUFHQztBQUFBQTtBQUFBQSxXQUFZQTtBQUFBQTtBQUFBQSxRQUFuQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSXJOLFlBQVksR0FBR29OLGdCQUFnQixHQUFHRTtBQUFBQTtBQUFBQSxTQUFILGdCQUFHQSxDQUFILEdBQWlDQztBQUFwRTtBQUFvRUEsT0FBcEU7QUFFZXZOOztBQUFBQSxpQ0FBZixZQUFlQTs7Ozs7Ozs7QUMxQmY7O0FBQUE7QUFBQTs7O0FBQUE7QUFBQTs7O0FBQUE7QUFJQTs7O0FBQ0EsVUFBSTRNLE9BQU8sR0FBWDtBQUFBLFVBQ0lZLFFBQVEsR0FEWjtBQUFBLFVBRUlDLE9BQU8sR0FGWDtBQUFBLFVBR0lDLE9BQU8sR0FIWDtBQUFBLFVBSUkvTSxRQUFRLEdBSlo7QUFBQSxVQUtJckMsT0FBTyxHQUxYO0FBQUEsVUFNSXFQLE1BQU0sR0FOVjtBQUFBLFVBT0lDLFNBQVMsR0FQYjtBQUFBLFVBUUlDLFNBQVMsR0FSYjtBQUFBLFVBU0lDLFNBQVMsR0FUYjtBQUFBLFVBVUlDLE1BQU0sR0FWVjtBQUFBLFVBV0lDLFNBQVMsR0FYYjtBQUFBLFVBWUlDLFVBQVUsR0FaZDtBQWNBLFVBQUlDLGNBQWMsR0FBbEI7QUFBQSxVQUNJQyxXQUFXLEdBRGY7QUFBQSxVQUVJQyxVQUFVLEdBRmQ7QUFBQSxVQUdJQyxVQUFVLEdBSGQ7QUFBQSxVQUlJQyxPQUFPLEdBSlg7QUFBQSxVQUtJQyxRQUFRLEdBTFo7QUFBQSxVQU1JQyxRQUFRLEdBTlo7QUFBQSxVQU9JQyxRQUFRLEdBUFo7QUFBQSxVQVFJQyxlQUFlLEdBUm5CO0FBQUEsVUFTSUMsU0FBUyxHQVRiO0FBQUEsVUFVSUMsU0FBUyxHQVZiO0FBWUE7O0FBQ0EsVUFBSUMsY0FBYyxHQUFsQjtBQUNBQSxvQkFBYyxDQUFkQSxVQUFjLENBQWRBLEdBQTZCQSxjQUFjLENBQWRBLFVBQWMsQ0FBZEEsR0FDN0JBLGNBQWMsQ0FBZEEsT0FBYyxDQUFkQSxHQUEwQkEsY0FBYyxDQUFkQSxRQUFjLENBQWRBLEdBQzFCQSxjQUFjLENBQWRBLFFBQWMsQ0FBZEEsR0FBMkJBLGNBQWMsQ0FBZEEsUUFBYyxDQUFkQSxHQUMzQkEsY0FBYyxDQUFkQSxlQUFjLENBQWRBLEdBQWtDQSxjQUFjLENBQWRBLFNBQWMsQ0FBZEEsR0FDbENBLGNBQWMsQ0FBZEEsU0FBYyxDQUFkQSxHQUpBQTtBQUtBQSxvQkFBYyxDQUFkQSxPQUFjLENBQWRBLEdBQTBCQSxjQUFjLENBQWRBLFFBQWMsQ0FBZEEsR0FDMUJBLGNBQWMsQ0FBZEEsY0FBYyxDQUFkQSxHQUFpQ0EsY0FBYyxDQUFkQSxPQUFjLENBQWRBLEdBQ2pDQSxjQUFjLENBQWRBLFdBQWMsQ0FBZEEsR0FBOEJBLGNBQWMsQ0FBZEEsT0FBYyxDQUFkQSxHQUM5QkEsY0FBYyxDQUFkQSxRQUFjLENBQWRBLEdBQTJCQSxjQUFjLENBQWRBLE9BQWMsQ0FBZEEsR0FDM0JBLGNBQWMsQ0FBZEEsTUFBYyxDQUFkQSxHQUF5QkEsY0FBYyxDQUFkQSxTQUFjLENBQWRBLEdBQ3pCQSxjQUFjLENBQWRBLFNBQWMsQ0FBZEEsR0FBNEJBLGNBQWMsQ0FBZEEsU0FBYyxDQUFkQSxHQUM1QkEsY0FBYyxDQUFkQSxNQUFjLENBQWRBLEdBQXlCQSxjQUFjLENBQWRBLFNBQWMsQ0FBZEEsR0FDekJBLGNBQWMsQ0FBZEEsVUFBYyxDQUFkQSxHQVBBQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHVDQUFpQztBQUMvQixlQUFPaFQ7QUFBQUE7QUFBQUEscUJBQ0x5QjtBQUFBQTtBQUFBQSxXQUFTdkcsS0FBSyxDQURUOEUsTUFDTHlCLENBREt6QixJQUNxQixDQUFDLENBQUNnVCxjQUFjLENBQUNqVDtBQUFBQTtBQUFBQSxXQUQ3QyxLQUM2Q0EsQ0FBRCxDQUQ1QztBQUVEO0FBRWMyUjs7O0FBQUFBLGlDQUFmLGdCQUFlQTs7Ozs7Ozs7QUMzRGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsK0JBQXlCO0FBQ3ZCLGVBQU8saUJBQWdCO0FBQ3JCLGlCQUFPcFAsSUFBSSxDQUFYLEtBQVcsQ0FBWDtBQURGO0FBR0Q7QUFFY21QOzs7QUFBQUEsaUNBQWYsU0FBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDWGY7OztBQUNBLFlBQUlULFdBQVcsR0FBRyxrRUFBeUMsQ0FBQ0MsT0FBTyxDQUFqRCxZQUFsQjtBQUVBOztBQUNBLFlBQUlDLFVBQVUsR0FBR0YsV0FBVyxJQUFJLHlDQUFmQSxzQkFBc0QsQ0FBQzNTLE1BQU0sQ0FBN0QyUyxZQUFqQjtBQUVBOztBQUNBLFlBQUlHLGFBQWEsR0FBR0QsVUFBVSxJQUFJQSxVQUFVLENBQVZBLFlBQWxDO0FBRUE7O0FBQ0EsWUFBSStCLFdBQVcsR0FBRzlCLGFBQWEsSUFBSTlQO0FBQUFBO0FBQUFBLFVBQW5DO0FBRUE7O0FBQ0EsWUFBSW1RLFFBQVEsR0FBSSxZQUFXO0FBQ3pCLGNBQUk7QUFDRjtBQUNBLGdCQUFJMEIsS0FBSyxHQUFHaEMsVUFBVSxJQUFJQSxVQUFVLENBQXhCQSxXQUFvQ0EsVUFBVSxDQUFWQSxnQkFBaEQ7O0FBRUEsdUJBQVc7QUFDVDtBQUxBLGNBUUY7OztBQUNBLG1CQUFPK0IsV0FBVyxJQUFJQSxXQUFXLENBQTFCQSxXQUFzQ0EsV0FBVyxDQUFYQSxRQUE3QyxNQUE2Q0EsQ0FBN0M7QUFURixZQVVFLFVBQVUsQ0FBRTtBQVhoQixTQUFnQixFQUFoQjtBQWNlekI7OztBQUFBQSxtQ0FBZixRQUFlQTs7Ozs7Ozs7OztBQzdCZjs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUlBOzs7QUFDQSxVQUFJOU4sV0FBVyxHQUFHeEosTUFBTSxDQUF4QjtBQUVBOztBQUNBLFVBQUl5SixjQUFjLEdBQUdELFdBQVcsQ0FBaEM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxrQ0FBNEI7QUFDMUIsWUFBSSxDQUFDekM7QUFBQUE7QUFBQUEsV0FBTCxNQUFLQSxDQUFMLEVBQXVCO0FBQ3JCLGlCQUFPa1M7QUFBQUE7QUFBQUEsYUFBUCxNQUFPQSxDQUFQO0FBQ0Q7O0FBQ0QsWUFBSUMsT0FBTyxHQUFHeE87QUFBQUE7QUFBQUEsV0FBZCxNQUFjQSxDQUFkO0FBQUEsWUFDSVAsTUFBTSxHQURWOztBQUdBLGFBQUssSUFBTCxlQUF3QjtBQUN0QixjQUFJLEVBQUV0SixHQUFHLElBQUhBLGtCQUF5QnFZLE9BQU8sSUFBSSxDQUFDelAsY0FBYyxDQUFkQSxhQUEzQyxHQUEyQ0EsQ0FBckM1SSxDQUFGLENBQUosRUFBK0U7QUFDN0VzSixrQkFBTSxDQUFOQTtBQUNEO0FBQ0Y7O0FBQ0Q7QUFDRDtBQUVjdU07OztBQUFBQSxpQ0FBZixVQUFlQTs7Ozs7Ozs7QUNoQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLG9DQUE4QjtBQUM1QixZQUFJdk0sTUFBTSxHQUFWOztBQUNBLFlBQUlqQyxNQUFNLElBQVYsTUFBb0I7QUFDbEIsZUFBSyxJQUFMLE9BQWdCbEksTUFBTSxDQUF0QixNQUFzQixDQUF0QixFQUFnQztBQUM5Qm1LLGtCQUFNLENBQU5BO0FBQ0Q7QUFDRjs7QUFDRDtBQUNEO0FBRWM4Tzs7O0FBQUFBLGlDQUFmLFlBQWVBOzs7Ozs7OztBQ25CZjs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJOUUsT0FBTyxHQUFHbkw7QUFBQUE7QUFBQUEsU0FBUyxzQkFBcUI7QUFDMUMsWUFBSTtBQUNGLGlCQUFPQztBQUFBQTtBQUFBQSxhQUFLLElBQUxBLEVBQUssU0FBTEEsRUFBUCxJQUFPQSxDQUFQO0FBREYsVUFFRSxVQUFVO0FBQ1YsaUJBQU82QjtBQUFBQTtBQUFBQSxzQkFBaUIsVUFBeEIsQ0FBd0IsQ0FBeEI7QUFDRDtBQUxILE9BQWM5QixDQUFkO0FBUWVtTDs7QUFBQUEsaUNBQWYsT0FBZUE7Ozs7Ozs7O0FDbENmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBSUE7OztBQUNBLFVBQUkyRCxTQUFTLEdBQWI7QUFFQTs7QUFDQSxVQUFJOUMsU0FBUyxHQUFHNU4sUUFBUSxDQUF4QjtBQUFBLFVBQ0lvQyxXQUFXLEdBQUd4SixNQUFNLENBRHhCO0FBR0E7O0FBQ0EsVUFBSWlWLFlBQVksR0FBR0QsU0FBUyxDQUE1QjtBQUVBOztBQUNBLFVBQUl2TCxjQUFjLEdBQUdELFdBQVcsQ0FBaEM7QUFFQTs7QUFDQSxVQUFJMlAsZ0JBQWdCLEdBQUdsRSxZQUFZLENBQVpBLEtBQXZCLE1BQXVCQSxDQUF2QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLG9DQUE4QjtBQUM1QixZQUFJLENBQUNuUDtBQUFBQTtBQUFBQSxXQUFELEtBQUNBLENBQUQsSUFBd0JEO0FBQUFBO0FBQUFBLHFCQUE1QixXQUE0RDtBQUMxRDtBQUNEOztBQUNELFlBQUk0RSxLQUFLLEdBQUcyTztBQUFBQTtBQUFBQSxXQUFaLEtBQVlBLENBQVo7O0FBQ0EsWUFBSTNPLEtBQUssS0FBVCxNQUFvQjtBQUNsQjtBQUNEOztBQUNELFlBQUlELElBQUksR0FBR2YsY0FBYyxDQUFkQSw4QkFBNkNnQixLQUFLLENBQTdEO0FBQ0EsZUFBTyw2QkFBNkJELElBQUksWUFBakMsUUFDTHlLLFlBQVksQ0FBWkEsY0FERjtBQUVEO0FBRWNwSzs7O0FBQUFBLGlDQUFmLGFBQWVBOzs7Ozs7OztBQzdEZjs7QUFBQTtBQUVBOzs7QUFDQSxVQUFJdU8sWUFBWSxHQUFHcE87QUFBQUE7QUFBQUEsU0FBUWhMLE1BQU0sQ0FBUCxjQUFQZ0wsRUFBbkIsTUFBbUJBLENBQW5CO0FBRWVvTzs7QUFBQUEsaUNBQWYsWUFBZUE7Ozs7Ozs7O0FDTGY7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EseUNBQW1DO0FBQ2pDLGVBQU9qTztBQUFBQTtBQUFBQSxXQUFRLEtBQVJBLEVBQWdCLGVBQWM7QUFDbkMsaUJBQU9qRCxNQUFNLENBQWIsR0FBYSxDQUFiO0FBREYsU0FBT2lELENBQVA7QUFHRDtBQUVjbUk7OztBQUFBQSxpQ0FBZixVQUFlQTs7Ozs7Ozs7QUNsQmY7O0FBQUE7QUFFQTs7O0FBQ0EsVUFBSTlKLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHVFQUFpRTtBQUMvRCxZQUFJbUwsUUFBUSxLQUFSQSxhQUNDck47QUFBQUE7QUFBQUEsV0FBRSxRQUFGQSxFQUFha0MsV0FBVyxDQUF4QmxDLEdBQXdCLENBQXhCQSxLQUFrQyxDQUFDbUMsY0FBYyxDQUFkQSxhQUR4QyxHQUN3Q0EsQ0FEeEMsRUFDMkU7QUFDekU7QUFDRDs7QUFDRDtBQUNEO0FBRWN5Sjs7O0FBQUFBLGlDQUFmLHNCQUFlQTs7Ozs7Ozs7QUM1QmY7O0FBQ0EsVUFBSW1HLGFBQWEsR0FBRztBQUNsQixjQURrQjtBQUVsQixhQUZrQjtBQUdsQixjQUhrQjtBQUlsQixjQUprQjtBQUtsQixrQkFMa0I7QUFNbEIsa0JBQVU7QUFOUSxPQUFwQjtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLHFDQUErQjtBQUM3QixlQUFPLE9BQU9BLGFBQWEsQ0FBM0IsR0FBMkIsQ0FBM0I7QUFDRDtBQUVjeEY7OztBQUFBQSxpQ0FBZixnQkFBZUE7Ozs7Ozs7O0FDckJmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLDRCQUFzQjtBQUNwQixlQUFPcE07QUFBQUE7QUFBQUEscUJBQXNCNkM7QUFBQUE7QUFBQUEsV0FBdEI3QyxNQUFzQjZDLENBQXRCN0MsR0FBOEM2UjtBQUFBQTtBQUFBQSxXQUFyRCxNQUFxREEsQ0FBckQ7QUFDRDtBQUVjN1k7OztBQUFBQSxpQ0FBZixJQUFlQTs7Ozs7Ozs7QUNwQ2Y7O0FBQUE7QUFBQTs7O0FBQUE7QUFHQTs7O0FBQ0EsVUFBSStJLFdBQVcsR0FBR3hKLE1BQU0sQ0FBeEI7QUFFQTs7QUFDQSxVQUFJeUosY0FBYyxHQUFHRCxXQUFXLENBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZ0NBQTBCO0FBQ3hCLFlBQUksQ0FBQ2tCO0FBQUFBO0FBQUFBLFdBQUwsTUFBS0EsQ0FBTCxFQUEwQjtBQUN4QixpQkFBTzZPO0FBQUFBO0FBQUFBLGFBQVAsTUFBT0EsQ0FBUDtBQUNEOztBQUNELFlBQUlwUCxNQUFNLEdBQVY7O0FBQ0EsYUFBSyxJQUFMLE9BQWdCbkssTUFBTSxDQUF0QixNQUFzQixDQUF0QixFQUFnQztBQUM5QixjQUFJeUosY0FBYyxDQUFkQSxxQkFBb0M1SSxHQUFHLElBQTNDLGVBQThEO0FBQzVEc0osa0JBQU0sQ0FBTkE7QUFDRDtBQUNGOztBQUNEO0FBQ0Q7QUFFY21QOzs7QUFBQUEsaUNBQWYsUUFBZUE7Ozs7Ozs7O0FDN0JmOztBQUFBO0FBRUE7OztBQUNBLFVBQUlDLFVBQVUsR0FBR3ZPO0FBQUFBO0FBQUFBLFNBQVFoTCxNQUFNLENBQVAsSUFBUGdMLEVBQWpCLE1BQWlCQSxDQUFqQjtBQUVldU87O0FBQUFBLGlDQUFmLFVBQWVBOzs7Ozs7OztBQ0xmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJekcsZ0JBQWdCLEdBQUc7QUFFckI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Usa0JBQVUwRztBQVJXO0FBUVhBLFNBUlc7O0FBVXJCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG9CQUFZQztBQWhCUztBQWdCVEEsU0FoQlM7O0FBa0JyQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSx1QkFBZXJPO0FBeEJNO0FBd0JOQSxTQXhCTTs7QUEwQnJCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLG9CQWhDcUI7O0FBa0NyQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxtQkFBVztBQUVUO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJLGVBQUs7QUFBRSxzQkFBVXNPO0FBQUFBO0FBQUFBO0FBQVo7QUFSSTtBQXhDVSxPQUF2QjtBQW9EZTVHOztBQUFBQSxpQ0FBZixnQkFBZUE7Ozs7Ozs7O0FDbEVmOztBQUFBO0FBQUE7OztBQUFBO0FBR0E7OztBQUNBLFVBQUk2RyxlQUFlLEdBQW5CO0FBQUEsVUFDSUMsa0JBQWtCLEdBQUdsRyxNQUFNLENBQUNpRyxlQUFlLENBRC9DLE1BQytCLENBRC9CO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsOEJBQXdCO0FBQ3RCM0csY0FBTSxHQUFHMUg7QUFBQUE7QUFBQUEsV0FBVDBILE1BQVMxSCxDQUFUMEg7QUFDQSxlQUFRQSxNQUFNLElBQUk0RyxrQkFBa0IsQ0FBbEJBLEtBQVgsTUFBV0EsQ0FBVjVHLEdBQ0pBLE1BQU0sQ0FBTkEseUJBQWdDNkc7QUFEN0I7QUFDNkJBLFNBQWhDN0csQ0FESUEsR0FBUjtBQUdEO0FBRWMwRzs7O0FBQUFBLGlDQUFmLE1BQWVBOzs7Ozs7OztBQzFDZjs7QUFBQTtBQUVBOzs7QUFDQSxVQUFJSSxXQUFXLEdBQUc7QUFDaEIsYUFEZ0I7QUFFaEIsYUFGZ0I7QUFHaEIsYUFIZ0I7QUFJaEIsYUFKZ0I7QUFLaEIsYUFBSztBQUxXLE9BQWxCO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSUQsY0FBYyxHQUFHRTtBQUFBQTtBQUFBQSxTQUFyQixXQUFxQkEsQ0FBckI7QUFFZUY7O0FBQUFBLGlDQUFmLGNBQWVBOzs7Ozs7OztBQ3BCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxzQ0FBZ0M7QUFDOUIsZUFBTyxlQUFjO0FBQ25CLGlCQUFPM1IsTUFBTSxJQUFOQSxtQkFBNkJBLE1BQU0sQ0FBMUMsR0FBMEMsQ0FBMUM7QUFERjtBQUdEO0FBRWM2Ujs7O0FBQUFBLGlDQUFmLGNBQWVBOzs7Ozs7OztBQ2JmOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBS0E7OztBQUNBLFVBQUlDLFFBQVEsR0FBRyxJQUFmO0FBRUE7O0FBQ0EsVUFBSUMsV0FBVyxHQUFHdlU7QUFBQUE7QUFBQUEsVUFBU0E7QUFBQUE7QUFBQUEsUUFBSCxTQUFOQSxHQUFsQjtBQUFBLFVBQ0l3VSxjQUFjLEdBQUdELFdBQVcsR0FBR0EsV0FBVyxDQUFkLFdBRGhDO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxtQ0FBNkI7QUFDM0I7QUFDQSxZQUFJLGdCQUFKLFVBQThCO0FBQzVCO0FBQ0Q7O0FBQ0QsWUFBSXRRO0FBQUFBO0FBQUFBLFdBQUosS0FBSUEsQ0FBSixFQUFvQjtBQUNsQjtBQUNBLGlCQUFPd0I7QUFBQUE7QUFBQUEsYUFBUSxLQUFSQSxrQkFBUDtBQUNEOztBQUNELFlBQUlnUDtBQUFBQTtBQUFBQSxXQUFKLEtBQUlBLENBQUosRUFBcUI7QUFDbkIsaUJBQU9ELGNBQWMsR0FBR0EsY0FBYyxDQUFkQSxLQUFILEtBQUdBLENBQUgsR0FBckI7QUFDRDs7QUFDRCxZQUFJL1AsTUFBTSxHQUFJbkosS0FBSyxHQUFuQjtBQUNBLGVBQVFtSixNQUFNLElBQU5BLE9BQWtCLElBQUQsS0FBQyxJQUFjLENBQWpDLFFBQUNBLEdBQUQsSUFBQ0EsR0FBUjtBQUNEO0FBRWNrQjs7O0FBQUFBLGlDQUFmLFlBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakNmOzs7QUFDQSxVQUFJK08sU0FBUyxHQUFiO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSwrQkFBeUI7QUFDdkIsZUFBTyw4QkFDSnRVO0FBQUFBO0FBQUFBLHFCQUF1QkQ7QUFBQUE7QUFBQUEscUJBRDFCO0FBRUQ7QUFFY3NVOzs7QUFBQUEsaUNBQWYsUUFBZUE7Ozs7Ozs7O0FDNUJmOztBQUNBLFVBQUlYLFFBQVEsR0FBWjtBQUVlQTs7QUFBQUEsaUNBQWYsUUFBZUE7Ozs7Ozs7O0FDSGY7O0FBQ0EsVUFBSUMsVUFBVSxHQUFkO0FBRWVBOztBQUFBQSxpQ0FBZixVQUFlQTs7Ozs7Ozs7QUNIZjs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUllWTs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7VUFDTUEsYTs7Ozs7Ozs7Ozs7Ozs7QUFDSjtBQUNGO0FBQ0E7a0NBQ1VqWSxNLEVBQVFrTixNLEVBQVE7QUFDdEIsZ0JBQU10TyxLQUFLLEdBQUdvQixNQUFNLENBQXBCO0FBQ0EsZ0JBQU1rWSxVQUFVLEdBQUcsNkNBQW5CLE1BQW1CLENBQW5CO0FBQ0EsZ0JBQU1DLFdBQVcsR0FBRyw4Q0FBcEIsTUFBb0IsQ0FBcEI7QUFDQSxnQkFBSUMsU0FBUyxHQUFHLG9DQUFoQixNQUFnQixDQUFoQjs7QUFFQSxnQkFBSTtBQUNGQSx1QkFBUyxHQUFHblYsSUFBSSxDQUFKQSxNQUFabVYsU0FBWW5WLENBQVptVjtBQURGLGNBRUUsVUFBVTtBQUNWQSx1QkFBUyxHQUFHQSxTQUFTLElBQXJCQTtBQUNEO0FBRUQ7OztBQUNBLGdCQUFJQSxTQUFTLElBQUlBLFNBQVMsQ0FBVEEsZUFBakIsS0FBaUJBLENBQWpCLEVBQWtEO0FBQ2hEcFksb0JBQU0sQ0FBTkE7QUFBd0I7QUFBeEJBLHlEQUVXb1ksU0FBUyxDQUFDcFksTUFBTSxDQUYzQkEsS0FFb0IsQ0FGcEJBO0FBREYsbUJBUU87QUFDTEEsb0JBQU0sQ0FBTkE7QUFDRDs7QUFFRDtBQUNEOzs7O1FBOUJ5QjZGO0FBQUFBO0FBQUFBLE87QUFpQ2JvUzs7O0FBQUFBLGlDQUFmLGFBQWVBOzs7Ozs7OztBQzFEZjs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUllSTs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBU0EsVUFBTUMsTUFBTSxHQUFHO0FBQ2JDLG1CQUFXLEVBREU7QUFFYkMsdUJBQWUsRUFGRjtBQUdiQyxrQkFBVSxFQUhHO0FBSWJDLHFCQUFhLEVBSkE7QUFLYkMsbUJBQVcsRUFMRTtBQU1iQyxpQkFBUyxFQU5JO0FBT2JDLGdCQUFRLEVBQUU7QUFQRyxPQUFmOztVQVdNQyxjLEdBRExDO0FBQUFBO0FBQUFBLFM7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkF5QkNDLGdCLEdBQW1CLElBQUluTztBQUFKO0FBQUlBLFdBQUosRTtnQkFLbkJvTyxzQixHQUF5QixJQUFJcE87QUFBSjtBQUFJQSxXQUFKLEU7Z0JBT3pCcU8sYyxHQUFpQixFO2dCQU9qQkMsYyxHQUFpQixDQUFDLEM7Ozs7Ozs7QUFDbEI7QUFDRjtBQUNBOytCQUVPblosTSxFQUFRO0FBQUE7QUFBQTs7QUFDWCxnQkFBTTZOLFNBQVMsR0FBRzdOLE1BQU0sQ0FBTkEsdUJBQWxCLGlCQUFrQkEsRUFBbEI7QUFFQSxrQ0FBc0Isd0NBQXdDLENBQzVEc1ksTUFBTSxDQURzRCxhQUU1REEsTUFBTSxDQUZzRCxpQkFHNURBLE1BQU0sQ0FIc0QsWUFJNURBLE1BQU0sQ0FKc0QsZUFLNURBLE1BQU0sQ0FMUixXQUE4RCxDQUF4QyxDQUF0QjtBQVFBLGtDQUFzQix3Q0FHcEIsNEJBQTRCQSxNQUFNLENBQWxDLGVBQWtELENBQWxELElBQ0lBLE1BQU0sQ0FEVixjQUVJLG9CQUxOLENBS00sQ0FMZ0IsQ0FBdEI7QUFRQSw4QkFBa0IsS0FBbEI7QUFFQSxnQkFBTWMsbUJBQW1CLHFFQUN0QmQsTUFBTSxDQURnQixhQUNEekssU0FBUyxDQUFDeUssTUFBTSxDQUFQLGFBRFIsUUFDUSxDQURSLHlDQUV0QkEsTUFBTSxDQUZnQixpQkFFR3pLLFNBQVMsQ0FBQ3lLLE1BQU0sQ0FBUCxhQUZaLFdBRVksQ0FGWix5Q0FHdEJBLE1BQU0sQ0FIZ0IsWUFHRnpLLFNBQVMsQ0FBQ3lLLE1BQU0sQ0FBUCxZQUhQLFdBR08sQ0FIUCx5Q0FJdEJBLE1BQU0sQ0FKZ0IsZUFJQ3pLLFNBQVMsQ0FBQ3lLLE1BQU0sQ0FBUCxlQUpWLGNBSVUsQ0FKVix5Q0FLdEJBLE1BQU0sQ0FMZ0IsYUFLRHpLLFNBQVMsQ0FBQ3lLLE1BQU0sQ0FBUCxhQUxSLFVBS1EsQ0FMUixHQUF6QixvQkFBeUIsQ0FBekI7QUFRQSx3QkFBWXRNLFFBQVEsQ0FBUkEsY0FBWixLQUFZQSxDQUFaO0FBQ0E7QUFDQTtBQUFzQjtBQUF0Qix5RkFFSSxnREFGSiwwQkFJTSx3QkFDQSxrQkFBTTtBQUFBO0FBQUk7QUFBSix3R0FHRlIsTUFBTSxLQUFLLE1BQUksQ0FBZkEsOEJBSEUsNENBS0E0TixtQkFBbUIsQ0FMbkIsTUFLbUIsQ0FMbkI7QUFBQTtBQUxaLGFBSU0sQ0FKTjs7QUFzQkE7O0FBQ0EscUNBQXlCdk87QUFBQUE7QUFBQUEsY0FBekIsaUJBQXdELHdCQUFnQjtBQUN0RSxvQkFBSSxDQUFKOztBQUNBLG9CQUFJLENBQUosT0FBWWlPLGNBQWMsQ0FBMUIsc0JBQWlELE1BQUksQ0FBckQ7QUFGRjs7QUFLQTs7QUFDQSwyQ0FDRWpPO0FBQUFBO0FBQUFBLGNBREYsaUJBRUUsd0JBQWdCO0FBQ2Qsb0JBQUksQ0FBSjs7QUFDQSxvQkFBSSxDQUFKLE9BQVlpTyxjQUFjLENBQTFCLHNCQUFpRCxNQUFJLENBQXJEO0FBSko7O0FBUUEsd0VBRWUsc0JBRmYsTUFFZSxFQUZmOztBQUdBLHNFQUVlLDRCQUZmLE1BRWUsRUFGZjs7QUFJQSxnQkFBTU8sTUFBTSxHQUFHLHdCQUFmLG1CQUFlLENBQWY7O0FBQ0FBLGtCQUFNLENBQU5BLDJCQUFrQyxLQUFsQ0E7QUFFQSwwQkFBYyxLQUFkO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7b0NBRVk7QUFDUixxQkFBU1AsY0FBYyxDQUF2Qjs7QUFDQTs7QUFDQTs7QUFDQSx1RkFFaUMsS0FGakM7O0FBR0E7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztrQ0FDVTtBQUNOO0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsd0JBQVlBLGNBQWMsQ0FBMUIsc0JBQWlELEtBQWpEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O21DQUNXUSxLLEVBQU87QUFDZEEsaUJBQUssR0FBR0EsS0FBSyxJQUFiQTtBQUNBLGdDQUFvQkEsS0FBSyxDQUFMQSxVQUFwQjtBQUNBLGtDQUFzQkEsS0FBSyxDQUFMQSxZQUF0QjtBQUNBLDhCQUFrQkEsS0FBSyxDQUFMQSxRQUFjLEtBQWhDO0FBRUEsZ0JBQU1DLEdBQUcsR0FBRyxLQUFaO0FBQ0EsZ0JBQU1DLGFBQWEsR0FBRyxLQUF0QjtBQUNBLGdCQUFNQyxRQUFRLEdBQUdGLEdBQUcsQ0FBSEEsY0FBakIsbUJBQWlCQSxDQUFqQjtBQUNBLGdCQUFNRyxXQUFXLEdBQUcsS0FBcEI7QUFDQSxnQkFBTUMsYUFBYSxHQUFHLEtBQXRCO0FBRUFGLG9CQUFRLENBQVJBLGdCQUF5QkQsYUFBYSxDQUFiQSxRQUFzQixXQUEvQ0MsSUFBeUJELENBQXpCQztBQUNBQyx1QkFBVyxDQUFYQSxRQUFvQixXQUFwQkE7QUFDQUMseUJBQWEsQ0FBYkEsUUFBc0IsV0FkUixRQWNkQSxFQWRjLENBZ0JkO0FBQ0E7O0FBQ0EsZ0JBQUksaUJBQUosVUFBK0I7QUFDN0Isa0JBQU1DLEdBQUcsR0FBRzVOLFFBQVEsQ0FBUkEsWUFBWixZQUFZQSxDQUFaO0FBQ0E0TixpQkFBRyxDQUFIQTtBQUNBSCxzQkFBUSxDQUFSQTtBQUhGLG1CQUlPO0FBQ0xBLHNCQUFRLENBQVJBO0FBQ0Q7O0FBRUQsd0JBQVlYLGNBQWMsQ0FBMUIsc0JBQWlELEtBQWpEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O3dDQUVnQjVNLEMsRUFBRztBQUNmLGdCQUFNMk4sRUFBRSxHQUFHM04sQ0FBQyxDQUFaOztBQUNBLGdCQUFNNE4sWUFBWSxHQUFHLHdCQUFyQixvQkFBcUIsQ0FBckI7O0FBRUEsOEJBQWtCRCxFQUFFLENBQUZBLFFBQVdBLEVBQUUsQ0FBYkEsZUFBbEI7O0FBRUEsZ0JBQUksb0JBQW9CdkIsTUFBTSxDQUE5QixhQUE0QztBQUMxQ3dCLDBCQUFZLENBQVpBO0FBREYsbUJBRU87QUFDTEEsMEJBQVksQ0FBWkE7QUFDRDs7QUFFRCx3QkFBWWhCLGNBQWMsQ0FBMUIsc0JBQWlELEtBQWpEO0FBQ0Q7Ozs7UUFoTjBCcGI7QUFBQUE7QUFBQUEsTyxXQVFwQnFjLG9CLEdBQXVCLHFDLHVFQUQ3QkM7QUFBQUE7QUFBQUEsTzs7Ozs7Ozt5RkFPQUE7QUFBQUE7QUFBQUEsTzs7Ozs7aUJBQ087QUFDTnRWLGdCQUFJLEVBQUU0VCxNQUFNLENBRE47QUFFTjJCLGtCQUFNLEVBRkE7QUFHTkMsb0JBQVEsRUFBRTtBQUhKLFc7O2dFQWdDUC9OO0FBQUFBO0FBQUFBLE8sNElBcUZBQTtBQUFBQTtBQUFBQSxPLHFKQThEQUM7QUFBQUE7QUFBQUEsTyxxR0FuTUYyTSxLOztVQXFOS29CLGtCLEdBRExwQjtBQUFBQTtBQUFBQSxTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJBMEJDcUIsb0IsR0FBdUIsb0I7aUJBS3ZCQyxxQixHQUF3QixvQjtpQkFLeEJDLGMsR0FBaUIsSTtpQkFPakJDLE8sR0FBVSxJOzs7Ozs7O0FBQ1Y7QUFDRjtBQUNBOytCQUVPdmEsTSxFQUFRO0FBQ1gsZ0JBQU02TixTQUFTLEdBQUc3TixNQUFNLENBQU5BLHVCQUFsQixpQkFBa0JBLEVBQWxCO0FBRUE7O0FBRUE7O0FBQ0EseUNBQ0U4WSxjQUFjLENBRGhCLHNCQUVFLEtBRkY7O0FBS0E7O0FBQ0EsMENBQ0VBLGNBQWMsQ0FEaEIsc0JBRUUsS0FGRjs7QUFJQTs7QUFFQSx3QkFBWTlNLFFBQVEsQ0FBUkEsY0FBWixLQUFZQSxDQUFaO0FBQ0E7O0FBQ0Esa0NBQXNCLDBCQXBCWCxNQW9CVyxFQUF0QixFQXBCVyxDQXNCWDs7O0FBQ0EsZ0JBQU13TyxLQUFLLEdBQUcsTUFBTTlVLElBQUksQ0FBSkEsZ0NBQXBCLENBQW9CQSxDQUFwQjtBQUFBLGdCQUNNK1UsS0FBSyxHQUFHLE1BQU0vVSxJQUFJLENBQUpBLGdDQURwQixDQUNvQkEsQ0FEcEI7QUFHQSxrQ0FBc0JzRyxRQUFRLENBQVJBLGNBQXRCLEtBQXNCQSxDQUF0QjtBQUNBO0FBQ0E7QUFBZ0M7QUFBaEMscVNBR1E2QixTQUFTLGlCQUhqQixLQUdpQixDQUhqQiw2UkFPRXlLLE1BQU0sQ0FQUiw2VkFjUXpLLFNBQVMsZ0JBZGpCLElBY2lCLENBZGpCLGdSQWtCRXlLLE1BQU0sQ0FsQlI7O0FBdUJBLGtDQUFzQixLQUF0Qjs7QUFDQSwyREFBK0MsS0FBL0M7O0FBRUEsa0NBQXNCLDJCQUF0QixNQUFzQixFQUF0QjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUVZO0FBQ1I7O0FBQ0E7O0FBQ0EsOERBQWtELEtBQWxEOztBQUNBLHFCQUFTNkIsa0JBQWtCLENBQTNCO0FBQ0E7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztrQ0FDVTtBQUNOOztBQUNBOztBQUNBLHdCQUFZckIsY0FBYyxDQUExQixzQkFBaUQsS0FBakQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7bUNBQ1dRLEssRUFBTztBQUFBOztBQUNkQSxpQkFBSyxHQUFHQSxLQUFLLElBQWJBO0FBQ0Esa0NBQXNCQSxLQUFLLENBQUxBLFlBQWtCaEIsTUFBTSxDQUE5QztBQUNBLG9DQUF3QmdCLEtBQUssQ0FBTEEsY0FBeEI7QUFDQSxvQ0FBd0JBLEtBQUssQ0FBTEEsY0FBeEI7O0FBRUEsK0NBQW1DLFdBQW5DOztBQUNBLGdEQUFvQyxXQUFwQzs7QUFDQSxrRUFBc0QsaUJBQVM7QUFDN0Qsa0JBQUkxSixLQUFLLENBQUxBLG1CQUF5QixNQUFJLENBQUosTUFBN0IsUUFBSUEsQ0FBSixFQUFtRDtBQUNqREEscUJBQUssQ0FBTEE7QUFERixxQkFFTztBQUNMQSxxQkFBSyxDQUFMQTtBQUNEO0FBTEg7O0FBUUEsd0JBQVl1SyxrQkFBa0IsQ0FBOUIsMkJBQTBELEtBQTFEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7OzZDQUVxQmpPLEMsRUFBRztBQUNwQixnQkFBTWxOLE1BQU0sR0FBR2tOLENBQUMsQ0FBaEI7QUFFQSxrQ0FBc0JsTixNQUFNLENBQTVCOztBQUVBLGdCQUFJQSxNQUFNLENBQU5BLG1CQUFKLElBQUlBLENBQUosRUFBcUM7QUFDbkM7O0FBR0E7QUFKRixtQkFPTztBQUNMOztBQUdBO0FBR0Q7O0FBRUQsd0JBQVltYixrQkFBa0IsQ0FBOUIsMkJBQTBELEtBQTFEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7bURBRTJCYixLLEVBQU87QUFDOUI7QUFFQSxnQkFBTW9CLHNCQUFzQixHQUFHLHlDQUU3QixLQUY2QixTQUEvQixLQUErQixDQUEvQjs7QUFNQSxnQkFBSSxDQUFKLHdCQUE2QjtBQUFBLDBDQUNRLFdBRFI7QUFBQSxrQkFDbkJULE1BRG1CO0FBQUEsa0JBQ1hDLFFBRFc7QUFBQSxrQkFDRHhWLElBREM7O0FBRTNCLGtCQUFNaVcsa0JBQWtCLEdBQUcsMkJBQTNCLE1BQTJCLEVBQTNCOztBQUNBLGtCQUFNQyxnQkFBZ0IsR0FBRyxLQUF6QjtBQUNBLGtCQUFNdmEsU0FBUyxHQUNicUUsSUFBSSxLQUFLNFQsTUFBTSxDQUFmNVQsY0FBOEIsV0FBVyxDQUF6Q0EsV0FBcUQsQ0FEdkQ7O0FBR0EsNkJBQWU7QUFDYmlXLGtDQUFrQixDQUFsQkE7QUFDQUMsZ0NBQWdCLENBQWhCQTtBQUZGLHFCQUdPO0FBQ0xELGtDQUFrQixDQUFsQkE7QUFDQUMsZ0NBQWdCLENBQWhCQTtBQUNEO0FBQ0Y7O0FBRUQsd0JBQVlULGtCQUFrQixDQUE5QiwyQkFBMEQsS0FBMUQ7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztvREFFNEJiLEssRUFBTztBQUMvQjtBQUNBLHdCQUFZYSxrQkFBa0IsQ0FBOUIsMkJBQTBELEtBQTFEO0FBQ0Q7Ozs7UUExTjhCemM7QUFBQUE7QUFBQUEsTyxXQVF4Qm1kLHlCLEdBQ0wsOEMsNkVBRkRiO0FBQUFBO0FBQUFBLE87Ozs7Ozs7MEZBUUFBO0FBQUFBO0FBQUFBLE87Ozs7O2lCQUNPO0FBQ05jLHNCQUFVLEVBREo7QUFFTkMsc0JBQVUsRUFGSjtBQUdOQyxvQkFBUSxFQUFFMUMsTUFBTSxDQUFDTztBQUhYLFc7O2dFQThCUDFNO0FBQUFBO0FBQUFBLE8sNElBNkRBQTtBQUFBQTtBQUFBQSxPLDBKQStDQUM7QUFBQUE7QUFBQUEsTywyS0E0QkFBO0FBQUFBO0FBQUFBLE8sa0xBZ0NBQTtBQUFBQTtBQUFBQSxPLGlIQXZORjJNLEs7QUE4TkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7VUFDTVYsYzs7Ozs7Ozs7Ozs7Ozs7O2lCQUlKNEMsbUIsR0FBc0Isd0I7aUJBT3RCQyxNLEdBQVMsRTtpQkFPVFgsTyxHQUFVLEU7aUJBS1ZZLHNCLEdBQXlCLEk7Ozs7Ozs7QUFFekI7QUFDRjtBQUNBOytCQUVPbmIsTSxFQUFRO0FBQUE7O0FBQ1gsZ0JBQU02TixTQUFTLEdBQUc3TixNQUFNLENBQU5BLHVCQUFsQixpQkFBa0JBLEVBQWxCO0FBQ0EsZ0JBQU04TixhQUFhLEdBQUcsc0NBQXRCLEtBQXNCLENBQXRCO0FBQ0EsZ0JBQU1DLGFBQWEsR0FBRyxzQ0FBdEIsS0FBc0IsQ0FBdEI7QUFDQSxnQkFBTUMsYUFBYSxHQUFHLHNDQUF0QixLQUFzQixDQUF0QjtBQUVBLHdCQUFZaEMsUUFBUSxDQUFSQSxjQUFaLEtBQVlBLENBQVo7O0FBRUE7O0FBQ0Esd0NBQ0VtTyxrQkFBa0IsQ0FEcEIsMkJBRUUsaUJBQVM7QUFDUCxrQkFBSSxDQUFDLE1BQUksQ0FBVCw4QkFBd0M7QUFDdEMsc0JBQUksQ0FBSjtBQUNEO0FBTEw7O0FBU0Esa0NBQXNCLHlCQUF0QixNQUFzQixFQUF0Qjs7QUFFQSxnQkFBTWhNLGdCQUFnQixHQUFHbkMsUUFBUSxDQUFSQSxjQUF6QixLQUF5QkEsQ0FBekI7QUFDQW1DLDRCQUFnQixDQUFoQkE7QUFDQUEsNEJBQWdCLENBQWhCQTtBQUE2QjtBQUE3QkEsb0dBQ3lFLGtCQUR6RUEsMkNBRWtDTixTQUFTLGdCQUYzQ00sY0FFMkMsQ0FGM0NBLG9HQU15RSxrQkFOekVBLDJDQU9rQ04sU0FBUyxnQkFQM0NNLGNBTzJDLENBUDNDQSxvR0FXeUUsa0JBWHpFQSwyQ0FZa0NOLFNBQVMsZ0JBWjNDTSxjQVkyQyxDQVozQ0E7O0FBa0JBLGdCQUFJTCxhQUFhLElBQWJBLGlCQUFKLGVBQXFEO0FBQ25ESyw4QkFBZ0IsQ0FBaEJBO0FBQ0Q7O0FBRURBLDRCQUFnQixDQUFoQkEsMEJBRUUsS0FGRkE7O0FBS0E7O0FBRUEsMEJBQWMseUJBQWQ7QUFDQTtBQUVBLDBDQUE4QjtBQUM1QmlOLHdCQUFVLEVBQUUscUNBQXFDLEtBQXJDLFNBRGdCLElBQ2hCLENBRGdCO0FBRTVCQyw4QkFBZ0IsRUFBRSxtQ0FBbUMsS0FBbkMsU0FGVSxLQUVWLENBRlU7QUFHNUI7QUFDQUMseUJBQVcsRUFBRSxtREFDVCxhQURTLG9CQUVULGFBQWFBO0FBTlcsYUFBOUI7QUFRRDtBQUVEO0FBQ0Y7QUFDQTs7OztvQ0FFWTtBQUNSO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozt5Q0FDaUJ0YixNLEVBQVE7QUFDckIsZ0JBQU1wQixLQUFLLEdBQUcsd0NBQWQsTUFBYyxDQUFkOztBQURxQiwrQkFFd0IsS0FGeEI7QUFBQSxnQkFFYmtjLFVBRmE7QUFBQSxnQkFFREMsVUFGQztBQUFBLGdCQUVXQyxRQUZYOztBQUdyQixnQkFBTU8sc0JBQXNCLEdBQUcsb0NBQS9CLEtBQStCLENBQS9COztBQUNBLGdCQUFNQyx1QkFBdUIsR0FBRyxvQ0FBaEMsS0FBZ0MsQ0FBaEM7O0FBRUEsbUJBQU9SLFFBQVEsS0FBSzFDLE1BQU0sQ0FBbkIwQyxXQUNITyxzQkFBc0IsSUFEbkJQLDBCQUVITyxzQkFBc0IsSUFGMUI7QUFHRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7MkNBQ21CO0FBQUEsZ0JBQ1BULFVBRE8sR0FDUSxLQURSLE1BQ1EsQ0FEUjs7QUFHZixnQkFBSUEsVUFBVSxJQUFJQSxVQUFVLENBQTVCLFFBQXFDO0FBQ25DLGtCQUFJQSxVQUFVLENBQVZBLFlBQXVCQSxVQUFVLENBQVZBLFNBQW9CeEMsTUFBTSxDQUFyRCxhQUFtRTtBQUNqRSx1QkFBT3dDLFVBQVUsQ0FBVkEsbUJBQThCQSxVQUFVLENBQVZBLGFBQXJDO0FBQ0Q7O0FBRUQscUJBQU9BLFVBQVUsQ0FBVkEsV0FBUDtBQUNEOztBQUVEO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7cUNBQ2E7QUFBQTs7QUFDVCxnQkFBTVcsS0FBSyxHQUFHeFksSUFBSSxDQUFKQSxNQUFXQSxJQUFJLENBQUpBLFVBQWUsS0FBeEMsTUFBeUJBLENBQVhBLENBQWQ7QUFDQyxhQUFDd1ksS0FBSyxDQUFOLFlBQW1CQSxLQUFLLENBQXhCLG9CQUE2Qyx3QkFBa0I7QUFDOUQsa0JBQUlwYixTQUFTLENBQWIsUUFBc0I7QUFDcEJBLHlCQUFTLENBQVRBLFNBQW1CLE1BQUksQ0FBSiwwQkFBd0I5QixDQUFDLEdBQXpCLFdBQW5COEIsV0FBbUIsRUFBbkJBO0FBQ0Q7O0FBQ0Qsa0JBQUlBLFNBQVMsQ0FBYixVQUF3QjtBQUN0QkEseUJBQVMsQ0FBVEEsV0FBcUIsTUFBSSxDQUFKLDBCQUNQOUIsQ0FBQyxHQURNLGFBQXJCOEIsV0FBcUIsRUFBckJBO0FBR0Q7QUFSRjtBQVdEb2IsaUJBQUssQ0FBTEE7QUFDQUEsaUJBQUssQ0FBTEE7QUFDQUEsaUJBQUssQ0FBTEEsd0JBZlMsVUFlVEEsQ0FmUyxDQWlCVDs7QUFDQSxtQkFBT0EsS0FBSyxDQUFMQSxnQ0FDTDtBQUNBQSxpQkFBSyxDQUFMQSwwQkFGS0EsUUFFTEEsQ0FGS0EsSUFHTEEsS0FBSyxDQUFMQSxXQUhLQSxpQkFLSEEsS0FBSyxDQUxUO0FBTUQ7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7bUNBQ1dyTixLLEVBQU87QUFDZCxnQkFDRUEsS0FBSyxJQUNMO0FBQ0EsYUFBQ0EsS0FBSyxDQUFMQSxlQUZEQSxZQUVDQSxDQUZEQSxJQUdBO0FBQ0EsYUFBQ0EsS0FBSyxDQUFMQSxlQUxILFlBS0dBLENBTEgsRUFNRTtBQUNBQSxtQkFBSyxHQUFHO0FBQ04wTSwwQkFBVSxFQUFFMU07QUFETixlQUFSQTtBQUdEOztBQUNEOztBQUNBOztBQUNBO0FBRUEsMEJBQWMseUJBQWQ7QUFDQyxhQUFDLFlBQUQsWUFBeUIsWUFBekIsb0JBQXlELHFCQUFhO0FBQ3JFLGtCQUFJL04sU0FBUyxDQUFiLFFBQXNCO0FBQ3BCQSx5QkFBUyxDQUFUQSxTQUFtQixTQUFTQSxTQUFTLENBQXJDQSxNQUFtQixDQUFuQkE7QUFDRDs7QUFDRCxrQkFBSUEsU0FBUyxDQUFiLFVBQXdCO0FBQ3RCQSx5QkFBUyxDQUFUQSxXQUFxQixTQUFTQSxTQUFTLENBQXZDQSxRQUFxQixDQUFyQkE7QUFDRDtBQU5GO0FBUUY7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7OzJDQUNtQitOLEssRUFBTztBQUN0QixnQkFBSSxDQUFKLE9BQVk7QUFDVjtBQUNEOztBQUVELGdCQUFNc04sWUFBWSxHQUFHLCtCQUVuQixLQUZtQixTQUduQjtBQUNBLHlGQUpGLFlBSUUsQ0FKbUIsQ0FBckI7QUFPQSxnQkFBTUMsTUFBTSxHQUFHLGlDQUViLEtBRmEsU0FHYkMsSUFBSSxDQUFKQSw2Q0FIRixPQUFlLENBQWY7O0FBWnNCLDhCQWtCdUIzWSxJQUFJLENBQUpBLE1BQzNDQSxJQUFJLENBQUpBLFVBbkJvQixLQW1CcEJBLENBRDJDQSxDQWxCdkI7QUFBQSxnQkFrQmQ2WCxVQWxCYztBQUFBLGdCQWtCRkMsVUFsQkU7QUFBQSxnQkFrQlVDLFFBbEJWOztBQXNCckIsNkNBQWlDLHFCQUFhO0FBQzdDLGtCQUFJM2EsU0FBUyxDQUFiLFFBQXNCO0FBQ3BCQSx5QkFBUyxDQUFUQSxTQUFtQndiLEdBQUcsQ0FBSEEsb0JBQ2pCeGIsU0FBUyxDQURRd2Isc0JBQW5CeGIsTUFBbUJ3YixDQUFuQnhiO0FBS0Q7O0FBRUQsa0JBQUlBLFNBQVMsQ0FBYixVQUF3QjtBQUN0QkEseUJBQVMsQ0FBVEEsV0FBcUJ3YixHQUFHLENBQUhBLG9CQUNuQnhiLFNBQVMsQ0FEVXdiLHdCQUFyQnhiLE1BQXFCd2IsQ0FBckJ4YjtBQUtEO0FBZkY7QUFrQkQsZ0JBQU15YixzQkFBc0IsYUFBTWhCLFVBQVUsQ0FBVkEsVUFBTixnQkFDMUJBLFVBQVUsQ0FBVkEsV0FBc0IsT0FBT0EsVUFBVSxDQUF2Q0EsV0FERixFQUE0QixDQUE1QjtBQUdBLGdCQUFNaUIsdUJBQXVCLGFBQU1oQixVQUFVLENBQVZBLFVBQU4sZ0JBQzNCQSxVQUFVLENBQVZBLFdBQXNCLE9BQU9BLFVBQVUsQ0FBdkNBLFdBREYsRUFBNkIsQ0FBN0I7QUFHQSxnQkFBTWlCLGdCQUFnQixhQUFNakIsVUFBVSxDQUFWQSxnQ0FBNUIsRUFBc0IsQ0FBdEI7QUFFQSxtQkFBTyxxR0FBUCxJQUFPLEVBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7NkNBQ3FCMWEsUyxFQUFXekIsSyxFQUFPO0FBQ25DLGdCQUFJLENBQUN5QixTQUFTLENBQVYsVUFBcUIsQ0FBekIsT0FBaUM7QUFDL0I7QUFDRDs7QUFIa0MsZ0JBSzNCNFosTUFMMkIsR0FLQTVaLFNBTEE7QUFBQSxnQkFLbkI2WixRQUxtQixHQUtBN1osU0FMQTtBQUFBLGdCQUtUcUUsSUFMUyxHQUtBckUsU0FMQTtBQU1uQyxnQkFBTXVKLFFBQVEsR0FBR2lTLEdBQUcsQ0FBSEEsa0JBQWpCLG1CQUFpQkEsRUFBakI7QUFDQSxnQkFBTVIsZ0JBQWdCLEdBQUcsNEJBQXpCO0FBQ0EsZ0JBQU1ELFVBQVUsR0FBRyw0QkFBbkI7QUFDQSxnQkFBSWEsTUFBTSxHQUFWOztBQUVBLGdCQUFJSixHQUFHLENBQUhBLHFDQUFKLEtBQUlBLENBQUosRUFBcUQ7QUFDbkRqZCxtQkFBSyxHQUFHQSxLQUFLLEdBQUdpZCxHQUFHLENBQUhBLDhCQUFoQmpkLEtBQWdCaWQsQ0FBaEJqZDtBQUNDLHlDQUEyQixnQkFBUTtBQUNsQyxvQkFBSXVLLElBQUksWUFBUixNQUEwQjtBQUN4QkEsc0JBQUksQ0FBSkE7QUFDQUEsc0JBQUksQ0FBSkE7QUFDQUEsc0JBQUksQ0FBSkE7QUFDRDtBQUxGO0FBRkgsbUJBU08sSUFBSTBTLEdBQUcsQ0FBSEEscUNBQUosS0FBSUEsQ0FBSixFQUFxRDtBQUMxRGpkLG1CQUFLLEdBQUdpZCxHQUFHLENBQUhBLDhCQUFSamQsS0FBUWlkLENBQVJqZDtBQXJCaUMsY0F3Qm5DOzs7QUFDQUEsaUJBQUssR0FBR3NkO0FBQUFBO0FBQUFBLGVBQWMsS0FBZEEsRUF6QjJCLFFBeUIzQkEsQ0FBUnRkLENBekJtQyxDQTBCbkM7QUFDQTs7QUFFQSxnQkFBSSxDQUFKLFlBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQUMsZ0RBQWtDLGdCQUFRO0FBQ3pDLG9CQUFJdUssSUFBSSxZQUFSLE1BQTBCO0FBQ3hCQSxzQkFBSSxDQUFKQTtBQUNBQSxzQkFBSSxDQUFKQTtBQUNBQSxzQkFBSSxDQUFKQTtBQUNBQSxzQkFBSSxDQUFKQTtBQUNEO0FBTkY7QUFRRjs7QUFFRCxnQkFBSXpFLElBQUksS0FBSzRULE1BQU0sQ0FBbkIsYUFBaUM7QUFDL0IyRCxvQkFBTSxHQUFHaEMsTUFBTSxHQUFOQSxtQkFBNEJBLE1BQU0sR0FBTkEsU0FBckNnQztBQURGLG1CQUVPLElBQUl2WCxJQUFJLEtBQUs0VCxNQUFNLENBQW5CLGlCQUFxQztBQUMxQzJELG9CQUFNLEdBQUcsRUFBRWhDLE1BQU0sR0FBTkEsbUJBQTRCQSxNQUFNLEdBQU5BLFNBQXZDZ0MsS0FBUyxDQUFUQTtBQURLLG1CQUVBLElBQUl2WCxJQUFJLEtBQUs0VCxNQUFNLENBQW5CLGVBQW1DO0FBQ3hDMkQsb0JBQU0sR0FBR2hDLE1BQU0sR0FBZmdDO0FBREssbUJBRUEsSUFBSXZYLElBQUksS0FBSzRULE1BQU0sQ0FBbkIsWUFBZ0M7QUFDckMyRCxvQkFBTSxHQUFHaEMsTUFBTSxHQUFmZ0M7QUFESyxtQkFFQSxJQUFJdlgsSUFBSSxLQUFLNFQsTUFBTSxDQUFmNVQsZUFBSixVQUE2QztBQUNsRCxvQ0FBc0I7QUFDcEJ1WCxzQkFBTSxHQUNILENBQUNoQyxNQUFNLEdBQU5BLFNBQ0NBLE1BQU0sR0FBTkEsbUJBQTRCQSxNQUFNLEdBQU5BLFNBRDlCLFVBRUNDLFFBQVEsR0FGVixLQUFDLElBR0FBLFFBQVEsR0FBUkEsbUJBQThCQSxRQUFRLEdBQVJBLFNBSmpDK0I7QUFERixxQkFNTztBQUNMQSxzQkFBTSxHQUFHaEMsTUFBTSxHQUFOQSxTQUFrQkMsUUFBUSxHQUFuQytCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNEO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O3VEQUUrQi9QLEMsRUFBRztBQUM5QixnQkFBTWxOLE1BQU0sR0FBR2tOLENBQUMsQ0FBaEI7O0FBRUEsZ0JBQUlsTixNQUFNLENBQU5BLGFBQUosVUFBa0M7QUFDaEMsa0JBQUlBLE1BQU0sQ0FBTkEsbUJBQUosT0FBSUEsQ0FBSixFQUF3QztBQUN0Qzs7QUFDQTtBQUZGLHFCQUdPLElBQUlBLE1BQU0sQ0FBTkEsbUJBQUosT0FBSUEsQ0FBSixFQUF3QztBQUM3QztBQURLLHFCQUVBLElBQUlBLE1BQU0sQ0FBTkEsbUJBQUosT0FBSUEsQ0FBSixFQUF3QztBQUM3QztBQUNEO0FBQ0Y7QUFDRjtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzREQUVvQ3NhLEssRUFBTzZDLG1CLEVBQXFCO0FBQzVEOztBQUNBLGdCQUFJLFVBQUoscUJBQW1DO0FBQ2pDO0FBQ0Q7QUFDRjs7OztRQS9XMEJ6ZTtBQUFBQTtBQUFBQSxPLG1FQTRCMUJ5TztBQUFBQTtBQUFBQSxPLDRJQW9FQUE7QUFBQUE7QUFBQUEsTyxvS0FrUEFDO0FBQUFBO0FBQUFBLE8sOExBdUJBQTtBQUFBQTtBQUFBQSxPO0FBU1lpTTs7QUFBQUEsaUNBQWYsY0FBZUE7Ozs7Ozs7O0FDMzFCZjs7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUNlLDhDQUF3QztBQUNyRCxZQUFJK0QsR0FBRyxHQUFHQyxpQkFBaUIsQ0FBM0IsUUFBMkIsQ0FBM0I7QUFDQSxlQUFPRCxHQUFHLENBQUhBLGdCQUFvQkUsV0FBVyxNQUEvQkYsSUFBK0IsQ0FBL0JBLEdBQTZDRyxXQUFXLE1BQS9ELElBQStELENBQS9EO0FBQ0Q7O0FBRUQsVUFBSUMsU0FBUyxHQUFHO0FBQ2RDLFlBQUksRUFEVTtBQUVkQyxhQUFLLEVBRlM7QUFHZEMsV0FBRyxFQUhXO0FBSWRDLFlBQUksRUFKVTtBQUtkQyxjQUFNLEVBTFE7QUFNZEMsY0FBTSxFQUFFO0FBTk0sT0FBaEI7O0FBU0Esc0NBQWdDO0FBQzlCLFlBQUlDLFNBQVMsR0FBR1gsR0FBRyxDQUFIQSxjQUFoQixJQUFnQkEsQ0FBaEI7QUFDQSxZQUFJWSxNQUFNLEdBQVY7O0FBQ0EsYUFBSyxJQUFJemUsQ0FBQyxHQUFWLEdBQWdCQSxDQUFDLEdBQUd3ZSxTQUFTLENBQTdCLFFBQXNDeGUsQ0FBdEMsSUFBMkM7QUFDekMsY0FBSTBlLEdBQUcsR0FBR1QsU0FBUyxDQUFDTyxTQUFTLENBQVRBLENBQVMsQ0FBVEEsQ0FBcEIsSUFBbUIsQ0FBbkI7O0FBRUEsY0FBSUUsR0FBRyxJQUFQLEdBQWM7QUFDWkQsa0JBQU0sQ0FBTkEsR0FBTSxDQUFOQSxHQUFjN1MsUUFBUSxDQUFDNFMsU0FBUyxDQUFUQSxDQUFTLENBQVRBLENBQUQsT0FBdEJDLEVBQXNCLENBQXRCQTtBQUNEO0FBQ0Y7O0FBQ0Q7QUFDRDs7QUFFRCxzQ0FBZ0M7QUFDOUIsWUFBSUQsU0FBUyxHQUFHWCxHQUFHLENBQUhBLGdDQUFoQixFQUFnQkEsQ0FBaEI7QUFDQSxZQUFJYyxNQUFNLEdBQUcsK0NBRmlCLFNBRWpCLENBQWIsQ0FGOEIsQ0FHOUI7QUFDQTs7QUFDQSxlQUFPLENBQUNBLE1BQU0sQ0FBUCxDQUFPLENBQVAsRUFBWUEsTUFBTSxDQUFsQixDQUFrQixDQUFsQixFQUF1QkEsTUFBTSxDQUE3QixDQUE2QixDQUE3QixFQUFrQ0EsTUFBTSxDQUF4QyxDQUF3QyxDQUF4QyxFQUE2Q0EsTUFBTSxDQUFuRCxDQUFtRCxDQUFuRCxFQUF3REEsTUFBTSxDQUFyRSxDQUFxRSxDQUE5RCxDQUFQO1FBR0Y7QUFDQTtBQUNBOzs7QUFDQSxVQUFJQyxRQUFRLEdBQVo7O0FBQ0EsMkNBQXFDO0FBQ25DLFlBQUksQ0FBQ0EsUUFBUSxDQUFiLFFBQWEsQ0FBYixFQUF5QjtBQUN2QjtBQUNBLGNBQUlDLGlCQUFpQixHQUFHLElBQUl4QixJQUFJLENBQVIsd0JBQWlDO0FBQ3ZEeUIsa0JBQU0sRUFEaUQ7QUFFdkRDLG9CQUFRLEVBRitDO0FBR3ZEYixnQkFBSSxFQUhtRDtBQUl2REMsaUJBQUssRUFKa0Q7QUFLdkRDLGVBQUcsRUFMb0Q7QUFNdkRDLGdCQUFJLEVBTm1EO0FBT3ZEQyxrQkFBTSxFQVBpRDtBQVF2REMsa0JBQU0sRUFBRTtBQVIrQyxXQUFqQyxTQVNkLFNBVFYsMEJBU1UsQ0FUYyxDQUF4QjtBQVVBLGNBQUlTLGtCQUFrQixHQUNwQkgsaUJBQWlCLEtBQWpCQSwwQkFDQUEsaUJBQWlCLEtBRm5CO0FBSUFELGtCQUFRLENBQVJBLFFBQVEsQ0FBUkEsR0FBcUJJLGtCQUFrQixHQUNuQyxJQUFJM0IsSUFBSSxDQUFSLHdCQUFpQztBQUMvQnlCLGtCQUFNLEVBRHlCO0FBRS9CQyxvQkFBUSxFQUZ1QjtBQUcvQmIsZ0JBQUksRUFIMkI7QUFJL0JDLGlCQUFLLEVBSjBCO0FBSy9CQyxlQUFHLEVBTDRCO0FBTS9CQyxnQkFBSSxFQU4yQjtBQU8vQkMsa0JBQU0sRUFQeUI7QUFRL0JDLGtCQUFNLEVBQUU7QUFSdUIsV0FBakMsQ0FEbUMsR0FXbkMsSUFBSWxCLElBQUksQ0FBUix3QkFBaUM7QUFDL0I0QixxQkFBUyxFQURzQjtBQUUvQkYsb0JBQVEsRUFGdUI7QUFHL0JiLGdCQUFJLEVBSDJCO0FBSS9CQyxpQkFBSyxFQUowQjtBQUsvQkMsZUFBRyxFQUw0QjtBQU0vQkMsZ0JBQUksRUFOMkI7QUFPL0JDLGtCQUFNLEVBUHlCO0FBUS9CQyxrQkFBTSxFQUFFO0FBUnVCLFdBQWpDLENBWEpLO0FBcUJEOztBQUNELGVBQU9BLFFBQVEsQ0FBZixRQUFlLENBQWY7Ozs7Ozs7Ozs7QUNsRkY7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFZSx1REFBaUQ7QUFDOURNO0FBQUFBO0FBQUFBLFdBQVksQ0FBWkE7QUFDQSxZQUFJQyxNQUFNLEdBQUdDO0FBQUFBO0FBQUFBLFdBQWIsV0FBYUEsQ0FBYjtBQUNBLGVBQU9DO0FBQUFBO0FBQUFBLFdBQWUsU0FBZkEsRUFBMkIsQ0FBbEMsTUFBT0EsQ0FBUDs7Ozs7Ozs7OztBQzdCRjs7QUFBQTtBQUFBOztBQUFBO0FBQUE7OztBQUFBO0FBQUE7OztBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVlLHVEQUFpRDtBQUM5REg7QUFBQUE7QUFBQUEsV0FBWSxDQUFaQTtBQUNBLFlBQUlJLFNBQVMsR0FBR3pVO0FBQUFBO0FBQUFBLHNCQUFoQixPQUFnQkEsRUFBaEI7QUFDQSxZQUFJc1UsTUFBTSxHQUFHQztBQUFBQTtBQUFBQSxXQUFiLFdBQWFBLENBQWI7QUFDQSxlQUFPLFNBQVNFLFNBQVMsR0FBekIsTUFBTyxDQUFQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVlLGdDQUEwQjtBQUN2Q0o7QUFBQUE7QUFBQUEsV0FBWSxDQUFaQTtBQUNBLFlBQUlLLE1BQU0sR0FBR2xnQixNQUFNLENBQU5BLHdCQUYwQixRQUUxQkEsQ0FBYixDQUZ1QyxDQUVnQjs7QUFFdkQsWUFBSW1nQixRQUFRLFlBQVJBLFFBQTRCLGtDQUFnQ0QsTUFBTSxLQUF0RSxpQkFBNEY7QUFDMUY7QUFDQSxpQkFBTyxTQUFTQyxRQUFRLENBQXhCLE9BQWdCQSxFQUFULENBQVA7QUFGRixlQUdPLElBQUksZ0NBQWdDRCxNQUFNLEtBQTFDLG1CQUFrRTtBQUN2RSxpQkFBTyxTQUFQLFFBQU8sQ0FBUDtBQURLLGVBRUE7QUFDTCxjQUFJLENBQUMsZ0NBQWdDQSxNQUFNLEtBQXZDLHNCQUFrRSxtQkFBdEUsYUFBc0c7QUFDcEc7QUFDQXRaLG1CQUFPLENBQVBBLEtBRm9HLGtKQUVwR0EsRUFGb0csQ0FFOEQ7O0FBRWxLQSxtQkFBTyxDQUFQQSxLQUFhLFlBQWJBO0FBQ0Q7O0FBRUQsaUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5Q0gsVUFBSWlGLG9CQUFvQixHQUF4QjtBQUNBLFVBQUlDLHNCQUFzQixHQUExQjtBQUNBLFVBQUlzVSx5QkFBeUIsR0FBN0I7QUFFQSxVQUFJclUsUUFBUSxHQUFHO0FBQ2JzVSx5QkFBaUIsRUFESjtBQUViQyxpQkFBUyxFQUZJO0FBR2JDLHlCQUFpQixFQUhKO0FBS2I7QUFDQUMsVUFBRSxFQU5XO0FBT2JDLFdBQUcsRUFBRSxrQkFDYztBQURkLHlCQUVjO0FBRmQsd0JBR2E7QUFIYixTQVBRO0FBWWJDLFlBQUksRUFaUztBQWFiQyxhQUFLLEVBQUUsaUJBQ1c7QUFEWCx3QkFFVztBQUZYLHVCQUdVO0FBSFYsU0FiTTtBQW1CYjtBQUNBQyxVQUFFLEVBcEJXO0FBcUJiQyxXQUFHLEVBckJVO0FBc0JiQyxZQUFJLEVBdEJTO0FBdUJiQyxXQUFHLEVBdkJVO0FBd0JiQyxZQUFJLEVBeEJTO0FBMEJiQyxVQUFFLEVBMUJXO0FBMkJiQyxZQUFJLEVBM0JTO0FBNEJiQyxjQUFNLEVBNUJPO0FBOEJiO0FBQ0FuVixnQkFBUSxFQUFFO0FBL0JHLE9BQWY7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDZSw4Q0FBd0M7QUFDckQsWUFBSXlLLFNBQVMsQ0FBVEEsU0FBSixHQUEwQjtBQUN4QixnQkFBTSxjQUNKLG1DQUFtQ0EsU0FBUyxDQUE1QyxTQURGLFVBQU0sQ0FBTjtBQUdEOztBQUVELFlBQUkwSixRQUFRLEtBQVosTUFBdUI7QUFDckIsaUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDs7QUFFRCxZQUFJdlIsT0FBTyxHQUFHd1MsWUFBWSxJQUExQjtBQUVBLFlBQUlDLGdCQUFnQixHQUNsQnpTLE9BQU8sQ0FBUEEsdURBRUltUjtBQUFBQTtBQUFBQSxXQUFVblIsT0FBTyxDQUh2QixnQkFHTW1SLENBSE47O0FBSUEsWUFDRXNCLGdCQUFnQixLQUFoQkEsS0FDQUEsZ0JBQWdCLEtBRGhCQSxLQUVBQSxnQkFBZ0IsS0FIbEIsR0FJRTtBQUNBLGdCQUFNLGVBQU4sb0NBQU0sQ0FBTjtBQXRCbUQsVUF5QnJEOzs7QUFDQSxZQUNFbEIsUUFBUSxZQUFSQSxRQUNDLGtDQUNDbmdCLE1BQU0sQ0FBTkEsc0NBSEosaUJBSUU7QUFDQTtBQUNBLGlCQUFPLFNBQVNtZ0IsUUFBUSxDQUF4QixPQUFnQkEsRUFBVCxDQUFQO0FBTkYsZUFPTyxJQUNMLGdDQUNBbmdCLE1BQU0sQ0FBTkEsc0NBRkssbUJBR0w7QUFDQSxpQkFBTyxTQUFQLFFBQU8sQ0FBUDtBQUpLLGVBS0EsSUFDTCxFQUNFLGdDQUNBQSxNQUFNLENBQU5BLHNDQUhHLGlCQUNMLENBREssRUFLTDtBQUNBLGlCQUFPLFNBQVAsR0FBTyxDQUFQO0FBQ0Q7O0FBRUQsWUFBSXNoQixXQUFXLEdBQUdDLGVBQWUsQ0FBakMsUUFBaUMsQ0FBakM7QUFFQSxZQUFJQyxlQUFlLEdBQUdDLFNBQVMsQ0FBQ0gsV0FBVyxDQUFaLE1BQS9CLGdCQUErQixDQUEvQjtBQUNBLFlBQUl6QyxJQUFJLEdBQUcyQyxlQUFlLENBQTFCO0FBQ0EsWUFBSUUsY0FBYyxHQUFHRixlQUFlLENBQXBDO0FBRUEsWUFBSWpXLElBQUksR0FBR29XLFNBQVMsaUJBQXBCLElBQW9CLENBQXBCOztBQUVBLFlBQUk5WixLQUFLLENBQVQsSUFBUyxDQUFULEVBQWlCO0FBQ2YsaUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDs7QUFFRCxrQkFBVTtBQUNSLGNBQUlvWSxTQUFTLEdBQUcxVSxJQUFJLENBQXBCLE9BQWdCQSxFQUFoQjtBQUNBLGNBQUlxVyxJQUFJLEdBQVI7QUFDQTs7QUFFQSxjQUFJTixXQUFXLENBQWYsTUFBc0I7QUFDcEJNLGdCQUFJLEdBQUdDLFNBQVMsQ0FBQ1AsV0FBVyxDQUE1Qk0sSUFBZ0IsQ0FBaEJBOztBQUVBLGdCQUFJL1osS0FBSyxDQUFULElBQVMsQ0FBVCxFQUFpQjtBQUNmLHFCQUFPLFNBQVAsR0FBTyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxjQUFJeVosV0FBVyxDQUFYQSxZQUF3QjFTLE9BQU8sQ0FBbkMsVUFBOEM7QUFDNUNvRixrQkFBTSxHQUFHckk7QUFBQUE7QUFBQUEsZUFDUDJWLFdBQVcsQ0FBWEEsWUFBd0IxUyxPQUFPLENBRFQsUUFBZmpELEVBRVAsU0FBU3NVLFNBQVMsR0FGcEJqTSxJQUVFLENBRk9ySSxDQUFUcUk7O0FBSUEsZ0JBQUluTSxLQUFLLENBQVQsTUFBUyxDQUFULEVBQW1CO0FBQ2pCLHFCQUFPLFNBQVAsR0FBTyxDQUFQO0FBQ0Q7O0FBQ0RtTSxrQkFBTSxHQUFHckk7QUFBQUE7QUFBQUEsZUFDUDJWLFdBQVcsQ0FBWEEsWUFBd0IxUyxPQUFPLENBRFQsUUFBZmpELEVBRVAsU0FBU3NVLFNBQVMsR0FBVEEsT0FGWGpNLE1BRUUsQ0FGT3JJLENBQVRxSTs7QUFJQSxnQkFBSW5NLEtBQUssQ0FBVCxNQUFTLENBQVQsRUFBbUI7QUFDakIscUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDtBQWRILGlCQWVPO0FBQ0w7QUFDQW1NLGtCQUFNLEdBQUc4TjtBQUFBQTtBQUFBQSxlQUFnQyxTQUFTN0IsU0FBUyxHQUEzRGpNLElBQXlDLENBQWhDOE4sQ0FBVDlOO0FBQ0FBLGtCQUFNLEdBQUc4TjtBQUFBQTtBQUFBQSxlQUNQLFNBQVM3QixTQUFTLEdBQVRBLE9BRFhqTSxNQUNFLENBRE84TixDQUFUOU47QUFHRDs7QUFFRCxpQkFBTyxTQUFTaU0sU0FBUyxHQUFUQSxPQUFoQixNQUFPLENBQVA7QUFwQ0YsZUFxQ087QUFDTCxpQkFBTyxTQUFQLEdBQU8sQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsMkNBQXFDO0FBQ25DLFlBQUlxQixXQUFXLEdBQWY7QUFDQSxZQUFJclcsS0FBSyxHQUFHOFcsVUFBVSxDQUFWQSxNQUFpQmhXLFFBQVEsQ0FBckMsaUJBQVlnVyxDQUFaO0FBQ0E7O0FBRUEsWUFBSWhXLFFBQVEsQ0FBUkEsZUFBd0JkLEtBQUssQ0FBakMsQ0FBaUMsQ0FBN0JjLENBQUosRUFBdUM7QUFDckN1VixxQkFBVyxDQUFYQTtBQUNBVSxvQkFBVSxHQUFHL1csS0FBSyxDQUFsQitXLENBQWtCLENBQWxCQTtBQUZGLGVBR087QUFDTFYscUJBQVcsQ0FBWEEsT0FBbUJyVyxLQUFLLENBQXhCcVcsQ0FBd0IsQ0FBeEJBO0FBQ0FVLG9CQUFVLEdBQUcvVyxLQUFLLENBQWxCK1csQ0FBa0IsQ0FBbEJBO0FBQ0FWLHFCQUFXLENBQVhBLFdBQXVCclcsS0FBSyxDQUE1QnFXLENBQTRCLENBQTVCQTs7QUFDQSxjQUFJdlYsUUFBUSxDQUFSQSx1QkFBZ0N1VixXQUFXLENBQS9DLElBQUl2VixDQUFKLEVBQXVEO0FBQ3JEdVYsdUJBQVcsQ0FBWEEsT0FBbUJTLFVBQVUsQ0FBVkEsTUFBaUJoVyxRQUFRLENBQXpCZ1csbUJBQW5CVCxDQUFtQlMsQ0FBbkJUO0FBQ0FVLHNCQUFVLEdBQUdELFVBQVUsQ0FBVkEsT0FBa0JULFdBQVcsQ0FBWEEsS0FBbEJTLFFBQTJDQSxVQUFVLENBQWxFQyxNQUFhRCxDQUFiQztBQUNEO0FBQ0Y7O0FBRUQsd0JBQWdCO0FBQ2QsY0FBSTNWLEtBQUssR0FBR04sUUFBUSxDQUFSQSxjQUFaLFVBQVlBLENBQVo7O0FBQ0EscUJBQVc7QUFDVHVWLHVCQUFXLENBQVhBLE9BQW1CVSxVQUFVLENBQVZBLFFBQW1CM1YsS0FBSyxDQUF4QjJWLENBQXdCLENBQXhCQSxFQUFuQlYsRUFBbUJVLENBQW5CVjtBQUNBQSx1QkFBVyxDQUFYQSxXQUF1QmpWLEtBQUssQ0FBNUJpVixDQUE0QixDQUE1QkE7QUFGRixpQkFHTztBQUNMQSx1QkFBVyxDQUFYQTtBQUNEO0FBQ0Y7O0FBRUQ7QUFDRDs7QUFFRCx1REFBaUQ7QUFDL0MsWUFBSVcsVUFBVSxHQUFHbFcsUUFBUSxDQUFSQSxJQUFqQixnQkFBaUJBLENBQWpCO0FBQ0EsWUFBSW1XLFlBQVksR0FBR25XLFFBQVEsQ0FBUkEsTUFBbkIsZ0JBQW1CQSxDQUFuQjtBQUVBLFlBSitDLEtBSS9DLENBSitDLENBTS9DOztBQUNBTSxhQUFLLEdBQUdOLFFBQVEsQ0FBUkEseUJBQWtDbVcsWUFBWSxDQUFaQSxLQUExQzdWLFVBQTBDNlYsQ0FBMUM3Vjs7QUFDQSxtQkFBVztBQUNULGNBQUk4VixVQUFVLEdBQUc5VixLQUFLLENBQXRCLENBQXNCLENBQXRCO0FBQ0EsaUJBQU87QUFDTHdTLGdCQUFJLEVBQUV0UyxRQUFRLGFBRFQsRUFDUyxDQURUO0FBRUxtViwwQkFBYyxFQUFFSyxVQUFVLENBQVZBLE1BQWlCSSxVQUFVLENBQTNCSjtBQUZYLFdBQVA7QUFWNkMsVUFnQi9DOzs7QUFDQTFWLGFBQUssR0FBR04sUUFBUSxDQUFSQSx1QkFBZ0NrVyxVQUFVLENBQVZBLEtBQXhDNVYsVUFBd0M0VixDQUF4QzVWOztBQUNBLG1CQUFXO0FBQ1QsY0FBSStWLGFBQWEsR0FBRy9WLEtBQUssQ0FBekIsQ0FBeUIsQ0FBekI7QUFDQSxpQkFBTztBQUNMd1MsZ0JBQUksRUFBRXRTLFFBQVEsZ0JBQVJBLEVBQVEsQ0FBUkEsR0FERDtBQUVMbVYsMEJBQWMsRUFBRUssVUFBVSxDQUFWQSxNQUFpQkssYUFBYSxDQUE5Qkw7QUFGWCxXQUFQO0FBcEI2QyxVQTBCL0M7OztBQUNBLGVBQU87QUFDTGxELGNBQUksRUFBRTtBQURELFNBQVA7QUFHRDs7QUFFRCwyQ0FBcUM7QUFDbkM7QUFDQSxZQUFJQSxJQUFJLEtBQVIsTUFBbUI7QUFDakI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxZQVRtQyxJQVNuQyxDQVRtQyxDQVduQzs7QUFDQSxZQUFJa0QsVUFBVSxDQUFWQSxXQUFKLEdBQTZCO0FBQzNCeFcsY0FBSSxHQUFHLFNBQVBBLENBQU8sQ0FBUEE7QUFDQUEsY0FBSSxDQUFKQTtBQUNBO0FBZmlDLFVBa0JuQzs7O0FBQ0FjLGFBQUssR0FBR04sUUFBUSxDQUFSQSxRQUFSTSxVQUFRTixDQUFSTTs7QUFDQSxtQkFBVztBQUNUZCxjQUFJLEdBQUcsU0FBUEEsQ0FBTyxDQUFQQTtBQUNBdVQsZUFBSyxHQUFHdlMsUUFBUSxDQUFDRixLQUFLLENBQU4sQ0FBTSxDQUFOLEVBQVJFLEVBQVEsQ0FBUkEsR0FBUnVTOztBQUVBLGNBQUksQ0FBQ3VELFlBQVksT0FBakIsS0FBaUIsQ0FBakIsRUFBZ0M7QUFDOUIsbUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDs7QUFFRDlXLGNBQUksQ0FBSkE7QUFDQTtBQTdCaUMsVUFnQ25DOzs7QUFDQWMsYUFBSyxHQUFHTixRQUFRLENBQVJBLFNBQVJNLFVBQVFOLENBQVJNOztBQUNBLG1CQUFXO0FBQ1RkLGNBQUksR0FBRyxTQUFQQSxDQUFPLENBQVBBO0FBQ0EsY0FBSStXLFNBQVMsR0FBRy9WLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUF4QixFQUF3QixDQUF4Qjs7QUFFQSxjQUFJLENBQUNrVyxxQkFBcUIsT0FBMUIsU0FBMEIsQ0FBMUIsRUFBNkM7QUFDM0MsbUJBQU8sU0FBUCxHQUFPLENBQVA7QUFDRDs7QUFFRGhYLGNBQUksQ0FBSkE7QUFDQTtBQTNDaUMsVUE4Q25DOzs7QUFDQWMsYUFBSyxHQUFHTixRQUFRLENBQVJBLFVBQVJNLFVBQVFOLENBQVJNOztBQUNBLG1CQUFXO0FBQ1RkLGNBQUksR0FBRyxTQUFQQSxDQUFPLENBQVBBO0FBQ0F1VCxlQUFLLEdBQUd2UyxRQUFRLENBQUNGLEtBQUssQ0FBTixDQUFNLENBQU4sRUFBUkUsRUFBUSxDQUFSQSxHQUFSdVM7QUFDQSxjQUFJQyxHQUFHLEdBQUd4UyxRQUFRLENBQUNGLEtBQUssQ0FBTixDQUFNLENBQU4sRUFBbEIsRUFBa0IsQ0FBbEI7O0FBRUEsY0FBSSxDQUFDZ1csWUFBWSxjQUFqQixHQUFpQixDQUFqQixFQUFxQztBQUNuQyxtQkFBTyxTQUFQLEdBQU8sQ0FBUDtBQUNEOztBQUVEOVcsY0FBSSxDQUFKQTtBQUNBO0FBMURpQyxVQTZEbkM7OztBQUNBYyxhQUFLLEdBQUdOLFFBQVEsQ0FBUkEsU0FBUk0sVUFBUU4sQ0FBUk07O0FBQ0EsbUJBQVc7QUFDVG1XLGNBQUksR0FBR2pXLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFSRSxFQUFRLENBQVJBLEdBQVBpVzs7QUFFQSxjQUFJLENBQUNDLGdCQUFnQixPQUFyQixJQUFxQixDQUFyQixFQUFtQztBQUNqQyxtQkFBTyxTQUFQLEdBQU8sQ0FBUDtBQUNEOztBQUVELGlCQUFPQyxnQkFBZ0IsT0FBdkIsSUFBdUIsQ0FBdkI7QUF0RWlDLFVBeUVuQzs7O0FBQ0FyVyxhQUFLLEdBQUdOLFFBQVEsQ0FBUkEsVUFBUk0sVUFBUU4sQ0FBUk07O0FBQ0EsbUJBQVc7QUFDVG1XLGNBQUksR0FBR2pXLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFSRSxFQUFRLENBQVJBLEdBQVBpVztBQUNBLGNBQUlHLFNBQVMsR0FBR3BXLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFSRSxFQUFRLENBQVJBLEdBQWhCOztBQUVBLGNBQUksQ0FBQ2tXLGdCQUFnQixhQUFyQixTQUFxQixDQUFyQixFQUE4QztBQUM1QyxtQkFBTyxTQUFQLEdBQU8sQ0FBUDtBQUNEOztBQUVELGlCQUFPQyxnQkFBZ0IsYUFBdkIsU0FBdUIsQ0FBdkI7QUFuRmlDLFVBc0ZuQzs7O0FBQ0E7QUFDRDs7QUFFRCxxQ0FBK0I7QUFDN0I7QUFDQTtBQUNBLFlBSDZCLE9BRzdCLENBSDZCLENBSzdCOztBQUNBclcsYUFBSyxHQUFHTixRQUFRLENBQVJBLFFBQVJNLFVBQVFOLENBQVJNOztBQUNBLG1CQUFXO0FBQ1RDLGVBQUssR0FBR3NXLFVBQVUsQ0FBQ3ZXLEtBQUssQ0FBTEEsQ0FBSyxDQUFMQSxjQUFuQkMsR0FBbUJELENBQUQsQ0FBbEJDOztBQUVBLGNBQUksQ0FBQ3VXLFlBQVksQ0FBakIsS0FBaUIsQ0FBakIsRUFBMEI7QUFDeEI7QUFDRDs7QUFFRCxpQkFBUXZXLEtBQUssR0FBTixFQUFDQSxHQUFSO0FBZDJCLFVBaUI3Qjs7O0FBQ0FELGFBQUssR0FBR04sUUFBUSxDQUFSQSxVQUFSTSxVQUFRTixDQUFSTTs7QUFDQSxtQkFBVztBQUNUQyxlQUFLLEdBQUdDLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFoQkMsRUFBZ0IsQ0FBaEJBO0FBQ0FJLGlCQUFPLEdBQUdrVyxVQUFVLENBQUN2VyxLQUFLLENBQUxBLENBQUssQ0FBTEEsY0FBckJLLEdBQXFCTCxDQUFELENBQXBCSzs7QUFFQSxjQUFJLENBQUNtVyxZQUFZLFFBQWpCLE9BQWlCLENBQWpCLEVBQW1DO0FBQ2pDO0FBQ0Q7O0FBRUQsaUJBQ0d2VyxLQUFLLEdBQU4sRUFBQ0EsR0FBRCxvQkFBQ0EsR0FBcUNJLE9BQU8sR0FEL0M7QUEzQjJCLFVBZ0M3Qjs7O0FBQ0FMLGFBQUssR0FBR04sUUFBUSxDQUFSQSxZQUFSTSxVQUFRTixDQUFSTTs7QUFDQSxtQkFBVztBQUNUQyxlQUFLLEdBQUdDLFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFoQkMsRUFBZ0IsQ0FBaEJBO0FBQ0FJLGlCQUFPLEdBQUdILFFBQVEsQ0FBQ0YsS0FBSyxDQUFOLENBQU0sQ0FBTixFQUFsQkssRUFBa0IsQ0FBbEJBO0FBQ0EsY0FBSW9XLE9BQU8sR0FBR0YsVUFBVSxDQUFDdlcsS0FBSyxDQUFMQSxDQUFLLENBQUxBLGNBQXpCLEdBQXlCQSxDQUFELENBQXhCOztBQUVBLGNBQUksQ0FBQ3dXLFlBQVksaUJBQWpCLE9BQWlCLENBQWpCLEVBQTRDO0FBQzFDO0FBQ0Q7O0FBRUQsaUJBQ0d2VyxLQUFLLEdBQU4sRUFBQ0EsR0FBRCxvQkFBQ0EsR0FDREksT0FBTyxHQURQLHNCQUFDSixHQUVEd1csT0FBTyxHQUhUO0FBM0MyQixVQWtEN0I7OztBQUNBO0FBQ0Q7O0FBRUQsd0RBQWtEO0FBQ2hETixZQUFJLEdBQUdBLElBQUksSUFBWEE7QUFDQXpELFdBQUcsR0FBR0EsR0FBRyxJQUFUQTtBQUNBLFlBQUl4VCxJQUFJLEdBQUcsU0FBWCxDQUFXLENBQVg7QUFDQUEsWUFBSSxDQUFKQTtBQUNBLFlBQUl3WCxrQkFBa0IsR0FBR3hYLElBQUksQ0FBSkEsZUFBekI7QUFDQSxZQUFJeVgsSUFBSSxHQUFHUixJQUFJLEdBQUpBLGNBQVg7QUFDQWpYLFlBQUksQ0FBSkEsV0FBZ0JBLElBQUksQ0FBSkEsZUFBaEJBO0FBQ0E7UUFHRjs7O0FBRUEsVUFBSTBYLGFBQWEsR0FBRyw2Q0FBcEIsRUFBb0IsQ0FBcEI7QUFDQSxVQUFJQyx1QkFBdUIsR0FBRyw2Q0FBOUIsRUFBOEIsQ0FBOUI7O0FBRUEscUNBQStCO0FBQzdCLGVBQU9yRSxJQUFJLEdBQUpBLGFBQXFCQSxJQUFJLEdBQUpBLFdBQWtCQSxJQUFJLEdBQUpBLFFBQTlDO0FBQ0Q7O0FBRUQsK0NBQXlDO0FBQ3ZDLFlBQUlDLEtBQUssR0FBTEEsS0FBYUEsS0FBSyxHQUF0QixJQUE2QjtBQUMzQjtBQUNEOztBQUVELFlBQUl2VCxJQUFJLElBQVIsTUFBa0I7QUFDaEIsY0FBSUEsSUFBSSxHQUFSLEdBQWM7QUFDWjtBQUNEOztBQUVELGNBQUk0WCxVQUFVLEdBQUdDLGVBQWUsQ0FBaEMsSUFBZ0MsQ0FBaEM7O0FBQ0EsY0FBSUQsVUFBVSxJQUFJNVgsSUFBSSxHQUFHMlgsdUJBQXVCLENBQWhELEtBQWdELENBQWhELEVBQXlEO0FBQ3ZEO0FBQ0Q7O0FBQ0QsY0FBSSxlQUFlM1gsSUFBSSxHQUFHMFgsYUFBYSxDQUF2QyxLQUF1QyxDQUF2QyxFQUFnRDtBQUM5QztBQUNEO0FBQ0Y7O0FBRUQ7QUFDRDs7QUFFRCxzREFBZ0Q7QUFDOUMsWUFBSVgsU0FBUyxHQUFiLEdBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQsWUFBSWEsVUFBVSxHQUFHQyxlQUFlLENBQWhDLElBQWdDLENBQWhDOztBQUNBLFlBQUlELFVBQVUsSUFBSWIsU0FBUyxHQUEzQixLQUFtQztBQUNqQztBQUNEOztBQUNELFlBQUksZUFBZUEsU0FBUyxHQUE1QixLQUFvQztBQUNsQztBQUNEOztBQUVEO0FBQ0Q7O0FBRUQsaURBQTJDO0FBQ3pDLFlBQUlFLElBQUksR0FBSkEsS0FBWUEsSUFBSSxHQUFwQixJQUEyQjtBQUN6QjtBQUNEOztBQUVELFlBQUl6RCxHQUFHLElBQUhBLFNBQWdCQSxHQUFHLEdBQUhBLEtBQVdBLEdBQUcsR0FBbEMsQ0FBSUEsQ0FBSixFQUF5QztBQUN2QztBQUNEOztBQUVEO0FBQ0Q7O0FBRUQscURBQStDO0FBQzdDLFlBQUl6UyxLQUFLLElBQUxBLFNBQWtCQSxLQUFLLEdBQUxBLEtBQWFBLEtBQUssSUFBeEMsRUFBSUEsQ0FBSixFQUFpRDtBQUMvQztBQUNEOztBQUVELFlBQUlJLE9BQU8sSUFBUEEsU0FBb0JBLE9BQU8sR0FBUEEsS0FBZUEsT0FBTyxJQUE5QyxFQUFJQSxDQUFKLEVBQXVEO0FBQ3JEO0FBQ0Q7O0FBRUQsWUFBSW9XLE9BQU8sSUFBUEEsU0FBb0JBLE9BQU8sR0FBUEEsS0FBZUEsT0FBTyxJQUE5QyxFQUFJQSxDQUFKLEVBQXVEO0FBQ3JEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUMxZEY7O0FBQUE7QUFBQSxVQUFJaFgsc0JBQXNCLEdBQTFCOztBQUVBLDZDQUF1QztBQUNyQyxlQUFPUCxJQUFJLENBQUpBLFlBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlLDBEQUFvRDtBQUNqRSxZQUFJQSxJQUFJLEdBQUcsU0FBUzhYLFNBQVMsQ0FBN0IsT0FBb0JBLEVBQVQsQ0FBWDtBQUNBLFlBQUlDLGtCQUFrQixHQUFHeGIsSUFBSSxDQUFKQSxLQUFVeUQsSUFBSSxDQUF2QyxpQkFBbUNBLEVBQVZ6RCxDQUF6QjtBQUNBeUQsWUFBSSxDQUFKQTtBQUNBLFlBQUlnWSxvQkFBb0IsR0FBR0Qsa0JBQWtCLEdBQTdDO0FBQ0EsWUFBSUUsZ0NBQWdDLEdBQUdELG9CQUFvQixHQUFHLENBQUN6WCxzQkFBc0IsR0FBRzJYLHVCQUF1QixDQUFqRCxJQUFpRCxDQUFqRCxJQUFILHlCQUF1RkEsdUJBQXVCLENBQXpLLElBQXlLLENBQXpLO0FBQ0EsZUFBT0gsa0JBQWtCLEdBQWxCQSx5QkFBUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBTXRXLFdBQVcsR0FBRyxTQUFkQSxXQUFjLGFBQVU7QUFBQTs7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7O0FBUzFCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWQ4Qiw4Q0FlUjtBQUNoQixzQ0FBd0IseUJBQXhCOztBQUNBO0FBQ0Q7QUFFRDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTNCOEI7QUFBQTtBQUFBLCtDQTRCUDtBQUNqQixzQ0FBd0IseUJBQXhCOztBQUNBLGtCQUFJLENBQUosU0FBYztBQUNaLHVCQUFPLGdCQUFQLElBQU8sQ0FBUDtBQURGLHFCQUVPO0FBQ0wscUJBQUssSUFBTCxxQkFBZ0MsS0FBaEMsWUFBaUQ7QUFDL0Msc0JBQ0UscURBQ0EsdUNBRkYsU0FHRTtBQUNBLDJCQUFPLGdCQUFQLElBQU8sQ0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBRUQ7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWpEOEI7QUFBQTtBQUFBLGtEQWtESjtBQUNwQixrQkFBTTBXLFFBQVEsR0FBRyx5QkFBakI7QUFDQUEsc0JBQVEsQ0FBUkEsUUFBaUIsbUJBQVc7QUFDMUJDLHVCQUFPLENBQVBBLE9BQU8sQ0FBUEE7QUFERkQ7QUFHRDtBQXZEeUI7O0FBQUE7QUFBQTtBQUE5QjtBQTBEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsMkNBQXFDO0FBQ25DLGVBQU8xVyxXQUFXLENBQWxCLFVBQWtCLENBQWxCO0FBQ0Q7QUFFY0E7OztBQUFBQSwyQ0FBZixXQUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEZmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7VUFFTUMsYSxHQURMa087QUFBQUE7QUFBQUEsUzs7OztBQUVDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUdFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBR0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFHRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDRSxpQ0FBOEI7QUFBQTs7QUFBQSxjQUFsQnlJLFFBQWtCLHVFQUFQLEtBQU87O0FBQUE7O0FBQzVCO0FBRDRCLGdCQXJCOUJDLE1BcUI4QixHQXJCckIsSUFxQnFCO0FBQUEsZ0JBZDlCQyxZQWM4QixHQWRmLElBY2U7QUFBQSxnQkFQOUJuSCxPQU84QixHQVBwQixFQU9vQjtBQUc1Qix1QkFBWXZPLFFBQVEsQ0FBUkEsY0FBWixLQUFZQSxDQUFaO0FBQ0E7QUFDQTtBQUFzQjtBQUF0Qix5SkFHSXdWLFFBQVEsZ0NBSFosNEhBTVFBLFFBQVEsMkJBTmhCO0FBTDRCO0FBbUI3QjtBQUVEO0FBQ0Y7QUFDQTs7Ozs7K0JBR094aEIsTSxFQUFRO0FBQ1g7QUFDQSxnQkFBTW9iLFVBQVUsR0FBRyw2Q0FBbkIsSUFBbUIsQ0FBbkI7QUFDQSxnQkFBTXVHLFNBQVMsR0FBRyw2Q0FBbEIsSUFBa0IsQ0FBbEI7QUFDQSxnQkFBTUMsYUFBYSxHQUFHLGdEQUF0QixLQUFzQixDQUF0QjtBQUNBLGdCQUFNQyxVQUFVLEdBQUcsQ0FBQyxpREFBcEIsSUFBb0IsQ0FBcEI7QUFFQSxnQkFBSUMsVUFBVSxHQUFHLCtCQVBOLE1BT00sQ0FBakIsQ0FQVyxDQVNYOztBQUNBLGdCQUFJLENBQUosWUFBaUI7QUFDZkEsd0JBQVUsR0FBR0QsVUFBVSxRQUF2QkM7O0FBQ0EsOEJBQWdCO0FBQ2RBLDBCQUFVLElBQUlILFNBQVMsZ0JBQXZCRzs7QUFFQSxtQ0FBbUI7QUFDakJBLDRCQUFVLElBQVZBO0FBQ0Q7QUFDRjtBQUNGOztBQUVEQSxzQkFBVSxHQUFHQSxVQUFVLENBckJaLElBcUJFQSxFQUFiQSxDQXJCVyxDQXVCWDs7QUFDQSwwQkFBY0MsU0FBUyxDQUFDLEtBQUQsTUFBWTtBQUNqQ0Msa0JBQUksRUFENkI7QUFFakM7QUFDQTtBQUNBQyx3QkFBVSxFQUp1QjtBQUtqQ0Msc0JBQVEsRUFBRSxLQUx1QjtBQU1qQ0Msd0JBQVUsRUFBRSxLQU5xQjtBQU9qQ0MscUJBQU8sRUFBRSxzQ0FQd0IsSUFPeEIsQ0FQd0I7QUFRakNDLHFCQUFPLEVBQUUsc0NBUndCLElBUXhCLENBUndCO0FBU2pDQyx5QkFBVyxFQUFFLDhDQVRvQixFQVNwQixDQVRvQjtBQVVqQ0MsMkJBQWEsRUFBRSxnREFWa0IsQ0FVbEIsQ0FWa0I7QUFXakNDLDJCQUFhLEVBQUUsZ0RBWGtCLEtBV2xCLENBWGtCO0FBWWpDQyx5QkFBVyxFQUFFLG1EQVpvQixLQVlwQixDQVpvQjtBQWFqQzlHLG9CQUFNLEVBQUUsS0FieUIsZ0JBYXpCLEVBYnlCO0FBY2pDa0csd0JBQVUsRUFkdUI7QUFlakNDLHdCQUFVLEVBZnVCO0FBZ0JqQzFHLHdCQUFVLEVBaEJ1QjtBQWlCakN3RywyQkFBYSxFQWpCb0I7QUFrQmpDRCx1QkFBUyxFQUFUQTtBQWxCaUMsYUFBWixDQUF2QixDQXhCVyxDQTZDWDs7QUFDQTtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUVZO0FBQ1I7QUFDQSxxQkFBUzlXLGFBQWEsQ0FBdEI7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7a0NBQ1VqTSxLLEVBQU87QUFDYjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O2lDQUNTO0FBQ0w7O0FBQ0E7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztrQ0FDVTtBQUNOO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7Ozs7a0NBQ1U7QUFDTjtBQUNBLGdCQUFJLFlBQUosUUFBd0I7QUFDdEI7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztxQ0FFYXVLLEksRUFBTXVaLE0sRUFBUTtBQUN2QixnQkFBTUMsaUJBQWlCLEdBQUcsb0NBQW9DLEtBQTlELE9BQTBCLENBQTFCO0FBQ0EsZ0JBQU1oSCxNQUFNLEdBQUcsaUNBRWIsS0FGYSxTQUdiQyxJQUFJLENBQUpBLDZDQUhGLE9BQWUsQ0FBZjs7QUFNQSxtQ0FBdUI7QUFDckIsa0JBQU1sWCxJQUFJLFdBQVYsaUJBQVUsQ0FBVjs7QUFDQSxrQkFBSWtlLFVBQVUsR0FBZDs7QUFFQTtBQUNFO0FBQ0Usc0JBQUksRUFBRUEsVUFBVSxDQUFWQSxxQkFBTixDQUFJLENBQUosRUFBMEM7QUFDeENBLDhCQUFVLEdBQUcseUJBQWJBO0FBQ0Q7O0FBRUQseUJBQU8sdUZBTWlCL0csR0FBRyxDQUFIQSxNQU54QixRQUFPLENBQVA7O0FBUUY7QUFDRSx5QkFBTzhHLGlCQUFpQix1QkFBdUI5RyxHQUFHLENBQUhBLE1BQS9DLFFBQXdCLENBQXhCOztBQUNGO0FBQ0Usd0JBQU0sbUVBQzZDLG9CQUQ3QyxPQUFOLDZEQUFNLEVBQU47QUFqQko7QUFKRixtQkF5Qk87QUFDTCxrQkFBSSxXQUFZNkcsTUFBTSxJQUFJQSxNQUFNLENBQU5BLGVBQTFCLEdBQW9EO0FBQ2xEO0FBQ0Q7O0FBRUQscUJBQU83RyxHQUFHLENBQUhBLGtDQUFQLE1BQU9BLENBQVA7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozt5Q0FFaUJnSCxhLEVBQWU7QUFDNUIsZ0NBQW9CQSxhQUFhLENBQWJBLENBQWEsQ0FBYkEsSUFBcEI7QUFDQSx3QkFBWWhZLGFBQWEsQ0FBekIsaUJBQTJDLEtBQTNDO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs2Q0FDcUI7QUFDakIsZ0JBQU04USxNQUFNLEdBQUdDLElBQUksQ0FBSkEsNkNBQWY7QUFFQSxnQkFBTWtILGFBQWEsR0FBbkI7QUFDQSxnQkFBTUMsWUFBWSxHQUFsQjs7QUFFQSxpQkFBSyxJQUFJcEcsR0FBRyxHQUFaLEdBQWtCQSxHQUFHLEdBQXJCLElBQTRCQSxHQUE1QixJQUFtQztBQUNqQyxrQkFBTXhULElBQUksR0FBRyxlQUFlLElBQWYsR0FBYixHQUFhLENBQWI7QUFFQTJaLDJCQUFhLENBQWJBLEtBQ0UsSUFBSSxDQUFKLHVCQUMwQjtBQUN0QkUsdUJBQU8sRUFBRTtBQURhLGVBRDFCLGFBREZGLENBQ0UsQ0FERkEsQ0FLbUI7QUFMbkJBO0FBUUFDLDBCQUFZLENBQVpBLEtBQ0UsSUFBSSxDQUFKLHVCQUMwQjtBQUN0QkMsdUJBQU8sRUFBRTtBQURhLGVBRDFCLGFBREZELENBQ0UsQ0FERkEsQ0FLbUI7QUFMbkJBO0FBT0Q7O0FBRUQsZ0JBQU1FLFdBQVcsR0FBakI7QUFDQSxnQkFBTUMsVUFBVSxHQUFoQjs7QUFFQSxpQkFBSyxJQUFJeEcsS0FBSyxHQUFkLEdBQW9CQSxLQUFLLEdBQXpCLElBQWdDQSxLQUFoQyxJQUF5QztBQUN2QyxrQkFBTXZULEtBQUksR0FBRyxzQkFBYixDQUFhLENBQWI7O0FBRUE4Wix5QkFBVyxDQUFYQSxLQUNFLEtBQUksQ0FBSix1QkFBNEI7QUFDMUJ2RyxxQkFBSyxFQUFFO0FBRG1CLGVBQTVCLENBREZ1RztBQU1BQyx3QkFBVSxDQUFWQSxLQUNFLEtBQUksQ0FBSix1QkFBNEI7QUFDMUJ4RyxxQkFBSyxFQUFFO0FBRG1CLGVBQTVCLENBREZ3RztBQUtEOztBQUVELG1CQUFPO0FBQ0xDLHNCQUFRLEVBQUU7QUFDUkMseUJBQVMsRUFERDtBQUVSQyx3QkFBUSxFQUFFTjtBQUZGLGVBREw7QUFLTE8sb0JBQU0sRUFBRTtBQUNORix5QkFBUyxFQURIO0FBRU5DLHdCQUFRLEVBQUVIO0FBRkosZUFMSDtBQVNMSyx5QkFBVyxFQUFFLDZDQVRSLEVBU1EsQ0FUUjtBQVVMQyw0QkFBYyxFQUFFM0gsR0FBRyxDQUFIQSx1Q0FWWCxNQVVXQSxDQVZYO0FBV0w7QUFDQTRILHFCQUFPLEVBQUUseUJBQU07QUFBQTtBQVpWO0FBYUxDLDRCQUFjLEVBYlQ7QUFjTEMsOEJBQWdCLEVBZFg7QUFlTEMseUJBQVcsRUFmTjtBQWdCTEMseUJBQVcsRUFoQk47QUFpQkxDLGtCQUFJLEVBQUUsT0FqQkQsSUFpQkMsQ0FqQkQ7QUFrQkxDLDJCQUFhLEVBbEJSO0FBbUJMQywyQkFBYSxFQW5CUjtBQW9CTEMsNkJBQWUsRUFBRTtBQXBCWixhQUFQO0FBc0JEOzs7O1FBbFN5QnZtQjtBQUFBQTtBQUFBQSxPLFdBUW5Cd21CLGUsR0FBa0IsK0Isa0VBRHhCbEs7QUFBQUE7QUFBQUEsTzs7Ozs7OzswRUFxREE3TjtBQUFBQTtBQUFBQSxPLDRJQXNEQUE7QUFBQUE7QUFBQUEsTyxrSkFnREFDO0FBQUFBO0FBQUFBLE8seUpBZ0RBQTtBQUFBQTtBQUFBQSxPLHNHQW5ORjJNLEs7QUFzU2NsTzs7O0FBQUFBLGlDQUFmLGFBQWVBOzs7Ozs7O0FDelRmLFVBQUk1SSxPQUFPLEdBQUdzSyxtQkFBTyxDQUFyQixHQUFxQixDQUFyQjs7QUFFQSxVQUFHLG1CQUFILFVBQWdDdEssT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBRCxZQUFYRSxFQUFXLENBQUQsQ0FBVkE7QUFFaEM7QUFDQTtBQUlBLFVBQUl1SyxPQUFPLEdBQUc7QUFBQyxlQUFNO0FBQVAsT0FBZDtBQUVBQSxhQUFPLENBQVBBOztBQUNBQSxhQUFPLENBQVBBLGFBQXFCLFlBQVc7QUFDaEIsZUFBT0MsTUFBTSxDQUFOQSxnQkFBUDtBQURoQkQ7O0FBSUEsVUFBSUUsTUFBTSxHQUFHSCxtQkFBTyxDQUFQQSxDQUFPLENBQVBBLFVBQWIsT0FBYUEsQ0FBYjs7QUFFQSxVQUFHdEssT0FBTyxDQUFWLFFBQW1CRixNQUFNLENBQU5BLFVBQWlCRSxPQUFPLENBQXhCRjs7QUFFbkIsaUJBQWUsRTs7Ozs7Ozs7QUNyQmYsaUNBQTJCLG1CQUFPLENBQUMsQ0FBRCxDQUFQLENBQXVELEtBQXZELENBQTNCLEMsQ0FDQTtBQUdBOztBQUNBLG9CQUFjLFFBQWQsRUFBdUIsNmpDQUF2QixFQUFtbEMsRUFBbmxDLEcsQ0FFQTs7Ozs7Ozs7QUNOQSxVQUFJRSxPQUFPLEdBQUdzSyxtQkFBTyxDQUFyQixHQUFxQixDQUFyQjs7QUFFQSxVQUFHLG1CQUFILFVBQWdDdEssT0FBTyxHQUFHLENBQUMsQ0FBQ0YsT0FBRCxZQUFYRSxFQUFXLENBQUQsQ0FBVkE7QUFFaEM7QUFDQTtBQUlBLFVBQUl1SyxPQUFPLEdBQUc7QUFBQyxlQUFNO0FBQVAsT0FBZDtBQUVBQSxhQUFPLENBQVBBOztBQUNBQSxhQUFPLENBQVBBLGFBQXFCLFlBQVc7QUFDaEIsZUFBT0MsTUFBTSxDQUFOQSxnQkFBUDtBQURoQkQ7O0FBSUEsVUFBSUUsTUFBTSxHQUFHSCxtQkFBTyxDQUFQQSxDQUFPLENBQVBBLFVBQWIsT0FBYUEsQ0FBYjs7QUFFQSxVQUFHdEssT0FBTyxDQUFWLFFBQW1CRixNQUFNLENBQU5BLFVBQWlCRSxPQUFPLENBQXhCRjs7QUFFbkIsaUJBQWUsRTs7Ozs7Ozs7QUNyQmYsaUNBQTJCLG1CQUFPLENBQUMsQ0FBRCxDQUFQLENBQXVELEtBQXZELENBQTNCLEMsQ0FDQTtBQUdBOztBQUNBLG9CQUFjLFFBQWQsRUFBdUIsdVZBQXZCLEVBQTZXLEVBQTdXLEcsQ0FFQTs7Ozs7Ozs7O0FDUEE7O0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJZW9pQjs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1VBQ01BLGM7Ozs7Ozs7Ozs7Ozs7OztnQkFJSkMsTSxHQUFTLElBQUl2WjtBQUFKO0FBQUlBLFdBQUosTTtnQkFLVHdaLE0sR0FBUyxJO2dCQU9UOUosTyxHQUFVLEk7Ozs7Ozs7QUFhVjtBQUNGO0FBQ0E7K0JBRU92YSxNLEVBQVE7QUFDWDtBQUNBLHNDQUEwQkEsTUFBTSxDQUFoQzs7QUFDQSxnQkFBSSxLQUFKLG9CQUE2QjtBQUMzQixrQkFBSWlMLHlCQUF5QixHQUMzQmpMLE1BQU0sQ0FBTkEsa0JBQXlCQSxNQUFNLENBQU5BLFlBRkEsRUFDM0IsQ0FEMkIsQ0FFc0I7O0FBRWpELDZDQUErQjtBQUM3QjtBQURGLHFCQUVPLElBQUlBLE1BQU0sQ0FBTkEsY0FBSixNQUErQjtBQUNwQyw4QkFBY0EsTUFBTSxDQUFwQjtBQURLLHFCQUVBO0FBQ0wsOEJBQWNBLE1BQU0sQ0FBcEI7O0FBQ0Esb0JBQUlBLE1BQU0sQ0FBTkEsWUFBSixLQUE0QjtBQUMxQjtBQUNBO0FBQ0Q7QUFDRjtBQWRILG1CQWVPO0FBQ0wsNEJBQWNBLE1BQU0sQ0FBcEI7QUFDRDs7QUFFRCwwQkFBY21rQixjQUFjLENBQWRBLFlBQTJCLEtBQXpDLE1BQWNBLENBQWQ7O0FBQ0E7O0FBQ0EsMkJBQWV0WjtBQUFBQTtBQUFBQSxjQUFmLGlCQUE4QyxLQUE5Qzs7QUFFQSxnQkFBSSxLQUFKLFFBQWlCO0FBQ2Ysa0NBQ0VxUjtBQUFBQTtBQUFBQSxpQkFBZSxLQUFELE1BQWRBLEVBQTRCTCxHQUFHLENBQUhBLGtCQUQ5QixtQkFDOEJBLEVBQTVCSyxDQURGO0FBR0Q7O0FBRUQsd0JBQVksWUFBWixNQUFZLEVBQVo7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztvQ0FFWTtBQUNSO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTs7Ozs2Q0FDcUI7QUFDakIsZ0JBQUksS0FBSixvQkFBNkI7QUFDM0I7QUFDRDtBQUNGO0FBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7OztxQ0FDYTtBQUNULG1CQUFPLHdCQUF3QixLQUEvQixNQUFPLENBQVA7QUFDRDtBQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7b0NBQ1k7QUFDUjtBQUNEO0FBRUQ7QUFDRjtBQUNBOzs7O29DQUNZO0FBQ1I7QUFDRDtBQUVEO0FBQ0Y7QUFDQTs7OztxQ0FDYTtBQUNUO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7O3dDQUVnQi9TLEksRUFBTTtBQUNsQiwwQkFBY0EsSUFBSSxZQUFKQSxPQUF1QkEsSUFBSSxDQUEzQkEsV0FBdUJBLEVBQXZCQSxHQUFkO0FBQ0Q7Ozs7QUE1R0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7c0NBQ3FCdkssSyxFQUFPO0FBQ3hCLG1CQUFPaWQsR0FBRyxDQUFIQSw4QkFBUCxLQUFPQSxDQUFQO0FBQ0Q7Ozs7UUEzQjBCbmU7QUFBQUE7QUFBQUEsTyxpRUFnQzFCeU87QUFBQUE7QUFBQUEsTyx5SUF1Q0FBO0FBQUFBO0FBQUFBLE8sa0pBb0RBQztBQUFBQTtBQUFBQSxPO0FBTVkrWDs7QUFBQUEsaUNBQWYsY0FBZUE7Ozs7O0FwSTdKZjtDQVZBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSxtSEFDQSwyT0FEQSxLQUVBLFVBQ0E7QUFBQTtBQUFBO0FBQUEscUdBREEsS0FFQSxFQUdBO0FBQ0MsQ0FURCxFQVNDLDJDQVRELEVBU0M7QUFDRDs7Ozs7QXFJVkE7QUFBQTs7QUFDQTtBQUFBOzs7QUFFQTtBQUFBOztBQUNBOztBQUFBOzs7QUFFQTtBQUFBOztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7O0FBQ0E7OztBQUFBO0FBQ0E7QUFBQSxxQkFEQTs7QUFFQTtBQUFBLGtCQUZBOztBQUdBO0FBQUE7QUFDQTs7QUFKQTs7O0FBTUE7QUFBQTs7QUFDQTs7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7QUFBQTs7O0FBRUE7QUFBQTs7QUFDQTs7QUFBQTtBQUNBO0FBQUE7Ozs7O0FBR0E7QUFBQTs7QUFDQTs7O0FBQUE7OztBQUVBO0FBQUE7O0FBQ0E7O0FBQUE7OztBQUVBO0FBQUE7O0FBQ0E7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUEsK0JBREE7O0FBRUE7QUFBQSw0QkFGQTs7QUFHQTtBQUFBO0FBQ0E7O0FBSkE7QUFLQTtBQUFBO0FBQ0E7O0FBQUEsT0FSQTs7O0FBVUE7QUFBQTs7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUEyQjtBQUE0QixTQUR2RDtBQUVBO0FBQUE7QUFBaUM7QUFBZSxTQUZoRDtBQUdBOztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFBQSxPQU5BOzs7QUFRQTtBQUFBOztBQUNBOzs7QUFBQTtBQUFzRDtBQUErRCxPQUFySDs7O0FBRUE7QUFBQTs7QUFDQTs7O0FBQUE7OztBQUVBO0FBQUE7O0FBQ0E7O0FBQUE7Ozs7Ozs7Ozs7O0FDN0RBOzs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFBQTtBQUFBOzs7Ozs7OztBQVVlRzs7O0FBQUFBO0FBQWY7QUFBZUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1ZmOzs7Ozs7OztBQWdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUFpQ01BLFM7QUFDSjs7Ozs7Ozs7Ozs7QUFXQSw2QkFBMEI7QUFBQSxjQUFkOVgsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUN4QiwyQ0FDSztBQUNEeUMsb0JBQVEsRUFEUDtBQUVEckQsZUFBRyxFQUZGO0FBR0QyWSx5QkFBYSxFQUhaO0FBSURDLDJCQUFlLEVBSmQ7QUFLRHRWLG9CQUFRLEVBTFA7QUFNREMscUJBQVMsRUFBRTtBQU5WLFdBREw7QUFXQSw4QkFBb0IsdUJBQXBCLElBQW9CLENBQXBCO0FBQ0EsMEJBQWdCLG1CQUFoQixJQUFnQixDQUFoQjtBQUNBO0FBQ0Q7QUFFRDs7Ozs7Ozs7b0NBSVU7QUFDUixnQkFBTUYsUUFBUSxHQUNaLE9BQU8sYUFBUCx3QkFDSSxrQ0FBa0MsYUFEdEMsUUFDSSxDQURKLEdBRUksYUFITjtBQUlBOztBQUVBLGlCQUFLLElBQUkxUSxDQUFDLEdBQVYsR0FBZ0JBLENBQUMsR0FBRzBRLFFBQVEsQ0FBNUIsUUFBcUMxUSxDQUFyQyxJQUEwQztBQUN4Q3FSLG1CQUFLLEdBQUdYLFFBQVEsQ0FBaEJXLENBQWdCLENBQWhCQTs7QUFDQSxrQkFBSUEsS0FBSyxZQUFULGtCQUF1QztBQUNyQzZVLDJCQUFXLEdBQUc3VSxLQUFLLENBQUxBLHdCQUFkNlUsT0FBYzdVLENBQWQ2VTs7QUFFQSxvQkFBSSxDQUFDN1UsS0FBSyxDQUFMQSxhQUFMLElBQUtBLENBQUwsRUFBK0I7QUFDN0JwTCx5QkFBTyxDQUFQQTtBQUlBO0FBUm1DLGtCQVdyQzs7O0FBQ0Esb0JBQU1rZ0IsU0FBUyxHQUNiRCxXQUFXLElBQUlBLFdBQVcsQ0FBWEEsaUNBQTZDLENBRDlEOztBQUVBO0FBZEYscUJBZU87QUFDTGpnQix1QkFBTyxDQUFQQTtBQUlEO0FBQ0Y7QUFDRjtBQUVEOzs7Ozs7b0NBR1U7QUFDUixnQkFBTXlLLFFBQVEsR0FDWixPQUFPLGFBQVAsd0JBQ0ksa0NBQWtDLGFBRHRDLFFBQ0ksQ0FESixHQUVJLGFBSE47QUFLQTs7QUFFQSxpQkFBSyxJQUFJMVEsQ0FBQyxHQUFWLEdBQWdCQSxDQUFDLEdBQUcwUSxRQUFRLENBQTVCLFFBQXFDMVEsQ0FBckMsSUFBMEM7QUFDeENxUixtQkFBSyxHQUFHWCxRQUFRLENBQWhCVyxDQUFnQixDQUFoQkE7QUFDQXBQLG9CQUFNLEdBQUdvUCxLQUFLLENBQWRwUDtBQUNBaWtCLHlCQUFXLEdBQUdqa0IsTUFBTSxDQUFOQSxhQUFkaWtCLE9BQWNqa0IsQ0FBZGlrQjs7QUFFQSxrQkFBSUEsV0FBVyxJQUFJQSxXQUFXLENBQVhBLGlDQUE2QyxDQUFoRSxHQUFvRTtBQUNsRTtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7Ozs7Ozs7Ozs7OztnQ0FXTTdVLEssRUFBTzhVLFMsRUFBVztBQUN0QixnQkFBTUMsT0FBTyxHQUFHL1UsS0FBSyxDQUFMQSxhQUFoQixJQUFnQkEsQ0FBaEI7QUFBQSxnQkFDRWdWLFNBQVMsR0FBR2hWLEtBQUssQ0FBTEEsYUFEZCxNQUNjQSxDQURkO0FBQUEsZ0JBRUVqQixJQUFJLEdBQUdpQixLQUFLLENBQUxBLGdCQUZUO0FBQUEsZ0JBR0VpVixlQUFlLEdBQUdqVixLQUFLLENBSHpCO0FBQUEsZ0JBSUVrVixjQUFjLEdBQUdDO0FBQUFBO0FBQUFBLGVBSm5CLElBSW1CQSxDQUpuQjtBQUFBLGdCQUtFaFYsT0FBTyxHQUFHOFUsZUFBZSxJQUwzQjtBQU9BLGdCQUFJN0MsSUFBSSxHQUFSO0FBQUEsZ0JBQ0VnRCxXQUFXLEdBRGI7O0FBR0EsZ0JBQUksQ0FBSixXQUFnQjtBQUNkaEQsa0JBQUksR0FBRywrQkFBUEEsTUFBTyxDQUFQQTtBQUNBZ0QseUJBQVcsR0FBRywrQkFGQSxPQUVBLENBQWRBLENBRmMsQ0FFd0M7QUFGeEQsbUJBR087QUFDTGhELGtCQUFJLEdBQUdwUyxLQUFLLENBQVpvUztBQUNBZ0QseUJBQVcsR0FBR2hELElBQUksQ0FBSkEsY0FBZGdELCtCQUFjaEQsQ0FBZGdEO0FBaEJvQixjQW1CdEI7QUFDQTs7O0FBQ0FwVixpQkFBSyxDQUFMQSxRQUFjcVY7QUFBQUE7QUFBQUEsZUFBZ0JyVixLQUFLLENBQU4sS0FBZnFWLEVBQWRyVixJQUFjcVYsQ0FBZHJWO0FBQ0FBLGlCQUFLLENBQUxBO0FBQ0FBLGlCQUFLLENBQUxBO0FBQ0FBLGlCQUFLLENBQUxBO0FBQ0FBLGlCQUFLLENBQUxBLHdCQUE4QnNWO0FBQUFBO0FBQUFBLGVBQU90VixLQUFLLENBQU4sS0FBTnNWLEVBQTlCdFYsSUFBOEJzVixDQUE5QnRWOztBQUNBLGdCQUFJaVYsZUFBZSxJQUFJQSxlQUFlLEtBQXRDLGdCQUEyRDtBQUN6RGpWLG1CQUFLLENBQUxBO0FBQ0Q7O0FBRUQsZ0JBQUksQ0FBSixXQUFnQjtBQUNkLGtCQUFJLEVBQUVBLEtBQUssQ0FBTEEsNEJBQWtDQSxLQUFLLENBQUxBLGFBQXhDLFNBQXdDQSxDQUFwQyxDQUFKLEVBQXdFO0FBQ3RFQSxxQkFBSyxDQUFMQSwwQkFBZ0MsS0FBaENBO0FBQ0FBLHFCQUFLLENBQUxBLDZCQUFtQyxLQUFuQ0E7QUFDQUEscUJBQUssQ0FBTEEsMEJBQWdDLEtBQWhDQTtBQUNBQSxxQkFBSyxDQUFMQSw0QkFBa0MsS0FBbENBO0FBQ0FBLHFCQUFLLENBQUxBLDBCQUFnQyxLQUFoQ0E7QUFDRDs7QUFDREEsbUJBQUssQ0FBTEEsOEJBUmMsS0FRZEEsRUFSYyxDQVE2QjtBQUM1Qzs7QUFFRCxnQkFBSSxvQkFBSixLQUFJLENBQUosRUFBZ0M7QUFDOUIsa0NBQW9CQSxLQUFLLENBQXpCLE9BQWlDQSxLQUFLLENBQUxBLFFBQWpDO0FBMUNvQixjQTZDdEI7QUFDQTs7O0FBQ0FvVix1QkFBVyxDQUFYQTtBQUNBQSx1QkFBVyxDQUFYQTtBQUNBQSx1QkFBVyxDQUFYQTtBQUNBQSx1QkFBVyxDQUFYQSxRQUFvQnBWLEtBQUssQ0FBTEEsUUFBcEJvVjtBQUNBLHlCQUFhQSxXQUFXLENBQVhBO0FBQ2IsMkJBQWVBLFdBQVcsQ0FBWEE7O0FBRWYsZ0JBQUksQ0FBSixXQUFnQjtBQUNkO0FBQ0FoRCxrQkFBSSxDQUFKQTtBQUNBQSxrQkFBSSxDQUFKQTtBQUNBQSxrQkFBSSxDQUFKQTtBQUNEOztBQUVEO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztrQ0FPUW1ELFMsRUFBVztBQUNqQkEscUJBQVMsQ0FBVEEsWUFDRUEsU0FBUyxDQUFUQSxjQURGQSwrQkFDRUEsQ0FERkE7QUFJQSxnQkFBTXZWLEtBQUssR0FBR3VWLFNBQVMsQ0FBVEEsY0FBZCwyQkFBY0EsQ0FBZDtBQUNBdlYsaUJBQUssQ0FBTEEsNkJBQW1DLEtBQW5DQTtBQUNBQSxpQkFBSyxDQUFMQSxnQ0FBc0MsS0FBdENBO0FBQ0FBLGlCQUFLLENBQUxBLDZCQUFtQyxLQUFuQ0E7QUFDQUEsaUJBQUssQ0FBTEEsK0JBQXFDLEtBQXJDQTtBQUNBQSxpQkFBSyxDQUFMQSw2QkFBbUMsS0FBbkNBO0FBQ0EsbUJBQU9BLEtBQUssQ0FBTEEsUUFBUDs7QUFDQSxnQkFBSSxDQUFDQSxLQUFLLENBQUxBLFFBQUwsaUJBQW9DO0FBQ2xDQSxtQkFBSyxDQUFMQTtBQUNBLHFCQUFPQSxLQUFLLENBQUxBLFFBQVA7QUFDRDs7QUFFREEsaUJBQUssQ0FBTEEsaUJBQXVCLGFBQXZCQTtBQUVBdVYscUJBQVMsQ0FBVEE7QUFDQUEscUJBQVMsQ0FBVEE7QUFDRDtBQUVEOzs7Ozs7Ozs7O3VDQU9halosQyxFQUFHO0FBQ2QsZ0JBQUlBLENBQUMsQ0FBREEsV0FBYUEsQ0FBQyxDQUFkQSxZQUEyQkEsQ0FBQyxDQUE1QkEsVUFBdUNBLENBQUMsQ0FBNUMsU0FBc0Q7QUFDdEQsZ0JBQUdBLENBQUMsQ0FBREEsWUFBSCxJQUFxQkEsQ0FBQyxDQUFEQTtBQUVyQixnQkFBTTBELEtBQUssR0FBRzFELENBQUMsQ0FBZjtBQUFBLGdCQUNFeUMsSUFBSSxHQUFHaUIsS0FBSyxDQUFMQSxnQkFBc0IsYUFEL0I7QUFBQSxnQkFFRXdWLFNBQVMsR0FBR2xaLENBQUMsQ0FGZjtBQUlBMEQsaUJBQUssQ0FBTEEsaUJBQXVCLGFBQXZCQTtBQUNBQSxpQkFBSyxDQUFMQSxpQkFBdUIsYUFBdkJBO0FBQ0FBLGlCQUFLLENBQUxBO0FBRUEsZ0JBQUloUixLQUFLLEdBQUdnUixLQUFLLENBQWpCO0FBQUEsZ0JBQ0V5VixPQUFPLEdBQUduWixDQUFDLENBRGI7QUFBQSxnQkFFRW9aLFVBQVUsR0FBR3BaLENBQUMsQ0FBREEsT0FBU0EsQ0FBQyxDQUFEQSx3QkFGeEIsRUFFd0JBLENBRnhCO0FBQUEsZ0JBR0V6TixHQUFHLEdBQUc2bUIsVUFBVSxHQUFJQSxVQUFVLENBQVZBLGtCQUFKLGFBSGxCO0FBQUEsZ0JBSUVDLGNBQWMsR0FBR0M7QUFBQUE7QUFBQUEsZUFBaUIsS0FBakJBLEVBSm5CLElBSW1CQSxDQUpuQjtBQUFBO0FBQUE7QUFBQSxnQkFPRUMsU0FBUyxHQVBYOztBQVNBO0FBQ0U7QUFDRW5oQix3QkFBUSxHQUFHMmdCO0FBQUFBO0FBQUFBLG1CQUNULENBQUMvWSxDQUFDLENBQURBLGlCQUFtQk8sTUFBTSxDQUExQix1QkFEd0IsTUFDeEIsQ0FEU3dZLEVBQVgzZ0IsSUFBVzJnQixDQUFYM2dCO0FBSUE7O0FBQ0Y7QUFDRUEsd0JBQVEsR0FBUkE7QUFDQTs7QUFDRjtBQUNFLG9CQUFNb2hCLGNBQWMsR0FBRzlWLEtBQUssQ0FBNUI7QUFDQSxvQkFBSThWLGNBQWMsS0FBbEIsZ0JBQXVDSCxjQUFjLEdBQWRBO0FBRXZDamhCLHdCQUFRLEdBQ04xRixLQUFLLENBQUxBLGtDQUF3Q0EsS0FBSyxDQUFMQSxPQUQxQzBGLGNBQzBDMUYsQ0FEMUMwRjtBQUVBOztBQUNGO0FBQ0U7QUFsQko7O0FBcUJBcWhCLHlCQUFhLEdBQUdUO0FBQUFBO0FBQUFBLGVBQU0sUUFBTkEsRUFBaEJTLElBQWdCVCxDQUFoQlM7O0FBRUEsZ0JBQUksOENBQThDLENBQWxELEdBQXNEO0FBQ3BELGtCQUFJO0FBQ0YvVixxQkFBSyxDQUFMQSxRQUFjZ1csMkZBQWRoVyxLQUFjZ1csQ0FBZGhXOztBQUNBLG9CQUFHLG9CQUFILEtBQUcsQ0FBSCxFQUErQjtBQUM3QkEsdUJBQUssQ0FBTEE7QUFDQSw0REFDTUEsS0FBSyxDQUFMQSxhQUROLElBQ01BLENBRE47O0FBR0E7O0FBQ0Esc0NBQW9CQSxLQUFLLENBQXpCLE9BQWlDQSxLQUFLLENBQUxBLFFBQWpDO0FBQ0Q7O0FBQ0Q2Vix5QkFBUyxHQUFUQTtBQVZGLGdCQVdFLGNBQWM7QUFDZDs7QUFDQTs7QUFDQUEseUJBQVMsR0FBVEE7QUFDRDs7QUFFRDtBQUNEOztBQUVELGdCQUFJLENBQUosV0FBZ0I7QUFDakI7QUFFRDs7Ozs7Ozs7Ozs7bUNBUVN2WixDLEVBQUc7QUFDVixnQkFBTTBELEtBQUssR0FBRzFELENBQUMsQ0FBZjtBQUNBLGdCQUFNeUMsSUFBSSxHQUFHaUIsS0FBSyxDQUFMQSxnQkFBc0IsYUFBbkM7O0FBQ0E7QUFDRDtBQUVEOzs7Ozs7Ozs7OzsrQ0FRcUJBLEssRUFBT2pCLEksRUFBTTtBQUNoQ2tYLHNCQUFVLENBQUMsWUFBTTtBQUNmLGtCQUFNQyxRQUFRLEdBQUdOO0FBQUFBO0FBQUFBLGlCQUFrQjVWLEtBQUssQ0FBTixLQUFqQjRWLEVBQWpCLElBQWlCQSxDQUFqQjtBQUNBNVYsbUJBQUssQ0FBTEE7QUFGUSxlQUFWaVcsQ0FBVSxDQUFWQTtBQUlEO0FBRUQ7Ozs7Ozs7Ozs7Ozt5Q0FTZWpXLEssRUFBTztBQUNwQixnQkFBTUosT0FBTyxHQUFHSSxLQUFLLENBQXJCLGFBQWdCQSxFQUFoQjs7QUFFQSx5QkFBYTtBQUNYOztBQUNBQSxtQkFBSyxDQUFMQTtBQUZGLG1CQUdPO0FBQ0w7O0FBQ0EsbUNBQXFCQSxLQUFLLENBQTFCO0FBQ0Q7O0FBRUQ7QUFDRDtBQUVEOzs7Ozs7eUNBR2VtVyxXLEVBQWFDLGEsRUFBZXBXLEssRUFBTztBQUNoRCxnQkFBSSxhQUFKLFVBQTJCO0FBQ3pCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7MENBR2dCRCxLLEVBQU9DLEssRUFBTztBQUM1QixnQkFBSSxhQUFKLFdBQTRCO0FBQzFCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7K0NBR3FCQSxLLEVBQU8wSixLLEVBQU87QUFDakMsZ0JBQUkxSixLQUFLLENBQUxBLDRCQUFrQ0EsS0FBSyxDQUFMQSxhQUF0QyxVQUFzQ0EsQ0FBdEMsRUFBc0U7QUFDcEVBLG1CQUFLLENBQUxBLGlCQUF1QixhQUF2QkE7QUFDQUEsbUJBQUssQ0FBTEEsaUJBQXVCLGFBQXZCQTtBQUZGLG1CQUdPO0FBQ0wsa0JBQUkwSixLQUFLLEtBQVQsV0FBeUI7QUFDdkIxSixxQkFBSyxDQUFMQSxpQkFBdUIsYUFBdkJBO0FBQ0FBLHFCQUFLLENBQUxBLGNBQW9CLGFBQXBCQTtBQUNEOztBQUVELGtCQUFJMEosS0FBSyxLQUFULFNBQXVCO0FBQ3JCMUoscUJBQUssQ0FBTEEsY0FBb0IsYUFBcEJBO0FBQ0FBLHFCQUFLLENBQUxBLGlCQUF1QixhQUF2QkE7QUFDRDtBQUNGO0FBQ0Y7Ozs7O0FBR1kwVTs7O0FBQUFBLGlDQUFmLFNBQWVBOzs7Ozs7OztBQ3haZjs7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7OztBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7O0FBQUE7QUFBQTs7O0FBQUE7QUFBQTs7Ozs7Ozs7O0FBVUEsVUFBTTJCLGVBQWUsR0FBRywrQkFBeEIsR0FBd0IsQ0FBeEI7QUFDQTs7Ozs7OztBQU1BLFVBQUlDLDZCQUE2QixHQUFqQzs7QUFDQSxVQUFJO0FBQ0ZDLFlBQUksQ0FBSkEsV0FBSSxDQUFKQTtBQUNBRCxxQ0FBNkIsR0FBN0JBO0FBRkYsUUFHRSxZQUFZO0FBQ1pBLHFDQUE2QixHQUE3QkE7QUFDRDtBQUVEOzs7Ozs7Ozs7O0FBUUEsVUFBTUUsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixjQUFpQjtBQUNyQyxZQUFJLE9BQU9BLGFBQWEsQ0FBcEIsY0FBSixhQUFvRDtBQUNsREEsdUJBQWEsQ0FBYkE7QUFDRDs7QUFFRCxZQUFNQyxRQUFRLGdDQUFkLElBQWMsQ0FBZDs7QUFFQSxZQUFJLENBQUNELGFBQWEsQ0FBYkEsVUFBTCxRQUFLQSxDQUFMLEVBQXdDO0FBQ3RDLGNBQU1ULGFBQWEsR0FBR1QsTUFBTSxRQUE1QixJQUE0QixDQUE1QjtBQUNBa0IsdUJBQWEsQ0FBYkEsc0JBQ0V4bkIsS0FBSyxLQUFLZ25CLHFGQURaUSxJQUNZUixDQURaUTtBQUVEOztBQUVELGVBQU9BLGFBQWEsQ0FBYkEsVUFBUCxRQUFPQSxDQUFQO0FBYkY7QUFnQkE7Ozs7Ozs7Ozs7O0FBU0EsVUFBTW5CLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0IsY0FBaUI7QUFDdkMsWUFBSSxPQUFPQSxlQUFlLENBQXRCLGNBQUosYUFBc0Q7QUFDcERBLHlCQUFlLENBQWZBO0FBQ0Q7O0FBRUQsWUFBTW9CLFFBQVEsZ0NBQWQsSUFBYyxDQUFkOztBQUVBLFlBQUksQ0FBQ3BCLGVBQWUsQ0FBZkEsVUFBTCxRQUFLQSxDQUFMLEVBQTBDO0FBQ3hDLGNBQUltQixhQUFhLFFBQWpCLElBQWlCLENBQWpCLEVBQWdDO0FBQzlCbkIsMkJBQWUsQ0FBZkE7QUFERixpQkFFTztBQUNMLGdCQUFJO0FBQ0ZBLDZCQUFlLENBQWZBLHNCQUFzQ1csbUZBQXRDWCxLQUFzQ1csQ0FBdENYO0FBREYsY0FNRSxVQUFVO0FBQ1ZBLDZCQUFlLENBQWZBLHNCQUFzQ1csMEVBQXRDWCxJQUFzQ1csQ0FBdENYO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGVBQU9BLGVBQWUsQ0FBZkEsVUFBUCxRQUFPQSxDQUFQO0FBdkJGO0FBMEJBOzs7Ozs7Ozs7QUFPQSxVQUFNRix1QkFBdUIsR0FBRyxTQUExQkEsdUJBQTBCLE9BQVE7QUFDdEMsWUFBSSxPQUFPQSx1QkFBdUIsQ0FBOUIsY0FBSixhQUE4RDtBQUM1REEsaUNBQXVCLENBQXZCQTtBQUNEOztBQUVELFlBQU1zQixRQUFRLEdBQWQ7O0FBRUEsWUFBSSxDQUFDdEIsdUJBQXVCLENBQXZCQSxVQUFMLFFBQUtBLENBQUwsRUFBa0Q7QUFDaEQsY0FBTXVCLFVBQVUsR0FBRzNYLElBQUksQ0FBSkEsTUFBbkIsRUFBbUJBLENBQW5CO0FBQ0EsY0FBSTRYLEtBQUssR0FBVDtBQUNBRCxvQkFBVSxDQUFWQSxRQUFtQixhQUFLO0FBQ3RCO0FBQ0U7QUFDRUMscUJBQUssSUFBTEE7QUFDQTs7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBQSxxQkFBSyxJQUFJTCw2QkFBNkIsY0FBdENLO0FBR0E7O0FBQ0Y7QUFDRUEscUJBQUssSUFBTEE7QUFDQTs7QUFDRjtBQUNBO0FBQ0VBLHFCQUFLLElBQUlMLDZCQUE2QixzQkFBdENLO0FBR0E7O0FBQ0Y7QUFDRUEscUJBQUssSUFBSUwsNkJBQTZCLDBEQUF0Q0s7QUFHQTs7QUFDRjtBQUNFQSxxQkFBSyxJQUFJQyxDQUFDLENBQURBLCtCQUFURCxNQUFTQyxDQUFURDtBQUNBO0FBNUJKO0FBREZEO0FBaUNBdkIsaUNBQXVCLENBQXZCQTtBQUNEOztBQUVELGVBQU9BLHVCQUF1QixDQUF2QkEsVUFBUCxRQUFPQSxDQUFQO0FBOUNGO0FBaURBOzs7Ozs7OztBQU1BLFVBQU1HLE1BQU0sR0FBRyxTQUFUQSxNQUFTLG9CQUF1QjtBQUNwQyxZQUFJLE9BQU9BLE1BQU0sQ0FBYixjQUFKLGFBQTZDO0FBQzNDQSxnQkFBTSxDQUFOQTtBQUNEOztBQUVELFlBQU1tQixRQUFRLHNDQUFkLElBQWMsQ0FBZDs7QUFFQSxZQUFJLENBQUNuQixNQUFNLENBQU5BLFVBQUwsUUFBS0EsQ0FBTCxFQUFpQztBQUMvQixjQUFNdUIsV0FBVyxHQUFHOVgsSUFBSSxDQUFKQSxNQUFwQixFQUFvQkEsQ0FBcEI7QUFDQSxjQUFNK1gsa0JBQWtCLEdBQUdDLFdBQVcsQ0FBWEEsTUFBM0IsRUFBMkJBLENBQTNCO0FBRUEsY0FBSWpYLFFBQVEsR0FBWjs7QUFFQSxlQUFLLElBQUkzSSxLQUFLLEdBQWQsR0FBb0JBLEtBQUssR0FBRzJmLGtCQUFrQixDQUE5QyxRQUF1RDNmLEtBQXZELElBQWdFO0FBQzlELGdCQUFNOFMsRUFBRSxHQUFHNk0sa0JBQWtCLENBQTdCLEtBQTZCLENBQTdCO0FBQ0EsZ0JBQU0vWCxLQUFJLEdBQUc4WCxXQUFXLENBQXhCLEtBQXdCLENBQXhCO0FBQ0EsZ0JBQU1HLFNBQVMsR0FBR1gsZUFBZSxDQUFmQSxpQkFBZ0MsQ0FBbEQ7O0FBQ0EsMkJBQWU7QUFDYixrQkFBTWxXLE9BQU8sR0FBRyxXQUNkZ1YsdUJBQXVCLENBRFQsS0FDUyxDQURULEVBRWRtQiw2QkFBNkIsU0FGL0IsRUFBZ0IsQ0FBaEI7QUFJQSxrQkFBSW5XLE9BQU8sQ0FBUEEsS0FBSixFQUFJQSxDQUFKLEVBQXNCTCxRQUFRLElBQTlCLEVBQXNCQSxDQUF0QixLQUNLO0FBQ047QUFDRjs7QUFFRHdWLGdCQUFNLENBQU5BLHNCQUE2QnhWLFFBQVEsQ0FBckN3VixpQkFBNkJ4VixFQUE3QndWO0FBQ0Q7O0FBRUQsZUFBT0EsTUFBTSxDQUFOQSxVQUFQLFFBQU9BLENBQVA7QUE5QkY7QUFpQ0E7Ozs7Ozs7OztBQU9BLFVBQU1NLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0Isb0JBQXVCO0FBQy9DLFlBQUksT0FBT0EsaUJBQWlCLENBQXhCLGNBQUosYUFBd0Q7QUFDdERBLDJCQUFpQixDQUFqQkE7QUFDRDs7QUFFRCxZQUFNYSxRQUFRLHNDQUFkLElBQWMsQ0FBZDs7QUFDQSxZQUFJLENBQUNiLGlCQUFpQixDQUFqQkEsVUFBTCxRQUFLQSxDQUFMLEVBQTRDO0FBQzFDLGNBQU1pQixXQUFXLEdBQUc5WCxJQUFJLENBQUpBLE1BQXBCLEVBQW9CQSxDQUFwQjtBQUNBLGNBQUkrWCxrQkFBa0IsR0FBR0MsV0FBVyxDQUFYQSxNQUF6QixFQUF5QkEsQ0FBekI7O0FBQ0EsY0FBSUQsa0JBQWtCLENBQWxCQSxTQUE0QkQsV0FBVyxDQUEzQyxRQUFvRDtBQUNsREMsOEJBQWtCLEdBQUdBLGtCQUFrQixDQUFsQkEsT0FDbkIsVUFBVUQsV0FBVyxDQUFYQSxTQUFxQkMsa0JBQWtCLENBQWpELHdCQURGQSxFQUNFLENBRG1CQSxDQUFyQkE7QUFHRDs7QUFFRCxjQUFJWixRQUFRLEdBQUcsQ0FBZjs7QUFDQSxlQUFLLElBQUkvZSxLQUFLLEdBQWQsR0FBb0JBLEtBQUssR0FBRzBmLFdBQVcsQ0FBdkMsUUFBZ0QxZixLQUFoRCxJQUF5RDtBQUN2RCxnQkFBTThTLEVBQUUsR0FBRzRNLFdBQVcsQ0FBdEIsS0FBc0IsQ0FBdEI7O0FBQ0EsZ0JBQUk1TSxFQUFFLEtBQUs2TSxrQkFBa0IsQ0FBN0IsS0FBNkIsQ0FBN0IsRUFBc0M7QUFDcEM7QUFDQSxrQkFBSVQsZUFBZSxDQUFmQSxjQUE4QixDQUFsQyxHQUFzQztBQUNwQyxvQkFBTWxXLE9BQU8sR0FBRyxXQUNkZ1YsdUJBQXVCLENBRFQsRUFDUyxDQURULEVBRWRtQiw2QkFBNkIsU0FGL0IsRUFBZ0IsQ0FBaEI7O0FBS0Esb0JBQUksQ0FBQ25XLE9BQU8sQ0FBUEEsS0FBYTJXLGtCQUFrQixDQUFwQyxLQUFvQyxDQUEvQjNXLENBQUwsRUFBOEM7QUFDNUMrViwwQkFBUSxHQUFSQTtBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUROLDJCQUFpQixDQUFqQkEsc0JBQ0VNLFFBQVEsR0FBUkEsSUFBZVksa0JBQWtCLENBQWpDWixTQURGTjtBQUVEOztBQUVELGVBQU9BLGlCQUFpQixDQUFqQkEsVUFBUCxRQUFPQSxDQUFQO0FBdENGOzs7Ozs7Ozs7QUMxTEE7O0FBQUE7QUFBQTs7Ozs7Ozs7QUFVZXFCOzs7QUFBQUE7QUFBZjtBQUFlQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjs7Ozs7Ozs7O0FBVUEsVUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixRQUFTO0FBQzdCLFlBQUlsb0IsS0FBSyxHQUFMQSxLQUFKLEdBQW9CO0FBQ2xCLGNBQU1tb0IsS0FBSyxHQUFHbm9CLEtBQUssQ0FBTEEsaUJBQWQsR0FBY0EsQ0FBZDtBQUNBLGNBQUltb0IsS0FBSyxDQUFMQSxXQUFKLEdBQXdCLE9BQU9BLEtBQUssQ0FBTEEsQ0FBSyxDQUFMQSxDQUFQO0FBQ3pCOztBQUNEO0FBTEY7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VBOENNRixXO0FBQ0o7Ozs7Ozs7Ozs7O0FBV0EsK0JBQTBCO0FBQUEsY0FBZHJhLE9BQWMsdUVBQUosRUFBSTs7QUFBQTs7QUFDeEIsMkNBQ0s7QUFDRHlDLG9CQUFRLEVBRFA7QUFFRHJELGVBQUcsRUFGRjtBQUdEMlkseUJBQWEsRUFIWjtBQUlEQywyQkFBZSxFQUpkO0FBS0R0VixvQkFBUSxFQUxQO0FBTURDLHFCQUFTLEVBQUU7QUFOVixXQURMO0FBWUEscUNBQTJCLDhCQUEzQixJQUEyQixDQUEzQjtBQUNBLHVDQUE2QixnQ0FBN0IsSUFBNkIsQ0FBN0I7QUFDQTtBQUNEO0FBRUQ7Ozs7Ozs7O29DQUlVO0FBQ1IsZ0JBQU1GLFFBQVEsR0FDWixPQUFPLGFBQVAsd0JBQ0ksa0NBQWtDLGFBRHRDLFFBQ0ksQ0FESixHQUVJLGFBSE47QUFJQTs7QUFFQSxpQkFBSyxJQUFJMVEsQ0FBQyxHQUFWLEdBQWdCQSxDQUFDLEdBQUcwUSxRQUFRLENBQTVCLFFBQXFDMVEsQ0FBckMsSUFBMEM7QUFDeENxUixtQkFBSyxHQUFHWCxRQUFRLENBQWhCVyxDQUFnQixDQUFoQkE7O0FBQ0Esa0JBQUlBLEtBQUssWUFBVCxrQkFBdUM7QUFDckM2VSwyQkFBVyxHQUFHN1UsS0FBSyxDQUFMQSx3QkFBZDZVLE9BQWM3VSxDQUFkNlU7O0FBRUEsb0JBQUksQ0FBQzdVLEtBQUssQ0FBTEEsYUFBTCxJQUFLQSxDQUFMLEVBQStCO0FBQzdCcEwseUJBQU8sQ0FBUEE7QUFJQTtBQVJtQyxrQkFXckM7OztBQUNBLG9CQUFNa2dCLFNBQVMsR0FDYkQsV0FBVyxJQUFJQSxXQUFXLENBQVhBLG1DQUErQyxDQURoRTs7QUFFQTtBQWRGLHFCQWVPO0FBQ0xqZ0IsdUJBQU8sQ0FBUEE7QUFJRDtBQUNGO0FBQ0Y7QUFFRDs7Ozs7O29DQUdVO0FBQ1IsZ0JBQU15SyxRQUFRLEdBQ1osT0FBTyxhQUFQLHdCQUNJLGtDQUFrQyxhQUR0QyxRQUNJLENBREosR0FFSSxhQUhOO0FBS0E7O0FBRUEsaUJBQUssSUFBSTFRLENBQUMsR0FBVixHQUFnQkEsQ0FBQyxHQUFHMFEsUUFBUSxDQUE1QixRQUFxQzFRLENBQXJDLElBQTBDO0FBQ3hDcVIsbUJBQUssR0FBR1gsUUFBUSxDQUFoQlcsQ0FBZ0IsQ0FBaEJBO0FBQ0FwUCxvQkFBTSxHQUFHb1AsS0FBSyxDQUFkcFA7QUFDQWlrQix5QkFBVyxHQUFHamtCLE1BQU0sQ0FBTkEsYUFBZGlrQixPQUFjamtCLENBQWRpa0I7O0FBRUEsa0JBQUlBLFdBQVcsSUFBSUEsV0FBVyxDQUFYQSxtQ0FBK0MsQ0FBbEUsR0FBc0U7QUFDcEU7QUFDRDtBQUNGO0FBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Z0NBV011QyxXLEVBQWF0QyxTLEVBQVc7QUFDNUIsZ0JBQU11QyxhQUFhLEdBQUdELFdBQVcsQ0FBWEEsYUFBdEIsSUFBc0JBLENBQXRCO0FBQUEsZ0JBQ0VFLGVBQWUsR0FBR0YsV0FBVyxDQUFYQSxhQURwQixNQUNvQkEsQ0FEcEI7QUFBQSxnQkFFRUcsZUFBZSxHQUFHSCxXQUFXLENBQVhBLGdCQUZwQjtBQUFBLGdCQUdFSSxjQUFjLEdBQUdKLFdBQVcsQ0FBWEEsZUFIbkI7QUFBQSxnQkFJRUssY0FBYyxHQUFHTCxXQUFXLENBQVhBLGVBSm5CO0FBQUEsZ0JBS0VNLDRCQUE0QixHQUMxQk4sV0FBVyxDQUFYQSw2QkFOSjtBQUFBLGdCQU9FTywyQkFBMkIsR0FBR1AsV0FBVyxDQUFYQSw0QkFQaEM7QUFBQSxnQkFRRVEsNkJBQTZCLEdBQzNCUixXQUFXLENBQVhBLDhCQVRKO0FBQUEsZ0JBVUVTLGVBQWUsR0FBR1QsV0FBVyxDQUFYQSxnQkFWcEI7QUFBQSxnQkFXRVUsa0JBQWtCLEdBQUdWLFdBQVcsQ0FBWEEsYUFYdkIsT0FXdUJBLENBWHZCO0FBQUEsZ0JBWUVXLG1CQUFtQixHQUFHWCxXQUFXLENBQVhBLDRCQVp4QjtBQWNBLGdCQUFJaEYsSUFBSSxHQUFSO0FBQUEsZ0JBQ0U0RixhQUFhLEdBRGY7O0FBR0EsZ0JBQUksQ0FBSixXQUFnQjtBQUNkNUYsa0JBQUksR0FBRywrQkFBUEEsTUFBTyxDQUFQQTtBQUNBNEYsMkJBQWEsR0FBRywrQkFGRixPQUVFLENBQWhCQSxDQUZjLENBRTBDO0FBRjFELG1CQUdPO0FBQ0w1RixrQkFBSSxHQUFHZ0YsV0FBVyxDQUFsQmhGO0FBQ0E0RiwyQkFBYSxHQUFHNUYsSUFBSSxDQUFKQSxjQUFoQjRGLGlDQUFnQjVGLENBQWhCNEY7QUF2QjBCLGNBMEI1QjtBQUNBOzs7QUFDQSxnQkFBSSxDQUFKLFdBQWdCO0FBQ2RaLHlCQUFXLENBQVhBLDhCQURjLFdBQ2RBLEVBRGMsQ0FDeUM7O0FBQ3ZELGtCQUNFLEVBQ0VBLFdBQVcsQ0FBWEEsNEJBQ0FBLFdBQVcsQ0FBWEEsYUFISixVQUdJQSxDQUZGLENBREYsRUFLRTtBQUNBQSwyQkFBVyxDQUFYQSwwQkFBc0MsS0FBdENBO0FBQ0FBLDJCQUFXLENBQVhBLDRCQUF3QyxLQUF4Q0E7QUFDRDtBQUNGOztBQUVEQSx1QkFBVyxDQUFYQSx3QkFBb0NBLFdBQVcsQ0FBWEEsU0FBcENBO0FBQ0FBLHVCQUFXLENBQVhBO0FBQ0FBLHVCQUFXLENBQVhBO0FBQ0FBLHVCQUFXLENBQVhBO0FBQ0FBLHVCQUFXLENBQVhBLFFBQW9CYSxzRUFDbEJiLFdBQVcsQ0FBWEEsUUFEa0JhLDBIQUFwQmIsSUFBb0JhLEVBQXBCYjtBQU9BQSx1QkFBVyxDQUFYQSw0Q0FFRSxhQXREMEIsZUFvRDVCQSxFQXBENEIsQ0F5RDVCO0FBQ0E7O0FBQ0FZLHlCQUFhLENBQWJBLFFBQXNCWixXQUFXLENBQVhBLFFBQXRCWTtBQUNBQSx5QkFBYSxDQUFiQTtBQUNBQSx5QkFBYSxDQUFiQTtBQUNBQSx5QkFBYSxDQUFiQTtBQUNBLCtCQUNFQSxhQUFhLENBQWJBO0FBQ0YsaUNBQ0VBLGFBQWEsQ0FBYkE7QUFDRixxQ0FBeUJBLGFBQWEsQ0FBYkE7QUFFekIsaUNBQXFCQSxhQUFhLENBQWJBLHFCQUFyQixlQUFxQkEsRUFBckIsS0FDSztBQUNILGtCQUFNRSxRQUFRLEdBQUdoQixhQUFhLENBQUNjLGFBQWEsQ0FBNUMsS0FBOEIsQ0FBOUI7QUFDQSxrQkFBSWxaLElBQUksR0FBUjs7QUFDQSxrQkFBSW9aLFFBQVEsR0FBWixHQUFrQjtBQUNoQnBaLG9CQUFJLGNBQU96SyxLQUFLLENBQUxBLFFBQUssQ0FBTEEsTUFBUCxHQUFPQSxDQUFQLEVBQUp5SyxHQUFJLENBQUpBO0FBQ0Q7O0FBRURrWiwyQkFBYSxDQUFiQTtBQUNEO0FBRUQsZ0NBQW9CQSxhQUFhLENBQWJBO0FBQ3BCLGdDQUFvQkEsYUFBYSxDQUFiQTtBQUNwQkEseUJBQWEsQ0FBYkE7QUFDQUEseUJBQWEsQ0FBYkE7QUFDQUEseUJBQWEsQ0FBYkE7QUFDQUEseUJBQWEsQ0FBYkE7QUFDQSwrQ0FDRUEsYUFBYSxDQUFiQTs7QUFFRixnQkFBSSxDQUFKLFdBQWdCO0FBQ2RBLDJCQUFhLENBQWJBO0FBQ0FBLDJCQUFhLENBQWJBLDRCQUEwQyxLQUExQ0E7QUFDQUEsMkJBQWEsQ0FBYkEsMEJBQXdDLEtBQXhDQTtBQUNBQSwyQkFBYSxDQUFiQSw2QkFBMkMsS0FKN0IscUJBSWRBLEVBSmMsQ0FNZDs7QUFDQTVGLGtCQUFJLENBQUpBO0FBQ0FBLGtCQUFJLENBQUpBO0FBQ0FBLGtCQUFJLENBQUpBO0FBQ0Q7O0FBRUQsZ0JBQUksQ0FBQ3ZjLEtBQUssQ0FBQ0QsTUFBTSxDQUFDd2hCLFdBQVcsQ0FBWEEsUUFBbEIsYUFBaUIsQ0FBUCxDQUFWLEVBQXVEO0FBQ3JELGtCQUFJLG1DQUFKLFdBQUksQ0FBSixFQUFxRDtBQUNuRCxvQ0FDRUEsV0FBVyxDQURiLE9BRUVBLFdBQVcsQ0FBWEEsUUFGRjtBQUtEO0FBUEgsbUJBUU87QUFDTEEseUJBQVcsQ0FBWEEsY0FBMEIsYUFBMUJBO0FBQ0Q7O0FBRUQ7QUFDRDtBQUVEOzs7Ozs7Ozs7O2tDQU9RZSxPLEVBQVM7QUFDZixnQkFBTWYsV0FBVyxHQUFHZSxPQUFPLENBQVBBLGNBQXBCLDZCQUFvQkEsQ0FBcEI7QUFBQSxnQkFDRWQsYUFBYSxHQUFHRCxXQUFXLENBRDdCO0FBQUEsZ0JBRUVZLGFBQWEsR0FBR0csT0FBTyxDQUFQQSx3Q0FGbEIsV0FFa0JBLEVBRmxCO0FBSUFILHlCQUFhLENBQWJBLDZCQUEyQyxLQUEzQ0E7QUFDQUEseUJBQWEsQ0FBYkEsZ0NBQThDLEtBQTlDQTtBQUNBQSx5QkFBYSxDQUFiQSxnQ0FBOEMsS0FBOUNBO0FBRUFHLG1CQUFPLENBQVBBO0FBRUFmLHVCQUFXLENBQVhBLDZCQUF5QyxLQUF6Q0E7QUFDQUEsdUJBQVcsQ0FBWEEsK0JBQTJDLEtBQTNDQTtBQUNBQSx1QkFBVyxDQUFYQTtBQUNBQSx1QkFBVyxDQUFYQSxpQkFBNkIsYUFBN0JBO0FBQ0FBLHVCQUFXLENBQVhBLGlCQUE2QixhQUE3QkE7QUFDQSxtQkFBT0EsV0FBVyxDQUFYQSxRQUFQO0FBRUFlLG1CQUFPLENBQVBBO0FBQ0FBLG1CQUFPLENBQVBBO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs4Q0FPb0I3YixDLEVBQUc7QUFDckIsZ0JBQU04YSxXQUFXLEdBQUc5YSxDQUFDLENBQXJCO0FBQUEsZ0JBQ0UrYSxhQUFhLEdBQUdELFdBQVcsQ0FEN0I7QUFBQSxnQkFFRVksYUFBYSxHQUFHLHlEQUZsQixXQUVrQixFQUZsQjtBQU1BWix1QkFBVyxDQUFYQTtBQUNBQSx1QkFBVyxDQUFYQTtBQUVBWSx5QkFBYSxDQUFiQTtBQUNBQSx5QkFBYSxDQUFiQTs7QUFDQTs7QUFDQS9CLHNCQUFVLENBQUMsWUFBTTtBQUNmK0IsMkJBQWEsQ0FBYkE7QUFDQSxrQkFBTXpnQixNQUFNLEdBQUc2RCxNQUFNLENBQUM0YyxhQUFhLENBQXBCNWMsS0FBTSxDQUFOQSxDQUFmO0FBQ0E0YywyQkFBYSxDQUFiQTtBQUNBQSwyQkFBYSxDQUFiQTtBQUNBQSwyQkFBYSxDQUFiQTtBQUxRLGVBQVYvQixDQUFVLENBQVZBO0FBT0Q7QUFFRDs7Ozs7Ozs7Ozs7Z0RBUXNCM1osQyxFQUFHO0FBQ3ZCLGdCQUFNMGIsYUFBYSxHQUFHMWIsQ0FBQyxDQUF2QjtBQUFBLGdCQUNFbVosT0FBTyxHQUFHblosQ0FBQyxDQURiO0FBQUEsZ0JBRUV5QyxJQUFJLEdBQUdpWixhQUFhLENBQWJBLFFBRlQ7QUFBQSxnQkFHRS9ZLGlCQUFpQixHQUFHK1ksYUFBYSxDQUFiQSxRQUh0QjtBQUFBLGdCQUlFOVksZ0JBQWdCLEdBQUc4WSxhQUFhLENBQWJBLFFBSnJCO0FBQUEsZ0JBS0U3WSxrQkFBa0IsR0FBRzZZLGFBQWEsQ0FBYkEsUUFMdkI7QUFBQSxnQkFNRVgsYUFBYSxHQUFHVyxhQUFhLENBQWJBLFFBTmxCO0FBQUEsZ0JBT0VaLFdBQVcsR0FBRywwQ0FQaEIsYUFPZ0IsRUFQaEI7O0FBU0EsZ0JBQUlnQixPQUFPLEdBQVg7QUFBQSxnQkFDRW5oQixLQUFLLEdBRFA7QUFBQSxnQkFFRThmLFdBQVcsR0FGYjtBQUFBLGdCQUdFblgsT0FBTyxHQUFHLG1DQUhaLFdBR1ksQ0FIWjs7QUFLQSxnQkFBSTtBQUNGbVgseUJBQVcsR0FBR2tCLHNFQUNaRCxhQUFhLENBQWJBLFNBRFlDLHlFQUFkbEIsSUFBY2tCLEVBQWRsQjtBQURGLGNBU0UsVUFBVTtBQUNWQSx5QkFBVyxHQUFYQTs7QUFDQTs7QUFDQTtBQUNEOztBQUVEcUIsbUJBQU8sR0FBRyw0QkFBNEIsQ0FBNUIsS0FBa0M5YixDQUFDLENBQURBLFNBQTVDOGI7QUFDQW5oQixpQkFBSyxHQUFHOGYsV0FBVyxJQUFuQjlmOztBQUVBLHlCQUFhO0FBQ1grZ0IsMkJBQWEsQ0FBYkEsaUJBQStCLGFBQS9CQTtBQUNBQSwyQkFBYSxDQUFiQSxpQkFBK0IsYUFBL0JBO0FBRUFBLDJCQUFhLENBQWJBO0FBQ0FBLDJCQUFhLENBQWJBO0FBRUFaLHlCQUFXLENBQVhBO0FBQ0FBLHlCQUFXLENBQVhBO0FBRUFBLHlCQUFXLENBQVhBLGNBQTBCLGFBQTFCQTs7QUFFQSx5QkFBVztBQUNUQSwyQkFBVyxDQUFYQTtBQUNBQSwyQkFBVyxDQUFYQSx3QkFBb0NZLGFBQWEsQ0FBakRaOztBQUNBLGlEQUFpQ1ksYUFBYSxDQUE5QztBQUhGLHFCQUlPO0FBQ0xBLDZCQUFhLENBQWJBLFFBQXNCWixXQUFXLENBQVhBLFFBQXRCWTs7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7Ozs7Ozs7Ozs7O3lDQVVlQSxhLEVBQWVaLFcsRUFBYTtBQUN6QyxnQkFBSXhYLE9BQU8sR0FBWDtBQUNBLGdCQUFNNVEsS0FBSyxHQUFHNEcsTUFBTSxDQUFDb2lCLGFBQWEsQ0FBbEMsS0FBb0IsQ0FBcEI7O0FBQ0EsZ0JBQUlBLGFBQWEsQ0FBYkEscUNBQW1ELENBQUNuaUIsS0FBSyxDQUE3RCxLQUE2RCxDQUE3RCxFQUFzRTtBQUNwRSxrQkFBTWdKLEdBQUcsR0FBR21aLGFBQWEsQ0FBYkEsYUFBWixLQUFZQSxDQUFaO0FBQ0Esa0JBQU1wWixHQUFHLEdBQUdvWixhQUFhLENBQWJBLGFBQVosS0FBWUEsQ0FBWjtBQUNBLGtCQUFNbFosSUFBSSxHQUFHa1osYUFBYSxDQUFiQSxhQUFiLE1BQWFBLENBQWI7QUFFQSx1QkFBU3BZLE9BQU8sR0FBR0EsT0FBTyxJQUFJNVEsS0FBSyxJQUFJNEcsTUFBTSxDQUFwQ2dLLEdBQW9DLENBQXBDQTtBQUNULHVCQUFTQSxPQUFPLEdBQUdBLE9BQU8sSUFBSTVRLEtBQUssSUFBSTRHLE1BQU0sQ0FBcENnSyxHQUFvQyxDQUFwQ0E7QUFFVCx3QkFDRUEsT0FBTyxHQUNMQSxPQUFPLElBQUlzWCxhQUFhLENBQWJBLElBQWEsQ0FBYkEsS0FBd0JBLGFBQWEsQ0FBQ2MsYUFBYSxDQURoRXBZLEtBQ2tELENBRGxEQTtBQVRKLG1CQVdPQSxPQUFPLEdBQUdvWSxhQUFhLENBQXZCcFksYUFBVW9ZLEVBQVZwWTs7QUFFUCx5QkFBYTtBQUNYO0FBREYsbUJBRU87QUFDTDs7QUFDQSxtQ0FDRW9ZLGFBQWEsQ0FBYkEscUJBREY7QUFJRDs7QUFFRDtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7eUNBT2U3QixXLEVBQWFDLGEsRUFBZXBXLEssRUFBTztBQUNoRCxnQkFBSSxhQUFKLFVBQTJCO0FBQ3pCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7Ozs7MENBTWdCRCxLLEVBQU9DLEssRUFBTztBQUM1QixnQkFBSSxhQUFKLFdBQTRCO0FBQzFCO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7K0NBR3FCZ1ksYSxFQUFlWixXLEVBQWExTixLLEVBQU87QUFDdEQsZ0JBQ0UwTixXQUFXLENBQVhBLDRCQUNBQSxXQUFXLENBQVhBLGFBRkYsVUFFRUEsQ0FGRixFQUdFO0FBQ0FBLHlCQUFXLENBQVhBLGlCQUE2QixhQUE3QkE7QUFDQUEseUJBQVcsQ0FBWEEsaUJBQTZCLGFBQTdCQTtBQUVBWSwyQkFBYSxDQUFiQSxpQkFBK0IsYUFBL0JBO0FBQ0FBLDJCQUFhLENBQWJBLGlCQUErQixhQUEvQkE7QUFSRixtQkFTTztBQUNMLGtCQUFJdE8sS0FBSyxLQUFULFdBQXlCO0FBQ3ZCME4sMkJBQVcsQ0FBWEEsaUJBQTZCLGFBQTdCQTtBQUNBQSwyQkFBVyxDQUFYQSxjQUEwQixhQUExQkE7QUFFQVksNkJBQWEsQ0FBYkEsaUJBQStCLGFBQS9CQTtBQUNBQSw2QkFBYSxDQUFiQSxjQUE0QixhQUE1QkE7QUFDRDs7QUFFRCxrQkFBSXRPLEtBQUssS0FBVCxTQUF1QjtBQUNyQjBOLDJCQUFXLENBQVhBLGNBQTBCLGFBQTFCQTtBQUNBQSwyQkFBVyxDQUFYQSxpQkFBNkIsYUFBN0JBO0FBRUFZLDZCQUFhLENBQWJBLGNBQTRCLGFBQTVCQTtBQUNBQSw2QkFBYSxDQUFiQSxpQkFBK0IsYUFBL0JBO0FBQ0Q7QUFDRjtBQUNGOzs7OztBQUdZZjs7O0FBQUFBLGlDQUFmLFdBQWVBOzs7Ozs7O0FDbmZmOzs7OztBNUlVQTtDQVZBLEU7Ozs7Ozs7Ozs7Ozs7Ozs7O0E2SUFBLENBQUMsU0FBU29CLGdDQUFULENBQTBDcmpCLElBQTFDLEVBQWdEc2pCLE9BQWhELEVBQXlEO0FBQ3pELE1BQUcsOEJBQU92VCxPQUFQLE9BQW1CLFFBQW5CLElBQStCLDhCQUFPNVMsTUFBUCxPQUFrQixRQUFwRCxFQUNDQSxNQUFNLENBQUM0UyxPQUFQLEdBQWlCdVQsT0FBTyxFQUF4QixDQURELEtBRUssSUFBRyxJQUFILEVBQ0pDLGlDQUFPLEVBQUQsb0NBQUtELE9BQUw7QUFBQTtBQUFBO0FBQUEsb0dBQU4sQ0FESSxLQUVBLEVBR0o7QUFDRCxDQVRELEVBU0csT0FBT3BqQixJQUFQLEtBQWdCLFdBQWhCLEdBQThCQSxJQUE5QixTQVRILEVBUzhDLFlBQVc7QUFDekQ7QUFBTztBQUFVLGNBQVMxQyxPQUFULEVBQWtCO0FBQUU7O0FBQ3JDO0FBQVU7O0FBQ1Y7QUFBVSxVQUFJZ21CLGdCQUFnQixHQUFHLEVBQXZCO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVSxlQUFTQyxtQkFBVCxDQUE2QkMsUUFBN0IsRUFBdUM7QUFDakQ7O0FBQ0E7QUFBVzs7QUFDWDtBQUFXLFlBQUdGLGdCQUFnQixDQUFDRSxRQUFELENBQW5CLEVBQStCO0FBQzFDO0FBQVksaUJBQU9GLGdCQUFnQixDQUFDRSxRQUFELENBQWhCLENBQTJCM1QsT0FBbEM7QUFDWjtBQUFZO0FBQ1o7QUFBVzs7QUFDWDs7O0FBQVcsWUFBSTVTLE1BQU0sR0FBR3FtQixnQkFBZ0IsQ0FBQ0UsUUFBRCxDQUFoQixHQUE2QjtBQUNyRDtBQUFZL3BCLFdBQUMsRUFBRStwQixRQURzQzs7QUFFckQ7QUFBWTlwQixXQUFDLEVBQUUsS0FGc0M7O0FBR3JEO0FBQVltVyxpQkFBTyxFQUFFO0FBQ3JCOztBQUpxRCxTQUExQztBQUtYOztBQUNBO0FBQVc7O0FBQ1g7O0FBQVd2UyxlQUFPLENBQUNrbUIsUUFBRCxDQUFQLENBQWtCQyxJQUFsQixDQUF1QnhtQixNQUFNLENBQUM0UyxPQUE5QixFQUF1QzVTLE1BQXZDLEVBQStDQSxNQUFNLENBQUM0UyxPQUF0RCxFQUErRDBULG1CQUEvRDtBQUNYOztBQUNBO0FBQVc7O0FBQ1g7O0FBQVd0bUIsY0FBTSxDQUFDdkQsQ0FBUCxHQUFXLElBQVg7QUFDWDs7QUFDQTtBQUFXOztBQUNYOztBQUFXLGVBQU91RCxNQUFNLENBQUM0UyxPQUFkO0FBQ1g7QUFBVztBQUNYOztBQUNBOztBQUNBO0FBQVU7O0FBQ1Y7OztBQUFVMFQseUJBQW1CLENBQUNHLENBQXBCLEdBQXdCcG1CLE9BQXhCO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVWltQix5QkFBbUIsQ0FBQzdCLENBQXBCLEdBQXdCNEIsZ0JBQXhCO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVUMseUJBQW1CLENBQUNJLENBQXBCLEdBQXdCLFVBQVM5VCxPQUFULEVBQWtCNVUsSUFBbEIsRUFBd0Iyb0IsTUFBeEIsRUFBZ0M7QUFDbEU7QUFBVyxZQUFHLENBQUNMLG1CQUFtQixDQUFDTSxDQUFwQixDQUFzQmhVLE9BQXRCLEVBQStCNVUsSUFBL0IsQ0FBSixFQUEwQztBQUNyRDtBQUFZbkMsZ0JBQU0sQ0FBQ0QsY0FBUCxDQUFzQmdYLE9BQXRCLEVBQStCNVUsSUFBL0IsRUFBcUM7QUFDakQ7QUFBYWxCLHdCQUFZLEVBQUUsS0FEc0I7O0FBRWpEO0FBQWFDLHNCQUFVLEVBQUUsSUFGd0I7O0FBR2pEO0FBQWFHLGVBQUcsRUFBRXlwQjtBQUNsQjs7QUFKaUQsV0FBckM7QUFLWjtBQUFZO0FBQ1o7O0FBQVcsT0FSRDtBQVNWOztBQUNBO0FBQVU7O0FBQ1Y7OztBQUFVTCx5QkFBbUIsQ0FBQ08sQ0FBcEIsR0FBd0IsVUFBUzdtQixNQUFULEVBQWlCO0FBQ25EO0FBQVcsWUFBSTJtQixNQUFNLEdBQUczbUIsTUFBTSxJQUFJQSxNQUFNLENBQUM4bUIsVUFBakI7QUFDeEI7QUFBWSxpQkFBU0MsVUFBVCxHQUFzQjtBQUFFLGlCQUFPL21CLE1BQU0sQ0FBQyxTQUFELENBQWI7QUFBMkIsU0FEdkM7QUFFeEI7QUFBWSxpQkFBU2duQixnQkFBVCxHQUE0QjtBQUFFLGlCQUFPaG5CLE1BQVA7QUFBZ0IsU0FGL0M7QUFHWDs7QUFBV3NtQiwyQkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JDLE1BQXRCLEVBQThCLEdBQTlCLEVBQW1DQSxNQUFuQztBQUNYOzs7QUFBVyxlQUFPQSxNQUFQO0FBQ1g7QUFBVyxPQU5EO0FBT1Y7O0FBQ0E7QUFBVTs7QUFDVjs7O0FBQVVMLHlCQUFtQixDQUFDTSxDQUFwQixHQUF3QixVQUFTN2lCLE1BQVQsRUFBaUJrakIsUUFBakIsRUFBMkI7QUFBRSxlQUFPcHJCLE1BQU0sQ0FBQ3FyQixTQUFQLENBQWlCNWhCLGNBQWpCLENBQWdDa2hCLElBQWhDLENBQXFDemlCLE1BQXJDLEVBQTZDa2pCLFFBQTdDLENBQVA7QUFBZ0UsT0FBckg7QUFDVjs7QUFDQTtBQUFVOztBQUNWOzs7QUFBVVgseUJBQW1CLENBQUNhLENBQXBCLEdBQXdCLEVBQXhCO0FBQ1Y7O0FBQ0E7QUFBVTs7QUFDVjs7QUFBVSxhQUFPYixtQkFBbUIsQ0FBQ0EsbUJBQW1CLENBQUNjLENBQXBCLEdBQXdCLENBQXpCLENBQTFCO0FBQ1Y7QUFBVSxLQS9ETTtBQWdFaEI7O0FBQ0E7QUFBVTtBQUNWOztBQUNBO0FBQU8sY0FBU3BuQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQWlDZSx5QkFBbUIsQ0FBQyxHQUFELENBQW5CLEdBQTJCekwsU0FBM0I7O0FBQ2pDLGVBQVNBLFNBQVQsQ0FBbUJyWSxXQUFuQixFQUFnQztBQUM5QixZQUFJQSxXQUFXLEtBQUssSUFBaEIsSUFBd0JBLFdBQVcsS0FBSyxJQUF4QyxJQUFnREEsV0FBVyxLQUFLLEtBQXBFLEVBQTJFO0FBQ3pFLGlCQUFPK2pCLEdBQVA7QUFDRDs7QUFFRCxZQUFJOWpCLE1BQU0sR0FBR0MsTUFBTSxDQUFDRixXQUFELENBQW5COztBQUVBLFlBQUlHLEtBQUssQ0FBQ0YsTUFBRCxDQUFULEVBQW1CO0FBQ2pCLGlCQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsZUFBT0EsTUFBTSxHQUFHLENBQVQsR0FBYUcsSUFBSSxDQUFDNGpCLElBQUwsQ0FBVS9qQixNQUFWLENBQWIsR0FBaUNHLElBQUksQ0FBQzZqQixLQUFMLENBQVdoa0IsTUFBWCxDQUF4QztBQUNEO0FBRUQ7O0FBQU8sS0FwQkc7QUFxQlY7O0FBQ0E7QUFBTyxjQUFTeEQsTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUFxQixVQUFJbUIseUNBQXlDLEdBQUduQixtQkFBbUIsQ0FBQyxDQUFELENBQW5FO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBNkJlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBNEJJLHlDQUF5QyxDQUFDO0FBQUk7QUFBTCxPQUFyRTtBQUU3QjtBQUFPLEtBcENHO0FBcUNWOztBQUNBO0FBQU8sY0FBU3puQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQXFCLFVBQUlvQix1Q0FBdUMsR0FBR3BCLG1CQUFtQixDQUFDLENBQUQsQ0FBakU7QUFDckI7OztBQUFpQ0EseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9LLHVDQUF1QyxDQUFDLEdBQUQsQ0FBOUM7QUFBc0QsT0FBbkg7QUFDakM7OztBQUFpQ3BCLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLEdBQTNDLEVBQWdELFlBQVc7QUFBRSxlQUFPSyx1Q0FBdUMsQ0FBQyxHQUFELENBQTlDO0FBQXNELE9BQW5IO0FBQ2pDOzs7QUFBaUNwQix5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxHQUEzQyxFQUFnRCxZQUFXO0FBQUUsZUFBT0ssdUNBQXVDLENBQUMsR0FBRCxDQUE5QztBQUFzRCxPQUFuSDtBQUNqQzs7O0FBQWlDcEIseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9LLHVDQUF1QyxDQUFDLEdBQUQsQ0FBOUM7QUFBc0QsT0FBbkg7QUFDakM7OztBQUFpQ3BCLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLEdBQTNDLEVBQWdELFlBQVc7QUFBRSxlQUFPSyx1Q0FBdUMsQ0FBQyxHQUFELENBQTlDO0FBQXNELE9BQW5IO0FBQ2pDOzs7QUFBaUNwQix5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxHQUEzQyxFQUFnRCxZQUFXO0FBQUUsZUFBT0ssdUNBQXVDLENBQUMsR0FBRCxDQUE5QztBQUFzRCxPQUFuSDtBQUNqQzs7O0FBQWlDcEIseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9LLHVDQUF1QyxDQUFDLEdBQUQsQ0FBOUM7QUFBc0QsT0FBbkg7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7OztBQUE2QkwseUJBQW1CLENBQUMsR0FBRCxDQUFuQixHQUE0QkssdUNBQXVDLENBQUM7QUFBSTtBQUFMLE9BQW5FO0FBRTdCO0FBQU8sS0E1REc7QUE2RFY7O0FBQ0E7QUFBTyxjQUFTMW5CLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7QUFDQTs7QUFBaUNlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBMkI3ZixlQUEzQjtBQUNqQzs7QUFBcUIsVUFBSW1nQixzREFBc0QsR0FBR3JCLG1CQUFtQixDQUFDLENBQUQsQ0FBaEY7O0FBR3JCLFVBQUk1ZSxvQkFBb0IsR0FBRyxPQUEzQjtBQUNBLFVBQUlDLHNCQUFzQixHQUFHLEtBQTdCO0FBRUEsVUFBSUMsUUFBUSxHQUFHO0FBQ2JDLGdCQUFRLEVBQUUsWUFERztBQUViQyxpQkFBUyxFQUFFLE9BRkU7QUFHYkMsa0JBQVUsRUFBRSxpQkFIQztBQUliQyxvQkFBWSxFQUFFLDBCQUpEO0FBS2JDLG9CQUFZLEVBQUU7QUFMRCxPQUFmLENBVmtFLENBa0JsRTs7QUFDQSxlQUFTVCxlQUFULENBQXlCb2dCLGNBQXpCLEVBQXlDeGdCLElBQXpDLEVBQStDO0FBQzdDLFlBQUljLEtBQUo7QUFDQSxZQUFJSSxjQUFKLENBRjZDLENBSTdDOztBQUNBSixhQUFLLEdBQUdOLFFBQVEsQ0FBQ0UsU0FBVCxDQUFtQitmLElBQW5CLENBQXdCRCxjQUF4QixDQUFSOztBQUNBLFlBQUkxZixLQUFKLEVBQVc7QUFDVCxpQkFBTyxDQUFQO0FBQ0Q7O0FBRUQsWUFBSUMsS0FBSixDQVY2QyxDQVk3Qzs7QUFDQUQsYUFBSyxHQUFHTixRQUFRLENBQUNHLFVBQVQsQ0FBb0I4ZixJQUFwQixDQUF5QkQsY0FBekIsQ0FBUjs7QUFDQSxZQUFJMWYsS0FBSixFQUFXO0FBQ1RDLGVBQUssR0FBR0MsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUFoQjs7QUFFQSxjQUFJLENBQUNHLGdCQUFnQixDQUFDRixLQUFELENBQXJCLEVBQThCO0FBQzVCLG1CQUFPbWYsR0FBUDtBQUNEOztBQUVEaGYsd0JBQWMsR0FBR0gsS0FBSyxHQUFHVCxvQkFBekI7QUFDQSxpQkFBT1EsS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhLEdBQWIsR0FBbUIsQ0FBQ0ksY0FBcEIsR0FBcUNBLGNBQTVDO0FBQ0QsU0F2QjRDLENBeUI3Qzs7O0FBQ0FKLGFBQUssR0FBR04sUUFBUSxDQUFDSSxZQUFULENBQXNCNmYsSUFBdEIsQ0FBMkJELGNBQTNCLENBQVI7O0FBQ0EsWUFBSTFmLEtBQUosRUFBVztBQUNUQyxlQUFLLEdBQUdDLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXLEVBQVgsQ0FBaEI7QUFDQSxjQUFJSyxPQUFPLEdBQUdILFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXLEVBQVgsQ0FBdEI7O0FBRUEsY0FBSSxDQUFDRyxnQkFBZ0IsQ0FBQ0YsS0FBRCxFQUFRSSxPQUFSLENBQXJCLEVBQXVDO0FBQ3JDLG1CQUFPK2UsR0FBUDtBQUNEOztBQUVEaGYsd0JBQWMsR0FDWkgsS0FBSyxHQUFHVCxvQkFBUixHQUErQmEsT0FBTyxHQUFHWixzQkFEM0M7QUFFQSxpQkFBT08sS0FBSyxDQUFDLENBQUQsQ0FBTCxLQUFhLEdBQWIsR0FBbUIsQ0FBQ0ksY0FBcEIsR0FBcUNBLGNBQTVDO0FBQ0QsU0F0QzRDLENBd0M3Qzs7O0FBQ0FKLGFBQUssR0FBR04sUUFBUSxDQUFDSyxZQUFULENBQXNCNGYsSUFBdEIsQ0FBMkJELGNBQTNCLENBQVI7O0FBQ0EsWUFBSTFmLEtBQUosRUFBVztBQUNUO0FBQ0EsY0FBSU0sTUFBTSxHQUFHM00sTUFBTSxDQUFDOHJCLHNEQUFzRCxDQUFDO0FBQUk7QUFBTCxXQUF2RCxDQUFOLENBQWtGdmdCLElBQWxGLEVBQXdGd2dCLGNBQXhGLENBQWI7QUFDQSxjQUFJbGYsS0FBSyxHQUFHQyxJQUFJLENBQUNtZixHQUFMLENBQ1Z0ZixNQUFNLENBQUMsQ0FBRCxDQURJLEVBRVZBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUZGLEVBR1ZBLE1BQU0sQ0FBQyxDQUFELENBSEksRUFJVkEsTUFBTSxDQUFDLENBQUQsQ0FKSSxFQUtWQSxNQUFNLENBQUMsQ0FBRCxDQUxJLEVBTVZBLE1BQU0sQ0FBQyxDQUFELENBTkksQ0FBWjtBQVFBLGNBQUlJLHFCQUFxQixHQUFHeEIsSUFBSSxDQUFDMmdCLE9BQUwsS0FBa0IzZ0IsSUFBSSxDQUFDMmdCLE9BQUwsS0FBaUIsSUFBL0Q7QUFDQSxpQkFBTyxFQUFFcmYsS0FBSyxHQUFHRSxxQkFBVixDQUFQO0FBQ0Q7O0FBRUQsZUFBTyxDQUFQO0FBQ0Q7O0FBRUQsZUFBU1AsZ0JBQVQsQ0FBMEJGLEtBQTFCLEVBQWlDSSxPQUFqQyxFQUEwQztBQUN4QyxZQUFJQSxPQUFPLElBQUksSUFBWCxLQUFvQkEsT0FBTyxHQUFHLENBQVYsSUFBZUEsT0FBTyxHQUFHLEVBQTdDLENBQUosRUFBc0Q7QUFDcEQsaUJBQU8sS0FBUDtBQUNEOztBQUVELGVBQU8sSUFBUDtBQUNEO0FBR0Q7O0FBQU8sS0F0Skc7QUF1SlY7O0FBQ0E7QUFBTyxjQUFTdkksTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUFxQixVQUFJMEIseUNBQXlDLEdBQUcxQixtQkFBbUIsQ0FBQyxFQUFELENBQW5FO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBNkJlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBNEJXLHlDQUF5QyxDQUFDO0FBQUk7QUFBTCxPQUFyRTtBQUU3QjtBQUFPLEtBdEtHO0FBdUtWOztBQUNBO0FBQU8sY0FBU2hvQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFOztBQUNBenFCLFlBQU0sQ0FBQ0QsY0FBUCxDQUFzQnlyQixtQkFBdEIsRUFBMkMsWUFBM0MsRUFBeUQ7QUFBRXhxQixhQUFLLEVBQUU7QUFBVCxPQUF6RDtBQUNBOztBQUErQnlwQix5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxPQUEzQyxFQUFvRCxZQUFXO0FBQUUsZUFBT1ksS0FBUDtBQUFlLE9BQWhGO0FBQy9COzs7QUFBcUIsVUFBSVIseUNBQXlDLEdBQUduQixtQkFBbUIsQ0FBQyxDQUFELENBQW5FO0FBQ3JCOzs7QUFBcUIsVUFBSTRCLHVDQUF1QyxHQUFHNUIsbUJBQW1CLENBQUMsQ0FBRCxDQUFqRTtBQUNyQjs7O0FBQXFCLFVBQUk2Qix5Q0FBeUMsR0FBRzdCLG1CQUFtQixDQUFDLENBQUQsQ0FBbkU7QUFDckI7OztBQUFxQixVQUFJOEIsb0NBQW9DLEdBQUc5QixtQkFBbUIsQ0FBQyxFQUFELENBQTlEO0FBQ3JCOzs7QUFBaUNBLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLE9BQTNDLEVBQW9ELFlBQVc7QUFBRSxlQUFPZSxvQ0FBb0MsQ0FBQyxHQUFELENBQTNDO0FBQW1ELE9BQXBIO0FBQ2pDOzs7QUFBaUM5Qix5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxZQUEzQyxFQUF5RCxZQUFXO0FBQUUsZUFBT0kseUNBQXlDLENBQUMsR0FBRCxDQUFoRDtBQUF3RCxPQUE5SDtBQUNqQzs7O0FBQWlDbkIseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsVUFBM0MsRUFBdUQsWUFBVztBQUFFLGVBQU9hLHVDQUF1QyxDQUFDLEdBQUQsQ0FBOUM7QUFBc0QsT0FBMUg7QUFDakM7OztBQUFpQzVCLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLFlBQTNDLEVBQXlELFlBQVc7QUFBRSxlQUFPYyx5Q0FBeUMsQ0FBQyxHQUFELENBQWhEO0FBQXdELE9BQTlIO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFLQSxVQUFJRixLQUFLLEdBQUc7QUFDVkksYUFBSyxFQUFFO0FBQ0xDLHNCQUFZLEVBQUVKLHVDQUF1QyxDQUFDO0FBQUk7QUFBTCxXQURoRDtBQUVMSyx1QkFBYSxFQUFFTCx1Q0FBdUMsQ0FBQztBQUFJO0FBQUwsV0FGakQ7QUFHTE0sOEJBQW9CLEVBQUVOLHVDQUF1QyxDQUFDO0FBQUk7QUFBTCxXQUh4RDtBQUlMTyx1QkFBYSxFQUFFUCx1Q0FBdUMsQ0FBQztBQUFJO0FBQUwsV0FKakQ7QUFLTFEsdUJBQWEsRUFBRVIsdUNBQXVDLENBQUM7QUFBSTtBQUFMLFdBTGpEO0FBTUxTLHFCQUFXLEVBQUVULHVDQUF1QyxDQUFDO0FBQUk7QUFBTCxXQU4vQztBQU9MVSw2QkFBbUIsRUFBRVYsdUNBQXVDLENBQUM7QUFBSTtBQUFMO0FBUHZEO0FBREcsT0FBWjtBQVdBOztBQUE2QmIseUJBQW1CLENBQUMsU0FBRCxDQUFuQixHQUFrQ2Usb0NBQW9DLENBQUM7QUFBSTtBQUFMLE9BQXRFO0FBRzdCO0FBQU8sS0E5TUc7QUErTVY7O0FBQ0E7QUFBTyxjQUFTcG9CLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7O0FBQ0EsZUFBU3VDLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxXQUFuQyxFQUFnRDtBQUFFLFlBQUksRUFBRUQsUUFBUSxZQUFZQyxXQUF0QixDQUFKLEVBQXdDO0FBQUUsZ0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosZUFBU0MsaUJBQVQsQ0FBMkJoc0IsTUFBM0IsRUFBbUNvVCxLQUFuQyxFQUEwQztBQUFFLGFBQUssSUFBSTdULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2VCxLQUFLLENBQUNqTCxNQUExQixFQUFrQzVJLENBQUMsRUFBbkMsRUFBdUM7QUFBRSxjQUFJc0IsVUFBVSxHQUFHdVMsS0FBSyxDQUFDN1QsQ0FBRCxDQUF0QjtBQUEyQnNCLG9CQUFVLENBQUNmLFVBQVgsR0FBd0JlLFVBQVUsQ0FBQ2YsVUFBWCxJQUF5QixLQUFqRDtBQUF3RGUsb0JBQVUsQ0FBQ2hCLFlBQVgsR0FBMEIsSUFBMUI7QUFBZ0MsY0FBSSxXQUFXZ0IsVUFBZixFQUEyQkEsVUFBVSxDQUFDVCxRQUFYLEdBQXNCLElBQXRCO0FBQTRCeEIsZ0JBQU0sQ0FBQ0QsY0FBUCxDQUFzQnFCLE1BQXRCLEVBQThCYSxVQUFVLENBQUNwQixHQUF6QyxFQUE4Q29CLFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULGVBQVNvckIsWUFBVCxDQUFzQkgsV0FBdEIsRUFBbUNJLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLFlBQUlELFVBQUosRUFBZ0JGLGlCQUFpQixDQUFDRixXQUFXLENBQUM3QixTQUFiLEVBQXdCaUMsVUFBeEIsQ0FBakI7QUFBc0QsWUFBSUMsV0FBSixFQUFpQkgsaUJBQWlCLENBQUNGLFdBQUQsRUFBY0ssV0FBZCxDQUFqQjtBQUE2QyxlQUFPTCxXQUFQO0FBQXFCO0FBRXZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFJakQsVUFBVSxHQUNkLGFBQ0EsWUFBWTtBQUNWLGlCQUFTQSxVQUFULEdBQXNCO0FBQ3BCK0MseUJBQWUsQ0FBQyxJQUFELEVBQU8vQyxVQUFQLENBQWY7QUFDRDs7QUFFRG9ELG9CQUFZLENBQUNwRCxVQUFELEVBQWEsSUFBYixFQUFtQixDQUFDO0FBQzlCcHBCLGFBQUcsRUFBRSxNQUR5Qjs7QUFHOUI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUcsZUFBSyxFQUFFLFNBQVMrUCxJQUFULENBQWNwSixNQUFkLEVBQXNCNmxCLEtBQXRCLEVBQTZCO0FBQ2xDLGdCQUFJdmMsaUJBQWlCLEdBQUd3RixTQUFTLENBQUNsTixNQUFWLEdBQW1CLENBQW5CLElBQXdCa04sU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQmdYLFNBQXpDLEdBQXFEaFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsR0FBNUY7QUFDQSxnQkFBSXZGLGdCQUFnQixHQUFHdUYsU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUFuQixJQUF3QmtOLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJnWCxTQUF6QyxHQUFxRGhYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEdBQTNGO0FBQ0EsZ0JBQUl0RixrQkFBa0IsR0FBR3NGLFNBQVMsQ0FBQ2xOLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JrTixTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCZ1gsU0FBekMsR0FBcURoWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxLQUE3RjtBQUNBLGdCQUFJaVgsS0FBSyxHQUFHalgsU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUFuQixJQUF3QmtOLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJnWCxTQUF6QyxHQUFxRGhYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLElBQWhGO0FBQ0EsZ0JBQUlrWCxPQUFPLEdBQUdILEtBQUssQ0FBQ2prQixNQUFwQjs7QUFFQSxnQkFBSSxNQUFNb2tCLE9BQVYsRUFBbUI7QUFDakIsa0JBQUlELEtBQUosRUFBVyxPQUFPRSxHQUFQLENBQVgsQ0FBdUI7QUFBdkIsbUJBQ0ssTUFBTTtBQUNQenJCLHNCQUFJLEVBQUUsV0FEQztBQUVQMHJCLHlCQUFPLEVBQUU7QUFGRixpQkFBTjtBQUlOLGFBYmlDLENBYWhDOzs7QUFHRixnQkFBSUMsaUJBQWlCLEdBQUcsQ0FBeEI7QUFDQSxnQkFBSUMsZ0JBQWdCLEdBQUcsQ0FBdkI7QUFDQSxnQkFBSUMsWUFBWSxHQUFHLEtBQW5COztBQUVBLGlCQUFLLElBQUlydEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2d0QixPQUFwQixFQUE2QixFQUFFaHRCLENBQS9CLEVBQWtDO0FBQ2hDLGtCQUFJaXFCLENBQUMsR0FBRzRDLEtBQUssQ0FBQ1MsTUFBTixDQUFhdHRCLENBQWIsQ0FBUjs7QUFFQSxrQkFBSWlxQixDQUFDLElBQUksR0FBTCxJQUFZQSxDQUFDLElBQUksR0FBckIsRUFBMEI7QUFDeEIsb0JBQUlvRCxZQUFKLEVBQWtCLEVBQUVELGdCQUFGLENBQWxCLEtBQTBDLEVBQUVELGlCQUFGO0FBQzNDLGVBRkQsTUFFTyxJQUFJbEQsQ0FBQyxJQUFJLEdBQVQsRUFBY29ELFlBQVksR0FBRyxJQUFmO0FBQ3RCOztBQUVELGdCQUFJRSxHQUFHLEdBQUdqRSxVQUFVLENBQUNrRSxNQUFYLENBQWtCeG1CLE1BQWxCLEVBQTBCb21CLGdCQUExQixDQUFWOztBQUVBLGdCQUFJSyxLQUFLLEdBQUduRSxVQUFVLENBQUNvRSxZQUFYLENBQXdCSCxHQUF4QixDQUFaLENBOUJrQyxDQThCUTs7O0FBRzFDLGdCQUFJSSxLQUFLLEdBQUdGLEtBQUssQ0FBQzdrQixNQUFsQjtBQUNBLGdCQUFJZ2xCLGdCQUFnQixHQUFHLENBQXZCO0FBQ0EsZ0JBQUlDLGVBQWUsR0FBRyxDQUF0QjtBQUNBUix3QkFBWSxHQUFHLEtBQWY7O0FBRUEsaUJBQUssSUFBSVMsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR0gsS0FBdEIsRUFBNkIsRUFBRUcsRUFBL0IsRUFBbUM7QUFDakMsa0JBQUlMLEtBQUssQ0FBQ0ssRUFBRCxDQUFMLElBQWEsR0FBakIsRUFBc0JULFlBQVksR0FBRyxJQUFmLENBQXRCLEtBQStDO0FBQzdDLG9CQUFJQSxZQUFKLEVBQWtCLEVBQUVRLGVBQUYsQ0FBbEIsS0FBeUMsRUFBRUQsZ0JBQUY7QUFDMUM7QUFDRixhQTFDaUMsQ0EwQ2hDOzs7QUFHRixnQkFBSUEsZ0JBQWdCLEdBQUdULGlCQUF2QixFQUEwQztBQUN4QyxrQkFBSUosS0FBSixFQUFXLE9BQU8vbEIsTUFBTSxDQUFDMkQsUUFBUCxFQUFQLENBQVgsQ0FBcUM7QUFBckMsbUJBQ0ssTUFBTTtBQUNQbkosc0JBQUksRUFBRSxXQURDO0FBRVAwckIseUJBQU8sRUFBRTtBQUZGLGlCQUFOO0FBSU4sYUFuRGlDLENBbURoQzs7O0FBR0YsZ0JBQUlXLGVBQWUsR0FBR1QsZ0JBQXRCLEVBQXdDO0FBQ3RDRyxpQkFBRyxHQUFHakUsVUFBVSxDQUFDa0UsTUFBWCxDQUFrQkQsR0FBbEIsRUFBdUJILGdCQUF2QixDQUFOO0FBQ0FLLG1CQUFLLEdBQUduRSxVQUFVLENBQUNvRSxZQUFYLENBQXdCSCxHQUF4QixDQUFSO0FBQ0FJLG1CQUFLLEdBQUdGLEtBQUssQ0FBQzdrQixNQUFkLENBSHNDLENBR2hCOztBQUV0QmdsQiw4QkFBZ0IsR0FBRyxDQUFuQjtBQUNBQyw2QkFBZSxHQUFHLENBQWxCO0FBQ0FSLDBCQUFZLEdBQUcsS0FBZjs7QUFFQSxtQkFBSyxJQUFJVSxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHSixLQUF4QixFQUErQixFQUFFSSxHQUFqQyxFQUFzQztBQUNwQyxvQkFBSU4sS0FBSyxDQUFDTSxHQUFELENBQUwsSUFBYyxHQUFsQixFQUF1QlYsWUFBWSxHQUFHLElBQWYsQ0FBdkIsS0FBZ0Q7QUFDOUMsc0JBQUlBLFlBQUosRUFBa0IsRUFBRVEsZUFBRixDQUFsQixLQUF5QyxFQUFFRCxnQkFBRjtBQUMxQztBQUNGLGVBYnFDLENBYXBDOzs7QUFHRixrQkFBSUEsZ0JBQWdCLEdBQUdULGlCQUF2QixFQUEwQztBQUN4QyxvQkFBSUosS0FBSixFQUFXLE9BQU8vbEIsTUFBTSxDQUFDMkQsUUFBUCxFQUFQLENBQVgsQ0FBcUM7QUFBckMscUJBQ0ssTUFBTTtBQUNQbkosd0JBQUksRUFBRSxXQURDO0FBRVAwckIsMkJBQU8sRUFBRTtBQUZGLG1CQUFOO0FBSU47QUFDRjs7QUFFRCxnQkFBSWMsUUFBUSxHQUFHLEdBQWY7QUFBQSxnQkFDSUMsU0FBUyxHQUFHLEdBRGhCO0FBRUEsZ0JBQUlDLEtBQUssR0FBRyxDQUFaO0FBQUEsZ0JBQ0lDLE1BQU0sR0FBRyxDQURiO0FBQUEsZ0JBRUlDLFFBQVEsR0FBRyxDQUZmO0FBR0EsZ0JBQUl2QixLQUFLLENBQUNTLE1BQU4sQ0FBYSxDQUFiLEtBQW1CLEdBQXZCLEVBQTRCVSxRQUFRLEdBQUcsR0FBWDtBQUM1QixnQkFBSUssUUFBUSxHQUFHTCxRQUFmO0FBQ0EsZ0JBQUlNLFVBQVUsR0FBR2hGLFVBQVUsQ0FBQ2lGLFFBQVgsQ0FBb0JoQixHQUFwQixJQUEyQixDQUE1QztBQUNBLGdCQUFJaUIsV0FBVyxHQUFHYixLQUFLLEdBQUcsQ0FBUixJQUFhZCxLQUFLLENBQUM0QixPQUFOLENBQWMsR0FBZCxLQUFzQixDQUFyRDtBQUNBLGdCQUFJQyxTQUFTLEdBQUcsS0FBaEI7QUFDQSxnQkFBSUMsVUFBVSxHQUFHLEtBQWpCO0FBQ0EsZ0JBQUlDLFFBQVEsR0FBRyxLQUFmO0FBQ0F2Qix3QkFBWSxHQUFHLEtBQWY7QUFDQSxnQkFBSXRmLEdBQUcsR0FBRyxJQUFJckksS0FBSixDQUFVc25CLE9BQVYsQ0FBVjs7QUFFQSxpQkFBSyxJQUFJNkIsT0FBTyxHQUFHLENBQW5CLEVBQXNCQSxPQUFPLEdBQUc3QixPQUFoQyxFQUF5QyxFQUFFNkIsT0FBM0MsRUFBb0Q7QUFDbEQsa0JBQUlDLEVBQUUsR0FBR2pDLEtBQUssQ0FBQ1MsTUFBTixDQUFhdUIsT0FBYixDQUFUOztBQUVBLHNCQUFRQyxFQUFSO0FBQ0UscUJBQUssR0FBTDtBQUNFLG9CQUFFM0IsaUJBQUY7O0FBRUEsc0JBQUlBLGlCQUFpQixHQUFHUyxnQkFBcEIsSUFBd0NNLEtBQUssR0FBR1AsS0FBcEQsRUFBMkQ7QUFDekQ1Zix1QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjVixLQUFLLENBQUNTLEtBQUQsQ0FBbkI7QUFDQSxzQkFBRUEsS0FBRjtBQUNBUyw4QkFBVSxHQUFHLElBQWI7QUFDRCxtQkFKRCxNQUlPO0FBQ0w1Z0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FPLDZCQUFTLEdBQUcsSUFBWjtBQUNEOztBQUVELG9CQUFFUCxNQUFGO0FBQ0E7O0FBRUYscUJBQUssR0FBTDtBQUNFLG9CQUFFaEIsaUJBQUY7O0FBRUEsc0JBQUlBLGlCQUFpQixHQUFHUyxnQkFBcEIsSUFBd0NNLEtBQUssR0FBR1AsS0FBcEQsRUFBMkQ7QUFDekQ1Zix1QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjVixLQUFLLENBQUNTLEtBQUQsQ0FBbkI7QUFDQSxzQkFBRUEsS0FBRjtBQUNBUyw4QkFBVSxHQUFHLElBQWI7QUFDRCxtQkFKRCxNQUlPO0FBQ0w1Z0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY2QsWUFBWSxJQUFJN2Msa0JBQWhCLElBQXNDOFksVUFBVSxDQUFDaUYsUUFBWCxDQUFvQmhCLEdBQXBCLEtBQTRCLENBQWxFLEdBQXNFLEdBQXRFLEdBQTRFUyxRQUExRjtBQUNBLHdCQUFJLENBQUNYLFlBQUwsRUFBbUJlLFFBQVEsR0FBR1MsT0FBWDtBQUNwQjs7QUFFRCxvQkFBRVYsTUFBRjtBQUNBOztBQUVGLHFCQUFLLEdBQUw7QUFDRSxzQkFBSU8sU0FBUyxJQUFJUixLQUFLLEdBQUcsQ0FBekIsRUFBNEJuZ0IsR0FBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjN2QsaUJBQWQsQ0FBNUIsS0FBaUU7QUFDL0R2Qyx1QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjSCxRQUFkO0FBQ0Esd0JBQUksQ0FBQ1gsWUFBTCxFQUFtQmUsUUFBUSxHQUFHUyxPQUFYO0FBQ3BCO0FBQ0Qsb0JBQUVWLE1BQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0Usc0JBQUksQ0FBQ1EsVUFBRCxJQUFlVixTQUFTLElBQUksR0FBaEMsRUFBcUM7QUFDbkMsd0JBQUlLLFVBQUosRUFBZ0JMLFNBQVMsR0FBRyxHQUFaO0FBQ2hCbGdCLHVCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNILFFBQWQ7QUFDQUksNEJBQVEsR0FBR2YsWUFBWSxHQUFHLENBQUMsQ0FBSixHQUFRd0IsT0FBL0I7QUFDRCxtQkFKRCxNQUlPOWdCLEdBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY0csVUFBVSxHQUFHLEdBQUgsR0FBU04sUUFBakM7O0FBRVAsb0JBQUVHLE1BQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0Usc0JBQUksQ0FBQ1EsVUFBRCxJQUFlVixTQUFTLElBQUksR0FBaEMsRUFBcUM7QUFDbkNBLDZCQUFTLEdBQUdLLFVBQVUsR0FBRyxHQUFILEdBQVMsR0FBL0I7QUFDQXZnQix1QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjSCxRQUFkO0FBQ0FJLDRCQUFRLEdBQUdmLFlBQVksR0FBRyxDQUFDLENBQUosR0FBUXdCLE9BQS9CO0FBQ0QsbUJBSkQsTUFJTzlnQixHQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNHLFVBQVUsR0FBRyxHQUFILEdBQVMsR0FBakM7O0FBRVAsb0JBQUVILE1BQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0Usc0JBQUksQ0FBQ1EsVUFBRCxJQUFlVixTQUFTLElBQUksR0FBaEMsRUFBcUM7QUFDbkNBLDZCQUFTLEdBQUcsR0FBWjtBQUNBbGdCLHVCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNILFFBQWQ7QUFDQUksNEJBQVEsR0FBR2YsWUFBWSxHQUFHLENBQUMsQ0FBSixHQUFRd0IsT0FBL0I7QUFDRCxtQkFKRCxNQUlPO0FBQ0w5Z0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0Q7O0FBRUQsb0JBQUVBLE1BQUY7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFLLEdBQUw7QUFDRSxzQkFBSSxDQUFDUSxVQUFELElBQWVWLFNBQVMsSUFBSSxHQUFoQyxFQUFxQztBQUNuQyx3QkFBSUssVUFBSixFQUFnQkwsU0FBUyxHQUFHLEdBQVo7QUFDaEJsZ0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY0gsUUFBZDtBQUNBSSw0QkFBUSxHQUFHZixZQUFZLEdBQUcsQ0FBQyxDQUFKLEdBQVF3QixPQUEvQjtBQUNELG1CQUpELE1BSU87QUFDTCx3QkFBSVAsVUFBSixFQUFnQjtBQUNkdmdCLHlCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNELHFCQUZELE1BRU87QUFDTHBnQix5QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjZCxZQUFZLEdBQUcsR0FBSCxHQUFTVyxRQUFuQztBQUNEO0FBQ0Y7O0FBRUQsb0JBQUVHLE1BQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0Usc0JBQUlHLFVBQUosRUFBZ0I7QUFDZHZnQix1QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDRCxtQkFGRCxNQUVPO0FBQ0xwZ0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY2QsWUFBWSxHQUFHLEdBQUgsR0FBU1csUUFBbkM7QUFDRDs7QUFFRCxvQkFBRUcsTUFBRjtBQUNBOztBQUVGLHFCQUFLLEdBQUw7QUFDRSxzQkFBSVUsT0FBTyxHQUFHN0IsT0FBTyxHQUFHLENBQXBCLElBQXlCSCxLQUFLLENBQUNTLE1BQU4sQ0FBYXVCLE9BQU8sR0FBRyxDQUF2QixLQUE2QixHQUExRCxFQUErRDtBQUM3RCx3QkFBSVAsVUFBSixFQUFnQjtBQUNkdmdCLHlCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNBcGdCLHlCQUFHLENBQUNvZ0IsTUFBTSxHQUFHLENBQVYsQ0FBSCxHQUFrQixHQUFsQjtBQUNELHFCQUhELE1BR087QUFDTHBnQix5QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDQXBnQix5QkFBRyxDQUFDb2dCLE1BQU0sR0FBRyxDQUFWLENBQUgsR0FBa0IsR0FBbEI7QUFDRDs7QUFFREEsMEJBQU0sSUFBSSxDQUFWO0FBQ0Esc0JBQUVVLE9BQUY7QUFDRCxtQkFYRCxNQVdPO0FBQ0w5Z0IsdUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0Esc0JBQUVBLE1BQUY7QUFDRDs7QUFFRDs7QUFFRixxQkFBSyxHQUFMO0FBQ0Usc0JBQUlVLE9BQU8sR0FBRzdCLE9BQU8sR0FBRyxDQUFwQixJQUF5QkgsS0FBSyxDQUFDUyxNQUFOLENBQWF1QixPQUFPLEdBQUcsQ0FBdkIsS0FBNkIsR0FBMUQsRUFBK0Q7QUFDN0Qsd0JBQUlQLFVBQUosRUFBZ0I7QUFDZHZnQix5QkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDQXBnQix5QkFBRyxDQUFDb2dCLE1BQU0sR0FBRyxDQUFWLENBQUgsR0FBa0IsR0FBbEI7QUFDRCxxQkFIRCxNQUdPO0FBQ0xwZ0IseUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FwZ0IseUJBQUcsQ0FBQ29nQixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCLEdBQWxCO0FBQ0Q7O0FBRURBLDBCQUFNLElBQUksQ0FBVjtBQUNBLHNCQUFFVSxPQUFGO0FBQ0QsbUJBWEQsTUFXTztBQUNMOWdCLHVCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNBLHNCQUFFQSxNQUFGO0FBQ0Q7O0FBRUQ7O0FBRUYscUJBQUssR0FBTDtBQUNFcGdCLHFCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNBLG9CQUFFQSxNQUFGO0FBQ0E7O0FBRUYscUJBQUssR0FBTDtBQUNFcGdCLHFCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNLLFdBQVcsR0FBR2plLGdCQUFILEdBQXNCeWQsUUFBL0M7QUFDQUEsMEJBQVEsR0FBRyxHQUFYO0FBQ0FYLDhCQUFZLEdBQUcsSUFBZjtBQUNBLG9CQUFFYSxLQUFGO0FBQ0Esb0JBQUVDLE1BQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0VwZ0IscUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0Esb0JBQUVBLE1BQUY7QUFDQTs7QUFFRjtBQUNFcGdCLHFCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNXLEVBQWQ7QUFDQSxvQkFBRVgsTUFBRjtBQUNBO0FBbExKO0FBb0xEOztBQUVELGdCQUFJRixTQUFTLElBQUksR0FBakIsRUFBc0I7QUFDcEIsa0JBQUlHLFFBQVEsR0FBRyxDQUFmLEVBQWtCQSxRQUFRLEdBQUdELE1BQVg7O0FBRWxCLHFCQUFPQyxRQUFRLElBQUlwQixPQUFuQixFQUE0QjtBQUMxQixrQkFBRW9CLFFBQUY7QUFDRDs7QUFFRCxrQkFBSXJnQixHQUFHLENBQUNxZ0IsUUFBRCxDQUFILElBQWlCQyxRQUFyQixFQUErQnRnQixHQUFHLENBQUNxZ0IsUUFBRCxDQUFILEdBQWdCSCxTQUFoQjtBQUNoQzs7QUFFRCxtQkFBT2xnQixHQUFHLENBQUNnaEIsSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNEO0FBclQ2QixTQUFELEVBc1Q1QjtBQUNEN3VCLGFBQUcsRUFBRSxRQURKO0FBRURHLGVBQUssRUFBRSxTQUFTMnVCLE1BQVQsQ0FBZ0Job0IsTUFBaEIsRUFBd0Jpb0IsU0FBeEIsRUFBbUNDLFlBQW5DLEVBQWlEO0FBQ3RELGdCQUFJQSxZQUFKLEVBQWtCRCxTQUFTLEdBQUcsQ0FBQ0EsU0FBYjtBQUNsQixnQkFBSUUsUUFBUSxHQUFHLENBQUMsS0FBS25vQixNQUFOLEVBQWN3aEIsS0FBZCxDQUFvQixHQUFwQixDQUFmO0FBQ0EsbUJBQU8sRUFBRTJHLFFBQVEsQ0FBQyxDQUFELENBQVIsR0FBYyxHQUFkLElBQXFCQSxRQUFRLENBQUMsQ0FBRCxDQUFSLEdBQWMsQ0FBQ0EsUUFBUSxDQUFDLENBQUQsQ0FBVCxHQUFlRixTQUE3QixHQUF5Q0EsU0FBOUQsQ0FBRixDQUFQO0FBQ0Q7QUFOQSxTQXRUNEIsRUE2VDVCO0FBQ0QvdUIsYUFBRyxFQUFFLFFBREo7QUFFREcsZUFBSyxFQUFFLFNBQVNtdEIsTUFBVCxDQUFnQnhtQixNQUFoQixFQUF3QmlvQixTQUF4QixFQUFtQztBQUN4QyxtQkFBTzNGLFVBQVUsQ0FBQzBGLE1BQVgsQ0FBa0I3bkIsSUFBSSxDQUFDaW9CLEtBQUwsQ0FBVzlGLFVBQVUsQ0FBQzBGLE1BQVgsQ0FBa0Job0IsTUFBbEIsRUFBMEJpb0IsU0FBMUIsRUFBcUMsS0FBckMsQ0FBWCxDQUFsQixFQUEyRUEsU0FBM0UsRUFBc0YsSUFBdEYsQ0FBUDtBQUNEO0FBSkEsU0E3VDRCLEVBa1U1QjtBQUNEL3VCLGFBQUcsRUFBRSxjQURKO0FBRURHLGVBQUssRUFBRSxTQUFTcXRCLFlBQVQsQ0FBc0IxbUIsTUFBdEIsRUFBOEI7QUFDbkMsZ0JBQUlxb0IsTUFBTSxHQUFHL0YsVUFBVSxDQUFDaUYsUUFBWCxDQUFvQnZuQixNQUFwQixDQUFiOztBQUVBLGdCQUFJc29CLEtBQUssR0FBRyxFQUFaOztBQUVBLGdCQUFJRCxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNoQixrQkFBSWhkLE1BQU0sR0FBR2dkLE1BQU0sR0FBRyxDQUFULEdBQWEsR0FBR0UsTUFBSCxDQUFVLENBQUMsQ0FBRCxHQUFLdm9CLE1BQU0sQ0FBQzJELFFBQVAsRUFBZixDQUFiLEdBQWlEM0QsTUFBTSxDQUFDMkQsUUFBUCxFQUE5RDtBQUNBLGtCQUFJMEgsTUFBTSxDQUFDekosTUFBUCxHQUFnQixDQUFoQixJQUFxQnlKLE1BQU0sQ0FBQ2liLE1BQVAsQ0FBYyxDQUFkLEtBQW9CLEdBQTdDLEVBQWtEamIsTUFBTSxHQUFHQSxNQUFNLENBQUNtZCxTQUFQLENBQWlCLENBQWpCLENBQVQsQ0FGbEMsQ0FFZ0U7O0FBRWhGRixtQkFBSyxHQUFHamQsTUFBTSxDQUFDbVcsS0FBUCxDQUFhLEVBQWIsQ0FBUjtBQUNEOztBQUVELG1CQUFPOEcsS0FBUDtBQUNEO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQXhCSyxTQWxVNEIsRUE0VjVCO0FBQ0RwdkIsYUFBRyxFQUFFLFVBREo7QUFFREcsZUFBSyxFQUFFLFNBQVNrdUIsUUFBVCxDQUFrQmtCLENBQWxCLEVBQXFCO0FBQzFCLG1CQUFPLENBQUNBLENBQUMsR0FBRyxDQUFMLEtBQVdBLENBQUMsR0FBRyxDQUFmLEtBQXFCLENBQUNBLENBQTdCO0FBQ0Q7QUFKQSxTQTVWNEIsQ0FBbkIsQ0FBWjs7QUFtV0EsZUFBT25HLFVBQVA7QUFDRCxPQXpXRCxFQUZBO0FBNldBOzs7QUFBNkJ1Qix5QkFBbUIsQ0FBQyxHQUFELENBQW5CLEdBQTRCdkIsVUFBNUI7QUFFN0I7QUFBTyxLQXZsQkc7QUF3bEJWOztBQUNBO0FBQU8sY0FBUzlsQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQStCQSx5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxHQUEzQyxFQUFnRCxZQUFXO0FBQUUsZUFBT3FCLGFBQVA7QUFBdUIsT0FBcEY7QUFDL0I7OztBQUErQnBDLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLEdBQTNDLEVBQWdELFlBQVc7QUFBRSxlQUFPb0IsYUFBUDtBQUF1QixPQUFwRjtBQUMvQjs7O0FBQStCbkMseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9tQixvQkFBUDtBQUE4QixPQUEzRjtBQUMvQjs7O0FBQStCbEMseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9pQixZQUFQO0FBQXNCLE9BQW5GO0FBQy9COzs7QUFBK0JoQyx5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxHQUEzQyxFQUFnRCxZQUFXO0FBQUUsZUFBT3NCLFdBQVA7QUFBcUIsT0FBbEY7QUFDL0I7OztBQUErQnJDLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLEdBQTNDLEVBQWdELFlBQVc7QUFBRSxlQUFPdUIsbUJBQVA7QUFBNkIsT0FBMUY7QUFDL0I7OztBQUErQnRDLHlCQUFtQixDQUFDSSxDQUFwQixDQUFzQlcsbUJBQXRCLEVBQTJDLEdBQTNDLEVBQWdELFlBQVc7QUFBRSxlQUFPa0IsYUFBUDtBQUF1QixPQUFwRjtBQUMvQjs7O0FBQXFCLFVBQUkyRCx3REFBd0QsR0FBRzVGLG1CQUFtQixDQUFDLENBQUQsQ0FBbEY7QUFDckI7OztBQUFxQixVQUFJNkYsdUNBQXVDLEdBQUc3RixtQkFBbUIsQ0FBQyxFQUFELENBQWpFOztBQUNyQixlQUFTdUMsZUFBVCxDQUF5QkMsUUFBekIsRUFBbUNDLFdBQW5DLEVBQWdEO0FBQUUsWUFBSSxFQUFFRCxRQUFRLFlBQVlDLFdBQXRCLENBQUosRUFBd0M7QUFBRSxnQkFBTSxJQUFJQyxTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixlQUFTQyxpQkFBVCxDQUEyQmhzQixNQUEzQixFQUFtQ29ULEtBQW5DLEVBQTBDO0FBQUUsYUFBSyxJQUFJN1QsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzZULEtBQUssQ0FBQ2pMLE1BQTFCLEVBQWtDNUksQ0FBQyxFQUFuQyxFQUF1QztBQUFFLGNBQUlzQixVQUFVLEdBQUd1UyxLQUFLLENBQUM3VCxDQUFELENBQXRCO0FBQTJCc0Isb0JBQVUsQ0FBQ2YsVUFBWCxHQUF3QmUsVUFBVSxDQUFDZixVQUFYLElBQXlCLEtBQWpEO0FBQXdEZSxvQkFBVSxDQUFDaEIsWUFBWCxHQUEwQixJQUExQjtBQUFnQyxjQUFJLFdBQVdnQixVQUFmLEVBQTJCQSxVQUFVLENBQUNULFFBQVgsR0FBc0IsSUFBdEI7QUFBNEJ4QixnQkFBTSxDQUFDRCxjQUFQLENBQXNCcUIsTUFBdEIsRUFBOEJhLFVBQVUsQ0FBQ3BCLEdBQXpDLEVBQThDb0IsVUFBOUM7QUFBNEQ7QUFBRTs7QUFFN1QsZUFBU29yQixZQUFULENBQXNCSCxXQUF0QixFQUFtQ0ksVUFBbkMsRUFBK0NDLFdBQS9DLEVBQTREO0FBQUUsWUFBSUQsVUFBSixFQUFnQkYsaUJBQWlCLENBQUNGLFdBQVcsQ0FBQzdCLFNBQWIsRUFBd0JpQyxVQUF4QixDQUFqQjtBQUFzRCxZQUFJQyxXQUFKLEVBQWlCSCxpQkFBaUIsQ0FBQ0YsV0FBRCxFQUFjSyxXQUFkLENBQWpCO0FBQTZDLGVBQU9MLFdBQVA7QUFBcUI7QUFFdk47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLFVBQUlMLGFBQWEsR0FBRyxtR0FBcEI7QUFDQSxVQUFJRCxhQUFhLEdBQUcsd0dBQXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBSUQsb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEI1TyxNQUE5QixFQUFzQztBQUMvRCxlQUFPL2QsTUFBTSxDQUFDc3dCLHVDQUF1QyxDQUFDO0FBQUk7QUFBTCxTQUF4QyxDQUFOLENBQWdGdlMsTUFBaEYsQ0FBUDtBQUNELE9BRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsVUFBSTBPLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCbGhCLElBQXRCLEVBQTRCO0FBQzdDLFlBQUlzSyxLQUFLLEdBQUcsSUFBSS9JLElBQUosQ0FBU3ZCLElBQUksQ0FBQ2dsQixXQUFMLEVBQVQsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBWjtBQUNBLFlBQUl2TixJQUFJLEdBQUd6WCxJQUFJLEdBQUdzSyxLQUFQLEdBQWUsQ0FBQ0EsS0FBSyxDQUFDMmEsaUJBQU4sS0FBNEJqbEIsSUFBSSxDQUFDaWxCLGlCQUFMLEVBQTdCLElBQXlELEVBQXpELEdBQThELElBQXhGO0FBQ0EsWUFBSUMsTUFBTSxHQUFHLE9BQU8sRUFBUCxHQUFZLEVBQVosR0FBaUIsRUFBOUI7QUFDQSxZQUFJMVIsR0FBRyxHQUFHalgsSUFBSSxDQUFDNmpCLEtBQUwsQ0FBVzNJLElBQUksR0FBR3lOLE1BQWxCLENBQVY7QUFDQSxlQUFPMVIsR0FBUDtBQUNELE9BTkQ7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsVUFBSStOLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCdmhCLElBQXJCLEVBQTJCO0FBQzNDLFlBQUl2SyxLQUFLLEdBQUd1SyxJQUFaO0FBQ0EsWUFBSXlJLE1BQU0sR0FBRyxDQUFDaFQsS0FBSyxDQUFDaVQsS0FBTixDQUFZLHFCQUFaLEtBQXNDLEVBQXZDLEVBQTJDLENBQTNDLENBQWI7O0FBRUEsWUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDWEEsZ0JBQU0sR0FBRyxHQUFUO0FBQ0FoVCxlQUFLLElBQUlnVCxNQUFUO0FBQ0Q7O0FBRUQsWUFBSTZZLGFBQWEsQ0FBQzZELElBQWQsQ0FBbUIxdkIsS0FBbkIsQ0FBSixFQUErQjtBQUM3QkEsZUFBSyxHQUFHLGNBQWNrdkIsTUFBZCxDQUFxQmx2QixLQUFyQixDQUFSO0FBQ0QsU0FGRCxNQUVPLElBQUk0ckIsYUFBYSxDQUFDOEQsSUFBZCxDQUFtQjF2QixLQUFuQixDQUFKLEVBQStCO0FBQ3BDQSxlQUFLLEdBQUcsR0FBR2t2QixNQUFILENBQVVsdkIsS0FBSyxDQUFDbW9CLEtBQU4sQ0FBWW5WLE1BQVosRUFBb0IsQ0FBcEIsQ0FBVixFQUFrQyxXQUFsQyxFQUErQ2tjLE1BQS9DLENBQXNEbGMsTUFBdEQsQ0FBUjtBQUNEOztBQUVELGVBQU9oVCxLQUFQO0FBQ0QsT0FoQkQ7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxVQUFJK3JCLG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULEdBQStCO0FBQ3ZELFlBQUkvZ0IsUUFBUSxHQUFHZ1MsSUFBSSxDQUFDMlMsY0FBTCxHQUFzQkMsZUFBdEIsR0FBd0NsUixRQUF2RDs7QUFFQSxZQUFJLENBQUMxVCxRQUFMLEVBQWU7QUFDYixjQUFJNmtCLEdBQUcsR0FBRyxTQUFTQSxHQUFULENBQWFscEIsTUFBYixFQUFxQjRCLE1BQXJCLEVBQTZCO0FBQ3JDLGdCQUFJcWtCLEdBQUcsR0FBRyxLQUFLam1CLE1BQWY7O0FBRUEsbUJBQU9pbUIsR0FBRyxDQUFDcmtCLE1BQUosR0FBYUEsTUFBcEIsRUFBNEI7QUFDMUJxa0IsaUJBQUcsR0FBRyxNQUFNQSxHQUFaO0FBQ0Q7O0FBRUQsbUJBQU9BLEdBQVA7QUFDRCxXQVJEOztBQVVBLGNBQUk1WixNQUFNLEdBQUcsSUFBSWxILElBQUosR0FBVzBqQixpQkFBWCxFQUFiO0FBQ0F4YyxnQkFBTSxHQUFHLENBQUNBLE1BQU0sR0FBRyxDQUFULEdBQWEsR0FBYixHQUFtQixHQUFwQixJQUEyQjtBQUNwQzZjLGFBQUcsQ0FBQ3RrQixRQUFRLENBQUN6RSxJQUFJLENBQUNncEIsR0FBTCxDQUFTOWMsTUFBTSxHQUFHLEVBQWxCLENBQUQsQ0FBVCxFQUFrQyxDQUFsQyxDQURNLEdBQ2lDNmMsR0FBRyxDQUFDL29CLElBQUksQ0FBQ2dwQixHQUFMLENBQVM5YyxNQUFNLEdBQUcsRUFBbEIsQ0FBRCxFQUF3QixDQUF4QixDQUQ3QztBQUVBLGlCQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsZUFBT2hJLFFBQVA7QUFDRCxPQXJCRDtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxVQUFJMGdCLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCbmhCLElBQXZCLEVBQTZCd2xCLFNBQTdCLEVBQXdDO0FBQzFELFlBQUlsRyxDQUFDLEdBQUcsSUFBSS9kLElBQUosQ0FBU0EsSUFBSSxDQUFDbWYsR0FBTCxDQUFTMWdCLElBQUksQ0FBQ2dsQixXQUFMLEVBQVQsRUFBNkJobEIsSUFBSSxDQUFDeWxCLFFBQUwsRUFBN0IsRUFBOEN6bEIsSUFBSSxDQUFDMGxCLE9BQUwsRUFBOUMsQ0FBVCxDQUFSO0FBQ0EsWUFBSUMsTUFBTSxHQUFHckcsQ0FBQyxDQUFDc0csU0FBRixNQUFpQkosU0FBUyxHQUFHLENBQTdCLEtBQW1DLENBQWhEO0FBQ0FsRyxTQUFDLENBQUN1RyxVQUFGLENBQWF2RyxDQUFDLENBQUN3RyxVQUFGLEtBQWlCLENBQWpCLEdBQXFCSCxNQUFsQztBQUNBLFlBQUlJLFNBQVMsR0FBRyxJQUFJeGtCLElBQUosQ0FBU0EsSUFBSSxDQUFDbWYsR0FBTCxDQUFTcEIsQ0FBQyxDQUFDMEcsY0FBRixFQUFULEVBQTZCLENBQTdCLEVBQWdDLENBQWhDLENBQVQsQ0FBaEI7QUFDQSxlQUFPenBCLElBQUksQ0FBQzRqQixJQUFMLENBQVUsQ0FBQyxDQUFDYixDQUFDLEdBQUd5RyxTQUFMLElBQWtCLFFBQWxCLEdBQTZCLENBQTlCLElBQW1DLENBQTdDLENBQVA7QUFDRCxPQU5EO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFVBQUlFLFFBQVEsR0FDWixhQUNBLFlBQVk7QUFDVixpQkFBU0EsUUFBVCxHQUFvQjtBQUNsQnhFLHlCQUFlLENBQUMsSUFBRCxFQUFPd0UsUUFBUCxDQUFmO0FBQ0Q7O0FBRURuRSxvQkFBWSxDQUFDbUUsUUFBRCxFQUFXLElBQVgsRUFBaUIsQ0FBQztBQUM1QjN3QixhQUFHLEVBQUUsTUFEdUI7O0FBRzVCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0lHLGVBQUssRUFBRSxTQUFTK1AsSUFBVCxDQUFjeEYsSUFBZCxFQUFvQmlpQixLQUFwQixFQUEyQnpQLE1BQTNCLEVBQW1DL1IsUUFBbkMsRUFBNkM7QUFDbEQsZ0JBQUksQ0FBQ1QsSUFBTCxFQUFXLE9BQU8sRUFBUDtBQUNYLGdCQUFJLENBQUNpaUIsS0FBTCxFQUFZLE9BQU9qaUIsSUFBUDtBQUNaUyxvQkFBUSxHQUFHQSxRQUFRLElBQUkrZ0IsbUJBQW1CLEVBQTFDO0FBQ0FoUCxrQkFBTSxHQUFHQSxNQUFNLElBQUlDLElBQUksQ0FBQzJTLGNBQUwsR0FBc0JDLGVBQXRCLEdBQXdDN1MsTUFBbEQsSUFBNEQsT0FBckUsQ0FKa0QsQ0FJNEI7O0FBRTlFeFMsZ0JBQUksR0FBR0EsSUFBSSxZQUFZdUIsSUFBaEIsR0FBdUJ2QixJQUF2QixHQUE4QnVoQixXQUFXLENBQUN2aEIsSUFBRCxDQUFoRDtBQUNBLGdCQUFJa21CLFVBQVUsR0FBR3p4QixNQUFNLENBQUNxd0Isd0RBQXdELENBQUM7QUFBSTtBQUFMLGFBQXpELENBQU4sQ0FBb0Y5a0IsSUFBcEYsRUFBMEZTLFFBQTFGLENBQWpCOztBQUVBLGdCQUFJMGxCLFdBQVcsR0FBR0YsUUFBUSxDQUFDRyxpQkFBVCxDQUEyQjtBQUMzQzlTLGtCQUFJLEVBQUU0UyxVQUFVLENBQUNsQixXQUFYLEVBRHFDO0FBRTNDelIsbUJBQUssRUFBRTJTLFVBQVUsQ0FBQ1QsUUFBWCxLQUF3QixDQUZZO0FBRzNDWSx3QkFBVSxFQUFFLElBQUk1VCxJQUFJLENBQUMyUyxjQUFULENBQXdCLENBQUM1UyxNQUFELENBQXhCLEVBQWtDO0FBQzVDZSxxQkFBSyxFQUFFO0FBRHFDLGVBQWxDLEVBRVRnRyxNQUZTLENBRUYyTSxVQUZFLENBSCtCO0FBTTNDSSx1QkFBUyxFQUFFLElBQUk3VCxJQUFJLENBQUMyUyxjQUFULENBQXdCLENBQUM1UyxNQUFELENBQXhCLEVBQWtDO0FBQzNDZSxxQkFBSyxFQUFFO0FBRG9DLGVBQWxDLEVBRVJnRyxNQUZRLENBRUQyTSxVQUZDLENBTmdDO0FBUzNDMVMsaUJBQUcsRUFBRTBTLFVBQVUsQ0FBQ1IsT0FBWCxFQVRzQztBQVUzQ2Esc0JBQVEsRUFBRSxJQUFJOVQsSUFBSSxDQUFDMlMsY0FBVCxDQUF3QixDQUFDNVMsTUFBRCxDQUF4QixFQUFrQztBQUMxQ3FILHVCQUFPLEVBQUU7QUFEaUMsZUFBbEMsRUFFUE4sTUFGTyxDQUVBMk0sVUFGQSxDQVZpQztBQWEzQ00scUJBQU8sRUFBRSxJQUFJL1QsSUFBSSxDQUFDMlMsY0FBVCxDQUF3QixDQUFDNVMsTUFBRCxDQUF4QixFQUFrQztBQUN6Q3FILHVCQUFPLEVBQUU7QUFEZ0MsZUFBbEMsRUFFTk4sTUFGTSxDQUVDMk0sVUFGRCxDQWJrQztBQWdCM0Mva0IscUJBQU8sRUFBRStrQixVQUFVLENBQUNPLFVBQVgsRUFoQmtDO0FBaUIzQ2xQLHFCQUFPLEVBQUUyTyxVQUFVLENBQUNRLFVBQVgsRUFqQmtDOztBQW1CM0Msa0JBQUlDLE9BQUosR0FBYztBQUNaLHVCQUFPVCxVQUFVLENBQUNVLFFBQVgsRUFBUDtBQUNELGVBckIwQzs7QUF1QjNDLGtCQUFJQyxPQUFKLEdBQWM7QUFDWix1QkFBTyxLQUFLRixPQUFMLEdBQWUsRUFBZixJQUFxQixFQUE1QjtBQUNELGVBekIwQzs7QUEyQjNDNVAsdUJBQVMsRUFBRW1LLFlBQVksQ0FBQ2dGLFVBQUQsQ0EzQm9CO0FBNEIzQzlPLHVCQUFTLEVBQUU4TyxVQUFVLENBQUNZLE1BQVgsS0FBc0IsQ0E1QlU7QUE2QjNDO0FBQ0FDLHdCQUFVLEVBQUU1RixhQUFhLENBQUMrRSxVQUFELEVBQWE5RSxvQkFBb0IsQ0FBQzVPLE1BQUQsQ0FBakMsQ0E5QmtCO0FBK0IzQ0Esb0JBQU0sRUFBRUEsTUEvQm1DO0FBZ0MzQy9SLHNCQUFRLEVBQUVBO0FBaENpQyxhQUEzQixDQUFsQjs7QUFtQ0EsZ0JBQUk3QixNQUFNLEdBQUdxakIsS0FBYjs7QUFFQSxpQkFBSyxJQUFJK0UsQ0FBVCxJQUFjYixXQUFkLEVBQTJCO0FBQ3pCdm5CLG9CQUFNLEdBQUdBLE1BQU0sQ0FBQ3FvQixPQUFQLENBQWUsSUFBSTllLE1BQUosQ0FBVyxPQUFPNmUsQ0FBUCxHQUFXLEdBQXRCLEVBQTJCLEdBQTNCLENBQWYsRUFBZ0RiLFdBQVcsQ0FBQ2EsQ0FBRCxDQUEzRCxDQUFUO0FBQ0Q7O0FBRUQsbUJBQU9wb0IsTUFBUDtBQUNEO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBMUVnQyxTQUFELEVBNEUxQjtBQUNEdEosYUFBRyxFQUFFLG1CQURKO0FBRURHLGVBQUssRUFBRSxTQUFTMndCLGlCQUFULENBQTJCYyxXQUEzQixFQUF3QztBQUM3QyxtQkFBTztBQUNMO0FBQ0FDLGdCQUFFLEVBQUVELFdBQVcsQ0FBQzVULElBQVosQ0FBaUJ2VCxRQUFqQixHQUE0QnFuQixNQUE1QixDQUFtQyxDQUFDLENBQXBDLENBRkM7QUFHTEMsZ0JBQUUsRUFBRUgsV0FBVyxDQUFDNVQsSUFIWDtBQUlMZ1UsZ0JBQUUsRUFBRUosV0FBVyxDQUFDNVQsSUFKWDtBQUtMaVUsZ0JBQUUsRUFBRTFsQixNQUFNLENBQUMybEIsWUFBUCxDQUFvQk4sV0FBVyxDQUFDNVQsSUFBaEMsQ0FMQztBQU1MbVUsZ0JBQUUsRUFBRVAsV0FBVyxDQUFDNVQsSUFOWDtBQU9Mb1UsZUFBQyxFQUFFUixXQUFXLENBQUM1VCxJQVBWO0FBUUw7QUFDQXFVLGdCQUFFLEVBQUU5bEIsTUFBTSxDQUFDcWxCLFdBQVcsQ0FBQzNULEtBQWIsQ0FBTixDQUEwQnZWLE1BQTFCLElBQW9DLENBQXBDLEdBQXdDLE1BQU1rcEIsV0FBVyxDQUFDM1QsS0FBMUQsR0FBa0UyVCxXQUFXLENBQUMzVCxLQVQ3RTtBQVVMcVUsZ0JBQUUsRUFBRVYsV0FBVyxDQUFDYixVQVZYO0FBV0x3QixnQkFBRSxFQUFFWCxXQUFXLENBQUNaLFNBWFg7QUFZTHdCLGdCQUFFLEVBQUVqbUIsTUFBTSxDQUFDMmxCLFlBQVAsQ0FBb0JOLFdBQVcsQ0FBQzNULEtBQWhDLENBWkM7QUFhTHdVLGdCQUFFLEVBQUViLFdBQVcsQ0FBQzNULEtBYlg7QUFjTHlVLGVBQUMsRUFBRWQsV0FBVyxDQUFDM1QsS0FkVjtBQWVMO0FBQ0EwVSxnQkFBRSxFQUFFcG1CLE1BQU0sQ0FBQ3FsQixXQUFXLENBQUMxVCxHQUFiLENBQU4sQ0FBd0J4VixNQUF4QixJQUFrQyxDQUFsQyxHQUFzQyxNQUFNa3BCLFdBQVcsQ0FBQzFULEdBQXhELEdBQThEMFQsV0FBVyxDQUFDMVQsR0FoQnpFO0FBaUJMMFUsZ0JBQUUsRUFBRWhCLFdBQVcsQ0FBQ1gsUUFqQlg7QUFrQkw0QixnQkFBRSxFQUFFakIsV0FBVyxDQUFDVixPQWxCWDtBQW1CTDRCLGdCQUFFLEVBQUV2bUIsTUFBTSxDQUFDMmxCLFlBQVAsQ0FBb0JOLFdBQVcsQ0FBQzFULEdBQWhDLENBbkJDO0FBb0JMNlUsZ0JBQUUsRUFBRW5CLFdBQVcsQ0FBQzFULEdBcEJYO0FBcUJMOFUsZUFBQyxFQUFFcEIsV0FBVyxDQUFDMVQsR0FyQlY7QUFzQkw7QUFDQStVLGdCQUFFLEVBQUUxbUIsTUFBTSxDQUFDcWxCLFdBQVcsQ0FBQ1AsT0FBYixDQUFOLENBQTRCM29CLE1BQTVCLElBQXNDLENBQXRDLEdBQTBDLE1BQU1rcEIsV0FBVyxDQUFDUCxPQUE1RCxHQUFzRU8sV0FBVyxDQUFDUCxPQXZCakY7QUF3Qkw2QixnQkFBRSxFQUFFdEIsV0FBVyxDQUFDUCxPQXhCWDtBQXlCTDhCLGdCQUFFLEVBQUV2QixXQUFXLENBQUNQLE9BekJYO0FBMEJMK0IsZ0JBQUUsRUFBRTdtQixNQUFNLENBQUMybEIsWUFBUCxDQUFvQk4sV0FBVyxDQUFDUCxPQUFoQyxDQTFCQztBQTJCTGdDLGdCQUFFLEVBQUV6QixXQUFXLENBQUNQLE9BM0JYO0FBNEJMaUMsZUFBQyxFQUFFMUIsV0FBVyxDQUFDUCxPQTVCVjtBQTZCTDtBQUNBa0MsZ0JBQUUsRUFBRWhuQixNQUFNLENBQUNxbEIsV0FBVyxDQUFDTCxPQUFiLENBQU4sQ0FBNEI3b0IsTUFBNUIsSUFBc0MsQ0FBdEMsR0FBMEMsTUFBTWtwQixXQUFXLENBQUNMLE9BQTVELEdBQXNFSyxXQUFXLENBQUNMLE9BOUJqRjtBQStCTGlDLGdCQUFFLEVBQUU1QixXQUFXLENBQUNMLE9BL0JYO0FBZ0NMa0MsZ0JBQUUsRUFBRTdCLFdBQVcsQ0FBQ0wsT0FoQ1g7QUFpQ0xtQyxnQkFBRSxFQUFFbm5CLE1BQU0sQ0FBQzJsQixZQUFQLENBQW9CTixXQUFXLENBQUNMLE9BQWhDLENBakNDO0FBa0NMb0MsZ0JBQUUsRUFBRS9CLFdBQVcsQ0FBQ0wsT0FsQ1g7QUFtQ0xxQyxlQUFDLEVBQUVoQyxXQUFXLENBQUNMLE9BbkNWO0FBb0NMO0FBQ0FzQyxnQkFBRSxFQUFFdG5CLE1BQU0sQ0FBQ3FsQixXQUFXLENBQUMvbEIsT0FBYixDQUFOLENBQTRCbkQsTUFBNUIsSUFBc0MsQ0FBdEMsR0FBMEMsTUFBTWtwQixXQUFXLENBQUMvbEIsT0FBNUQsR0FBc0UrbEIsV0FBVyxDQUFDL2xCLE9BckNqRjtBQXNDTGlvQixnQkFBRSxFQUFFbEMsV0FBVyxDQUFDL2xCLE9BdENYO0FBdUNMa29CLGdCQUFFLEVBQUVuQyxXQUFXLENBQUMvbEIsT0F2Q1g7QUF3Q0xtb0IsZ0JBQUUsRUFBRXpuQixNQUFNLENBQUMybEIsWUFBUCxDQUFvQk4sV0FBVyxDQUFDL2xCLE9BQWhDLENBeENDO0FBeUNMb29CLGdCQUFFLEVBQUVyQyxXQUFXLENBQUMvbEIsT0F6Q1g7QUEwQ0xrZSxlQUFDLEVBQUU2SCxXQUFXLENBQUMvbEIsT0ExQ1Y7QUEyQ0w7QUFDQXFvQixnQkFBRSxFQUFFM25CLE1BQU0sQ0FBQ3FsQixXQUFXLENBQUMzUCxPQUFiLENBQU4sQ0FBNEJ2WixNQUE1QixJQUFzQyxDQUF0QyxHQUEwQyxNQUFNa3BCLFdBQVcsQ0FBQzNQLE9BQTVELEdBQXNFMlAsV0FBVyxDQUFDM1AsT0E1Q2pGO0FBNkNMa1MsZ0JBQUUsRUFBRXZDLFdBQVcsQ0FBQzNQLE9BN0NYO0FBOENMbVMsZ0JBQUUsRUFBRXhDLFdBQVcsQ0FBQzNQLE9BOUNYO0FBK0NMb1MsZ0JBQUUsRUFBRTluQixNQUFNLENBQUMybEIsWUFBUCxDQUFvQk4sV0FBVyxDQUFDM1AsT0FBaEMsQ0EvQ0M7QUFnRExxUyxnQkFBRSxFQUFFMUMsV0FBVyxDQUFDM1AsT0FoRFg7QUFpREx5SSxlQUFDLEVBQUVrSCxXQUFXLENBQUMzUCxPQWpEVjtBQWtETDtBQUNBc1MsZ0JBQUUsRUFBRTNDLFdBQVcsQ0FBQ1AsT0FBWixHQUFzQixFQUF0QixHQUEyQixJQUEzQixHQUFrQyxJQW5EakM7QUFvRExtRCxlQUFDLEVBQUU1QyxXQUFXLENBQUNQLE9BQVosR0FBc0IsRUFBdEIsR0FBMkIsSUFBM0IsR0FBa0MsSUFwRGhDO0FBcURMb0QsZ0JBQUUsRUFBRTdDLFdBQVcsQ0FBQ1AsT0FBWixHQUFzQixFQUF0QixHQUEyQixJQUEzQixHQUFrQyxJQXJEakM7QUFzREw1RyxlQUFDLEVBQUVtSCxXQUFXLENBQUNQLE9BQVosR0FBc0IsRUFBdEIsR0FBMkIsSUFBM0IsR0FBa0MsSUF0RGhDO0FBdURMO0FBQ0FxRCxnQkFBRSxFQUFFbm9CLE1BQU0sQ0FBQ3FsQixXQUFXLENBQUNuUSxTQUFiLENBQU4sQ0FBOEIvWSxNQUE5QixJQUF3QyxDQUF4QyxHQUE0QyxNQUFNa3BCLFdBQVcsQ0FBQ25RLFNBQTlELEdBQTBFbVEsV0FBVyxDQUFDblEsU0F4RHJGO0FBeURMa1QsZ0JBQUUsRUFBRS9DLFdBQVcsQ0FBQ25RLFNBekRYO0FBMERMbVQsZ0JBQUUsRUFBRWhELFdBQVcsQ0FBQ25RLFNBMURYO0FBMkRMb1QsZ0JBQUUsRUFBRWpELFdBQVcsQ0FBQ25RLFNBM0RYO0FBNERMcVQsZUFBQyxFQUFFbEQsV0FBVyxDQUFDblEsU0E1RFY7QUE2REw7QUFDQXNULGdCQUFFLEVBQUV4b0IsTUFBTSxDQUFDcWxCLFdBQVcsQ0FBQzlQLFNBQWIsQ0FBTixDQUE4QnBaLE1BQTlCLElBQXdDLENBQXhDLEdBQTRDLE1BQU1rcEIsV0FBVyxDQUFDOVAsU0FBOUQsR0FBMEU4UCxXQUFXLENBQUM5UCxTQTlEckY7QUErRExrVCxnQkFBRSxFQUFFcEQsV0FBVyxDQUFDOVAsU0EvRFg7QUFnRUxtVCxnQkFBRSxFQUFFckQsV0FBVyxDQUFDOVAsU0FoRVg7QUFpRUxvVCxnQkFBRSxFQUFFM29CLE1BQU0sQ0FBQzJsQixZQUFQLENBQW9CTixXQUFXLENBQUM5UCxTQUFoQyxDQWpFQztBQWtFTHFULGdCQUFFLEVBQUV2RCxXQUFXLENBQUM5UCxTQWxFWDtBQW1FTHNULGVBQUMsRUFBRXhELFdBQVcsQ0FBQzlQLFNBbkVWO0FBb0VMO0FBQ0F1VCxnQkFBRSxFQUFFOW9CLE1BQU0sQ0FBQ3FsQixXQUFXLENBQUNILFVBQWIsQ0FBTixDQUErQi9vQixNQUEvQixJQUF5QyxDQUF6QyxHQUE2QyxNQUFNa3BCLFdBQVcsQ0FBQ0gsVUFBL0QsR0FBNEVHLFdBQVcsQ0FBQ0gsVUFyRXZGO0FBc0VMNkQsZ0JBQUUsRUFBRTFELFdBQVcsQ0FBQ0gsVUF0RVg7QUF1RUw4RCxnQkFBRSxFQUFFM0QsV0FBVyxDQUFDSCxVQXZFWDtBQXdFTCtELGdCQUFFLEVBQUVqcEIsTUFBTSxDQUFDMmxCLFlBQVAsQ0FBb0JOLFdBQVcsQ0FBQ0gsVUFBaEMsQ0F4RUM7QUF5RUxnRSxnQkFBRSxFQUFFN0QsV0FBVyxDQUFDSCxVQXpFWDtBQTBFTGlFLGVBQUMsRUFBRTlELFdBQVcsQ0FBQ0g7QUExRVYsYUFBUDtBQTRFRDtBQS9FQSxTQTVFMEIsQ0FBakIsQ0FBWjs7QUE4SkEsZUFBT2QsUUFBUDtBQUNELE9BcEtELEVBRkE7QUF3S0E7OztBQUE2QmhHLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBNEJnRyxRQUE1QjtBQUU3QjtBQUFPLEtBeDRCRztBQXk0QlY7O0FBQ0E7QUFBTyxjQUFTcnRCLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7QUFDQTs7QUFBaUNlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBMkJsTixjQUEzQjtBQUNqQzs7QUFBcUIsVUFBSWtZLGtEQUFrRCxHQUFHL0wsbUJBQW1CLENBQUMsQ0FBRCxDQUE1RTtBQUNyQjs7O0FBQXFCLFVBQUlnTSwwREFBMEQsR0FBR2hNLG1CQUFtQixDQUFDLEVBQUQsQ0FBcEY7QUFDckI7OztBQUFxQixVQUFJaU0scUNBQXFDLEdBQUdqTSxtQkFBbUIsQ0FBQyxFQUFELENBQS9EO0FBS3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsZUFBU25NLGNBQVQsQ0FBd0IrRSxTQUF4QixFQUFtQzNELFFBQW5DLEVBQTZDOVEsT0FBN0MsRUFBc0Q7QUFDcEQsWUFBSXJELElBQUksR0FBR3ZMLE1BQU0sQ0FBQzAyQixxQ0FBcUMsQ0FBQztBQUFJO0FBQUwsU0FBdEMsQ0FBTixDQUFpRXJULFNBQWpFLEVBQTRFelUsT0FBNUUsQ0FBWCxDQURvRCxDQUdwRDs7QUFDQSxZQUFJbkQsT0FBTyxHQUFHLElBQUlxQixJQUFKLENBQ1p2QixJQUFJLENBQUNnbUIsY0FBTCxFQURZLEVBRVpobUIsSUFBSSxDQUFDb3JCLFdBQUwsRUFGWSxFQUdacHJCLElBQUksQ0FBQzhsQixVQUFMLEVBSFksRUFJWjlsQixJQUFJLENBQUNxckIsV0FBTCxFQUpZLEVBS1pyckIsSUFBSSxDQUFDc3JCLGFBQUwsRUFMWSxFQU1adHJCLElBQUksQ0FBQ3VyQixhQUFMLEVBTlksRUFPWnZyQixJQUFJLENBQUN3ckIsa0JBQUwsRUFQWSxDQUFkLENBSm9ELENBYXBEOztBQUNBLFlBQUlyckIsa0JBQWtCLEdBQUcxTCxNQUFNLENBQUN3MkIsa0RBQWtELENBQUM7QUFBSTtBQUFMLFNBQW5ELENBQU4sQ0FBOEU5VyxRQUE5RSxFQUF3Rm5VLElBQXhGLENBQXpCO0FBRUEsZUFBT0csa0JBQWtCLEdBQ3JCMUwsTUFBTSxDQUFDeTJCLDBEQUEwRCxDQUFDO0FBQUk7QUFBTCxTQUEzRCxDQUFOLENBQXNGaHJCLE9BQXRGLEVBQStGQyxrQkFBL0YsQ0FEcUIsR0FFckJELE9BRko7QUFHRDtBQUdEOztBQUFPLEtBbjhCRztBQW84QlY7O0FBQ0E7QUFBTyxjQUFTdEgsTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUFpQ2UseUJBQW1CLENBQUMsR0FBRCxDQUFuQixHQUEyQjVlLGNBQTNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGVBQVNBLGNBQVQsQ0FBd0JyQixJQUF4QixFQUE4Qm1VLFFBQTlCLEVBQXdDO0FBQ3RDLFlBQUlsQixHQUFHLEdBQUdDLGlCQUFpQixDQUFDaUIsUUFBRCxDQUEzQjtBQUNBLGVBQU9sQixHQUFHLENBQUN3WSxhQUFKLEdBQW9CdFksV0FBVyxDQUFDRixHQUFELEVBQU1qVCxJQUFOLENBQS9CLEdBQTZDb1QsV0FBVyxDQUFDSCxHQUFELEVBQU1qVCxJQUFOLENBQS9EO0FBQ0Q7O0FBRUQsVUFBSXFULFNBQVMsR0FBRztBQUNkQyxZQUFJLEVBQUUsQ0FEUTtBQUVkQyxhQUFLLEVBQUUsQ0FGTztBQUdkQyxXQUFHLEVBQUUsQ0FIUztBQUlkQyxZQUFJLEVBQUUsQ0FKUTtBQUtkQyxjQUFNLEVBQUUsQ0FMTTtBQU1kQyxjQUFNLEVBQUU7QUFOTSxPQUFoQjs7QUFTQSxlQUFTUixXQUFULENBQXFCRixHQUFyQixFQUEwQmpULElBQTFCLEVBQWdDO0FBQzlCLFlBQUk0VCxTQUFTLEdBQUdYLEdBQUcsQ0FBQ3dZLGFBQUosQ0FBa0J6ckIsSUFBbEIsQ0FBaEI7QUFDQSxZQUFJNlQsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsYUFBSyxJQUFJemUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dlLFNBQVMsQ0FBQzVWLE1BQTlCLEVBQXNDNUksQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxjQUFJMGUsR0FBRyxHQUFHVCxTQUFTLENBQUNPLFNBQVMsQ0FBQ3hlLENBQUQsQ0FBVCxDQUFhbUcsSUFBZCxDQUFuQjs7QUFFQSxjQUFJdVksR0FBRyxJQUFJLENBQVgsRUFBYztBQUNaRCxrQkFBTSxDQUFDQyxHQUFELENBQU4sR0FBYzlTLFFBQVEsQ0FBQzRTLFNBQVMsQ0FBQ3hlLENBQUQsQ0FBVCxDQUFhSyxLQUFkLEVBQXFCLEVBQXJCLENBQXRCO0FBQ0Q7QUFDRjs7QUFDRCxlQUFPb2UsTUFBUDtBQUNEOztBQUVELGVBQVNULFdBQVQsQ0FBcUJILEdBQXJCLEVBQTBCalQsSUFBMUIsRUFBZ0M7QUFDOUIsWUFBSTRULFNBQVMsR0FBR1gsR0FBRyxDQUFDc0csTUFBSixDQUFXdlosSUFBWCxFQUFpQmluQixPQUFqQixDQUF5QixTQUF6QixFQUFvQyxFQUFwQyxDQUFoQjtBQUNBLFlBQUlsVCxNQUFNLEdBQUcsMENBQTBDME0sSUFBMUMsQ0FBK0M3TSxTQUEvQyxDQUFiLENBRjhCLENBRzlCO0FBQ0E7O0FBQ0EsZUFBTyxDQUFDRyxNQUFNLENBQUMsQ0FBRCxDQUFQLEVBQVlBLE1BQU0sQ0FBQyxDQUFELENBQWxCLEVBQXVCQSxNQUFNLENBQUMsQ0FBRCxDQUE3QixFQUFrQ0EsTUFBTSxDQUFDLENBQUQsQ0FBeEMsRUFBNkNBLE1BQU0sQ0FBQyxDQUFELENBQW5ELEVBQXdEQSxNQUFNLENBQUMsQ0FBRCxDQUE5RCxDQUFQO0FBQ0QsT0F6Q2lFLENBMkNsRTtBQUNBO0FBQ0E7OztBQUNBLFVBQUlDLFFBQVEsR0FBRyxFQUFmOztBQUNBLGVBQVNkLGlCQUFULENBQTJCaUIsUUFBM0IsRUFBcUM7QUFDbkMsWUFBSSxDQUFDSCxRQUFRLENBQUNHLFFBQUQsQ0FBYixFQUF5QjtBQUN2QjtBQUNBLGNBQUlGLGlCQUFpQixHQUFHLElBQUl4QixJQUFJLENBQUMyUyxjQUFULENBQXdCLE9BQXhCLEVBQWlDO0FBQ3ZEbFIsa0JBQU0sRUFBRSxLQUQrQztBQUV2REMsb0JBQVEsRUFBRSxrQkFGNkM7QUFHdkRiLGdCQUFJLEVBQUUsU0FIaUQ7QUFJdkRDLGlCQUFLLEVBQUUsU0FKZ0Q7QUFLdkRDLGVBQUcsRUFBRSxTQUxrRDtBQU12REMsZ0JBQUksRUFBRSxTQU5pRDtBQU92REMsa0JBQU0sRUFBRSxTQVArQztBQVF2REMsa0JBQU0sRUFBRTtBQVIrQyxXQUFqQyxFQVNyQjRGLE1BVHFCLENBU2QsSUFBSWhZLElBQUosQ0FBUywwQkFBVCxDQVRjLENBQXhCO0FBVUEsY0FBSTZTLGtCQUFrQixHQUNwQkgsaUJBQWlCLEtBQUssc0JBQXRCLElBQ0FBLGlCQUFpQixLQUFLLGdDQUZ4QjtBQUlBRCxrQkFBUSxDQUFDRyxRQUFELENBQVIsR0FBcUJDLGtCQUFrQixHQUNuQyxJQUFJM0IsSUFBSSxDQUFDMlMsY0FBVCxDQUF3QixPQUF4QixFQUFpQztBQUMvQmxSLGtCQUFNLEVBQUUsS0FEdUI7QUFFL0JDLG9CQUFRLEVBQUVBLFFBRnFCO0FBRy9CYixnQkFBSSxFQUFFLFNBSHlCO0FBSS9CQyxpQkFBSyxFQUFFLFNBSndCO0FBSy9CQyxlQUFHLEVBQUUsU0FMMEI7QUFNL0JDLGdCQUFJLEVBQUUsU0FOeUI7QUFPL0JDLGtCQUFNLEVBQUUsU0FQdUI7QUFRL0JDLGtCQUFNLEVBQUU7QUFSdUIsV0FBakMsQ0FEbUMsR0FXbkMsSUFBSWxCLElBQUksQ0FBQzJTLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUM7QUFDL0IvUSxxQkFBUyxFQUFFLEtBRG9CO0FBRS9CRixvQkFBUSxFQUFFQSxRQUZxQjtBQUcvQmIsZ0JBQUksRUFBRSxTQUh5QjtBQUkvQkMsaUJBQUssRUFBRSxTQUp3QjtBQUsvQkMsZUFBRyxFQUFFLFNBTDBCO0FBTS9CQyxnQkFBSSxFQUFFLFNBTnlCO0FBTy9CQyxrQkFBTSxFQUFFLFNBUHVCO0FBUS9CQyxrQkFBTSxFQUFFO0FBUnVCLFdBQWpDLENBWEo7QUFxQkQ7O0FBQ0QsZUFBT0ssUUFBUSxDQUFDRyxRQUFELENBQWY7QUFDRDtBQUdEOztBQUFPLEtBL2hDRztBQWdpQ1Y7O0FBQ0E7QUFBTyxjQUFTdmIsTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUFpQ2UseUJBQW1CLENBQUMsR0FBRCxDQUFuQixHQUEyQjVmLGVBQTNCO0FBQ2pDOztBQUFxQixVQUFJcXJCLHFEQUFxRCxHQUFHeE0sbUJBQW1CLENBQUMsQ0FBRCxDQUEvRTtBQUNyQjs7O0FBQXFCLFVBQUl5TSx1REFBdUQsR0FBR3pNLG1CQUFtQixDQUFDLEVBQUQsQ0FBakY7QUFHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLGVBQVM3ZSxlQUFULENBQXlCeVgsU0FBekIsRUFBb0M4VCxXQUFwQyxFQUFpRDtBQUMvQyxZQUFJMWdCLFNBQVMsQ0FBQ2xOLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZ0JBQU0sSUFBSTRqQixTQUFKLENBQWMsb0NBQW9DMVcsU0FBUyxDQUFDbE4sTUFBOUMsR0FBdUQsVUFBckUsQ0FBTjtBQUNEOztBQUVELFlBQUl1VyxNQUFNLEdBQUc5ZixNQUFNLENBQUNpM0IscURBQXFELENBQUM7QUFBSTtBQUFMLFNBQXRELENBQU4sQ0FBaUZFLFdBQWpGLENBQWI7QUFDQSxlQUFPbjNCLE1BQU0sQ0FBQ2szQix1REFBdUQsQ0FBQztBQUFJO0FBQUwsU0FBeEQsQ0FBTixDQUFtRjdULFNBQW5GLEVBQThGLENBQUN2RCxNQUEvRixDQUFQO0FBQ0Q7QUFFRDs7QUFBTyxLQXprQ0c7QUEwa0NWOztBQUNBO0FBQU8sY0FBUzNiLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7QUFDQTs7QUFBaUNlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBMkJ4TCxlQUEzQjtBQUNqQzs7QUFBcUIsVUFBSWlYLHFEQUFxRCxHQUFHeE0sbUJBQW1CLENBQUMsQ0FBRCxDQUEvRTtBQUNyQjs7O0FBQXFCLFVBQUkyTSw4Q0FBOEMsR0FBRzNNLG1CQUFtQixDQUFDLEVBQUQsQ0FBeEU7QUFHckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLGVBQVN6SyxlQUFULENBQXlCcUQsU0FBekIsRUFBb0M4VCxXQUFwQyxFQUFpRDtBQUMvQyxZQUFJMWdCLFNBQVMsQ0FBQ2xOLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZ0JBQU0sSUFBSTRqQixTQUFKLENBQWMsb0NBQW9DMVcsU0FBUyxDQUFDbE4sTUFBOUMsR0FBdUQsVUFBckUsQ0FBTjtBQUNEOztBQUVELFlBQUkwVyxTQUFTLEdBQUdqZ0IsTUFBTSxDQUFDbzNCLDhDQUE4QyxDQUFDO0FBQUk7QUFBTCxTQUEvQyxDQUFOLENBQTBFL1QsU0FBMUUsRUFBcUY2SSxPQUFyRixFQUFoQjtBQUNBLFlBQUlwTSxNQUFNLEdBQUc5ZixNQUFNLENBQUNpM0IscURBQXFELENBQUM7QUFBSTtBQUFMLFNBQXRELENBQU4sQ0FBaUZFLFdBQWpGLENBQWI7QUFDQSxlQUFPLElBQUlycUIsSUFBSixDQUFTbVQsU0FBUyxHQUFHSCxNQUFyQixDQUFQO0FBQ0Q7QUFFRDs7QUFBTyxLQXBuQ0c7QUFxbkNWOztBQUNBO0FBQU8sY0FBUzNiLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7QUFDQTs7QUFBaUNlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBMkJoZ0IsTUFBM0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGVBQVNBLE1BQVQsQ0FBZ0IyVSxRQUFoQixFQUEwQjtBQUN4QixZQUFJMUosU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixnQkFBTSxJQUFJNGpCLFNBQUosQ0FBYyxtQ0FBbUMxVyxTQUFTLENBQUNsTixNQUE3QyxHQUFzRCxVQUFwRSxDQUFOO0FBQ0Q7O0FBRUQsWUFBSTJXLE1BQU0sR0FBR2xnQixNQUFNLENBQUNxckIsU0FBUCxDQUFpQi9mLFFBQWpCLENBQTBCcWYsSUFBMUIsQ0FBK0J4SyxRQUEvQixDQUFiLENBTHdCLENBSytCOztBQUV2RCxZQUFJQSxRQUFRLFlBQVlyVCxJQUFwQixJQUE0QixRQUFPcVQsUUFBUCxNQUFvQixRQUFwQixJQUFnQ0QsTUFBTSxLQUFLLGVBQTNFLEVBQTRGO0FBQzFGO0FBQ0EsaUJBQU8sSUFBSXBULElBQUosQ0FBU3FULFFBQVEsQ0FBQytMLE9BQVQsRUFBVCxDQUFQO0FBQ0QsU0FIRCxNQUdPLElBQUksT0FBTy9MLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0NELE1BQU0sS0FBSyxpQkFBL0MsRUFBa0U7QUFDdkUsaUJBQU8sSUFBSXBULElBQUosQ0FBU3FULFFBQVQsQ0FBUDtBQUNELFNBRk0sTUFFQTtBQUNMLGNBQUksQ0FBQyxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDRCxNQUFNLEtBQUssaUJBQTVDLEtBQWtFLE9BQU90WixPQUFQLEtBQW1CLFdBQXpGLEVBQXNHO0FBQ3BHO0FBQ0FBLG1CQUFPLENBQUNELElBQVIsQ0FBYSw2SUFBYixFQUZvRyxDQUV5RDs7QUFFN0pDLG1CQUFPLENBQUNELElBQVIsQ0FBYSxJQUFJMHdCLEtBQUosR0FBWUMsS0FBekI7QUFDRDs7QUFFRCxpQkFBTyxJQUFJeHFCLElBQUosQ0FBUzJlLEdBQVQsQ0FBUDtBQUNEO0FBQ0Y7QUFFRDs7QUFBTyxLQWhyQ0c7QUFpckNWOztBQUNBO0FBQU8sY0FBU3RuQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQWlDZSx5QkFBbUIsQ0FBQyxHQUFELENBQW5CLEdBQTJCaGdCLE1BQTNCO0FBQ2pDOztBQUFxQixVQUFJK3JCLGlFQUFpRSxHQUFHOU0sbUJBQW1CLENBQUMsQ0FBRCxDQUEzRjtBQUNyQjs7O0FBQXFCLFVBQUkrTSx1RkFBdUYsR0FBRy9NLG1CQUFtQixDQUFDLEVBQUQsQ0FBakg7QUFDckI7OztBQUFxQixVQUFJZ04sa0RBQWtELEdBQUdoTixtQkFBbUIsQ0FBQyxDQUFELENBQTVFOztBQUtyQixVQUFJNWUsb0JBQW9CLEdBQUcsT0FBM0I7QUFDQSxVQUFJQyxzQkFBc0IsR0FBRyxLQUE3QjtBQUNBLFVBQUlzVSx5QkFBeUIsR0FBRyxDQUFoQztBQUVBLFVBQUlyVSxRQUFRLEdBQUc7QUFDYnNVLHlCQUFpQixFQUFFLE1BRE47QUFFYkMsaUJBQVMsRUFBRSxHQUZFO0FBR2JDLHlCQUFpQixFQUFFLE9BSE47QUFLYjtBQUNBQyxVQUFFLEVBQUUsV0FOUztBQU9iQyxXQUFHLEVBQUUsQ0FDSCxlQURHLEVBQ2M7QUFDakIsdUJBRkcsRUFFYztBQUNqQix1QkFIRyxDQUdhO0FBSGIsU0FQUTtBQVliQyxZQUFJLEVBQUUsVUFaTztBQWFiQyxhQUFLLEVBQUUsQ0FDTCxjQURLLEVBQ1c7QUFDaEIsc0JBRkssRUFFVztBQUNoQixzQkFISyxDQUdVO0FBSFYsU0FiTTtBQW1CYjtBQUNBQyxVQUFFLEVBQUUsWUFwQlM7QUFxQmJDLFdBQUcsRUFBRSxhQXJCUTtBQXNCYkMsWUFBSSxFQUFFLHNCQXRCTztBQXVCYkMsV0FBRyxFQUFFLGNBdkJRO0FBd0JiQyxZQUFJLEVBQUUsdUJBeEJPO0FBMEJiQyxVQUFFLEVBQUUscUJBMUJTO0FBMkJiQyxZQUFJLEVBQUUsOEJBM0JPO0FBNEJiQyxjQUFNLEVBQUUsdUNBNUJLO0FBOEJiO0FBQ0FuVixnQkFBUSxFQUFFO0FBL0JHLE9BQWY7QUFrQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxlQUFTUixNQUFULENBQWdCMlUsUUFBaEIsRUFBMEJpQixZQUExQixFQUF3QztBQUN0QyxZQUFJM0ssU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixnQkFBTSxJQUFJNGpCLFNBQUosQ0FDSixtQ0FBbUMxVyxTQUFTLENBQUNsTixNQUE3QyxHQUFzRCxVQURsRCxDQUFOO0FBR0Q7O0FBRUQsWUFBSTRXLFFBQVEsS0FBSyxJQUFqQixFQUF1QjtBQUNyQixpQkFBTyxJQUFJclQsSUFBSixDQUFTMmUsR0FBVCxDQUFQO0FBQ0Q7O0FBRUQsWUFBSTdjLE9BQU8sR0FBR3dTLFlBQVksSUFBSSxFQUE5QjtBQUVBLFlBQUlDLGdCQUFnQixHQUNsQnpTLE9BQU8sQ0FBQ3lTLGdCQUFSLElBQTRCLElBQTVCLEdBQ0lqQix5QkFESixHQUVJcGdCLE1BQU0sQ0FBQ3UzQixpRUFBaUUsQ0FBQztBQUFJO0FBQUwsU0FBbEUsQ0FBTixDQUE2RjNvQixPQUFPLENBQUN5UyxnQkFBckcsQ0FITjs7QUFJQSxZQUNFQSxnQkFBZ0IsS0FBSyxDQUFyQixJQUNBQSxnQkFBZ0IsS0FBSyxDQURyQixJQUVBQSxnQkFBZ0IsS0FBSyxDQUh2QixFQUlFO0FBQ0EsZ0JBQU0sSUFBSXFXLFVBQUosQ0FBZSxvQ0FBZixDQUFOO0FBQ0QsU0F2QnFDLENBeUJ0Qzs7O0FBQ0EsWUFDRXZYLFFBQVEsWUFBWXJULElBQXBCLElBQ0MsUUFBT3FULFFBQVAsTUFBb0IsUUFBcEIsSUFDQ25nQixNQUFNLENBQUNxckIsU0FBUCxDQUFpQi9mLFFBQWpCLENBQTBCcWYsSUFBMUIsQ0FBK0J4SyxRQUEvQixNQUE2QyxlQUhqRCxFQUlFO0FBQ0E7QUFDQSxpQkFBTyxJQUFJclQsSUFBSixDQUFTcVQsUUFBUSxDQUFDK0wsT0FBVCxFQUFULENBQVA7QUFDRCxTQVBELE1BT08sSUFDTCxPQUFPL0wsUUFBUCxLQUFvQixRQUFwQixJQUNBbmdCLE1BQU0sQ0FBQ3FyQixTQUFQLENBQWlCL2YsUUFBakIsQ0FBMEJxZixJQUExQixDQUErQnhLLFFBQS9CLE1BQTZDLGlCQUZ4QyxFQUdMO0FBQ0EsaUJBQU8sSUFBSXJULElBQUosQ0FBU3FULFFBQVQsQ0FBUDtBQUNELFNBTE0sTUFLQSxJQUNMLEVBQ0UsT0FBT0EsUUFBUCxLQUFvQixRQUFwQixJQUNBbmdCLE1BQU0sQ0FBQ3FyQixTQUFQLENBQWlCL2YsUUFBakIsQ0FBMEJxZixJQUExQixDQUErQnhLLFFBQS9CLE1BQTZDLGlCQUYvQyxDQURLLEVBS0w7QUFDQSxpQkFBTyxJQUFJclQsSUFBSixDQUFTMmUsR0FBVCxDQUFQO0FBQ0Q7O0FBRUQsWUFBSW5LLFdBQVcsR0FBR0MsZUFBZSxDQUFDcEIsUUFBRCxDQUFqQztBQUVBLFlBQUlxQixlQUFlLEdBQUdDLFNBQVMsQ0FBQ0gsV0FBVyxDQUFDL1YsSUFBYixFQUFtQjhWLGdCQUFuQixDQUEvQjtBQUNBLFlBQUl4QyxJQUFJLEdBQUcyQyxlQUFlLENBQUMzQyxJQUEzQjtBQUNBLFlBQUk2QyxjQUFjLEdBQUdGLGVBQWUsQ0FBQ0UsY0FBckM7QUFFQSxZQUFJblcsSUFBSSxHQUFHb1csU0FBUyxDQUFDRCxjQUFELEVBQWlCN0MsSUFBakIsQ0FBcEI7O0FBRUEsWUFBSWhYLEtBQUssQ0FBQzBELElBQUQsQ0FBVCxFQUFpQjtBQUNmLGlCQUFPLElBQUl1QixJQUFKLENBQVMyZSxHQUFULENBQVA7QUFDRDs7QUFFRCxZQUFJbGdCLElBQUosRUFBVTtBQUNSLGNBQUkwVSxTQUFTLEdBQUcxVSxJQUFJLENBQUMyZ0IsT0FBTCxFQUFoQjtBQUNBLGNBQUl0SyxJQUFJLEdBQUcsQ0FBWDtBQUNBLGNBQUk1TixNQUFKOztBQUVBLGNBQUlzTixXQUFXLENBQUNNLElBQWhCLEVBQXNCO0FBQ3BCQSxnQkFBSSxHQUFHQyxTQUFTLENBQUNQLFdBQVcsQ0FBQ00sSUFBYixDQUFoQjs7QUFFQSxnQkFBSS9aLEtBQUssQ0FBQytaLElBQUQsQ0FBVCxFQUFpQjtBQUNmLHFCQUFPLElBQUk5VSxJQUFKLENBQVMyZSxHQUFULENBQVA7QUFDRDtBQUNGOztBQUVELGNBQUluSyxXQUFXLENBQUN0VixRQUFaLElBQXdCNEMsT0FBTyxDQUFDOFEsUUFBcEMsRUFBOEM7QUFDNUMxTCxrQkFBTSxHQUFHaFUsTUFBTSxDQUFDeTNCLGtEQUFrRCxDQUFDO0FBQUk7QUFBTCxhQUFuRCxDQUFOLENBQ1BuVyxXQUFXLENBQUN0VixRQUFaLElBQXdCNEMsT0FBTyxDQUFDOFEsUUFEekIsRUFFUCxJQUFJNVMsSUFBSixDQUFTbVQsU0FBUyxHQUFHMkIsSUFBckIsQ0FGTyxDQUFUOztBQUlBLGdCQUFJL1osS0FBSyxDQUFDbU0sTUFBRCxDQUFULEVBQW1CO0FBQ2pCLHFCQUFPLElBQUlsSCxJQUFKLENBQVMyZSxHQUFULENBQVA7QUFDRDtBQUNGLFdBUkQsTUFRTztBQUNMO0FBQ0F6WCxrQkFBTSxHQUFHaFUsTUFBTSxDQUFDdzNCLHVGQUF1RixDQUFDO0FBQUk7QUFBTCxhQUF4RixDQUFOLENBQW1ILElBQUkxcUIsSUFBSixDQUFTbVQsU0FBUyxHQUFHMkIsSUFBckIsQ0FBbkgsQ0FBVDtBQUNBNU4sa0JBQU0sR0FBR2hVLE1BQU0sQ0FBQ3czQix1RkFBdUYsQ0FBQztBQUFJO0FBQUwsYUFBeEYsQ0FBTixDQUNQLElBQUkxcUIsSUFBSixDQUFTbVQsU0FBUyxHQUFHMkIsSUFBWixHQUFtQjVOLE1BQTVCLENBRE8sQ0FBVDtBQUdEOztBQUVELGlCQUFPLElBQUlsSCxJQUFKLENBQVNtVCxTQUFTLEdBQUcyQixJQUFaLEdBQW1CNU4sTUFBNUIsQ0FBUDtBQUNELFNBOUJELE1BOEJPO0FBQ0wsaUJBQU8sSUFBSWxILElBQUosQ0FBUzJlLEdBQVQsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsZUFBU2xLLGVBQVQsQ0FBeUJRLFVBQXpCLEVBQXFDO0FBQ25DLFlBQUlULFdBQVcsR0FBRyxFQUFsQjtBQUNBLFlBQUlyVyxLQUFLLEdBQUc4VyxVQUFVLENBQUNvSCxLQUFYLENBQWlCcGQsUUFBUSxDQUFDc1UsaUJBQTFCLENBQVo7QUFDQSxZQUFJMkIsVUFBSjs7QUFFQSxZQUFJalcsUUFBUSxDQUFDdVUsU0FBVCxDQUFtQm9RLElBQW5CLENBQXdCemxCLEtBQUssQ0FBQyxDQUFELENBQTdCLENBQUosRUFBdUM7QUFDckNxVyxxQkFBVyxDQUFDL1YsSUFBWixHQUFtQixJQUFuQjtBQUNBeVcsb0JBQVUsR0FBRy9XLEtBQUssQ0FBQyxDQUFELENBQWxCO0FBQ0QsU0FIRCxNQUdPO0FBQ0xxVyxxQkFBVyxDQUFDL1YsSUFBWixHQUFtQk4sS0FBSyxDQUFDLENBQUQsQ0FBeEI7QUFDQStXLG9CQUFVLEdBQUcvVyxLQUFLLENBQUMsQ0FBRCxDQUFsQjtBQUNBcVcscUJBQVcsQ0FBQ3RWLFFBQVosR0FBdUJmLEtBQUssQ0FBQyxDQUFELENBQTVCOztBQUNBLGNBQUljLFFBQVEsQ0FBQ3dVLGlCQUFULENBQTJCbVEsSUFBM0IsQ0FBZ0NwUCxXQUFXLENBQUMvVixJQUE1QyxDQUFKLEVBQXVEO0FBQ3JEK1YsdUJBQVcsQ0FBQy9WLElBQVosR0FBbUJ3VyxVQUFVLENBQUNvSCxLQUFYLENBQWlCcGQsUUFBUSxDQUFDd1UsaUJBQTFCLEVBQTZDLENBQTdDLENBQW5CO0FBQ0F5QixzQkFBVSxHQUFHRCxVQUFVLENBQUM0USxNQUFYLENBQWtCclIsV0FBVyxDQUFDL1YsSUFBWixDQUFpQmhDLE1BQW5DLEVBQTJDd1ksVUFBVSxDQUFDeFksTUFBdEQsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsWUFBSXlZLFVBQUosRUFBZ0I7QUFDZCxjQUFJM1YsS0FBSyxHQUFHTixRQUFRLENBQUNDLFFBQVQsQ0FBa0JnZ0IsSUFBbEIsQ0FBdUJoSyxVQUF2QixDQUFaOztBQUNBLGNBQUkzVixLQUFKLEVBQVc7QUFDVGlWLHVCQUFXLENBQUNNLElBQVosR0FBbUJJLFVBQVUsQ0FBQ3dRLE9BQVgsQ0FBbUJubUIsS0FBSyxDQUFDLENBQUQsQ0FBeEIsRUFBNkIsRUFBN0IsQ0FBbkI7QUFDQWlWLHVCQUFXLENBQUN0VixRQUFaLEdBQXVCSyxLQUFLLENBQUMsQ0FBRCxDQUE1QjtBQUNELFdBSEQsTUFHTztBQUNMaVYsdUJBQVcsQ0FBQ00sSUFBWixHQUFtQkksVUFBbkI7QUFDRDtBQUNGOztBQUVELGVBQU9WLFdBQVA7QUFDRDs7QUFFRCxlQUFTRyxTQUFULENBQW1CTSxVQUFuQixFQUErQlYsZ0JBQS9CLEVBQWlEO0FBQy9DLFlBQUlZLFVBQVUsR0FBR2xXLFFBQVEsQ0FBQzBVLEdBQVQsQ0FBYVksZ0JBQWIsQ0FBakI7QUFDQSxZQUFJYSxZQUFZLEdBQUduVyxRQUFRLENBQUM0VSxLQUFULENBQWVVLGdCQUFmLENBQW5CO0FBRUEsWUFBSWhWLEtBQUosQ0FKK0MsQ0FNL0M7O0FBQ0FBLGFBQUssR0FBR04sUUFBUSxDQUFDMlUsSUFBVCxDQUFjc0wsSUFBZCxDQUFtQmpLLFVBQW5CLEtBQWtDRyxZQUFZLENBQUM4SixJQUFiLENBQWtCakssVUFBbEIsQ0FBMUM7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNULGNBQUk4VixVQUFVLEdBQUc5VixLQUFLLENBQUMsQ0FBRCxDQUF0QjtBQUNBLGlCQUFPO0FBQ0x3UyxnQkFBSSxFQUFFdFMsUUFBUSxDQUFDNFYsVUFBRCxFQUFhLEVBQWIsQ0FEVDtBQUVMVCwwQkFBYyxFQUFFSyxVQUFVLENBQUM0VixLQUFYLENBQWlCeFYsVUFBVSxDQUFDNVksTUFBNUI7QUFGWCxXQUFQO0FBSUQsU0FkOEMsQ0FnQi9DOzs7QUFDQThDLGFBQUssR0FBR04sUUFBUSxDQUFDeVUsRUFBVCxDQUFZd0wsSUFBWixDQUFpQmpLLFVBQWpCLEtBQWdDRSxVQUFVLENBQUMrSixJQUFYLENBQWdCakssVUFBaEIsQ0FBeEM7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNULGNBQUkrVixhQUFhLEdBQUcvVixLQUFLLENBQUMsQ0FBRCxDQUF6QjtBQUNBLGlCQUFPO0FBQ0x3UyxnQkFBSSxFQUFFdFMsUUFBUSxDQUFDNlYsYUFBRCxFQUFnQixFQUFoQixDQUFSLEdBQThCLEdBRC9CO0FBRUxWLDBCQUFjLEVBQUVLLFVBQVUsQ0FBQzRWLEtBQVgsQ0FBaUJ2VixhQUFhLENBQUM3WSxNQUEvQjtBQUZYLFdBQVA7QUFJRCxTQXhCOEMsQ0EwQi9DOzs7QUFDQSxlQUFPO0FBQ0xzVixjQUFJLEVBQUU7QUFERCxTQUFQO0FBR0Q7O0FBRUQsZUFBUzhDLFNBQVQsQ0FBbUJJLFVBQW5CLEVBQStCbEQsSUFBL0IsRUFBcUM7QUFDbkM7QUFDQSxZQUFJQSxJQUFJLEtBQUssSUFBYixFQUFtQjtBQUNqQixpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSXhTLEtBQUo7QUFDQSxZQUFJZCxJQUFKO0FBQ0EsWUFBSXVULEtBQUo7QUFDQSxZQUFJMEQsSUFBSixDQVRtQyxDQVduQzs7QUFDQSxZQUFJVCxVQUFVLENBQUN4WSxNQUFYLEtBQXNCLENBQTFCLEVBQTZCO0FBQzNCZ0MsY0FBSSxHQUFHLElBQUl1QixJQUFKLENBQVMsQ0FBVCxDQUFQO0FBQ0F2QixjQUFJLENBQUNxc0IsY0FBTCxDQUFvQi9ZLElBQXBCO0FBQ0EsaUJBQU90VCxJQUFQO0FBQ0QsU0FoQmtDLENBa0JuQzs7O0FBQ0FjLGFBQUssR0FBR04sUUFBUSxDQUFDNlUsRUFBVCxDQUFZb0wsSUFBWixDQUFpQmpLLFVBQWpCLENBQVI7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNUZCxjQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBUyxDQUFULENBQVA7QUFDQWdTLGVBQUssR0FBR3ZTLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXLEVBQVgsQ0FBUixHQUF5QixDQUFqQzs7QUFFQSxjQUFJLENBQUNnVyxZQUFZLENBQUN4RCxJQUFELEVBQU9DLEtBQVAsQ0FBakIsRUFBZ0M7QUFDOUIsbUJBQU8sSUFBSWhTLElBQUosQ0FBUzJlLEdBQVQsQ0FBUDtBQUNEOztBQUVEbGdCLGNBQUksQ0FBQ3FzQixjQUFMLENBQW9CL1ksSUFBcEIsRUFBMEJDLEtBQTFCO0FBQ0EsaUJBQU92VCxJQUFQO0FBQ0QsU0E5QmtDLENBZ0NuQzs7O0FBQ0FjLGFBQUssR0FBR04sUUFBUSxDQUFDOFUsR0FBVCxDQUFhbUwsSUFBYixDQUFrQmpLLFVBQWxCLENBQVI7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNUZCxjQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBUyxDQUFULENBQVA7QUFDQSxjQUFJd1YsU0FBUyxHQUFHL1YsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUF4Qjs7QUFFQSxjQUFJLENBQUNrVyxxQkFBcUIsQ0FBQzFELElBQUQsRUFBT3lELFNBQVAsQ0FBMUIsRUFBNkM7QUFDM0MsbUJBQU8sSUFBSXhWLElBQUosQ0FBUzJlLEdBQVQsQ0FBUDtBQUNEOztBQUVEbGdCLGNBQUksQ0FBQ3FzQixjQUFMLENBQW9CL1ksSUFBcEIsRUFBMEIsQ0FBMUIsRUFBNkJ5RCxTQUE3QjtBQUNBLGlCQUFPL1csSUFBUDtBQUNELFNBNUNrQyxDQThDbkM7OztBQUNBYyxhQUFLLEdBQUdOLFFBQVEsQ0FBQytVLElBQVQsQ0FBY2tMLElBQWQsQ0FBbUJqSyxVQUFuQixDQUFSOztBQUNBLFlBQUkxVixLQUFKLEVBQVc7QUFDVGQsY0FBSSxHQUFHLElBQUl1QixJQUFKLENBQVMsQ0FBVCxDQUFQO0FBQ0FnUyxlQUFLLEdBQUd2UyxRQUFRLENBQUNGLEtBQUssQ0FBQyxDQUFELENBQU4sRUFBVyxFQUFYLENBQVIsR0FBeUIsQ0FBakM7QUFDQSxjQUFJMFMsR0FBRyxHQUFHeFMsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUFsQjs7QUFFQSxjQUFJLENBQUNnVyxZQUFZLENBQUN4RCxJQUFELEVBQU9DLEtBQVAsRUFBY0MsR0FBZCxDQUFqQixFQUFxQztBQUNuQyxtQkFBTyxJQUFJalMsSUFBSixDQUFTMmUsR0FBVCxDQUFQO0FBQ0Q7O0FBRURsZ0IsY0FBSSxDQUFDcXNCLGNBQUwsQ0FBb0IvWSxJQUFwQixFQUEwQkMsS0FBMUIsRUFBaUNDLEdBQWpDO0FBQ0EsaUJBQU94VCxJQUFQO0FBQ0QsU0EzRGtDLENBNkRuQzs7O0FBQ0FjLGFBQUssR0FBR04sUUFBUSxDQUFDZ1YsR0FBVCxDQUFhaUwsSUFBYixDQUFrQmpLLFVBQWxCLENBQVI7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNUbVcsY0FBSSxHQUFHalcsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUFSLEdBQXlCLENBQWhDOztBQUVBLGNBQUksQ0FBQ29XLGdCQUFnQixDQUFDNUQsSUFBRCxFQUFPMkQsSUFBUCxDQUFyQixFQUFtQztBQUNqQyxtQkFBTyxJQUFJMVYsSUFBSixDQUFTMmUsR0FBVCxDQUFQO0FBQ0Q7O0FBRUQsaUJBQU8vSSxnQkFBZ0IsQ0FBQzdELElBQUQsRUFBTzJELElBQVAsQ0FBdkI7QUFDRCxTQXZFa0MsQ0F5RW5DOzs7QUFDQW5XLGFBQUssR0FBR04sUUFBUSxDQUFDaVYsSUFBVCxDQUFjZ0wsSUFBZCxDQUFtQmpLLFVBQW5CLENBQVI7O0FBQ0EsWUFBSTFWLEtBQUosRUFBVztBQUNUbVcsY0FBSSxHQUFHalcsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUFSLEdBQXlCLENBQWhDO0FBQ0EsY0FBSXNXLFNBQVMsR0FBR3BXLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXLEVBQVgsQ0FBUixHQUF5QixDQUF6Qzs7QUFFQSxjQUFJLENBQUNvVyxnQkFBZ0IsQ0FBQzVELElBQUQsRUFBTzJELElBQVAsRUFBYUcsU0FBYixDQUFyQixFQUE4QztBQUM1QyxtQkFBTyxJQUFJN1YsSUFBSixDQUFTMmUsR0FBVCxDQUFQO0FBQ0Q7O0FBRUQsaUJBQU8vSSxnQkFBZ0IsQ0FBQzdELElBQUQsRUFBTzJELElBQVAsRUFBYUcsU0FBYixDQUF2QjtBQUNELFNBcEZrQyxDQXNGbkM7OztBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELGVBQVNkLFNBQVQsQ0FBbUJHLFVBQW5CLEVBQStCO0FBQzdCLFlBQUkzVixLQUFKO0FBQ0EsWUFBSUMsS0FBSjtBQUNBLFlBQUlJLE9BQUosQ0FINkIsQ0FLN0I7O0FBQ0FMLGFBQUssR0FBR04sUUFBUSxDQUFDa1YsRUFBVCxDQUFZK0ssSUFBWixDQUFpQmhLLFVBQWpCLENBQVI7O0FBQ0EsWUFBSTNWLEtBQUosRUFBVztBQUNUQyxlQUFLLEdBQUdzVyxVQUFVLENBQUN2VyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNtbUIsT0FBVCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFELENBQWxCOztBQUVBLGNBQUksQ0FBQzNQLFlBQVksQ0FBQ3ZXLEtBQUQsQ0FBakIsRUFBMEI7QUFDeEIsbUJBQU9tZixHQUFQO0FBQ0Q7O0FBRUQsaUJBQVFuZixLQUFLLEdBQUcsRUFBVCxHQUFlVCxvQkFBdEI7QUFDRCxTQWY0QixDQWlCN0I7OztBQUNBUSxhQUFLLEdBQUdOLFFBQVEsQ0FBQ21WLElBQVQsQ0FBYzhLLElBQWQsQ0FBbUJoSyxVQUFuQixDQUFSOztBQUNBLFlBQUkzVixLQUFKLEVBQVc7QUFDVEMsZUFBSyxHQUFHQyxRQUFRLENBQUNGLEtBQUssQ0FBQyxDQUFELENBQU4sRUFBVyxFQUFYLENBQWhCO0FBQ0FLLGlCQUFPLEdBQUdrVyxVQUFVLENBQUN2VyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNtbUIsT0FBVCxDQUFpQixHQUFqQixFQUFzQixHQUF0QixDQUFELENBQXBCOztBQUVBLGNBQUksQ0FBQzNQLFlBQVksQ0FBQ3ZXLEtBQUQsRUFBUUksT0FBUixDQUFqQixFQUFtQztBQUNqQyxtQkFBTytlLEdBQVA7QUFDRDs7QUFFRCxpQkFDR25mLEtBQUssR0FBRyxFQUFULEdBQWVULG9CQUFmLEdBQXNDYSxPQUFPLEdBQUdaLHNCQURsRDtBQUdELFNBOUI0QixDQWdDN0I7OztBQUNBTyxhQUFLLEdBQUdOLFFBQVEsQ0FBQ29WLE1BQVQsQ0FBZ0I2SyxJQUFoQixDQUFxQmhLLFVBQXJCLENBQVI7O0FBQ0EsWUFBSTNWLEtBQUosRUFBVztBQUNUQyxlQUFLLEdBQUdDLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDLENBQUQsQ0FBTixFQUFXLEVBQVgsQ0FBaEI7QUFDQUssaUJBQU8sR0FBR0gsUUFBUSxDQUFDRixLQUFLLENBQUMsQ0FBRCxDQUFOLEVBQVcsRUFBWCxDQUFsQjtBQUNBLGNBQUl5VyxPQUFPLEdBQUdGLFVBQVUsQ0FBQ3ZXLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU21tQixPQUFULENBQWlCLEdBQWpCLEVBQXNCLEdBQXRCLENBQUQsQ0FBeEI7O0FBRUEsY0FBSSxDQUFDM1AsWUFBWSxDQUFDdlcsS0FBRCxFQUFRSSxPQUFSLEVBQWlCb1csT0FBakIsQ0FBakIsRUFBNEM7QUFDMUMsbUJBQU8ySSxHQUFQO0FBQ0Q7O0FBRUQsaUJBQ0duZixLQUFLLEdBQUcsRUFBVCxHQUFlVCxvQkFBZixHQUNBYSxPQUFPLEdBQUdaLHNCQURWLEdBRUFnWCxPQUFPLEdBQUcsSUFIWjtBQUtELFNBaEQ0QixDQWtEN0I7OztBQUNBLGVBQU8sSUFBUDtBQUNEOztBQUVELGVBQVNKLGdCQUFULENBQTBCbVYsV0FBMUIsRUFBdUNyVixJQUF2QyxFQUE2Q3pELEdBQTdDLEVBQWtEO0FBQ2hEeUQsWUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBZjtBQUNBekQsV0FBRyxHQUFHQSxHQUFHLElBQUksQ0FBYjtBQUNBLFlBQUl4VCxJQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBUyxDQUFULENBQVg7QUFDQXZCLFlBQUksQ0FBQ3FzQixjQUFMLENBQW9CQyxXQUFwQixFQUFpQyxDQUFqQyxFQUFvQyxDQUFwQztBQUNBLFlBQUk5VSxrQkFBa0IsR0FBR3hYLElBQUksQ0FBQzRsQixTQUFMLE1BQW9CLENBQTdDO0FBQ0EsWUFBSW5PLElBQUksR0FBR1IsSUFBSSxHQUFHLENBQVAsR0FBV3pELEdBQVgsR0FBaUIsQ0FBakIsR0FBcUJnRSxrQkFBaEM7QUFDQXhYLFlBQUksQ0FBQzZsQixVQUFMLENBQWdCN2xCLElBQUksQ0FBQzhsQixVQUFMLEtBQW9Cck8sSUFBcEM7QUFDQSxlQUFPelgsSUFBUDtBQUNELE9BaFppRSxDQWtabEU7OztBQUVBLFVBQUkwWCxhQUFhLEdBQUcsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLENBQXBCO0FBQ0EsVUFBSUMsdUJBQXVCLEdBQUcsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLENBQTlCOztBQUVBLGVBQVNFLGVBQVQsQ0FBeUJ2RSxJQUF6QixFQUErQjtBQUM3QixlQUFPQSxJQUFJLEdBQUcsR0FBUCxLQUFlLENBQWYsSUFBcUJBLElBQUksR0FBRyxDQUFQLEtBQWEsQ0FBYixJQUFrQkEsSUFBSSxHQUFHLEdBQVAsS0FBZSxDQUE3RDtBQUNEOztBQUVELGVBQVN3RCxZQUFULENBQXNCeEQsSUFBdEIsRUFBNEJDLEtBQTVCLEVBQW1DdlQsSUFBbkMsRUFBeUM7QUFDdkMsWUFBSXVULEtBQUssR0FBRyxDQUFSLElBQWFBLEtBQUssR0FBRyxFQUF6QixFQUE2QjtBQUMzQixpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsWUFBSXZULElBQUksSUFBSSxJQUFaLEVBQWtCO0FBQ2hCLGNBQUlBLElBQUksR0FBRyxDQUFYLEVBQWM7QUFDWixtQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsY0FBSTRYLFVBQVUsR0FBR0MsZUFBZSxDQUFDdkUsSUFBRCxDQUFoQzs7QUFDQSxjQUFJc0UsVUFBVSxJQUFJNVgsSUFBSSxHQUFHMlgsdUJBQXVCLENBQUNwRSxLQUFELENBQWhELEVBQXlEO0FBQ3ZELG1CQUFPLEtBQVA7QUFDRDs7QUFDRCxjQUFJLENBQUNxRSxVQUFELElBQWU1WCxJQUFJLEdBQUcwWCxhQUFhLENBQUNuRSxLQUFELENBQXZDLEVBQWdEO0FBQzlDLG1CQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELGVBQU8sSUFBUDtBQUNEOztBQUVELGVBQVN5RCxxQkFBVCxDQUErQjFELElBQS9CLEVBQXFDeUQsU0FBckMsRUFBZ0Q7QUFDOUMsWUFBSUEsU0FBUyxHQUFHLENBQWhCLEVBQW1CO0FBQ2pCLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxZQUFJYSxVQUFVLEdBQUdDLGVBQWUsQ0FBQ3ZFLElBQUQsQ0FBaEM7O0FBQ0EsWUFBSXNFLFVBQVUsSUFBSWIsU0FBUyxHQUFHLEdBQTlCLEVBQW1DO0FBQ2pDLGlCQUFPLEtBQVA7QUFDRDs7QUFDRCxZQUFJLENBQUNhLFVBQUQsSUFBZWIsU0FBUyxHQUFHLEdBQS9CLEVBQW9DO0FBQ2xDLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxlQUFPLElBQVA7QUFDRDs7QUFFRCxlQUFTRyxnQkFBVCxDQUEwQjVELElBQTFCLEVBQWdDMkQsSUFBaEMsRUFBc0N6RCxHQUF0QyxFQUEyQztBQUN6QyxZQUFJeUQsSUFBSSxHQUFHLENBQVAsSUFBWUEsSUFBSSxHQUFHLEVBQXZCLEVBQTJCO0FBQ3pCLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxZQUFJekQsR0FBRyxJQUFJLElBQVAsS0FBZ0JBLEdBQUcsR0FBRyxDQUFOLElBQVdBLEdBQUcsR0FBRyxDQUFqQyxDQUFKLEVBQXlDO0FBQ3ZDLGlCQUFPLEtBQVA7QUFDRDs7QUFFRCxlQUFPLElBQVA7QUFDRDs7QUFFRCxlQUFTOEQsWUFBVCxDQUFzQnZXLEtBQXRCLEVBQTZCSSxPQUE3QixFQUFzQ29XLE9BQXRDLEVBQStDO0FBQzdDLFlBQUl4VyxLQUFLLElBQUksSUFBVCxLQUFrQkEsS0FBSyxHQUFHLENBQVIsSUFBYUEsS0FBSyxJQUFJLEVBQXhDLENBQUosRUFBaUQ7QUFDL0MsaUJBQU8sS0FBUDtBQUNEOztBQUVELFlBQUlJLE9BQU8sSUFBSSxJQUFYLEtBQW9CQSxPQUFPLEdBQUcsQ0FBVixJQUFlQSxPQUFPLElBQUksRUFBOUMsQ0FBSixFQUF1RDtBQUNyRCxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsWUFBSW9XLE9BQU8sSUFBSSxJQUFYLEtBQW9CQSxPQUFPLEdBQUcsQ0FBVixJQUFlQSxPQUFPLElBQUksRUFBOUMsQ0FBSixFQUF1RDtBQUNyRCxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsZUFBTyxJQUFQO0FBQ0Q7QUFHRDs7QUFBTyxLQWhwREc7QUFpcERWOztBQUNBO0FBQU8sY0FBUzNlLE1BQVQsRUFBaUJxbkIsbUJBQWpCLEVBQXNDZixtQkFBdEMsRUFBMkQ7QUFFbEU7QUFDQTs7QUFBaUNlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBMkIxSiwrQkFBM0I7QUFDakMsVUFBSWhXLHNCQUFzQixHQUFHLEtBQTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFTZ1csK0JBQVQsQ0FBeUN1QixTQUF6QyxFQUFvRDtBQUNsRCxZQUFJOVgsSUFBSSxHQUFHLElBQUl1QixJQUFKLENBQVN1VyxTQUFTLENBQUM2SSxPQUFWLEVBQVQsQ0FBWDtBQUNBLFlBQUk1SSxrQkFBa0IsR0FBR3hiLElBQUksQ0FBQzRqQixJQUFMLENBQVVuZ0IsSUFBSSxDQUFDaWxCLGlCQUFMLEVBQVYsQ0FBekI7QUFDQWpsQixZQUFJLENBQUN1c0IsVUFBTCxDQUFnQixDQUFoQixFQUFtQixDQUFuQjtBQUNBLFlBQUl0VSxnQ0FBZ0MsR0FBR2pZLElBQUksQ0FBQzJnQixPQUFMLEtBQWlCcGdCLHNCQUF4RDtBQUNBLGVBQU93WCxrQkFBa0IsR0FBR3hYLHNCQUFyQixHQUE4QzBYLGdDQUFyRDtBQUNEO0FBRUQ7O0FBQU8sS0EzcURHO0FBNHFEVjs7QUFDQTtBQUFPLGNBQVNyZixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQ0E7O0FBQStCQSx5QkFBbUIsQ0FBQ0ksQ0FBcEIsQ0FBc0JXLG1CQUF0QixFQUEyQyxHQUEzQyxFQUFnRCxZQUFXO0FBQUUsZUFBT3VNLHNCQUFQO0FBQWdDLE9BQTdGO0FBQy9COzs7QUFBcUIsVUFBSUMscUNBQXFDLEdBQUd2TixtQkFBbUIsQ0FBQyxFQUFELENBQS9EO0FBQ3JCOzs7QUFBcUIsVUFBSXdOLCtDQUErQyxHQUFHeE4sbUJBQW1CLENBQUMsRUFBRCxDQUF6RTtBQUNyQjs7O0FBQXFCLFVBQUl5Tiw4Q0FBOEMsR0FBR3pOLG1CQUFtQixDQUFDLEVBQUQsQ0FBeEU7O0FBS3JCLGVBQVMwTixzQkFBVCxDQUFnQ0MsVUFBaEMsRUFBNEM7QUFDeEMsZUFBT3A0QixNQUFNLENBQUNnNEIscUNBQXFDLENBQUM7QUFBSTtBQUFMLFNBQXRDLENBQU4sQ0FBOEVJLFVBQTlFLEVBQTBGRiw4Q0FBOEMsQ0FBQztBQUFJO0FBQUwsU0FBeEksQ0FBUDtBQUNIOztBQUVELGVBQVNILHNCQUFULENBQWdDaGEsTUFBaEMsRUFBd0M7QUFDcEMsZUFBTy9kLE1BQU0sQ0FBQ2c0QixxQ0FBcUMsQ0FBQztBQUFJO0FBQUwsU0FBdEMsQ0FBTixDQUE4RWphLE1BQTlFLEVBQXNGa2EsK0NBQStDLENBQUM7QUFBSTtBQUFMLFNBQXJJLEVBQTBKQyw4Q0FBOEMsQ0FBQztBQUFJO0FBQUwsU0FBeE0sQ0FBUDtBQUNIO0FBTUQ7O0FBQU8sS0Fyc0RHO0FBc3NEVjs7QUFDQTtBQUFPLGNBQVMvekIsTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUErQkEseUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU82TSxvQkFBUDtBQUE4QixPQUEzRjtBQUMvQjs7O0FBQStCNU4seUJBQW1CLENBQUNJLENBQXBCLENBQXNCVyxtQkFBdEIsRUFBMkMsR0FBM0MsRUFBZ0QsWUFBVztBQUFFLGVBQU9tQixvQkFBUDtBQUE4QixPQUEzRjs7QUFDL0IsZUFBUzBMLG9CQUFULENBQThCRCxVQUE5QixFQUEwQ0UsWUFBMUMsRUFBd0Q7QUFDcEQsWUFBSUMsSUFBSSxHQUFHRCxZQUFZLENBQUMsT0FBT0YsVUFBUCxLQUFzQixRQUF0QixHQUFpQ0EsVUFBVSxDQUFDSSxXQUFYLEVBQWpDLEdBQTRESixVQUE3RCxDQUF2QjtBQUNBLGVBQU8sT0FBT0csSUFBUCxLQUFnQixRQUFoQixHQUEyQkEsSUFBM0IsR0FBa0MsQ0FBekM7QUFDSDs7QUFFRCxlQUFTNUwsb0JBQVQsQ0FBOEI1TyxNQUE5QixFQUFzQzBhLGFBQXRDLEVBQXFESCxZQUFyRCxFQUFtRTtBQUMvRCxZQUFJdmEsTUFBSixFQUFZO0FBQ1IsY0FBSXpZLElBQUksR0FBR3lZLE1BQU0sQ0FBQzJhLFdBQVAsR0FBcUJ2UCxLQUFyQixDQUEyQixNQUEzQixDQUFYO0FBQ0EsY0FBSXdQLFFBQVEsR0FBR3J6QixJQUFJLENBQUMsQ0FBRCxDQUFuQjtBQUNBLGNBQUlzekIsT0FBSjs7QUFDQSxjQUFJdHpCLElBQUksQ0FBQyxDQUFELENBQUosSUFBV0EsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRaUUsTUFBUixLQUFtQixDQUFsQyxFQUFxQztBQUNqQ292QixvQkFBUSxJQUFJLE1BQU9yekIsSUFBSSxDQUFDLENBQUQsQ0FBdkI7QUFDQXN6QixtQkFBTyxHQUFHdHpCLElBQUksQ0FBQyxDQUFELENBQWQ7QUFDSCxXQUhELE1BR087QUFDSHN6QixtQkFBTyxHQUFHdHpCLElBQUksQ0FBQyxDQUFELENBQWQ7QUFDSDs7QUFDRCxjQUFJLENBQUNzekIsT0FBTCxFQUFjO0FBQ1ZBLG1CQUFPLEdBQUdILGFBQWEsQ0FBQ0UsUUFBRCxDQUF2QjtBQUNIOztBQUNELGNBQUlDLE9BQUosRUFBYTtBQUNULG1CQUFPUCxvQkFBb0IsQ0FBQ08sT0FBTyxDQUFDM2tCLEtBQVIsQ0FBYyxPQUFkLElBQXlCck0sTUFBTSxDQUFDZ3hCLE9BQUQsQ0FBL0IsR0FBMkNBLE9BQTVDLEVBQXFETixZQUFyRCxDQUEzQjtBQUNIO0FBQ0o7O0FBQ0QsZUFBTyxDQUFQO0FBQ0g7QUFNRDs7QUFBTyxLQTF1REc7QUEydURWOztBQUNBO0FBQU8sY0FBU24wQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFOztBQUNBLFVBQUlnTyxhQUFhLEdBQUc7QUFDaEJJLFVBQUUsRUFBRSxJQURZO0FBRWhCQyxVQUFFLEVBQUUsSUFGWTtBQUdoQkMsZUFBTyxFQUFFLElBSE87QUFJaEJDLFlBQUksRUFBRSxJQUpVO0FBS2hCQyxXQUFHLEVBQUUsSUFMVztBQU1oQkMsV0FBRyxFQUFFLElBTlc7QUFPaEJDLFdBQUcsRUFBRSxJQVBXO0FBUWhCQyxXQUFHLEVBQUUsSUFSVztBQVNoQkMsV0FBRyxFQUFFLElBVFc7QUFVaEJDLFVBQUUsRUFBRSxJQVZZO0FBV2hCQyxVQUFFLEVBQUUsSUFYWTtBQVloQkMsVUFBRSxFQUFFLElBWlk7QUFhaEJDLFVBQUUsRUFBRSxJQWJZO0FBY2hCQyxVQUFFLEVBQUUsSUFkWTtBQWVoQkMsVUFBRSxFQUFFLElBZlk7QUFnQmhCQyxVQUFFLEVBQUUsSUFoQlk7QUFpQmhCaEYsVUFBRSxFQUFFLElBakJZO0FBa0JoQmlGLGVBQU8sRUFBRSxJQWxCTztBQW1CaEJDLFdBQUcsRUFBRSxJQW5CVztBQW9CaEJDLFdBQUcsRUFBRSxJQXBCVztBQXFCaEJDLFVBQUUsRUFBRSxJQXJCWTtBQXNCaEJDLFdBQUcsRUFBRSxJQXRCVztBQXVCaEJDLFdBQUcsRUFBRSxJQXZCVztBQXdCaEJDLFdBQUcsRUFBRSxJQXhCVztBQXlCaEJDLFdBQUcsRUFBRSxJQXpCVztBQTBCaEJDLFdBQUcsRUFBRSxJQTFCVztBQTJCaEJDLFdBQUcsRUFBRSxJQTNCVztBQTRCaEJDLFVBQUUsRUFBRSxJQTVCWTtBQTZCaEJDLFVBQUUsRUFBRSxJQTdCWTtBQThCaEJDLFVBQUUsRUFBRSxJQTlCWTtBQStCaEJDLFVBQUUsRUFBRSxJQS9CWTtBQWdDaEJDLFdBQUcsRUFBRSxJQWhDVztBQWlDaEJqMkIsVUFBRSxFQUFFLElBakNZO0FBa0NoQmsyQixVQUFFLEVBQUUsSUFsQ1k7QUFtQ2hCQyxVQUFFLEVBQUUsSUFuQ1k7QUFvQ2hCQyxXQUFHLEVBQUUsSUFwQ1c7QUFxQ2hCQyxlQUFPLEVBQUUsSUFyQ087QUFzQ2hCQyxVQUFFLEVBQUUsSUF0Q1k7QUF1Q2hCQyxVQUFFLEVBQUUsSUF2Q1k7QUF3Q2hCQyxXQUFHLEVBQUUsSUF4Q1c7QUF5Q2hCQyxVQUFFLEVBQUUsSUF6Q1k7QUEwQ2hCQyxVQUFFLEVBQUUsSUExQ1k7QUEyQ2hCQyxVQUFFLEVBQUUsSUEzQ1k7QUE0Q2hCQyxVQUFFLEVBQUUsSUE1Q1k7QUE2Q2hCQyxVQUFFLEVBQUUsSUE3Q1k7QUE4Q2hCQyxVQUFFLEVBQUUsSUE5Q1k7QUErQ2hCQyxVQUFFLEVBQUUsSUEvQ1k7QUFnRGhCQyxVQUFFLEVBQUUsSUFoRFk7QUFpRGhCQyxXQUFHLEVBQUUsSUFqRFc7QUFrRGhCQyxXQUFHLEVBQUUsSUFsRFc7QUFtRGhCQyxXQUFHLEVBQUUsSUFuRFc7QUFvRGhCQyxVQUFFLEVBQUUsSUFwRFk7QUFxRGhCQyxVQUFFLEVBQUUsSUFyRFk7QUFzRGhCQyxlQUFPLEVBQUUsSUF0RE87QUF1RGhCQyxZQUFJLEVBQUUsSUF2RFU7QUF3RGhCQyxXQUFHLEVBQUUsSUF4RFc7QUF5RGhCQyxVQUFFLEVBQUUsSUF6RFk7QUEwRGhCaEgsVUFBRSxFQUFFLElBMURZO0FBMkRoQmlILGVBQU8sRUFBRSxJQTNETztBQTREaEJDLFdBQUcsRUFBRSxJQTVEVztBQTZEaEJDLFVBQUUsRUFBRSxJQTdEWTtBQThEaEJDLFVBQUUsRUFBRSxJQTlEWTtBQStEaEJDLFdBQUcsRUFBRSxJQS9EVztBQWdFaEJDLFdBQUcsRUFBRSxJQWhFVztBQWlFaEJDLGVBQU8sRUFBRSxJQWpFTztBQWtFaEJDLFlBQUksRUFBRSxJQWxFVTtBQW1FaEJDLFVBQUUsRUFBRSxJQW5FWTtBQW9FaEJDLFVBQUUsRUFBRSxJQXBFWTtBQXFFaEJDLFVBQUUsRUFBRSxJQXJFWTtBQXNFaEJDLFdBQUcsRUFBRSxJQXRFVztBQXVFaEJDLFVBQUUsRUFBRSxJQXZFWTtBQXdFaEJDLFdBQUcsRUFBRSxJQXhFVztBQXlFaEJDLFVBQUUsRUFBRSxJQXpFWTtBQTBFaEJDLGVBQU8sRUFBRSxJQTFFTztBQTJFaEJDLFdBQUcsRUFBRSxJQTNFVztBQTRFaEJDLFVBQUUsRUFBRSxJQTVFWTtBQTZFaEJDLFdBQUcsRUFBRSxJQTdFVztBQThFaEJDLFVBQUUsRUFBRTtBQTlFWSxPQUFwQjtBQWlGQTs7QUFBNkIvUix5QkFBbUIsQ0FBQyxHQUFELENBQW5CLEdBQTRCaU4sYUFBNUI7QUFJN0I7QUFBTyxLQXAwREc7QUFxMERWOztBQUNBO0FBQU8sY0FBU3QwQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFOztBQUNBLFVBQUk2TixZQUFZLEdBQUc7QUFDZmtGLFVBQUUsRUFBRSxDQURXO0FBRWZDLFdBQUcsRUFBRSxDQUZVO0FBR2YsWUFBSSxDQUhXO0FBSWZDLFVBQUUsRUFBRSxDQUpXO0FBS2ZDLFdBQUcsRUFBRSxDQUxVO0FBTWYsWUFBSSxDQU5XO0FBT2ZDLFVBQUUsRUFBRSxDQVBXO0FBUWZDLFdBQUcsRUFBRSxDQVJVO0FBU2YsWUFBSSxDQVRXO0FBVWZDLFVBQUUsRUFBRSxDQVZXO0FBV2ZDLFdBQUcsRUFBRSxDQVhVO0FBWWYsWUFBSSxDQVpXO0FBYWZDLFVBQUUsRUFBRSxDQWJXO0FBY2ZDLFdBQUcsRUFBRSxDQWRVO0FBZWYsWUFBSSxDQWZXO0FBZ0JmQyxVQUFFLEVBQUUsQ0FoQlc7QUFpQmZDLFdBQUcsRUFBRSxDQWpCVTtBQWtCZixZQUFJLENBbEJXO0FBbUJmQyxVQUFFLEVBQUUsQ0FuQlc7QUFvQmZDLFdBQUcsRUFBRSxDQXBCVTtBQXFCZixZQUFJLENBckJXO0FBc0JmQyxVQUFFLEVBQUUsQ0F0Qlc7QUF1QmZDLFdBQUcsRUFBRSxDQXZCVTtBQXdCZixZQUFJLENBeEJXO0FBeUJmQyxVQUFFLEVBQUUsQ0F6Qlc7QUEwQmZDLFdBQUcsRUFBRSxDQTFCVTtBQTJCZixZQUFJLENBM0JXO0FBNEJmQyxVQUFFLEVBQUUsQ0E1Qlc7QUE2QmZDLFdBQUcsRUFBRSxDQTdCVTtBQThCZixhQUFLLENBOUJVO0FBK0JmQyxVQUFFLEVBQUUsQ0EvQlc7QUFnQ2ZDLFdBQUcsRUFBRSxDQWhDVTtBQWlDZixhQUFLLENBakNVO0FBa0NmQyxVQUFFLEVBQUUsQ0FsQ1c7QUFtQ2ZDLFdBQUcsRUFBRSxDQW5DVTtBQW9DZixhQUFLLENBcENVO0FBcUNmQyxVQUFFLEVBQUUsQ0FyQ1c7QUFzQ2ZDLFdBQUcsRUFBRSxDQXRDVTtBQXVDZixhQUFLLENBdkNVO0FBd0NmQyxVQUFFLEVBQUUsQ0F4Q1c7QUF5Q2ZDLFdBQUcsRUFBRSxDQXpDVTtBQTBDZixhQUFLLENBMUNVO0FBMkNmQyxVQUFFLEVBQUUsQ0EzQ1c7QUE0Q2ZDLFdBQUcsRUFBRSxDQTVDVTtBQTZDZixhQUFLLENBN0NVO0FBOENmQyxVQUFFLEVBQUUsQ0E5Q1c7QUErQ2ZDLFdBQUcsRUFBRSxDQS9DVTtBQWdEZixhQUFLLENBaERVO0FBaURmQyxVQUFFLEVBQUUsQ0FqRFc7QUFrRGZDLFdBQUcsRUFBRSxDQWxEVTtBQW1EZixhQUFLLENBbkRVO0FBb0RmQyxVQUFFLEVBQUUsQ0FwRFc7QUFxRGZDLFdBQUcsRUFBRSxDQXJEVTtBQXNEZixhQUFLLENBdERVO0FBdURmQyxVQUFFLEVBQUUsQ0F2RFc7QUF3RGZDLFdBQUcsRUFBRSxDQXhEVTtBQXlEZixhQUFLLENBekRVO0FBMERmQyxVQUFFLEVBQUUsQ0ExRFc7QUEyRGZDLFdBQUcsRUFBRSxDQTNEVTtBQTREZixhQUFLLENBNURVO0FBNkRmQyxVQUFFLEVBQUUsQ0E3RFc7QUE4RGZDLFdBQUcsRUFBRSxDQTlEVTtBQStEZixhQUFLLENBL0RVO0FBZ0VmQyxVQUFFLEVBQUUsQ0FoRVc7QUFpRWZDLFdBQUcsRUFBRSxDQWpFVTtBQWtFZixhQUFLLENBbEVVO0FBbUVmQyxVQUFFLEVBQUUsQ0FuRVc7QUFvRWZDLFdBQUcsRUFBRSxDQXBFVTtBQXFFZixhQUFLLENBckVVO0FBc0VmQyxVQUFFLEVBQUUsQ0F0RVc7QUF1RWZDLFdBQUcsRUFBRSxDQXZFVTtBQXdFZixhQUFLLENBeEVVO0FBeUVmQyxVQUFFLEVBQUUsQ0F6RVc7QUEwRWZDLFdBQUcsRUFBRSxDQTFFVTtBQTJFZixhQUFLLENBM0VVO0FBNEVmQyxVQUFFLEVBQUUsQ0E1RVc7QUE2RWZDLFdBQUcsRUFBRSxDQTdFVTtBQThFZixhQUFLLENBOUVVO0FBK0VmQyxVQUFFLEVBQUUsQ0EvRVc7QUFnRmZDLFdBQUcsRUFBRSxDQWhGVTtBQWlGZixhQUFLLENBakZVO0FBa0ZmQyxVQUFFLEVBQUUsQ0FsRlc7QUFtRmZDLFdBQUcsRUFBRSxDQW5GVTtBQW9GZixhQUFLLENBcEZVO0FBcUZmQyxVQUFFLEVBQUUsQ0FyRlc7QUFzRmZDLFdBQUcsRUFBRSxDQXRGVTtBQXVGZixhQUFLLENBdkZVO0FBd0ZmQyxVQUFFLEVBQUUsQ0F4Rlc7QUF5RmZDLFdBQUcsRUFBRSxDQXpGVTtBQTBGZixhQUFLLENBMUZVO0FBMkZmdmdCLFVBQUUsRUFBRSxDQTNGVztBQTRGZndnQixXQUFHLEVBQUUsQ0E1RlU7QUE2RmYsYUFBSyxDQTdGVTtBQThGZkMsVUFBRSxFQUFFLENBOUZXO0FBK0ZmQyxXQUFHLEVBQUUsQ0EvRlU7QUFnR2YsYUFBSyxDQWhHVTtBQWlHZkMsVUFBRSxFQUFFLENBakdXO0FBa0dmQyxXQUFHLEVBQUUsQ0FsR1U7QUFtR2YsYUFBSyxDQW5HVTtBQW9HZkMsVUFBRSxFQUFFLENBcEdXO0FBcUdmQyxXQUFHLEVBQUUsQ0FyR1U7QUFzR2YsYUFBSyxDQXRHVTtBQXVHZkMsVUFBRSxFQUFFLENBdkdXO0FBd0dmQyxXQUFHLEVBQUUsQ0F4R1U7QUF5R2YsYUFBSyxDQXpHVTtBQTBHZkMsVUFBRSxFQUFFLENBMUdXO0FBMkdmQyxXQUFHLEVBQUUsQ0EzR1U7QUE0R2YsYUFBSyxDQTVHVTtBQTZHZkMsVUFBRSxFQUFFLENBN0dXO0FBOEdmQyxXQUFHLEVBQUUsQ0E5R1U7QUErR2YsYUFBSyxDQS9HVTtBQWdIZkMsVUFBRSxFQUFFLENBaEhXO0FBaUhmQyxXQUFHLEVBQUUsQ0FqSFU7QUFrSGYsYUFBSyxDQWxIVTtBQW1IZkMsVUFBRSxFQUFFLENBbkhXO0FBb0hmQyxXQUFHLEVBQUUsQ0FwSFU7QUFxSGYsYUFBSyxDQXJIVTtBQXNIZkMsVUFBRSxFQUFFLENBdEhXO0FBdUhmQyxXQUFHLEVBQUUsQ0F2SFU7QUF3SGYsYUFBSyxDQXhIVTtBQXlIZkMsVUFBRSxFQUFFLENBekhXO0FBMEhmQyxXQUFHLEVBQUUsQ0ExSFU7QUEySGYsYUFBSyxDQTNIVTtBQTRIZkMsVUFBRSxFQUFFLENBNUhXO0FBNkhmQyxXQUFHLEVBQUUsQ0E3SFU7QUE4SGYsYUFBSyxDQTlIVTtBQStIZkMsVUFBRSxFQUFFLENBL0hXO0FBZ0lmQyxXQUFHLEVBQUUsQ0FoSVU7QUFpSWYsYUFBSyxDQWpJVTtBQWtJZkMsVUFBRSxFQUFFLENBbElXO0FBbUlmQyxXQUFHLEVBQUUsQ0FuSVU7QUFvSWYsYUFBSyxDQXBJVTtBQXFJZkMsVUFBRSxFQUFFLENBcklXO0FBc0lmQyxXQUFHLEVBQUUsQ0F0SVU7QUF1SWYsYUFBSyxDQXZJVTtBQXdJZkMsVUFBRSxFQUFFLENBeElXO0FBeUlmQyxXQUFHLEVBQUUsQ0F6SVU7QUEwSWYsYUFBSyxDQTFJVTtBQTJJZkMsVUFBRSxFQUFFLENBM0lXO0FBNElmQyxXQUFHLEVBQUUsQ0E1SVU7QUE2SWYsYUFBSyxDQTdJVTtBQThJZkMsVUFBRSxFQUFFLENBOUlXO0FBK0lmQyxXQUFHLEVBQUUsQ0EvSVU7QUFnSmYsYUFBSyxDQWhKVTtBQWlKZkMsVUFBRSxFQUFFLENBakpXO0FBa0pmQyxXQUFHLEVBQUUsQ0FsSlU7QUFtSmYsYUFBSyxDQW5KVTtBQW9KZkMsVUFBRSxFQUFFLENBcEpXO0FBcUpmQyxXQUFHLEVBQUUsQ0FySlU7QUFzSmYsYUFBSyxDQXRKVTtBQXVKZkMsVUFBRSxFQUFFLENBdkpXO0FBd0pmQyxXQUFHLEVBQUUsQ0F4SlU7QUF5SmYsYUFBSyxDQXpKVTtBQTBKZkMsVUFBRSxFQUFFLENBMUpXO0FBMkpmQyxXQUFHLEVBQUUsQ0EzSlU7QUE0SmYsYUFBSyxDQTVKVTtBQTZKZkMsVUFBRSxFQUFFLENBN0pXO0FBOEpmQyxXQUFHLEVBQUUsQ0E5SlU7QUErSmYsYUFBSyxDQS9KVTtBQWdLZkMsVUFBRSxFQUFFLENBaEtXO0FBaUtmQyxXQUFHLEVBQUUsQ0FqS1U7QUFrS2YsYUFBSyxDQWxLVTtBQW1LZkMsVUFBRSxFQUFFLENBbktXO0FBb0tmQyxXQUFHLEVBQUUsQ0FwS1U7QUFxS2YsYUFBSyxDQXJLVTtBQXNLZkMsVUFBRSxFQUFFLENBdEtXO0FBdUtmQyxXQUFHLEVBQUUsQ0F2S1U7QUF3S2YsYUFBSyxDQXhLVTtBQXlLZkMsVUFBRSxFQUFFLENBektXO0FBMEtmQyxXQUFHLEVBQUUsQ0ExS1U7QUEyS2YsYUFBSyxDQTNLVTtBQTRLZkMsVUFBRSxFQUFFLENBNUtXO0FBNktmQyxXQUFHLEVBQUUsQ0E3S1U7QUE4S2YsYUFBSyxDQTlLVTtBQStLZkMsVUFBRSxFQUFFLENBL0tXO0FBZ0xmQyxXQUFHLEVBQUUsQ0FoTFU7QUFpTGYsYUFBSyxDQWpMVTtBQWtMZkMsVUFBRSxFQUFFLENBbExXO0FBbUxmQyxXQUFHLEVBQUUsQ0FuTFU7QUFvTGYsYUFBSyxDQXBMVTtBQXFMZkMsVUFBRSxFQUFFLENBckxXO0FBc0xmQyxXQUFHLEVBQUUsQ0F0TFU7QUF1TGYsV0FBRyxDQXZMWTtBQXdMZkMsVUFBRSxFQUFFLENBeExXO0FBeUxmQyxXQUFHLEVBQUUsQ0F6TFU7QUEwTGYsWUFBSSxDQTFMVztBQTJMZkMsVUFBRSxFQUFFLENBM0xXO0FBNExmQyxXQUFHLEVBQUUsQ0E1TFU7QUE2TGYsYUFBSyxDQTdMVTtBQThMZkMsVUFBRSxFQUFFLENBOUxXO0FBK0xmQyxXQUFHLEVBQUUsQ0EvTFU7QUFnTWYsWUFBSSxDQWhNVztBQWlNZkMsVUFBRSxFQUFFLENBak1XO0FBa01mQyxXQUFHLEVBQUUsQ0FsTVU7QUFtTWYsYUFBSyxDQW5NVTtBQW9NZkMsVUFBRSxFQUFFLENBcE1XO0FBcU1mQyxXQUFHLEVBQUUsQ0FyTVU7QUFzTWYsYUFBSyxDQXRNVTtBQXVNZkMsVUFBRSxFQUFFLENBdk1XO0FBd01mQyxXQUFHLEVBQUUsQ0F4TVU7QUF5TWYsYUFBSyxDQXpNVTtBQTBNZkMsVUFBRSxFQUFFLENBMU1XO0FBMk1mQyxXQUFHLEVBQUUsQ0EzTVU7QUE0TWYsYUFBSyxDQTVNVTtBQTZNZkMsVUFBRSxFQUFFLENBN01XO0FBOE1mQyxXQUFHLEVBQUUsQ0E5TVU7QUErTWYsYUFBSyxDQS9NVTtBQWdOZkMsVUFBRSxFQUFFLENBaE5XO0FBaU5mQyxXQUFHLEVBQUUsQ0FqTlU7QUFrTmYsYUFBSyxDQWxOVTtBQW1OZkMsVUFBRSxFQUFFLENBbk5XO0FBb05mQyxXQUFHLEVBQUUsQ0FwTlU7QUFxTmYsYUFBSyxDQXJOVTtBQXNOZkMsVUFBRSxFQUFFLENBdE5XO0FBdU5mQyxXQUFHLEVBQUUsQ0F2TlU7QUF3TmYsYUFBSyxDQXhOVTtBQXlOZkMsVUFBRSxFQUFFLENBek5XO0FBME5mQyxXQUFHLEVBQUUsQ0ExTlU7QUEyTmYsYUFBSyxDQTNOVTtBQTROZkMsVUFBRSxFQUFFLENBNU5XO0FBNk5mQyxXQUFHLEVBQUUsQ0E3TlU7QUE4TmYsYUFBSyxDQTlOVTtBQStOZkMsVUFBRSxFQUFFLENBL05XO0FBZ09mQyxXQUFHLEVBQUUsQ0FoT1U7QUFpT2YsYUFBSyxDQWpPVTtBQWtPZkMsVUFBRSxFQUFFLENBbE9XO0FBbU9mQyxXQUFHLEVBQUUsQ0FuT1U7QUFvT2YsWUFBSSxDQXBPVztBQXFPZkMsVUFBRSxFQUFFLENBck9XO0FBc09mQyxXQUFHLEVBQUUsQ0F0T1U7QUF1T2YsYUFBSztBQXZPVSxPQUFuQjtBQTBPQTs7QUFBNkJ4Yix5QkFBbUIsQ0FBQyxHQUFELENBQW5CLEdBQTRCOE0sWUFBNUI7QUFJN0I7QUFBTyxLQXZqRUc7QUF3akVWOztBQUNBO0FBQU8sY0FBU24wQixNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFOztBQUNBLGVBQVN1QyxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsV0FBbkMsRUFBZ0Q7QUFBRSxZQUFJLEVBQUVELFFBQVEsWUFBWUMsV0FBdEIsQ0FBSixFQUF3QztBQUFFLGdCQUFNLElBQUlDLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLGVBQVNDLGlCQUFULENBQTJCaHNCLE1BQTNCLEVBQW1Db1QsS0FBbkMsRUFBMEM7QUFBRSxhQUFLLElBQUk3VCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNlQsS0FBSyxDQUFDakwsTUFBMUIsRUFBa0M1SSxDQUFDLEVBQW5DLEVBQXVDO0FBQUUsY0FBSXNCLFVBQVUsR0FBR3VTLEtBQUssQ0FBQzdULENBQUQsQ0FBdEI7QUFBMkJzQixvQkFBVSxDQUFDZixVQUFYLEdBQXdCZSxVQUFVLENBQUNmLFVBQVgsSUFBeUIsS0FBakQ7QUFBd0RlLG9CQUFVLENBQUNoQixZQUFYLEdBQTBCLElBQTFCO0FBQWdDLGNBQUksV0FBV2dCLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ1QsUUFBWCxHQUFzQixJQUF0QjtBQUE0QnhCLGdCQUFNLENBQUNELGNBQVAsQ0FBc0JxQixNQUF0QixFQUE4QmEsVUFBVSxDQUFDcEIsR0FBekMsRUFBOENvQixVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxlQUFTb3JCLFlBQVQsQ0FBc0JILFdBQXRCLEVBQW1DSSxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxZQUFJRCxVQUFKLEVBQWdCRixpQkFBaUIsQ0FBQ0YsV0FBVyxDQUFDN0IsU0FBYixFQUF3QmlDLFVBQXhCLENBQWpCO0FBQXNELFlBQUlDLFdBQUosRUFBaUJILGlCQUFpQixDQUFDRixXQUFELEVBQWNLLFdBQWQsQ0FBakI7QUFBNkMsZUFBT0wsV0FBUDtBQUFxQjtBQUV2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSStaLGFBQWEsR0FBRyxPQUFwQjtBQUNBLFVBQUlDLGlCQUFpQixHQUFHLElBQXhCO0FBQ0EsVUFBSUMsZUFBZSxHQUFHLGtDQUF0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBSUMsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUJ4WixHQUFyQixFQUEwQjtBQUMxQyxlQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQzhLLFdBQUosRUFBUCxJQUE0QjlLLEdBQUcsSUFBSUEsR0FBRyxDQUFDNEssV0FBSixFQUExQztBQUNELE9BRkQ7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxVQUFJNk8sV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUJ6WixHQUFyQixFQUEwQjtBQUMxQyxlQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQzRLLFdBQUosRUFBUCxJQUE0QjVLLEdBQUcsSUFBSUEsR0FBRyxDQUFDOEssV0FBSixFQUExQztBQUNELE9BRkQ7O0FBSUEsVUFBSTRPLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCNVosS0FBMUIsRUFBaUNoZixHQUFqQyxFQUFzQy9OLENBQXRDLEVBQXlDaXRCLEdBQXpDLEVBQThDO0FBQ25FLFlBQUksQ0FBQ0YsS0FBTCxFQUFZO0FBQ1YsY0FBSTZaLEtBQUssR0FBRzNaLEdBQUcsQ0FBQ0ssTUFBSixDQUFXdHRCLENBQVgsQ0FBWjs7QUFFQSxjQUFJMGUsR0FBRyxHQUFHMWUsQ0FBQyxHQUFHLENBQWQ7QUFDQSxnQkFBTTtBQUNKd0IsZ0JBQUksRUFBRSxpQkFERjtBQUVKMHJCLG1CQUFPLEVBQUUsc0RBQXNEcUMsTUFBdEQsQ0FBNkQ3USxHQUE3RCxFQUFrRSxjQUFsRSxFQUFrRjZRLE1BQWxGLENBQXlGcVgsS0FBekYsRUFBZ0csSUFBaEcsQ0FGTDtBQUdKbG9CLGVBQUcsRUFBRUEsR0FIRDtBQUlKLG9CQUFRa29CO0FBSkosV0FBTjtBQU1ELFNBVkQsTUFVTzc0QixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUO0FBQ1IsT0FaRDtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxVQUFJcW5CLFVBQVUsR0FDZCxhQUNBLFlBQVk7QUFDVixpQkFBU0EsVUFBVCxHQUFzQjtBQUNwQmdGLHlCQUFlLENBQUMsSUFBRCxFQUFPaEYsVUFBUCxDQUFmO0FBQ0Q7O0FBRURxRixvQkFBWSxDQUFDckYsVUFBRCxFQUFhLElBQWIsRUFBbUIsQ0FBQztBQUM5Qm5uQixhQUFHLEVBQUUsTUFEeUI7O0FBRzlCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUcsZUFBSyxFQUFFLFNBQVMrUCxJQUFULENBQWM2YyxHQUFkLEVBQW1CSixLQUFuQixFQUEwQjtBQUMvQixnQkFBSUUsS0FBSyxHQUFHalgsU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUFuQixJQUF3QmtOLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJnWCxTQUF6QyxHQUFxRGhYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLElBQWhGO0FBQ0FtWCxlQUFHLEdBQUd4Z0IsTUFBTSxDQUFDd2dCLEdBQUQsQ0FBWjtBQUNBSixpQkFBSyxHQUFHcGdCLE1BQU0sQ0FBQ29nQixLQUFELENBQWQ7QUFDQSxnQkFBSUcsT0FBTyxHQUFHSCxLQUFLLENBQUNqa0IsTUFBcEI7QUFDQSxnQkFBSWkrQixNQUFNLEdBQUc1WixHQUFHLENBQUNya0IsTUFBakI7O0FBRUEsZ0JBQUlpK0IsTUFBTSxHQUFHN1osT0FBYixFQUFzQjtBQUNwQixrQkFBSUQsS0FBSixFQUFXLE9BQU9FLEdBQVAsQ0FBWCxDQUF1QjtBQUF2QixtQkFDSyxNQUFNO0FBQ1B6ckIsc0JBQUksRUFBRSxxQkFEQztBQUVQMHJCLHlCQUFPLEVBQUU7QUFGRixpQkFBTjtBQUlOOztBQUVELGdCQUFJbmYsR0FBRyxHQUFHLElBQUlySSxLQUFKLENBQVVzbkIsT0FBVixDQUFWO0FBQ0EsZ0JBQUl0TyxHQUFHLEdBQUcsQ0FBVixDQWhCK0IsQ0FnQmxCOztBQUViLGdCQUFJb29CLFFBQVEsR0FBRyxFQUFmOztBQUVBLGlCQUFLLElBQUk5bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2d0QixPQUFwQixFQUE2Qmh0QixDQUFDLEVBQTlCLEVBQWtDO0FBQ2hDOG1DLHNCQUFRLEdBQUdqYSxLQUFLLENBQUNTLE1BQU4sQ0FBYXR0QixDQUFiLENBQVg7O0FBRUEsc0JBQVE4bUMsUUFBUjtBQUNFLHFCQUFLLEdBQUw7QUFDRTtBQUNBLzRCLHFCQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzBlLEdBQUcsR0FBR21vQixNQUFOLEdBQWU1WixHQUFHLENBQUNLLE1BQUosQ0FBVzVPLEdBQVgsQ0FBZixHQUFpQyxHQUExQztBQUNBLG9CQUFFQSxHQUFGO0FBQ0E7O0FBRUYscUJBQUssR0FBTDtBQUNFO0FBQ0Esc0JBQUlBLEdBQUcsR0FBR21vQixNQUFWLEVBQWtCO0FBQ2hCLHdCQUFJRSxLQUFLLEdBQUc5WixHQUFHLENBQUNLLE1BQUosQ0FBVzVPLEdBQVgsQ0FBWjs7QUFFQSx3QkFBSWdvQixXQUFXLENBQUNLLEtBQUQsQ0FBZixFQUF3Qmg1QixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyttQyxLQUFULENBQXhCLEtBQTRDLElBQUlOLFdBQVcsQ0FBQ00sS0FBRCxDQUFmLEVBQXdCaDVCLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTK21DLEtBQUssQ0FBQ2xQLFdBQU4sRUFBVCxDQUF4QixLQUEwRDhPLGdCQUFnQixDQUFDNVosS0FBRCxFQUFRaGYsR0FBUixFQUFhL04sQ0FBYixFQUFnQml0QixHQUFoQixDQUFoQjtBQUN2RyxtQkFKRCxNQUlPbGYsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVMsR0FBVDs7QUFFUCxvQkFBRTBlLEdBQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0U7QUFDQSxzQkFBSUEsR0FBRyxHQUFHbW9CLE1BQVYsRUFBa0I7QUFDaEIsd0JBQUlHLE1BQU0sR0FBRy9aLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFiOztBQUVBLHdCQUFJZ29CLFdBQVcsQ0FBQ00sTUFBRCxDQUFYLElBQXVCUCxXQUFXLENBQUNPLE1BQUQsQ0FBdEMsRUFBZ0RqNUIsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVNnbkMsTUFBVCxDQUFoRCxLQUFxRUwsZ0JBQWdCLENBQUM1WixLQUFELEVBQVFoZixHQUFSLEVBQWEvTixDQUFiLEVBQWdCaXRCLEdBQWhCLENBQWhCO0FBQ3RFLG1CQUpELE1BSU9sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUVQLG9CQUFFMGUsR0FBRjtBQUNBOztBQUVGLHFCQUFLLEdBQUw7QUFDRTtBQUNBLHNCQUFJQSxHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQix3QkFBSUksTUFBTSxHQUFHaGEsR0FBRyxDQUFDSyxNQUFKLENBQVc1TyxHQUFYLENBQWI7O0FBRUEsd0JBQUk0bkIsYUFBYSxDQUFDdlcsSUFBZCxDQUFtQmtYLE1BQW5CLENBQUosRUFBZ0NsNUIsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVNpbkMsTUFBVCxDQUFoQyxLQUFxRE4sZ0JBQWdCLENBQUM1WixLQUFELEVBQVFoZixHQUFSLEVBQWEvTixDQUFiLEVBQWdCaXRCLEdBQWhCLENBQWhCO0FBQ3RELG1CQUpELE1BSU9sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUVQLG9CQUFFMGUsR0FBRjtBQUNBOztBQUVGLHFCQUFLLEdBQUw7QUFDRTtBQUNBLHNCQUFJQSxHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQix3QkFBSUssTUFBTSxHQUFHamEsR0FBRyxDQUFDSyxNQUFKLENBQVc1TyxHQUFYLENBQWI7O0FBRUEsd0JBQUlnb0IsV0FBVyxDQUFDUSxNQUFELENBQVgsSUFBdUJaLGFBQWEsQ0FBQ3ZXLElBQWQsQ0FBbUJtWCxNQUFuQixDQUEzQixFQUF1RG41QixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBU2tuQyxNQUFULENBQXZELEtBQTRFLElBQUlULFdBQVcsQ0FBQ1MsTUFBRCxDQUFmLEVBQXlCbjVCLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTa25DLE1BQU0sQ0FBQ3JQLFdBQVAsRUFBVCxDQUF6QixLQUE0RDhPLGdCQUFnQixDQUFDNVosS0FBRCxFQUFRaGYsR0FBUixFQUFhL04sQ0FBYixFQUFnQml0QixHQUFoQixDQUFoQjtBQUN6SSxtQkFKRCxNQUlPbGYsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVMsR0FBVDs7QUFFUCxvQkFBRTBlLEdBQUY7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0U7QUFDQSxzQkFBSUEsR0FBRyxHQUFHbW9CLE1BQVYsRUFBa0I7QUFDaEIsd0JBQUlNLE1BQU0sR0FBR2xhLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFiOztBQUVBLHdCQUFJZ29CLFdBQVcsQ0FBQ1MsTUFBRCxDQUFYLElBQXVCVixXQUFXLENBQUNVLE1BQUQsQ0FBbEMsSUFBOENiLGFBQWEsQ0FBQ3ZXLElBQWQsQ0FBbUJvWCxNQUFuQixDQUFsRCxFQUE4RXA1QixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBU21uQyxNQUFULENBQTlFLEtBQW1HUixnQkFBZ0IsQ0FBQzVaLEtBQUQsRUFBUWhmLEdBQVIsRUFBYS9OLENBQWIsRUFBZ0JpdEIsR0FBaEIsQ0FBaEI7QUFDcEcsbUJBSkQsTUFJT2xmLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTLEdBQVQ7O0FBRVAsb0JBQUUwZSxHQUFGO0FBQ0E7QUFDQTs7QUFFRixxQkFBSyxHQUFMO0FBQ0U7QUFDQSxzQkFBSUEsR0FBRyxHQUFHbW9CLE1BQVYsRUFBa0I7QUFDaEIsd0JBQUlPLE1BQU0sR0FBR25hLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFiOztBQUVBLHdCQUFJK25CLFdBQVcsQ0FBQ1csTUFBRCxDQUFmLEVBQXlCcjVCLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTb25DLE1BQU0sQ0FBQ3ZQLFdBQVAsRUFBVCxDQUF6QixLQUE0RCxJQUFJNk8sV0FBVyxDQUFDVSxNQUFELENBQVgsSUFBdUJkLGFBQWEsQ0FBQ3ZXLElBQWQsQ0FBbUJxWCxNQUFuQixDQUF2QixJQUFxRGIsaUJBQWlCLENBQUN4VyxJQUFsQixDQUF1QnFYLE1BQXZCLENBQXJELElBQXVGWixlQUFlLENBQUMvWCxPQUFoQixDQUF3QjJZLE1BQXhCLElBQWtDLENBQUMsQ0FBOUgsRUFBaUlyNUIsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVNvbkMsTUFBVCxDQUFqSSxLQUFzSlQsZ0JBQWdCLENBQUM1WixLQUFELEVBQVFoZixHQUFSLEVBQWEvTixDQUFiLEVBQWdCaXRCLEdBQWhCLENBQWhCO0FBQ25OLG1CQUpELE1BSU9sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUVQLG9CQUFFMGUsR0FBRjtBQUNBOztBQUVGO0FBQ0UzUSxxQkFBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVM4bUMsUUFBVDtBQUNBO0FBNUVKO0FBOEVEOztBQUVELGdCQUFJcG9CLEdBQUcsR0FBR21vQixNQUFWLEVBQWtCO0FBQ2hCLGtCQUFJLENBQUM5WixLQUFMLEVBQVk7QUFDVixzQkFBTTtBQUNKdnJCLHNCQUFJLEVBQUUsV0FERjtBQUVKMHJCLHlCQUFPLEVBQUU7QUFGTCxpQkFBTjtBQUlEO0FBQ0Y7O0FBRUQsbUJBQU9uZixHQUFHLENBQUNnaEIsSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNEO0FBbEk2QixTQUFELENBQW5CLENBQVo7O0FBcUlBLGVBQU8xSCxVQUFQO0FBQ0QsT0EzSUQsRUFGQTtBQStJQTs7O0FBQTZCd0QseUJBQW1CLENBQUMsR0FBRCxDQUFuQixHQUE0QnhELFVBQTVCO0FBRTdCO0FBQU8sS0F2d0VHO0FBd3dFVjs7QUFDQTtBQUFPLGNBQVM3akIsTUFBVCxFQUFpQnFuQixtQkFBakIsRUFBc0NmLG1CQUF0QyxFQUEyRDtBQUVsRTtBQUNBOztBQUFxQixVQUFJdWQsb0NBQW9DLEdBQUd2ZCxtQkFBbUIsQ0FBQyxFQUFELENBQTlEO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFBNkJlLHlCQUFtQixDQUFDLEdBQUQsQ0FBbkIsR0FBNEJ3YyxvQ0FBb0MsQ0FBQztBQUFJO0FBQUwsT0FBaEU7QUFFN0I7QUFBTyxLQXZ4RUc7QUF3eEVWOztBQUNBO0FBQU8sY0FBUzdqQyxNQUFULEVBQWlCcW5CLG1CQUFqQixFQUFzQ2YsbUJBQXRDLEVBQTJEO0FBRWxFO0FBQ0E7O0FBQXFCLFVBQUltQix5Q0FBeUMsR0FBR25CLG1CQUFtQixDQUFDLENBQUQsQ0FBbkU7QUFDckI7OztBQUFxQixVQUFJNEIsdUNBQXVDLEdBQUc1QixtQkFBbUIsQ0FBQyxDQUFELENBQWpFO0FBQ3JCOzs7QUFBcUIsVUFBSTZCLHlDQUF5QyxHQUFHN0IsbUJBQW1CLENBQUMsQ0FBRCxDQUFuRTs7QUFDckIsZUFBU3VDLGVBQVQsQ0FBeUJDLFFBQXpCLEVBQW1DQyxXQUFuQyxFQUFnRDtBQUFFLFlBQUksRUFBRUQsUUFBUSxZQUFZQyxXQUF0QixDQUFKLEVBQXdDO0FBQUUsZ0JBQU0sSUFBSUMsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosZUFBU0MsaUJBQVQsQ0FBMkJoc0IsTUFBM0IsRUFBbUNvVCxLQUFuQyxFQUEwQztBQUFFLGFBQUssSUFBSTdULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2VCxLQUFLLENBQUNqTCxNQUExQixFQUFrQzVJLENBQUMsRUFBbkMsRUFBdUM7QUFBRSxjQUFJc0IsVUFBVSxHQUFHdVMsS0FBSyxDQUFDN1QsQ0FBRCxDQUF0QjtBQUEyQnNCLG9CQUFVLENBQUNmLFVBQVgsR0FBd0JlLFVBQVUsQ0FBQ2YsVUFBWCxJQUF5QixLQUFqRDtBQUF3RGUsb0JBQVUsQ0FBQ2hCLFlBQVgsR0FBMEIsSUFBMUI7QUFBZ0MsY0FBSSxXQUFXZ0IsVUFBZixFQUEyQkEsVUFBVSxDQUFDVCxRQUFYLEdBQXNCLElBQXRCO0FBQTRCeEIsZ0JBQU0sQ0FBQ0QsY0FBUCxDQUFzQnFCLE1BQXRCLEVBQThCYSxVQUFVLENBQUNwQixHQUF6QyxFQUE4Q29CLFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULGVBQVNvckIsWUFBVCxDQUFzQkgsV0FBdEIsRUFBbUNJLFVBQW5DLEVBQStDQyxXQUEvQyxFQUE0RDtBQUFFLFlBQUlELFVBQUosRUFBZ0JGLGlCQUFpQixDQUFDRixXQUFXLENBQUM3QixTQUFiLEVBQXdCaUMsVUFBeEIsQ0FBakI7QUFBc0QsWUFBSUMsV0FBSixFQUFpQkgsaUJBQWlCLENBQUNGLFdBQUQsRUFBY0ssV0FBZCxDQUFqQjtBQUE2QyxlQUFPTCxXQUFQO0FBQXFCO0FBRXZOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQSxVQUFJK2EsS0FBSyxHQUNULGFBQ0EsWUFBWTtBQUNWLGlCQUFTQSxLQUFULEdBQWlCO0FBQ2ZqYix5QkFBZSxDQUFDLElBQUQsRUFBT2liLEtBQVAsQ0FBZjtBQUNEOztBQUVENWEsb0JBQVksQ0FBQzRhLEtBQUQsRUFBUSxJQUFSLEVBQWMsQ0FBQztBQUN6QnBuQyxhQUFHLEVBQUUsUUFEb0I7O0FBR3pCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSUcsZUFBSyxFQUFFLFNBQVMyRyxNQUFULENBQWdCdWdDLE9BQWhCLEVBQXlCbjNCLElBQXpCLEVBQStCO0FBQ3BDLGdCQUFJRSxpQkFBaUIsR0FBR3dGLFNBQVMsQ0FBQ2xOLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JrTixTQUFTLENBQUMsQ0FBRCxDQUFULEtBQWlCZ1gsU0FBekMsR0FBcURoWCxTQUFTLENBQUMsQ0FBRCxDQUE5RCxHQUFvRSxHQUE1RjtBQUNBLGdCQUFJdkYsZ0JBQWdCLEdBQUd1RixTQUFTLENBQUNsTixNQUFWLEdBQW1CLENBQW5CLElBQXdCa04sU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQmdYLFNBQXpDLEdBQXFEaFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsR0FBM0Y7QUFDQSxnQkFBSXRGLGtCQUFrQixHQUFHc0YsU0FBUyxDQUFDbE4sTUFBVixHQUFtQixDQUFuQixJQUF3QmtOLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJnWCxTQUF6QyxHQUFxRGhYLFNBQVMsQ0FBQyxDQUFELENBQTlELEdBQW9FLEtBQTdGO0FBQ0EsZ0JBQUlpWCxLQUFLLEdBQUdqWCxTQUFTLENBQUNsTixNQUFWLEdBQW1CLENBQW5CLElBQXdCa04sU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQmdYLFNBQXpDLEdBQXFEaFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsSUFBaEY7QUFDQSxtQkFBT21WLHlDQUF5QyxDQUFDO0FBQUk7QUFBTCxhQUF6QyxDQUE2RDdhLElBQTdELENBQWtFbTNCLE9BQWxFLEVBQTJFbjNCLElBQTNFLEVBQWlGRSxpQkFBakYsRUFBb0dDLGdCQUFwRyxFQUFzSEMsa0JBQXRILEVBQTBJdWMsS0FBMUksQ0FBUDtBQUNEO0FBQ0Q7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFsQzZCLFNBQUQsRUFvQ3ZCO0FBQ0Q3c0IsYUFBRyxFQUFFLE1BREo7QUFFREcsZUFBSyxFQUFFLFNBQVN1SyxJQUFULENBQWM0OEIsS0FBZCxFQUFxQnAzQixJQUFyQixFQUEyQmdOLE1BQTNCLEVBQW1DL1IsUUFBbkMsRUFBNkM7QUFDbEQsbUJBQU9xZ0IsdUNBQXVDLENBQUM7QUFBSTtBQUFMLGFBQXZDLENBQTJEdGIsSUFBM0QsQ0FBZ0VvM0IsS0FBaEUsRUFBdUVwM0IsSUFBdkUsRUFBNkVnTixNQUE3RSxFQUFxRi9SLFFBQXJGLENBQVA7QUFDRDtBQUNEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbEJLLFNBcEN1QixFQXdEdkI7QUFDRG5MLGFBQUcsRUFBRSxRQURKO0FBRURHLGVBQUssRUFBRSxTQUFTZ1MsTUFBVCxDQUFnQjRhLEdBQWhCLEVBQXFCN2MsSUFBckIsRUFBMkI7QUFDaEMsZ0JBQUkyYyxLQUFLLEdBQUdqWCxTQUFTLENBQUNsTixNQUFWLEdBQW1CLENBQW5CLElBQXdCa04sU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQmdYLFNBQXpDLEdBQXFEaFgsU0FBUyxDQUFDLENBQUQsQ0FBOUQsR0FBb0UsSUFBaEY7QUFDQSxtQkFBTzZWLHlDQUF5QyxDQUFDO0FBQUk7QUFBTCxhQUF6QyxDQUE2RHZiLElBQTdELENBQWtFNmMsR0FBbEUsRUFBdUU3YyxJQUF2RSxFQUE2RTJjLEtBQTdFLENBQVA7QUFDRDtBQUxBLFNBeER1QixDQUFkLENBQVo7O0FBZ0VBLGVBQU91YSxLQUFQO0FBQ0QsT0F0RUQsRUFGQTtBQTBFQTs7O0FBQTZCemMseUJBQW1CLENBQUMsR0FBRCxDQUFuQixHQUE0QnljLEtBQTVCO0FBRTdCO0FBQU87QUFDUDtBQXA0RVUsS0FqRU07QUFBaEI7QUFzOEVDLENBaDlFRCxFOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0MsV0FBVXQvQixNQUFWLEVBQWtCMmhCLE9BQWxCLEVBQTJCO0FBQ3hCLGdDQUFPdlQsT0FBUCxPQUFtQixRQUFuQixJQUErQixPQUFPNVMsTUFBUCxLQUFrQixXQUFqRCxHQUErREEsTUFBTSxDQUFDNFMsT0FBUCxHQUFpQnVULE9BQU8sRUFBdkYsR0FDQSxRQUE2Q0Msb0NBQU9ELE9BQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBbkQsSUFDQzNoQixTQURELENBREE7QUFHSCxDQUpBLFVBSVEsWUFBWTtBQUFFO0FBRW5CO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJSSxNQUFJeS9CLE9BQVEsR0FBRyxvQkFBVztBQUN0QkEsV0FBUSxHQUFHcG9DLE1BQU0sQ0FBQ3FvQyxNQUFQLElBQWlCLFNBQVNELFFBQVQsQ0FBa0JFLENBQWxCLEVBQXFCO0FBQzdDLFdBQUssSUFBSS9jLENBQUosRUFBTzVxQixDQUFDLEdBQUcsQ0FBWCxFQUFjcXFCLENBQUMsR0FBR3ZVLFNBQVMsQ0FBQ2xOLE1BQWpDLEVBQXlDNUksQ0FBQyxHQUFHcXFCLENBQTdDLEVBQWdEcnFCLENBQUMsRUFBakQsRUFBcUQ7QUFDakQ0cUIsU0FBQyxHQUFHOVUsU0FBUyxDQUFDOVYsQ0FBRCxDQUFiOztBQUNBLGFBQUssSUFBSTJxQixDQUFULElBQWNDLENBQWQ7QUFBaUIsY0FBSXZyQixNQUFNLENBQUNxckIsU0FBUCxDQUFpQjVoQixjQUFqQixDQUFnQ2toQixJQUFoQyxDQUFxQ1ksQ0FBckMsRUFBd0NELENBQXhDLENBQUosRUFBZ0RnZCxDQUFDLENBQUNoZCxDQUFELENBQUQsR0FBT0MsQ0FBQyxDQUFDRCxDQUFELENBQVI7QUFBakU7QUFDSDs7QUFDRCxhQUFPZ2QsQ0FBUDtBQUNILEtBTkQ7O0FBT0EsV0FBT0YsT0FBUSxDQUFDbi9CLEtBQVQsQ0FBZSxJQUFmLEVBQXFCd04sU0FBckIsQ0FBUDtBQUNILEdBVEQ7O0FBV0EsV0FBUzh4QixjQUFULEdBQTBCO0FBQ3RCLFNBQUssSUFBSWhkLENBQUMsR0FBRyxDQUFSLEVBQVc1cUIsQ0FBQyxHQUFHLENBQWYsRUFBa0I2bkMsRUFBRSxHQUFHL3hCLFNBQVMsQ0FBQ2xOLE1BQXRDLEVBQThDNUksQ0FBQyxHQUFHNm5DLEVBQWxELEVBQXNEN25DLENBQUMsRUFBdkQ7QUFBMkQ0cUIsT0FBQyxJQUFJOVUsU0FBUyxDQUFDOVYsQ0FBRCxDQUFULENBQWE0SSxNQUFsQjtBQUEzRDs7QUFDQSxTQUFLLElBQUlrL0IsQ0FBQyxHQUFHcGlDLEtBQUssQ0FBQ2tsQixDQUFELENBQWIsRUFBa0JnSCxDQUFDLEdBQUcsQ0FBdEIsRUFBeUI1eEIsQ0FBQyxHQUFHLENBQWxDLEVBQXFDQSxDQUFDLEdBQUc2bkMsRUFBekMsRUFBNkM3bkMsQ0FBQyxFQUE5QztBQUNJLFdBQUssSUFBSStuQyxDQUFDLEdBQUdqeUIsU0FBUyxDQUFDOVYsQ0FBRCxDQUFqQixFQUFzQmdvQyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkJDLEVBQUUsR0FBR0YsQ0FBQyxDQUFDbi9CLE1BQXpDLEVBQWlEby9CLENBQUMsR0FBR0MsRUFBckQsRUFBeURELENBQUMsSUFBSXBXLENBQUMsRUFBL0Q7QUFDSWtXLFNBQUMsQ0FBQ2xXLENBQUQsQ0FBRCxHQUFPbVcsQ0FBQyxDQUFDQyxDQUFELENBQVI7QUFESjtBQURKOztBQUdBLFdBQU9GLENBQVA7QUFDSDs7QUFFRCxNQUFJSSxLQUFLLEdBQUcsQ0FDUixVQURRLEVBRVIsU0FGUSxFQUdSLGFBSFEsRUFJUixXQUpRLEVBS1IsV0FMUSxFQU1SLGVBTlEsRUFPUixRQVBRLEVBUVIsZUFSUSxFQVNSLFNBVFEsRUFVUixlQVZRLEVBV1IsY0FYUSxFQVlSLHVCQVpRLENBQVo7QUFjQSxNQUFJQyxRQUFRLEdBQUc7QUFDWEMsWUFBUSxFQUFFLEVBREM7QUFFWEMsV0FBTyxFQUFFLEVBRkU7QUFHWDNrQixjQUFVLEVBQUUsS0FIRDtBQUlYNGtCLHVCQUFtQixFQUFFLEtBSlY7QUFLWEMsYUFBUyxFQUFFLFFBTEE7QUFNWEMsWUFBUSxFQUFFLEtBTkM7QUFPWEMsaUJBQWEsRUFBRSxvQkFQSjtBQVFYQyxXQUFPLEVBQUUsUUFBT3g2QixNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQ0xBLE1BQU0sQ0FBQ3k2QixTQUFQLENBQWlCQyxTQUFqQixDQUEyQm5hLE9BQTNCLENBQW1DLE1BQW5DLE1BQStDLENBQUMsQ0FUekM7QUFVWG9hLGtCQUFjLEVBQUUsUUFWTDtBQVdYQyx1QkFBbUIsRUFBRSxJQVhWO0FBWVhDLGNBQVUsRUFBRSxJQVpEO0FBYVhDLGlCQUFhLEVBQUUsSUFiSjtBQWNYQyxlQUFXLEVBQUUsSUFkRjtBQWVYMWxCLGNBQVUsRUFBRSxPQWZEO0FBZ0JYUSxlQUFXLEVBQUUsRUFoQkY7QUFpQlhDLGlCQUFhLEVBQUUsQ0FqQko7QUFrQlhrbEIsa0JBQWMsRUFBRSxDQWxCTDtBQW1CWEMsV0FBTyxFQUFFLEVBbkJFO0FBb0JYbGxCLGlCQUFhLEVBQUUsS0FwQko7QUFxQlhtbEIsVUFBTSxFQUFFLEVBckJHO0FBc0JYL2xCLGlCQUFhLEVBQUUsS0F0Qko7QUF1Qlh4RyxjQUFVLEVBQUUsS0F2QkQ7QUF3Qlh3c0IsZ0JBQVksRUFBRSxzQkFBVUMsR0FBVixFQUFlO0FBQ3pCLGFBQU8sT0FBT3JqQyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxPQUFPLENBQUNELElBQVIsQ0FBYXNqQyxHQUFiLENBQXpDO0FBQ0gsS0ExQlU7QUEyQlhDLFdBQU8sRUFBRSxpQkFBVUMsU0FBVixFQUFxQjtBQUMxQixVQUFJNStCLElBQUksR0FBRyxJQUFJdUIsSUFBSixDQUFTcTlCLFNBQVMsQ0FBQ2plLE9BQVYsRUFBVCxDQUFYO0FBQ0EzZ0IsVUFBSSxDQUFDNitCLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBRjBCLENBRzFCOztBQUNBNytCLFVBQUksQ0FBQzgrQixPQUFMLENBQWE5K0IsSUFBSSxDQUFDMGxCLE9BQUwsS0FBaUIsQ0FBakIsR0FBc0IsQ0FBQzFsQixJQUFJLENBQUM4bUIsTUFBTCxLQUFnQixDQUFqQixJQUFzQixDQUF6RCxFQUowQixDQUsxQjs7QUFDQSxVQUFJaVksS0FBSyxHQUFHLElBQUl4OUIsSUFBSixDQUFTdkIsSUFBSSxDQUFDZ2xCLFdBQUwsRUFBVCxFQUE2QixDQUE3QixFQUFnQyxDQUFoQyxDQUFaLENBTjBCLENBTzFCOztBQUNBLGFBQVEsSUFDSnpvQixJQUFJLENBQUNpb0IsS0FBTCxDQUFXLENBQUMsQ0FBQ3hrQixJQUFJLENBQUMyZ0IsT0FBTCxLQUFpQm9lLEtBQUssQ0FBQ3BlLE9BQU4sRUFBbEIsSUFBcUMsUUFBckMsR0FDUixDQURRLEdBRVAsQ0FBQ29lLEtBQUssQ0FBQ2pZLE1BQU4sS0FBaUIsQ0FBbEIsSUFBdUIsQ0FGakIsSUFHUCxDQUhKLENBREo7QUFLSCxLQXhDVTtBQXlDWGtZLGlCQUFhLEVBQUUsQ0F6Q0o7QUEwQ1hDLHdCQUFvQixFQUFFLEVBMUNYO0FBMkNYQyxVQUFNLEVBQUUsS0EzQ0c7QUE0Q1gxc0IsVUFBTSxFQUFFLFNBNUNHO0FBNkNYMnNCLG1CQUFlLEVBQUUsQ0E3Q047QUE4Q1hDLFFBQUksRUFBRSxRQTlDSztBQStDWEMscUJBQWlCLEVBQUUsVUEvQ1I7QUFnRFhDLGFBQVMsRUFBRSx3T0FoREE7QUFpRFg1bUIsY0FBVSxFQUFFLEtBakREO0FBa0RYNm1CLE9BQUcsRUFBRSxJQUFJaCtCLElBQUosRUFsRE07QUFtRFh3WCxZQUFRLEVBQUUsRUFuREM7QUFvRFh5bUIsV0FBTyxFQUFFLEVBcERFO0FBcURYQyxlQUFXLEVBQUUsRUFyREY7QUFzRFhDLGFBQVMsRUFBRSxFQXREQTtBQXVEWEMsYUFBUyxFQUFFLEVBdkRBO0FBd0RYQyxpQkFBYSxFQUFFLEVBeERKO0FBeURYQyxVQUFNLEVBQUUsRUF6REc7QUEwRFhDLGlCQUFhLEVBQUUsRUExREo7QUEyRFhDLFdBQU8sRUFBRSxFQTNERTtBQTREWEMsaUJBQWEsRUFBRSxFQTVESjtBQTZEWEMsZ0JBQVksRUFBRSxFQTdESDtBQThEWEMseUJBQXFCLEVBQUUsRUE5RFo7QUErRFhDLFdBQU8sRUFBRSxFQS9ERTtBQWdFWHhqQixZQUFRLEVBQUUsTUFoRUM7QUFpRVh5akIsbUJBQWUsRUFBRWxlLFNBakVOO0FBa0VYbWUsYUFBUyxFQUFFLHNPQWxFQTtBQW1FWEMseUJBQXFCLEVBQUUsS0FuRVo7QUFvRVhDLGNBQVUsRUFBRSxDQXBFRDtBQXFFWEMsVUFBTSxFQUFFLEtBckVHO0FBc0VYaG9CLGFBQVMsRUFBRSxLQXRFQTtBQXVFWGMsZUFBVyxFQUFFLEtBdkVGO0FBd0VYVCxRQUFJLEVBQUU7QUF4RUssR0FBZjtBQTJFQSxNQUFJNG5CLE9BQU8sR0FBRztBQUNWem1CLFlBQVEsRUFBRTtBQUNOQyxlQUFTLEVBQUUsQ0FBQyxLQUFELEVBQVEsS0FBUixFQUFlLEtBQWYsRUFBc0IsS0FBdEIsRUFBNkIsS0FBN0IsRUFBb0MsS0FBcEMsRUFBMkMsS0FBM0MsQ0FETDtBQUVOQyxjQUFRLEVBQUUsQ0FDTixRQURNLEVBRU4sUUFGTSxFQUdOLFNBSE0sRUFJTixXQUpNLEVBS04sVUFMTSxFQU1OLFFBTk0sRUFPTixVQVBNO0FBRkosS0FEQTtBQWFWQyxVQUFNLEVBQUU7QUFDSkYsZUFBUyxFQUFFLENBQ1AsS0FETyxFQUVQLEtBRk8sRUFHUCxLQUhPLEVBSVAsS0FKTyxFQUtQLEtBTE8sRUFNUCxLQU5PLEVBT1AsS0FQTyxFQVFQLEtBUk8sRUFTUCxLQVRPLEVBVVAsS0FWTyxFQVdQLEtBWE8sRUFZUCxLQVpPLENBRFA7QUFlSkMsY0FBUSxFQUFFLENBQ04sU0FETSxFQUVOLFVBRk0sRUFHTixPQUhNLEVBSU4sT0FKTSxFQUtOLEtBTE0sRUFNTixNQU5NLEVBT04sTUFQTSxFQVFOLFFBUk0sRUFTTixXQVRNLEVBVU4sU0FWTSxFQVdOLFVBWE0sRUFZTixVQVpNO0FBZk4sS0FiRTtBQTJDVkUsZUFBVyxFQUFFLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsRUFBYixFQUFpQixFQUFqQixFQUFxQixFQUFyQixFQUF5QixFQUF6QixFQUE2QixFQUE3QixFQUFpQyxFQUFqQyxFQUFxQyxFQUFyQyxFQUF5QyxFQUF6QyxFQUE2QyxFQUE3QyxDQTNDSDtBQTRDVkMsa0JBQWMsRUFBRSxDQTVDTjtBQTZDVkMsV0FBTyxFQUFFLGlCQUFVb21CLEdBQVYsRUFBZTtBQUNwQixVQUFJMWdCLENBQUMsR0FBRzBnQixHQUFHLEdBQUcsR0FBZDtBQUNBLFVBQUkxZ0IsQ0FBQyxHQUFHLENBQUosSUFBU0EsQ0FBQyxHQUFHLEVBQWpCLEVBQ0ksT0FBTyxJQUFQOztBQUNKLGNBQVFBLENBQUMsR0FBRyxFQUFaO0FBQ0ksYUFBSyxDQUFMO0FBQ0ksaUJBQU8sSUFBUDs7QUFDSixhQUFLLENBQUw7QUFDSSxpQkFBTyxJQUFQOztBQUNKLGFBQUssQ0FBTDtBQUNJLGlCQUFPLElBQVA7O0FBQ0o7QUFDSSxpQkFBTyxJQUFQO0FBUlI7QUFVSCxLQTNEUztBQTREVnpGLGtCQUFjLEVBQUUsTUE1RE47QUE2RFZDLG9CQUFnQixFQUFFLElBN0RSO0FBOERWQyxlQUFXLEVBQUUscUJBOURIO0FBK0RWQyxlQUFXLEVBQUUsaUJBL0RIO0FBZ0VWQyxRQUFJLEVBQUUsQ0FBQyxJQUFELEVBQU8sSUFBUCxDQWhFSTtBQWlFVkMsaUJBQWEsRUFBRSxNQWpFTDtBQWtFVitsQixrQkFBYyxFQUFFLE9BbEVOO0FBbUVWOWxCLGlCQUFhLEVBQUUsTUFuRUw7QUFvRVZDLG1CQUFlLEVBQUUsUUFwRVA7QUFxRVZ0QyxhQUFTLEVBQUU7QUFyRUQsR0FBZDs7QUF3RUEsTUFBSThNLEdBQUcsR0FBRyxTQUFOQSxHQUFNLENBQVVscEIsTUFBVixFQUFrQjRCLE1BQWxCLEVBQTBCO0FBQ2hDLFFBQUlBLE1BQU0sS0FBSyxLQUFLLENBQXBCLEVBQXVCO0FBQUVBLFlBQU0sR0FBRyxDQUFUO0FBQWE7O0FBQ3RDLFdBQU8sQ0FBQyxRQUFRNUIsTUFBVCxFQUFpQmd3QixLQUFqQixDQUF1QnB1QixNQUFNLEdBQUcsQ0FBQyxDQUFqQyxDQUFQO0FBQ0gsR0FIRDs7QUFJQSxNQUFJNGlDLEdBQUcsR0FBRyxTQUFOQSxHQUFNLENBQVVDLElBQVYsRUFBZ0I7QUFBRSxXQUFRQSxJQUFJLEtBQUssSUFBVCxHQUFnQixDQUFoQixHQUFvQixDQUE1QjtBQUFpQyxHQUE3RDtBQUNBOzs7QUFDQSxXQUFTQyxRQUFULENBQWtCamtDLElBQWxCLEVBQXdCa2tDLElBQXhCLEVBQThCQyxTQUE5QixFQUF5QztBQUNyQyxRQUFJQSxTQUFTLEtBQUssS0FBSyxDQUF2QixFQUEwQjtBQUFFQSxlQUFTLEdBQUcsS0FBWjtBQUFvQjs7QUFDaEQsUUFBSUMsT0FBSjtBQUNBLFdBQU8sWUFBWTtBQUNmLFVBQUkxK0IsT0FBTyxHQUFHLElBQWQ7QUFBQSxVQUFvQm5NLElBQUksR0FBRzhVLFNBQTNCO0FBQ0ErMUIsYUFBTyxLQUFLLElBQVosSUFBb0JDLFlBQVksQ0FBQ0QsT0FBRCxDQUFoQztBQUNBQSxhQUFPLEdBQUczOUIsTUFBTSxDQUFDb1osVUFBUCxDQUFrQixZQUFZO0FBQ3BDdWtCLGVBQU8sR0FBRyxJQUFWO0FBQ0EsWUFBSSxDQUFDRCxTQUFMLEVBQ0lua0MsSUFBSSxDQUFDYSxLQUFMLENBQVc2RSxPQUFYLEVBQW9Cbk0sSUFBcEI7QUFDUCxPQUpTLEVBSVAycUMsSUFKTyxDQUFWO0FBS0EsVUFBSUMsU0FBUyxJQUFJLENBQUNDLE9BQWxCLEVBQ0lwa0MsSUFBSSxDQUFDYSxLQUFMLENBQVc2RSxPQUFYLEVBQW9Cbk0sSUFBcEI7QUFDUCxLQVZEO0FBV0g7O0FBQ0QsTUFBSStxQyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVam1DLEdBQVYsRUFBZTtBQUMxQixXQUFPQSxHQUFHLFlBQVlKLEtBQWYsR0FBdUJJLEdBQXZCLEdBQTZCLENBQUNBLEdBQUQsQ0FBcEM7QUFDSCxHQUZEOztBQUlBLFdBQVNrbUMsV0FBVCxDQUFxQkMsSUFBckIsRUFBMkJDLFNBQTNCLEVBQXNDVCxJQUF0QyxFQUE0QztBQUN4QyxRQUFJQSxJQUFJLEtBQUssSUFBYixFQUNJLE9BQU9RLElBQUksQ0FBQ0UsU0FBTCxDQUFlQyxHQUFmLENBQW1CRixTQUFuQixDQUFQO0FBQ0pELFFBQUksQ0FBQ0UsU0FBTCxDQUFlRSxNQUFmLENBQXNCSCxTQUF0QjtBQUNIOztBQUNELFdBQVNJLGFBQVQsQ0FBdUJ2a0MsR0FBdkIsRUFBNEJta0MsU0FBNUIsRUFBdUN4b0MsT0FBdkMsRUFBZ0Q7QUFDNUMsUUFBSWlLLENBQUMsR0FBR08sTUFBTSxDQUFDVCxRQUFQLENBQWdCNitCLGFBQWhCLENBQThCdmtDLEdBQTlCLENBQVI7QUFDQW1rQyxhQUFTLEdBQUdBLFNBQVMsSUFBSSxFQUF6QjtBQUNBeG9DLFdBQU8sR0FBR0EsT0FBTyxJQUFJLEVBQXJCO0FBQ0FpSyxLQUFDLENBQUN1K0IsU0FBRixHQUFjQSxTQUFkO0FBQ0EsUUFBSXhvQyxPQUFPLEtBQUtvcEIsU0FBaEIsRUFDSW5mLENBQUMsQ0FBQzQrQixXQUFGLEdBQWdCN29DLE9BQWhCO0FBQ0osV0FBT2lLLENBQVA7QUFDSDs7QUFDRCxXQUFTNitCLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXlCO0FBQ3JCLFdBQU9BLElBQUksQ0FBQ0MsVUFBWjtBQUNJRCxVQUFJLENBQUNFLFdBQUwsQ0FBaUJGLElBQUksQ0FBQ0MsVUFBdEI7QUFESjtBQUVIOztBQUNELFdBQVNFLFVBQVQsQ0FBb0JILElBQXBCLEVBQTBCM3FDLFNBQTFCLEVBQXFDO0FBQ2pDLFFBQUlBLFNBQVMsQ0FBQzJxQyxJQUFELENBQWIsRUFDSSxPQUFPQSxJQUFQLENBREosS0FFSyxJQUFJQSxJQUFJLENBQUNJLFVBQVQsRUFDRCxPQUFPRCxVQUFVLENBQUNILElBQUksQ0FBQ0ksVUFBTixFQUFrQi9xQyxTQUFsQixDQUFqQjtBQUNKLFdBQU9nckIsU0FBUCxDQUxpQyxDQUtmO0FBQ3JCOztBQUNELFdBQVNnZ0IsaUJBQVQsQ0FBMkJDLGNBQTNCLEVBQTJDQyxJQUEzQyxFQUFpRDtBQUM3QyxRQUFJeGpCLE9BQU8sR0FBRzhpQixhQUFhLENBQUMsS0FBRCxFQUFRLGlCQUFSLENBQTNCO0FBQUEsUUFBdURXLFFBQVEsR0FBR1gsYUFBYSxDQUFDLE9BQUQsRUFBVSxjQUFjUyxjQUF4QixDQUEvRTtBQUFBLFFBQXdIRyxPQUFPLEdBQUdaLGFBQWEsQ0FBQyxNQUFELEVBQVMsU0FBVCxDQUEvSTtBQUFBLFFBQW9LYSxTQUFTLEdBQUdiLGFBQWEsQ0FBQyxNQUFELEVBQVMsV0FBVCxDQUE3TDs7QUFDQSxRQUFJM0QsU0FBUyxDQUFDQyxTQUFWLENBQW9CbmEsT0FBcEIsQ0FBNEIsVUFBNUIsTUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtBQUNoRHdlLGNBQVEsQ0FBQzltQyxJQUFULEdBQWdCLFFBQWhCO0FBQ0gsS0FGRCxNQUdLO0FBQ0Q4bUMsY0FBUSxDQUFDOW1DLElBQVQsR0FBZ0IsTUFBaEI7QUFDQThtQyxjQUFRLENBQUN6N0IsT0FBVCxHQUFtQixNQUFuQjtBQUNIOztBQUNELFFBQUl3N0IsSUFBSSxLQUFLbGdCLFNBQWIsRUFDSSxLQUFLLElBQUk1c0IsR0FBVCxJQUFnQjhzQyxJQUFoQjtBQUNJQyxjQUFRLENBQUNHLFlBQVQsQ0FBc0JsdEMsR0FBdEIsRUFBMkI4c0MsSUFBSSxDQUFDOXNDLEdBQUQsQ0FBL0I7QUFESjtBQUVKc3BCLFdBQU8sQ0FBQzZqQixXQUFSLENBQW9CSixRQUFwQjtBQUNBempCLFdBQU8sQ0FBQzZqQixXQUFSLENBQW9CSCxPQUFwQjtBQUNBMWpCLFdBQU8sQ0FBQzZqQixXQUFSLENBQW9CRixTQUFwQjtBQUNBLFdBQU8zakIsT0FBUDtBQUNIOztBQUNELFdBQVM4akIsY0FBVCxDQUF3QnQ4QixLQUF4QixFQUErQjtBQUMzQixRQUFJO0FBQ0EsVUFBSSxPQUFPQSxLQUFLLENBQUN1OEIsWUFBYixLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxZQUFJQyxJQUFJLEdBQUd4OEIsS0FBSyxDQUFDdThCLFlBQU4sRUFBWDtBQUNBLGVBQU9DLElBQUksQ0FBQyxDQUFELENBQVg7QUFDSDs7QUFDRCxhQUFPeDhCLEtBQUssQ0FBQ3ZRLE1BQWI7QUFDSCxLQU5ELENBT0EsT0FBTzJRLEtBQVAsRUFBYztBQUNWLGFBQU9KLEtBQUssQ0FBQ3ZRLE1BQWI7QUFDSDtBQUNKOztBQUVELE1BQUlndEMsU0FBUyxHQUFHLFNBQVpBLFNBQVksR0FBWTtBQUFFLFdBQU8zZ0IsU0FBUDtBQUFtQixHQUFqRDs7QUFDQSxNQUFJNGdCLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVVDLFdBQVYsRUFBdUI5b0IsU0FBdkIsRUFBa0N6SCxNQUFsQyxFQUEwQztBQUFFLFdBQU9BLE1BQU0sQ0FBQzJILE1BQVAsQ0FBY0YsU0FBUyxHQUFHLFdBQUgsR0FBaUIsVUFBeEMsRUFBb0Q4b0IsV0FBcEQsQ0FBUDtBQUEwRSxHQUF2STs7QUFDQSxNQUFJQyxTQUFTLEdBQUc7QUFDWjFhLEtBQUMsRUFBRXVhLFNBRFM7QUFFWkksS0FBQyxFQUFFLFdBQVVDLE9BQVYsRUFBbUJDLFNBQW5CLEVBQThCM3dCLE1BQTlCLEVBQXNDO0FBQ3JDMHdCLGFBQU8sQ0FBQ0UsUUFBUixDQUFpQjV3QixNQUFNLENBQUMySCxNQUFQLENBQWNELFFBQWQsQ0FBdUIySixPQUF2QixDQUErQnNmLFNBQS9CLENBQWpCO0FBQ0gsS0FKVztBQUtaRSxLQUFDLEVBQUUsV0FBVUgsT0FBVixFQUFtQnp2QixJQUFuQixFQUF5QjtBQUN4Qnl2QixhQUFPLENBQUNyRSxRQUFSLENBQWlCeG5CLFVBQVUsQ0FBQzVELElBQUQsQ0FBM0I7QUFDSCxLQVBXO0FBUVptVixLQUFDLEVBQUUsV0FBVXNhLE9BQVYsRUFBbUJ6dkIsSUFBbkIsRUFBeUI7QUFDeEJ5dkIsYUFBTyxDQUFDckUsUUFBUixDQUFpQnhuQixVQUFVLENBQUM1RCxJQUFELENBQTNCO0FBQ0gsS0FWVztBQVdaMlcsS0FBQyxFQUFFLFdBQVU4WSxPQUFWLEVBQW1CMXZCLEdBQW5CLEVBQXdCO0FBQ3ZCMHZCLGFBQU8sQ0FBQ3BFLE9BQVIsQ0FBZ0J6bkIsVUFBVSxDQUFDN0QsR0FBRCxDQUExQjtBQUNILEtBYlc7QUFjWjh2QixLQUFDLEVBQUUsV0FBVUosT0FBVixFQUFtQnZvQixJQUFuQixFQUF5Qm5JLE1BQXpCLEVBQWlDO0FBQ2hDMHdCLGFBQU8sQ0FBQ3JFLFFBQVIsQ0FBa0JxRSxPQUFPLENBQUN0YyxRQUFSLEtBQXFCLEVBQXRCLEdBQ2IsS0FBS2dhLEdBQUcsQ0FBQyxJQUFJejRCLE1BQUosQ0FBV3FLLE1BQU0sQ0FBQ21JLElBQVAsQ0FBWSxDQUFaLENBQVgsRUFBMkIsR0FBM0IsRUFBZ0N3SyxJQUFoQyxDQUFxQ3hLLElBQXJDLENBQUQsQ0FEWjtBQUVILEtBakJXO0FBa0JacU4sS0FBQyxFQUFFLFdBQVVrYixPQUFWLEVBQW1CSyxVQUFuQixFQUErQi93QixNQUEvQixFQUF1QztBQUN0QzB3QixhQUFPLENBQUNFLFFBQVIsQ0FBaUI1d0IsTUFBTSxDQUFDMkgsTUFBUCxDQUFjRixTQUFkLENBQXdCNEosT0FBeEIsQ0FBZ0MwZixVQUFoQyxDQUFqQjtBQUNILEtBcEJXO0FBcUJaQyxLQUFDLEVBQUUsV0FBVU4sT0FBVixFQUFtQjNyQixPQUFuQixFQUE0QjtBQUMzQjJyQixhQUFPLENBQUMzVyxVQUFSLENBQW1CbFYsVUFBVSxDQUFDRSxPQUFELENBQTdCO0FBQ0gsS0F2Qlc7QUF3Qlprc0IsS0FBQyxFQUFFLFdBQVVDLENBQVYsRUFBYUMsV0FBYixFQUEwQjtBQUFFLGFBQU8sSUFBSXBpQyxJQUFKLENBQVM4VixVQUFVLENBQUNzc0IsV0FBRCxDQUFWLEdBQTBCLElBQW5DLENBQVA7QUFBa0QsS0F4QnJFO0FBeUJaalosS0FBQyxFQUFFLFdBQVV3WSxPQUFWLEVBQW1CVSxPQUFuQixFQUE0QnB4QixNQUE1QixFQUFvQztBQUNuQyxVQUFJdVUsVUFBVSxHQUFHL2xCLFFBQVEsQ0FBQzRpQyxPQUFELENBQXpCO0FBQ0EsVUFBSTVqQyxJQUFJLEdBQUcsSUFBSXVCLElBQUosQ0FBUzJoQyxPQUFPLENBQUNsZSxXQUFSLEVBQVQsRUFBZ0MsQ0FBaEMsRUFBbUMsSUFBSSxDQUFDK0IsVUFBVSxHQUFHLENBQWQsSUFBbUIsQ0FBMUQsRUFBNkQsQ0FBN0QsRUFBZ0UsQ0FBaEUsRUFBbUUsQ0FBbkUsRUFBc0UsQ0FBdEUsQ0FBWDtBQUNBL21CLFVBQUksQ0FBQzgrQixPQUFMLENBQWE5K0IsSUFBSSxDQUFDMGxCLE9BQUwsS0FBaUIxbEIsSUFBSSxDQUFDOG1CLE1BQUwsRUFBakIsR0FBaUN0VSxNQUFNLENBQUM2SCxjQUFyRDtBQUNBLGFBQU9yYSxJQUFQO0FBQ0gsS0E5Qlc7QUErQlowbkIsS0FBQyxFQUFFLFdBQVV3YixPQUFWLEVBQW1CNXZCLElBQW5CLEVBQXlCO0FBQ3hCNHZCLGFBQU8sQ0FBQ1csV0FBUixDQUFvQnhzQixVQUFVLENBQUMvRCxJQUFELENBQTlCO0FBQ0gsS0FqQ1c7QUFrQ1p3d0IsS0FBQyxFQUFFLFdBQVVKLENBQVYsRUFBYUssT0FBYixFQUFzQjtBQUFFLGFBQU8sSUFBSXhpQyxJQUFKLENBQVN3aUMsT0FBVCxDQUFQO0FBQTJCLEtBbEMxQztBQW1DWnprQixLQUFDLEVBQUUsV0FBVTRqQixPQUFWLEVBQW1CMXZCLEdBQW5CLEVBQXdCO0FBQ3ZCMHZCLGFBQU8sQ0FBQ3BFLE9BQVIsQ0FBZ0J6bkIsVUFBVSxDQUFDN0QsR0FBRCxDQUExQjtBQUNILEtBckNXO0FBc0NaMFYsS0FBQyxFQUFFLFdBQVVnYSxPQUFWLEVBQW1CenZCLElBQW5CLEVBQXlCO0FBQ3hCeXZCLGFBQU8sQ0FBQ3JFLFFBQVIsQ0FBaUJ4bkIsVUFBVSxDQUFDNUQsSUFBRCxDQUEzQjtBQUNILEtBeENXO0FBeUNacmUsS0FBQyxFQUFFLFdBQVU4dEMsT0FBVixFQUFtQi9oQyxPQUFuQixFQUE0QjtBQUMzQitoQyxhQUFPLENBQUNjLFVBQVIsQ0FBbUIzc0IsVUFBVSxDQUFDbFcsT0FBRCxDQUE3QjtBQUNILEtBM0NXO0FBNENaaThCLEtBQUMsRUFBRSxXQUFVOEYsT0FBVixFQUFtQjF2QixHQUFuQixFQUF3QjtBQUN2QjB2QixhQUFPLENBQUNwRSxPQUFSLENBQWdCem5CLFVBQVUsQ0FBQzdELEdBQUQsQ0FBMUI7QUFDSCxLQTlDVztBQStDWm5lLEtBQUMsRUFBRXd0QyxTQS9DUztBQWdEWnhqQixLQUFDLEVBQUUsV0FBVTZqQixPQUFWLEVBQW1CM3ZCLEtBQW5CLEVBQTBCO0FBQ3pCMnZCLGFBQU8sQ0FBQ0UsUUFBUixDQUFpQi9yQixVQUFVLENBQUM5RCxLQUFELENBQVYsR0FBb0IsQ0FBckM7QUFDSCxLQWxEVztBQW1EWmtNLEtBQUMsRUFBRSxXQUFVeWpCLE9BQVYsRUFBbUIzdkIsS0FBbkIsRUFBMEI7QUFDekIydkIsYUFBTyxDQUFDRSxRQUFSLENBQWlCL3JCLFVBQVUsQ0FBQzlELEtBQUQsQ0FBVixHQUFvQixDQUFyQztBQUNILEtBckRXO0FBc0RaeU0sS0FBQyxFQUFFLFdBQVVrakIsT0FBVixFQUFtQjNyQixPQUFuQixFQUE0QjtBQUMzQjJyQixhQUFPLENBQUMzVyxVQUFSLENBQW1CbFYsVUFBVSxDQUFDRSxPQUFELENBQTdCO0FBQ0gsS0F4RFc7QUF5RFowc0IsS0FBQyxFQUFFLFdBQVVQLENBQVYsRUFBYVEsZUFBYixFQUE4QjtBQUM3QixhQUFPLElBQUkzaUMsSUFBSixDQUFTOFYsVUFBVSxDQUFDNnNCLGVBQUQsQ0FBbkIsQ0FBUDtBQUNILEtBM0RXO0FBNERabFosS0FBQyxFQUFFNlgsU0E1RFM7QUE2RFpzQixLQUFDLEVBQUUsV0FBVWpCLE9BQVYsRUFBbUI1dkIsSUFBbkIsRUFBeUI7QUFDeEI0dkIsYUFBTyxDQUFDVyxXQUFSLENBQW9CLE9BQU94c0IsVUFBVSxDQUFDL0QsSUFBRCxDQUFyQztBQUNIO0FBL0RXLEdBQWhCO0FBaUVBLE1BQUk4d0IsVUFBVSxHQUFHO0FBQ2I5YixLQUFDLEVBQUUsUUFEVTtBQUViMmEsS0FBQyxFQUFFLFFBRlU7QUFHYkksS0FBQyxFQUFFLGNBSFU7QUFJYnphLEtBQUMsRUFBRSxjQUpVO0FBS2J3QixLQUFDLEVBQUUsa0JBTFU7QUFNYmtaLEtBQUMsRUFBRSxFQU5VO0FBT2J0YixLQUFDLEVBQUUsUUFQVTtBQVFid2IsS0FBQyxFQUFFLGNBUlU7QUFTYkMsS0FBQyxFQUFFLE1BVFU7QUFVYi9ZLEtBQUMsRUFBRSxjQVZVO0FBV2JoRCxLQUFDLEVBQUUsVUFYVTtBQVlib2MsS0FBQyxFQUFFLE1BWlU7QUFhYnhrQixLQUFDLEVBQUUsY0FiVTtBQWNiNEosS0FBQyxFQUFFLGNBZFU7QUFlYjl6QixLQUFDLEVBQUUsY0FmVTtBQWdCYmdvQyxLQUFDLEVBQUUsY0FoQlU7QUFpQmIvbkMsS0FBQyxFQUFFLFFBakJVO0FBa0JiZ3FCLEtBQUMsRUFBRSxjQWxCVTtBQW1CYkksS0FBQyxFQUFFLGNBbkJVO0FBb0JiTyxLQUFDLEVBQUUsY0FwQlU7QUFxQmJpa0IsS0FBQyxFQUFFLE1BckJVO0FBc0JialosS0FBQyxFQUFFLGNBdEJVO0FBdUJibVosS0FBQyxFQUFFO0FBdkJVLEdBQWpCO0FBeUJBLE1BQUlFLE9BQU8sR0FBRztBQUNWO0FBQ0FQLEtBQUMsRUFBRSxXQUFVOWpDLElBQVYsRUFBZ0I7QUFBRSxhQUFPQSxJQUFJLENBQUNza0MsV0FBTCxFQUFQO0FBQTRCLEtBRnZDO0FBR1Y7QUFDQWhjLEtBQUMsRUFBRSxXQUFVdG9CLElBQVYsRUFBZ0J3UyxNQUFoQixFQUF3Qm5QLE9BQXhCLEVBQWlDO0FBQ2hDLGFBQU9tUCxNQUFNLENBQUN3SCxRQUFQLENBQWdCQyxTQUFoQixDQUEwQm9xQixPQUFPLENBQUNyWixDQUFSLENBQVVockIsSUFBVixFQUFnQndTLE1BQWhCLEVBQXdCblAsT0FBeEIsQ0FBMUIsQ0FBUDtBQUNILEtBTlM7QUFPVjtBQUNBNC9CLEtBQUMsRUFBRSxXQUFVampDLElBQVYsRUFBZ0J3UyxNQUFoQixFQUF3Qm5QLE9BQXhCLEVBQWlDO0FBQ2hDLGFBQU95L0IsVUFBVSxDQUFDdUIsT0FBTyxDQUFDNWtCLENBQVIsQ0FBVXpmLElBQVYsRUFBZ0J3UyxNQUFoQixFQUF3Qm5QLE9BQXhCLElBQW1DLENBQXBDLEVBQXVDLEtBQXZDLEVBQThDbVAsTUFBOUMsQ0FBakI7QUFDSCxLQVZTO0FBV1Y7QUFDQTZ3QixLQUFDLEVBQUUsV0FBVXJqQyxJQUFWLEVBQWdCd1MsTUFBaEIsRUFBd0JuUCxPQUF4QixFQUFpQztBQUNoQyxhQUFPaWlCLEdBQUcsQ0FBQytlLE9BQU8sQ0FBQ25iLENBQVIsQ0FBVWxwQixJQUFWLEVBQWdCd1MsTUFBaEIsRUFBd0JuUCxPQUF4QixDQUFELENBQVY7QUFDSCxLQWRTO0FBZVY7QUFDQXVsQixLQUFDLEVBQUUsV0FBVTVvQixJQUFWLEVBQWdCO0FBQUUsYUFBT3NsQixHQUFHLENBQUN0bEIsSUFBSSxDQUFDNG1CLFFBQUwsRUFBRCxDQUFWO0FBQThCLEtBaEJ6QztBQWlCVjtBQUNBd0QsS0FBQyxFQUFFLFdBQVVwcUIsSUFBVixFQUFnQndTLE1BQWhCLEVBQXdCO0FBQ3ZCLGFBQU9BLE1BQU0sQ0FBQzhILE9BQVAsS0FBbUI0SCxTQUFuQixHQUNEbGlCLElBQUksQ0FBQzBsQixPQUFMLEtBQWlCbFQsTUFBTSxDQUFDOEgsT0FBUCxDQUFldGEsSUFBSSxDQUFDMGxCLE9BQUwsRUFBZixDQURoQixHQUVEMWxCLElBQUksQ0FBQzBsQixPQUFMLEVBRk47QUFHSCxLQXRCUztBQXVCVjtBQUNBNGQsS0FBQyxFQUFFLFdBQVV0akMsSUFBVixFQUFnQndTLE1BQWhCLEVBQXdCO0FBQUUsYUFBT0EsTUFBTSxDQUFDbUksSUFBUCxDQUFZaW1CLEdBQUcsQ0FBQzVnQyxJQUFJLENBQUM0bUIsUUFBTCxLQUFrQixFQUFuQixDQUFmLENBQVA7QUFBZ0QsS0F4Qm5FO0FBeUJWO0FBQ0FvQixLQUFDLEVBQUUsV0FBVWhvQixJQUFWLEVBQWdCd1MsTUFBaEIsRUFBd0I7QUFDdkIsYUFBT3N3QixVQUFVLENBQUM5aUMsSUFBSSxDQUFDeWxCLFFBQUwsRUFBRCxFQUFrQixJQUFsQixFQUF3QmpULE1BQXhCLENBQWpCO0FBQ0gsS0E1QlM7QUE2QlY7QUFDQWd4QixLQUFDLEVBQUUsV0FBVXhqQyxJQUFWLEVBQWdCO0FBQUUsYUFBT3NsQixHQUFHLENBQUN0bEIsSUFBSSxDQUFDMG1CLFVBQUwsRUFBRCxDQUFWO0FBQWdDLEtBOUIzQztBQStCVjtBQUNBK2MsS0FBQyxFQUFFLFdBQVV6akMsSUFBVixFQUFnQjtBQUFFLGFBQU9BLElBQUksQ0FBQzJnQixPQUFMLEtBQWlCLElBQXhCO0FBQStCLEtBaEMxQztBQWlDVitKLEtBQUMsRUFBRSxXQUFVMXFCLElBQVYsRUFBZ0IwakMsQ0FBaEIsRUFBbUJyZ0MsT0FBbkIsRUFBNEI7QUFDM0IsYUFBT0EsT0FBTyxDQUFDczdCLE9BQVIsQ0FBZ0IzK0IsSUFBaEIsQ0FBUDtBQUNILEtBbkNTO0FBb0NWO0FBQ0EwbkIsS0FBQyxFQUFFLFdBQVUxbkIsSUFBVixFQUFnQjtBQUFFLGFBQU9zbEIsR0FBRyxDQUFDdGxCLElBQUksQ0FBQ2dsQixXQUFMLEVBQUQsRUFBcUIsQ0FBckIsQ0FBVjtBQUFvQyxLQXJDL0M7QUFzQ1Y7QUFDQTFGLEtBQUMsRUFBRSxXQUFVdGYsSUFBVixFQUFnQjtBQUFFLGFBQU9zbEIsR0FBRyxDQUFDdGxCLElBQUksQ0FBQzBsQixPQUFMLEVBQUQsQ0FBVjtBQUE2QixLQXZDeEM7QUF3Q1Y7QUFDQXdELEtBQUMsRUFBRSxXQUFVbHBCLElBQVYsRUFBZ0I7QUFBRSxhQUFRQSxJQUFJLENBQUM0bUIsUUFBTCxLQUFrQixFQUFsQixHQUF1QjVtQixJQUFJLENBQUM0bUIsUUFBTCxLQUFrQixFQUF6QyxHQUE4QyxFQUF0RDtBQUE0RCxLQXpDdkU7QUEwQ1Y7QUFDQXh4QixLQUFDLEVBQUUsV0FBVTRLLElBQVYsRUFBZ0I7QUFBRSxhQUFPc2xCLEdBQUcsQ0FBQ3RsQixJQUFJLENBQUN5bUIsVUFBTCxFQUFELENBQVY7QUFBZ0MsS0EzQzNDO0FBNENWO0FBQ0EyVyxLQUFDLEVBQUUsV0FBVXA5QixJQUFWLEVBQWdCO0FBQUUsYUFBT0EsSUFBSSxDQUFDMGxCLE9BQUwsRUFBUDtBQUF3QixLQTdDbkM7QUE4Q1Y7QUFDQXJ3QixLQUFDLEVBQUUsV0FBVTJLLElBQVYsRUFBZ0J3UyxNQUFoQixFQUF3QjtBQUN2QixhQUFPQSxNQUFNLENBQUN3SCxRQUFQLENBQWdCRSxRQUFoQixDQUF5QmxhLElBQUksQ0FBQzhtQixNQUFMLEVBQXpCLENBQVA7QUFDSCxLQWpEUztBQWtEVjtBQUNBekgsS0FBQyxFQUFFLFdBQVVyZixJQUFWLEVBQWdCO0FBQUUsYUFBT3NsQixHQUFHLENBQUN0bEIsSUFBSSxDQUFDeWxCLFFBQUwsS0FBa0IsQ0FBbkIsQ0FBVjtBQUFrQyxLQW5EN0M7QUFvRFY7QUFDQWhHLEtBQUMsRUFBRSxXQUFVemYsSUFBVixFQUFnQjtBQUFFLGFBQU9BLElBQUksQ0FBQ3lsQixRQUFMLEtBQWtCLENBQXpCO0FBQTZCLEtBckR4QztBQXNEVjtBQUNBekYsS0FBQyxFQUFFLFdBQVVoZ0IsSUFBVixFQUFnQjtBQUFFLGFBQU9BLElBQUksQ0FBQzBtQixVQUFMLEVBQVA7QUFBMkIsS0F2RHRDO0FBd0RWO0FBQ0F1ZCxLQUFDLEVBQUUsV0FBVWprQyxJQUFWLEVBQWdCO0FBQUUsYUFBT0EsSUFBSSxDQUFDMmdCLE9BQUwsRUFBUDtBQUF3QixLQXpEbkM7QUEwRFY7QUFDQXFLLEtBQUMsRUFBRSxXQUFVaHJCLElBQVYsRUFBZ0I7QUFBRSxhQUFPQSxJQUFJLENBQUM4bUIsTUFBTCxFQUFQO0FBQXVCLEtBM0RsQztBQTREVjtBQUNBcWQsS0FBQyxFQUFFLFdBQVVua0MsSUFBVixFQUFnQjtBQUFFLGFBQU82QixNQUFNLENBQUM3QixJQUFJLENBQUNnbEIsV0FBTCxFQUFELENBQU4sQ0FBMkJKLFNBQTNCLENBQXFDLENBQXJDLENBQVA7QUFBaUQ7QUE3RDVELEdBQWQ7O0FBZ0VBLE1BQUkyZixtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLENBQVVDLEVBQVYsRUFBYztBQUNwQyxRQUFJQyxFQUFFLEdBQUdELEVBQUUsQ0FBQ0UsTUFBWjtBQUFBLFFBQW9CQSxNQUFNLEdBQUdELEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0JsSCxRQUFoQixHQUEyQmtILEVBQXhEO0FBQUEsUUFBNERFLEVBQUUsR0FBR0gsRUFBRSxDQUFDSSxJQUFwRTtBQUFBLFFBQTBFQSxJQUFJLEdBQUdELEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0JsRSxPQUFoQixHQUEwQmtFLEVBQTNHO0FBQUEsUUFBK0dFLEVBQUUsR0FBR0wsRUFBRSxDQUFDTSxRQUF2SDtBQUFBLFFBQWlJQSxRQUFRLEdBQUdELEVBQUUsS0FBSyxLQUFLLENBQVosR0FBZ0IsS0FBaEIsR0FBd0JBLEVBQXBLO0FBQ0EsV0FBTyxVQUFVM0IsT0FBVixFQUFtQjZCLElBQW5CLEVBQXlCQyxjQUF6QixFQUF5QztBQUM1QyxVQUFJeHlCLE1BQU0sR0FBR3d5QixjQUFjLElBQUlKLElBQS9COztBQUNBLFVBQUlGLE1BQU0sQ0FBQzFyQixVQUFQLEtBQXNCa0osU0FBdEIsSUFBbUMsQ0FBQzRpQixRQUF4QyxFQUFrRDtBQUM5QyxlQUFPSixNQUFNLENBQUMxckIsVUFBUCxDQUFrQmtxQixPQUFsQixFQUEyQjZCLElBQTNCLEVBQWlDdnlCLE1BQWpDLENBQVA7QUFDSDs7QUFDRCxhQUFPdXlCLElBQUksQ0FDTm5uQixLQURFLENBQ0ksRUFESixFQUVGcW5CLEdBRkUsQ0FFRSxVQUFVNW5CLENBQVYsRUFBYWpvQixDQUFiLEVBQWdCOHZDLEdBQWhCLEVBQXFCO0FBQzFCLGVBQU9iLE9BQU8sQ0FBQ2huQixDQUFELENBQVAsSUFBYzZuQixHQUFHLENBQUM5dkMsQ0FBQyxHQUFHLENBQUwsQ0FBSCxLQUFlLElBQTdCLEdBQ0RpdkMsT0FBTyxDQUFDaG5CLENBQUQsQ0FBUCxDQUFXNmxCLE9BQVgsRUFBb0Ixd0IsTUFBcEIsRUFBNEJreUIsTUFBNUIsQ0FEQyxHQUVEcm5CLENBQUMsS0FBSyxJQUFOLEdBQ0lBLENBREosR0FFSSxFQUpWO0FBS0gsT0FSTSxFQVNGOEcsSUFURSxDQVNHLEVBVEgsQ0FBUDtBQVVILEtBZkQ7QUFnQkgsR0FsQkQ7O0FBbUJBLE1BQUlnaEIsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFVWCxFQUFWLEVBQWM7QUFDakMsUUFBSUMsRUFBRSxHQUFHRCxFQUFFLENBQUNFLE1BQVo7QUFBQSxRQUFvQkEsTUFBTSxHQUFHRCxFQUFFLEtBQUssS0FBSyxDQUFaLEdBQWdCbEgsUUFBaEIsR0FBMkJrSCxFQUF4RDtBQUFBLFFBQTRERSxFQUFFLEdBQUdILEVBQUUsQ0FBQ0ksSUFBcEU7QUFBQSxRQUEwRUEsSUFBSSxHQUFHRCxFQUFFLEtBQUssS0FBSyxDQUFaLEdBQWdCbEUsT0FBaEIsR0FBMEJrRSxFQUEzRztBQUNBLFdBQU8sVUFBVTNrQyxJQUFWLEVBQWdCb2xDLFdBQWhCLEVBQTZCQyxRQUE3QixFQUF1Q0MsWUFBdkMsRUFBcUQ7QUFDeEQsVUFBSXRsQyxJQUFJLEtBQUssQ0FBVCxJQUFjLENBQUNBLElBQW5CLEVBQ0ksT0FBT2tpQixTQUFQO0FBQ0osVUFBSTFQLE1BQU0sR0FBRzh5QixZQUFZLElBQUlWLElBQTdCO0FBQ0EsVUFBSVcsVUFBSjtBQUNBLFVBQUlDLFFBQVEsR0FBR3hsQyxJQUFmO0FBQ0EsVUFBSUEsSUFBSSxZQUFZdUIsSUFBcEIsRUFDSWdrQyxVQUFVLEdBQUcsSUFBSWhrQyxJQUFKLENBQVN2QixJQUFJLENBQUMyZ0IsT0FBTCxFQUFULENBQWIsQ0FESixLQUVLLElBQUksT0FBTzNnQixJQUFQLEtBQWdCLFFBQWhCLElBQ0xBLElBQUksQ0FBQ3lsQyxPQUFMLEtBQWlCdmpCLFNBRGhCLENBQzBCO0FBRDFCLFFBR0Q7QUFDQXFqQixrQkFBVSxHQUFHLElBQUloa0MsSUFBSixDQUFTdkIsSUFBVCxDQUFiLENBSkMsS0FLQSxJQUFJLE9BQU9BLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDL0I7QUFDQSxZQUFJdVosTUFBTSxHQUFHNnJCLFdBQVcsSUFBSSxDQUFDVixNQUFNLElBQUluSCxRQUFYLEVBQXFCNWtCLFVBQWpEO0FBQ0EsWUFBSStzQixPQUFPLEdBQUc3akMsTUFBTSxDQUFDN0IsSUFBRCxDQUFOLENBQWEybEMsSUFBYixFQUFkOztBQUNBLFlBQUlELE9BQU8sS0FBSyxPQUFoQixFQUF5QjtBQUNyQkgsb0JBQVUsR0FBRyxJQUFJaGtDLElBQUosRUFBYjtBQUNBOGpDLGtCQUFRLEdBQUcsSUFBWDtBQUNILFNBSEQsTUFJSyxJQUFJLEtBQUtsZ0IsSUFBTCxDQUFVdWdCLE9BQVYsS0FDTCxPQUFPdmdCLElBQVAsQ0FBWXVnQixPQUFaLENBREMsQ0FDb0I7QUFEcEIsVUFHREgsVUFBVSxHQUFHLElBQUloa0MsSUFBSixDQUFTdkIsSUFBVCxDQUFiLENBSEMsS0FJQSxJQUFJMGtDLE1BQU0sSUFBSUEsTUFBTSxDQUFDdHVCLFNBQXJCLEVBQ0RtdkIsVUFBVSxHQUFHYixNQUFNLENBQUN0dUIsU0FBUCxDQUFpQnBXLElBQWpCLEVBQXVCdVosTUFBdkIsQ0FBYixDQURDLEtBRUE7QUFDRGdzQixvQkFBVSxHQUNOLENBQUNiLE1BQUQsSUFBVyxDQUFDQSxNQUFNLENBQUNoc0IsVUFBbkIsR0FDTSxJQUFJblgsSUFBSixDQUFTLElBQUlBLElBQUosR0FBV3lqQixXQUFYLEVBQVQsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEMsRUFBeUMsQ0FBekMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QsQ0FBbEQsQ0FETixHQUVNLElBQUl6akIsSUFBSixDQUFTLElBQUlBLElBQUosR0FBV3M5QixRQUFYLENBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLENBQTdCLENBQVQsQ0FIVjtBQUlBLGNBQUkrRyxPQUFPLEdBQUcsS0FBSyxDQUFuQjtBQUFBLGNBQXNCQyxHQUFHLEdBQUcsRUFBNUI7O0FBQ0EsZUFBSyxJQUFJendDLENBQUMsR0FBRyxDQUFSLEVBQVcwd0MsVUFBVSxHQUFHLENBQXhCLEVBQTJCQyxRQUFRLEdBQUcsRUFBM0MsRUFBK0Mzd0MsQ0FBQyxHQUFHbWtCLE1BQU0sQ0FBQ3ZiLE1BQTFELEVBQWtFNUksQ0FBQyxFQUFuRSxFQUF1RTtBQUNuRSxnQkFBSTR3QyxPQUFPLEdBQUd6c0IsTUFBTSxDQUFDbmtCLENBQUQsQ0FBcEI7QUFDQSxnQkFBSTZ3QyxXQUFXLEdBQUdELE9BQU8sS0FBSyxJQUE5QjtBQUNBLGdCQUFJRSxPQUFPLEdBQUczc0IsTUFBTSxDQUFDbmtCLENBQUMsR0FBRyxDQUFMLENBQU4sS0FBa0IsSUFBbEIsSUFBMEI2d0MsV0FBeEM7O0FBQ0EsZ0JBQUk3QixVQUFVLENBQUM0QixPQUFELENBQVYsSUFBdUIsQ0FBQ0UsT0FBNUIsRUFBcUM7QUFDakNILHNCQUFRLElBQUkzQixVQUFVLENBQUM0QixPQUFELENBQXRCO0FBQ0Esa0JBQUl0OUIsS0FBSyxHQUFHLElBQUlQLE1BQUosQ0FBVzQ5QixRQUFYLEVBQXFCdGxCLElBQXJCLENBQTBCemdCLElBQTFCLENBQVo7O0FBQ0Esa0JBQUkwSSxLQUFLLEtBQUtrOUIsT0FBTyxHQUFHLElBQWYsQ0FBVCxFQUErQjtBQUMzQkMsbUJBQUcsQ0FBQ0csT0FBTyxLQUFLLEdBQVosR0FBa0IsTUFBbEIsR0FBMkIsU0FBNUIsQ0FBSCxDQUEwQztBQUN0Q3J4QyxvQkFBRSxFQUFFcXVDLFNBQVMsQ0FBQ2dELE9BQUQsQ0FEeUI7QUFFdENHLHFCQUFHLEVBQUV6OUIsS0FBSyxDQUFDLEVBQUVvOUIsVUFBSDtBQUY0QixpQkFBMUM7QUFJSDtBQUNKLGFBVEQsTUFVSyxJQUFJLENBQUNHLFdBQUwsRUFDREYsUUFBUSxJQUFJLEdBQVosQ0FmK0QsQ0FlOUM7OztBQUNyQkYsZUFBRyxDQUFDTyxPQUFKLENBQVksVUFBVTVCLEVBQVYsRUFBYztBQUN0QixrQkFBSTd2QyxFQUFFLEdBQUc2dkMsRUFBRSxDQUFDN3ZDLEVBQVo7QUFBQSxrQkFBZ0J3eEMsR0FBRyxHQUFHM0IsRUFBRSxDQUFDMkIsR0FBekI7QUFDQSxxQkFBUVosVUFBVSxHQUFHNXdDLEVBQUUsQ0FBQzR3QyxVQUFELEVBQWFZLEdBQWIsRUFBa0IzekIsTUFBbEIsQ0FBRixJQUErQit5QixVQUFwRDtBQUNILGFBSEQ7QUFJSDs7QUFDREEsb0JBQVUsR0FBR0ssT0FBTyxHQUFHTCxVQUFILEdBQWdCcmpCLFNBQXBDO0FBQ0g7QUFDSjtBQUNEOztBQUNBLFVBQUksRUFBRXFqQixVQUFVLFlBQVloa0MsSUFBdEIsSUFBOEIsQ0FBQ2pGLEtBQUssQ0FBQ2lwQyxVQUFVLENBQUM1a0IsT0FBWCxFQUFELENBQXRDLENBQUosRUFBbUU7QUFDL0QrakIsY0FBTSxDQUFDakcsWUFBUCxDQUFvQixJQUFJM1MsS0FBSixDQUFVLDRCQUE0QjBaLFFBQXRDLENBQXBCO0FBQ0EsZUFBT3RqQixTQUFQO0FBQ0g7O0FBQ0QsVUFBSW1qQixRQUFRLEtBQUssSUFBakIsRUFDSUUsVUFBVSxDQUFDMUcsUUFBWCxDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QjtBQUNKLGFBQU8wRyxVQUFQO0FBQ0gsS0FqRUQ7QUFrRUgsR0FwRUQ7QUFxRUE7QUFDSjtBQUNBOzs7QUFDSSxXQUFTYyxZQUFULENBQXNCQyxLQUF0QixFQUE2QkMsS0FBN0IsRUFBb0NsQixRQUFwQyxFQUE4QztBQUMxQyxRQUFJQSxRQUFRLEtBQUssS0FBSyxDQUF0QixFQUF5QjtBQUFFQSxjQUFRLEdBQUcsSUFBWDtBQUFrQjs7QUFDN0MsUUFBSUEsUUFBUSxLQUFLLEtBQWpCLEVBQXdCO0FBQ3BCLGFBQVEsSUFBSTlqQyxJQUFKLENBQVMra0MsS0FBSyxDQUFDM2xCLE9BQU4sRUFBVCxFQUEwQmtlLFFBQTFCLENBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDLEVBQTRDLENBQTVDLElBQ0osSUFBSXQ5QixJQUFKLENBQVNnbEMsS0FBSyxDQUFDNWxCLE9BQU4sRUFBVCxFQUEwQmtlLFFBQTFCLENBQW1DLENBQW5DLEVBQXNDLENBQXRDLEVBQXlDLENBQXpDLEVBQTRDLENBQTVDLENBREo7QUFFSDs7QUFDRCxXQUFPeUgsS0FBSyxDQUFDM2xCLE9BQU4sS0FBa0I0bEIsS0FBSyxDQUFDNWxCLE9BQU4sRUFBekI7QUFDSDs7QUFDRCxNQUFJNmxCLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVVDLEVBQVYsRUFBY0MsR0FBZCxFQUFtQkMsR0FBbkIsRUFBd0I7QUFDcEMsV0FBT0YsRUFBRSxHQUFHbHFDLElBQUksQ0FBQzhJLEdBQUwsQ0FBU3FoQyxHQUFULEVBQWNDLEdBQWQsQ0FBTCxJQUEyQkYsRUFBRSxHQUFHbHFDLElBQUksQ0FBQytJLEdBQUwsQ0FBU29oQyxHQUFULEVBQWNDLEdBQWQsQ0FBdkM7QUFDSCxHQUZEOztBQUdBLE1BQUlDLFFBQVEsR0FBRztBQUNYQyxPQUFHLEVBQUU7QUFETSxHQUFmOztBQUlBLE1BQUksT0FBT3B5QyxNQUFNLENBQUNxb0MsTUFBZCxLQUF5QixVQUE3QixFQUF5QztBQUNyQ3JvQyxVQUFNLENBQUNxb0MsTUFBUCxHQUFnQixVQUFVam5DLE1BQVYsRUFBa0I7QUFDOUIsVUFBSU8sSUFBSSxHQUFHLEVBQVg7O0FBQ0EsV0FBSyxJQUFJOHNCLEVBQUUsR0FBRyxDQUFkLEVBQWlCQSxFQUFFLEdBQUdoWSxTQUFTLENBQUNsTixNQUFoQyxFQUF3Q2tsQixFQUFFLEVBQTFDLEVBQThDO0FBQzFDOXNCLFlBQUksQ0FBQzhzQixFQUFFLEdBQUcsQ0FBTixDQUFKLEdBQWVoWSxTQUFTLENBQUNnWSxFQUFELENBQXhCO0FBQ0g7O0FBQ0QsVUFBSSxDQUFDcnRCLE1BQUwsRUFBYTtBQUNULGNBQU0rckIsU0FBUyxDQUFDLDRDQUFELENBQWY7QUFDSDs7QUFDRCxVQUFJa2xCLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVU3K0IsTUFBVixFQUFrQjtBQUM1QixZQUFJQSxNQUFKLEVBQVk7QUFDUnhULGdCQUFNLENBQUNTLElBQVAsQ0FBWStTLE1BQVosRUFBb0JtK0IsT0FBcEIsQ0FBNEIsVUFBVTl3QyxHQUFWLEVBQWU7QUFBRSxtQkFBUU8sTUFBTSxDQUFDUCxHQUFELENBQU4sR0FBYzJTLE1BQU0sQ0FBQzNTLEdBQUQsQ0FBNUI7QUFBcUMsV0FBbEY7QUFDSDtBQUNKLE9BSkQ7O0FBS0EsV0FBSyxJQUFJa3ZDLEVBQUUsR0FBRyxDQUFULEVBQVl1QyxNQUFNLEdBQUczd0MsSUFBMUIsRUFBZ0NvdUMsRUFBRSxHQUFHdUMsTUFBTSxDQUFDL29DLE1BQTVDLEVBQW9Ed21DLEVBQUUsRUFBdEQsRUFBMEQ7QUFDdEQsWUFBSXY4QixNQUFNLEdBQUc4K0IsTUFBTSxDQUFDdkMsRUFBRCxDQUFuQjs7QUFDQXNDLGVBQU8sQ0FBQzcrQixNQUFELENBQVA7QUFDSDs7QUFDRCxhQUFPcFMsTUFBUDtBQUNILEtBbEJEO0FBbUJIOztBQUVELE1BQUlteEMsbUJBQW1CLEdBQUcsR0FBMUI7O0FBQ0EsV0FBU0MsaUJBQVQsQ0FBMkJDLE9BQTNCLEVBQW9DQyxjQUFwQyxFQUFvRDtBQUNoRCxRQUFJeHJDLElBQUksR0FBRztBQUNQK29DLFlBQU0sRUFBRTdILE9BQVEsQ0FBQ0EsT0FBUSxDQUFDLEVBQUQsRUFBS1UsUUFBTCxDQUFULEVBQXlCM2tCLFNBQVMsQ0FBQ3d1QixhQUFuQyxDQURUO0FBRVB4QyxVQUFJLEVBQUVuRTtBQUZDLEtBQVg7QUFJQTlrQyxRQUFJLENBQUN5YSxTQUFMLEdBQWlCK3VCLGdCQUFnQixDQUFDO0FBQUVULFlBQU0sRUFBRS9vQyxJQUFJLENBQUMrb0MsTUFBZjtBQUF1QkUsVUFBSSxFQUFFanBDLElBQUksQ0FBQ2lwQztBQUFsQyxLQUFELENBQWpDO0FBQ0FqcEMsUUFBSSxDQUFDMHJDLFNBQUwsR0FBaUIsRUFBakI7QUFDQTFyQyxRQUFJLENBQUMyckMsY0FBTCxHQUFzQixFQUF0QjtBQUNBM3JDLFFBQUksQ0FBQzRyQyxhQUFMLEdBQXFCLEVBQXJCO0FBQ0E1ckMsUUFBSSxDQUFDNnJDLEtBQUwsR0FBYTF5QyxJQUFiO0FBQ0E2RyxRQUFJLENBQUM4ckMsaUJBQUwsR0FBeUJDLGdCQUF6QjtBQUNBL3JDLFFBQUksQ0FBQ2dzQyxpQkFBTCxHQUF5QkMsZ0JBQXpCO0FBQ0Fqc0MsUUFBSSxDQUFDa3NDLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0Fsc0MsUUFBSSxDQUFDbXNDLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0Fuc0MsUUFBSSxDQUFDb3NDLEtBQUwsR0FBYUEsS0FBYjtBQUNBcHNDLFFBQUksQ0FBQ3FzQyxLQUFMLEdBQWFBLEtBQWI7QUFDQXJzQyxRQUFJLENBQUNzc0MsY0FBTCxHQUFzQnZHLGFBQXRCO0FBQ0EvbEMsUUFBSSxDQUFDdXNDLE9BQUwsR0FBZUEsT0FBZjtBQUNBdnNDLFFBQUksQ0FBQ3dzQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBeHNDLFFBQUksQ0FBQ3lzQyxVQUFMLEdBQWtCQSxVQUFsQjtBQUNBenNDLFFBQUksQ0FBQzBzQyxJQUFMLEdBQVlBLElBQVo7QUFDQTFzQyxRQUFJLENBQUMyc0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0Ezc0MsUUFBSSxDQUFDekYsR0FBTCxHQUFXQSxHQUFYO0FBQ0F5RixRQUFJLENBQUNtakMsT0FBTCxHQUFlQSxPQUFmO0FBQ0FuakMsUUFBSSxDQUFDNHNDLE1BQUwsR0FBY0EsTUFBZDs7QUFDQSxhQUFTQyxvQkFBVCxHQUFnQztBQUM1QjdzQyxVQUFJLENBQUM4c0MsS0FBTCxHQUFhO0FBQ1RDLHNCQUFjLEVBQUUsd0JBQVVuMUIsS0FBVixFQUFpQm8xQixFQUFqQixFQUFxQjtBQUNqQyxjQUFJcDFCLEtBQUssS0FBSyxLQUFLLENBQW5CLEVBQXNCO0FBQUVBLGlCQUFLLEdBQUc1WCxJQUFJLENBQUNpdEMsWUFBYjtBQUE0Qjs7QUFDcEQsY0FBSUQsRUFBRSxLQUFLLEtBQUssQ0FBaEIsRUFBbUI7QUFBRUEsY0FBRSxHQUFHaHRDLElBQUksQ0FBQ2t0QyxXQUFWO0FBQXdCOztBQUM3QyxjQUFJdDFCLEtBQUssS0FBSyxDQUFWLEtBQWlCbzFCLEVBQUUsR0FBRyxDQUFMLEtBQVcsQ0FBWCxJQUFnQkEsRUFBRSxHQUFHLEdBQUwsS0FBYSxDQUE5QixJQUFvQ0EsRUFBRSxHQUFHLEdBQUwsS0FBYSxDQUFqRSxDQUFKLEVBQ0ksT0FBTyxFQUFQO0FBQ0osaUJBQU9odEMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVXhxQixXQUFWLENBQXNCN0csS0FBdEIsQ0FBUDtBQUNIO0FBUFEsT0FBYjtBQVNIOztBQUNELGFBQVN1MUIsSUFBVCxHQUFnQjtBQUNabnRDLFVBQUksQ0FBQ3VyQyxPQUFMLEdBQWV2ckMsSUFBSSxDQUFDOEssS0FBTCxHQUFheWdDLE9BQTVCO0FBQ0F2ckMsVUFBSSxDQUFDb3RDLE1BQUwsR0FBYyxLQUFkO0FBQ0FDLGlCQUFXO0FBQ1hDLGlCQUFXO0FBQ1hDLGlCQUFXO0FBQ1hDLGdCQUFVO0FBQ1ZYLDBCQUFvQjtBQUNwQixVQUFJLENBQUM3c0MsSUFBSSxDQUFDbXBDLFFBQVYsRUFDSXNFLEtBQUs7QUFDVEMsZ0JBQVU7O0FBQ1YsVUFBSTF0QyxJQUFJLENBQUMrZCxhQUFMLENBQW1CMWIsTUFBbkIsSUFBNkJyQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZaHNCLFVBQTdDLEVBQXlEO0FBQ3JELFlBQUkvYyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenlCLFVBQWhCLEVBQTRCO0FBQ3hCeTFCLDBCQUFnQixDQUFDL3JDLElBQUksQ0FBQytvQyxNQUFMLENBQVloc0IsVUFBWixHQUNYL2MsSUFBSSxDQUFDMnRDLHFCQUFMLElBQThCM3RDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FEL0IsR0FFWGdKLFNBRlUsQ0FBaEI7QUFHSDs7QUFDRHFuQixtQkFBVyxDQUFDLEtBQUQsQ0FBWDtBQUNIOztBQUNEQyxzQkFBZ0I7QUFDaEIsVUFBSUMsUUFBUSxHQUFHLGlDQUFpQ3RrQixJQUFqQyxDQUFzQzRZLFNBQVMsQ0FBQ0MsU0FBaEQsQ0FBZjtBQUNBO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFHWSxVQUFJLENBQUNyaUMsSUFBSSxDQUFDbXBDLFFBQU4sSUFBa0IyRSxRQUF0QixFQUFnQztBQUM1QjdCLHdCQUFnQjtBQUNuQjs7QUFDRDhCLGtCQUFZLENBQUMsU0FBRCxDQUFaO0FBQ0g7O0FBQ0QsYUFBU0MsY0FBVCxDQUF3QmgxQyxFQUF4QixFQUE0QjtBQUN4QixhQUFPQSxFQUFFLENBQUNHLElBQUgsQ0FBUTZHLElBQVIsQ0FBUDtBQUNIOztBQUNELGFBQVM2dEMsZ0JBQVQsR0FBNEI7QUFDeEIsVUFBSTlFLE1BQU0sR0FBRy9vQyxJQUFJLENBQUMrb0MsTUFBbEI7O0FBQ0EsVUFBSUEsTUFBTSxDQUFDcHJCLFdBQVAsS0FBdUIsS0FBdkIsSUFBZ0NvckIsTUFBTSxDQUFDbkUsVUFBUCxLQUFzQixDQUExRCxFQUE2RDtBQUN6RDtBQUNILE9BRkQsTUFHSyxJQUFJbUUsTUFBTSxDQUFDaHNCLFVBQVAsS0FBc0IsSUFBMUIsRUFBZ0M7QUFDakNwVixjQUFNLENBQUNzbUMscUJBQVAsQ0FBNkIsWUFBWTtBQUNyQyxjQUFJanVDLElBQUksQ0FBQ2t1QyxpQkFBTCxLQUEyQjNuQixTQUEvQixFQUEwQztBQUN0Q3ZtQixnQkFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2QkMsVUFBN0IsR0FBMEMsUUFBMUM7QUFDQXB1QyxnQkFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2QkUsT0FBN0IsR0FBdUMsT0FBdkM7QUFDSDs7QUFDRCxjQUFJcnVDLElBQUksQ0FBQ3N1QyxhQUFMLEtBQXVCL25CLFNBQTNCLEVBQXNDO0FBQ2xDLGdCQUFJZ29CLFNBQVMsR0FBRyxDQUFDdnVDLElBQUksQ0FBQ3d1QyxJQUFMLENBQVVDLFdBQVYsR0FBd0IsQ0FBekIsSUFBOEIxRixNQUFNLENBQUNuRSxVQUFyRDtBQUNBNWtDLGdCQUFJLENBQUNzdUMsYUFBTCxDQUFtQkgsS0FBbkIsQ0FBeUJPLEtBQXpCLEdBQWlDSCxTQUFTLEdBQUcsSUFBN0M7QUFDQXZ1QyxnQkFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2Qk8sS0FBN0IsR0FDSUgsU0FBUyxJQUNKdnVDLElBQUksQ0FBQzJ1QyxXQUFMLEtBQXFCcG9CLFNBQXJCLEdBQ0t2bUIsSUFBSSxDQUFDMnVDLFdBQUwsQ0FBaUJGLFdBRHRCLEdBRUssQ0FIRCxDQUFULEdBSUksSUFMUjtBQU1BenVDLGdCQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJDLEtBQXZCLENBQTZCUyxjQUE3QixDQUE0QyxZQUE1QztBQUNBNXVDLGdCQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJDLEtBQXZCLENBQTZCUyxjQUE3QixDQUE0QyxTQUE1QztBQUNIO0FBQ0osU0FqQkQ7QUFrQkg7QUFDSjtBQUNEO0FBQ1I7QUFDQTs7O0FBQ1EsYUFBU0MsVUFBVCxDQUFvQnpuQyxDQUFwQixFQUF1QjtBQUNuQixVQUFJcEgsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEtBQThCLENBQWxDLEVBQXFDO0FBQ2pDLFlBQUl5c0MsV0FBVyxHQUFHOXVDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixLQUF3QmdKLFNBQXhCLEdBQ1osSUFBSTNnQixJQUFKLENBQVM1RixJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0J5SCxPQUFwQixFQUFULENBRFksR0FFWixJQUFJcGYsSUFBSixFQUZOOztBQUdBLFlBQUlpakMsRUFBRSxHQUFHa0csZUFBZSxFQUF4QjtBQUFBLFlBQTRCM3BDLEtBQUssR0FBR3lqQyxFQUFFLENBQUN6akMsS0FBdkM7QUFBQSxZQUE4Q0ksT0FBTyxHQUFHcWpDLEVBQUUsQ0FBQ3JqQyxPQUEzRDtBQUFBLFlBQW9Fb1csT0FBTyxHQUFHaXRCLEVBQUUsQ0FBQ2p0QixPQUFqRjs7QUFDQWt6QixtQkFBVyxDQUFDNUwsUUFBWixDQUFxQjk5QixLQUFyQixFQUE0QkksT0FBNUIsRUFBcUNvVyxPQUFyQyxFQUE4QyxDQUE5QztBQUNBNWIsWUFBSSxDQUFDbWpDLE9BQUwsQ0FBYTJMLFdBQWIsRUFBMEIsS0FBMUI7QUFDSDs7QUFDRCxVQUFJMW5DLENBQUMsS0FBS21mLFNBQU4sSUFBbUJuZixDQUFDLENBQUN4SCxJQUFGLEtBQVcsTUFBbEMsRUFBMEM7QUFDdENvdkMsbUJBQVcsQ0FBQzVuQyxDQUFELENBQVg7QUFDSDs7QUFDRCxVQUFJNm5DLFNBQVMsR0FBR2p2QyxJQUFJLENBQUNzZixNQUFMLENBQVl4bEIsS0FBNUI7QUFDQW8xQyx3QkFBa0I7QUFDbEJ0QixpQkFBVzs7QUFDWCxVQUFJNXRDLElBQUksQ0FBQ3NmLE1BQUwsQ0FBWXhsQixLQUFaLEtBQXNCbTFDLFNBQTFCLEVBQXFDO0FBQ2pDanZDLFlBQUksQ0FBQ212QyxnQkFBTDtBQUNIO0FBQ0o7O0FBQ0QsYUFBU0MsYUFBVCxDQUF1QnQzQixJQUF2QixFQUE2QmtILElBQTdCLEVBQW1DO0FBQy9CLGFBQVFsSCxJQUFJLEdBQUcsRUFBUixHQUFjLEtBQUttdEIsR0FBRyxDQUFDam1CLElBQUksS0FBS2hmLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqcUIsSUFBVixDQUFlLENBQWYsQ0FBVixDQUE3QjtBQUNIOztBQUNELGFBQVNxd0IsYUFBVCxDQUF1QnYzQixJQUF2QixFQUE2QjtBQUN6QixjQUFRQSxJQUFJLEdBQUcsRUFBZjtBQUNJLGFBQUssQ0FBTDtBQUNBLGFBQUssRUFBTDtBQUNJLGlCQUFPLEVBQVA7O0FBQ0o7QUFDSSxpQkFBT0EsSUFBSSxHQUFHLEVBQWQ7QUFMUjtBQU9IO0FBQ0Q7QUFDUjtBQUNBOzs7QUFDUSxhQUFTbzNCLGtCQUFULEdBQThCO0FBQzFCLFVBQUlsdkMsSUFBSSxDQUFDc3ZDLFdBQUwsS0FBcUIvb0IsU0FBckIsSUFBa0N2bUIsSUFBSSxDQUFDdXZDLGFBQUwsS0FBdUJocEIsU0FBN0QsRUFDSTtBQUNKLFVBQUluaEIsS0FBSyxHQUFHLENBQUNDLFFBQVEsQ0FBQ3JGLElBQUksQ0FBQ3N2QyxXQUFMLENBQWlCeDFDLEtBQWpCLENBQXVCMjJCLEtBQXZCLENBQTZCLENBQUMsQ0FBOUIsQ0FBRCxFQUFtQyxFQUFuQyxDQUFSLElBQWtELENBQW5ELElBQXdELEVBQXBFO0FBQUEsVUFBd0VqckIsT0FBTyxHQUFHLENBQUNILFFBQVEsQ0FBQ3JGLElBQUksQ0FBQ3V2QyxhQUFMLENBQW1CejFDLEtBQXBCLEVBQTJCLEVBQTNCLENBQVIsSUFBMEMsQ0FBM0MsSUFBZ0QsRUFBbEk7QUFBQSxVQUFzSThoQixPQUFPLEdBQUc1YixJQUFJLENBQUN3dkMsYUFBTCxLQUF1QmpwQixTQUF2QixHQUMxSSxDQUFDbGhCLFFBQVEsQ0FBQ3JGLElBQUksQ0FBQ3d2QyxhQUFMLENBQW1CMTFDLEtBQXBCLEVBQTJCLEVBQTNCLENBQVIsSUFBMEMsQ0FBM0MsSUFBZ0QsRUFEMEYsR0FFMUksQ0FGTjs7QUFHQSxVQUFJa0csSUFBSSxDQUFDZ2YsSUFBTCxLQUFjdUgsU0FBbEIsRUFBNkI7QUFDekJuaEIsYUFBSyxHQUFHZ3FDLGFBQWEsQ0FBQ2hxQyxLQUFELEVBQVFwRixJQUFJLENBQUNnZixJQUFMLENBQVVnbkIsV0FBbEIsQ0FBckI7QUFDSDs7QUFDRCxVQUFJeUosYUFBYSxHQUFHenZDLElBQUksQ0FBQytvQyxNQUFMLENBQVkyRyxPQUFaLEtBQXdCbnBCLFNBQXhCLElBQ2Z2bUIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLElBQ0d2ZCxJQUFJLENBQUMydkMsY0FEUixJQUVHM3ZDLElBQUksQ0FBQzJ0QyxxQkFGUixJQUdHakQsWUFBWSxDQUFDMXFDLElBQUksQ0FBQzJ0QyxxQkFBTixFQUE2QjN0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQXpDLEVBQWtELElBQWxELENBQVosS0FDSSxDQUxaO0FBTUEsVUFBSXF5QixhQUFhLEdBQUc1dkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWThHLE9BQVosS0FBd0J0cEIsU0FBeEIsSUFDZnZtQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosSUFDR3RkLElBQUksQ0FBQzh2QyxjQURSLElBRUc5dkMsSUFBSSxDQUFDMnRDLHFCQUZSLElBR0dqRCxZQUFZLENBQUMxcUMsSUFBSSxDQUFDMnRDLHFCQUFOLEVBQTZCM3RDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBekMsRUFBa0QsSUFBbEQsQ0FBWixLQUNJLENBTFo7O0FBTUEsVUFBSXN5QixhQUFKLEVBQW1CO0FBQ2YsWUFBSUMsT0FBTyxHQUFHN3ZDLElBQUksQ0FBQytvQyxNQUFMLENBQVk4RyxPQUFaLEtBQXdCdHBCLFNBQXhCLEdBQ1J2bUIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWThHLE9BREosR0FFUjd2QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BRmxCO0FBR0FsWSxhQUFLLEdBQUd4RSxJQUFJLENBQUM4SSxHQUFMLENBQVN0RSxLQUFULEVBQWdCeXFDLE9BQU8sQ0FBQzVrQixRQUFSLEVBQWhCLENBQVI7QUFDQSxZQUFJN2xCLEtBQUssS0FBS3lxQyxPQUFPLENBQUM1a0IsUUFBUixFQUFkLEVBQ0l6bEIsT0FBTyxHQUFHNUUsSUFBSSxDQUFDOEksR0FBTCxDQUFTbEUsT0FBVCxFQUFrQnFxQyxPQUFPLENBQUMva0IsVUFBUixFQUFsQixDQUFWO0FBQ0osWUFBSXRsQixPQUFPLEtBQUtxcUMsT0FBTyxDQUFDL2tCLFVBQVIsRUFBaEIsRUFDSWxQLE9BQU8sR0FBR2hiLElBQUksQ0FBQzhJLEdBQUwsQ0FBU2tTLE9BQVQsRUFBa0JpMEIsT0FBTyxDQUFDOWtCLFVBQVIsRUFBbEIsQ0FBVjtBQUNQOztBQUNELFVBQUkwa0IsYUFBSixFQUFtQjtBQUNmLFlBQUlDLE9BQU8sR0FBRzF2QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZMkcsT0FBWixLQUF3Qm5wQixTQUF4QixHQUNSdm1CLElBQUksQ0FBQytvQyxNQUFMLENBQVkyRyxPQURKLEdBRVIxdkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUZsQjtBQUdBblksYUFBSyxHQUFHeEUsSUFBSSxDQUFDK0ksR0FBTCxDQUFTdkUsS0FBVCxFQUFnQnNxQyxPQUFPLENBQUN6a0IsUUFBUixFQUFoQixDQUFSO0FBQ0EsWUFBSTdsQixLQUFLLEtBQUtzcUMsT0FBTyxDQUFDemtCLFFBQVIsRUFBZCxFQUNJemxCLE9BQU8sR0FBRzVFLElBQUksQ0FBQytJLEdBQUwsQ0FBU25FLE9BQVQsRUFBa0JrcUMsT0FBTyxDQUFDNWtCLFVBQVIsRUFBbEIsQ0FBVjtBQUNKLFlBQUl0bEIsT0FBTyxLQUFLa3FDLE9BQU8sQ0FBQzVrQixVQUFSLEVBQWhCLEVBQ0lsUCxPQUFPLEdBQUdoYixJQUFJLENBQUMrSSxHQUFMLENBQVNpUyxPQUFULEVBQWtCOHpCLE9BQU8sQ0FBQzNrQixVQUFSLEVBQWxCLENBQVY7QUFDUDs7QUFDRG1ZLGNBQVEsQ0FBQzk5QixLQUFELEVBQVFJLE9BQVIsRUFBaUJvVyxPQUFqQixDQUFSO0FBQ0g7QUFDRDtBQUNSO0FBQ0E7OztBQUNRLGFBQVNtd0IsZ0JBQVQsQ0FBMEJ4RSxPQUExQixFQUFtQztBQUMvQixVQUFJbGpDLElBQUksR0FBR2tqQyxPQUFPLElBQUl2bkMsSUFBSSxDQUFDMnRDLHFCQUEzQjs7QUFDQSxVQUFJdHBDLElBQUosRUFBVTtBQUNONitCLGdCQUFRLENBQUM3K0IsSUFBSSxDQUFDNG1CLFFBQUwsRUFBRCxFQUFrQjVtQixJQUFJLENBQUN5bUIsVUFBTCxFQUFsQixFQUFxQ3ptQixJQUFJLENBQUMwbUIsVUFBTCxFQUFyQyxDQUFSO0FBQ0g7QUFDSjs7QUFDRCxhQUFTZ2tCLGVBQVQsR0FBMkI7QUFDdkIsVUFBSTNwQyxLQUFLLEdBQUdwRixJQUFJLENBQUMrb0MsTUFBTCxDQUFZdnJCLFdBQXhCO0FBQ0EsVUFBSWhZLE9BQU8sR0FBR3hGLElBQUksQ0FBQytvQyxNQUFMLENBQVl0ckIsYUFBMUI7QUFDQSxVQUFJN0IsT0FBTyxHQUFHNWIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXBHLGNBQTFCOztBQUNBLFVBQUkzaUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLEtBQXdCZ0osU0FBNUIsRUFBdUM7QUFDbkMsWUFBSXdwQixLQUFLLEdBQUcvdkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9CME4sUUFBcEIsRUFBWjtBQUNBLFlBQUkra0IsVUFBVSxHQUFHaHdDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQnVOLFVBQXBCLEVBQWpCO0FBQ0ExbEIsYUFBSyxHQUFHeEUsSUFBSSxDQUFDK0ksR0FBTCxDQUFTdkUsS0FBVCxFQUFnQjJxQyxLQUFoQixDQUFSO0FBQ0EsWUFBSTNxQyxLQUFLLEtBQUsycUMsS0FBZCxFQUNJdnFDLE9BQU8sR0FBRzVFLElBQUksQ0FBQytJLEdBQUwsQ0FBU3FtQyxVQUFULEVBQXFCeHFDLE9BQXJCLENBQVY7QUFDSixZQUFJSixLQUFLLEtBQUsycUMsS0FBVixJQUFtQnZxQyxPQUFPLEtBQUt3cUMsVUFBbkMsRUFDSXAwQixPQUFPLEdBQUc1YixJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0J3TixVQUFwQixFQUFWO0FBQ1A7O0FBQ0QsVUFBSS9xQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosS0FBd0JpSixTQUE1QixFQUF1QztBQUNuQyxZQUFJMHBCLEtBQUssR0FBR2p3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0IyTixRQUFwQixFQUFaO0FBQ0EsWUFBSWlsQixVQUFVLEdBQUdsd0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9Cd04sVUFBcEIsRUFBakI7QUFDQTFsQixhQUFLLEdBQUd4RSxJQUFJLENBQUM4SSxHQUFMLENBQVN0RSxLQUFULEVBQWdCNnFDLEtBQWhCLENBQVI7QUFDQSxZQUFJN3FDLEtBQUssS0FBSzZxQyxLQUFkLEVBQ0l6cUMsT0FBTyxHQUFHNUUsSUFBSSxDQUFDOEksR0FBTCxDQUFTd21DLFVBQVQsRUFBcUIxcUMsT0FBckIsQ0FBVjtBQUNKLFlBQUlKLEtBQUssS0FBSzZxQyxLQUFWLElBQW1CenFDLE9BQU8sS0FBSzBxQyxVQUFuQyxFQUNJdDBCLE9BQU8sR0FBRzViLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixDQUFvQnlOLFVBQXBCLEVBQVY7QUFDUDs7QUFDRCxhQUFPO0FBQUUzbEIsYUFBSyxFQUFFQSxLQUFUO0FBQWdCSSxlQUFPLEVBQUVBLE9BQXpCO0FBQWtDb1csZUFBTyxFQUFFQTtBQUEzQyxPQUFQO0FBQ0g7QUFDRDtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNRLGFBQVNzbkIsUUFBVCxDQUFrQjk5QixLQUFsQixFQUF5QkksT0FBekIsRUFBa0NvVyxPQUFsQyxFQUEyQztBQUN2QyxVQUFJNWIsSUFBSSxDQUFDMnRDLHFCQUFMLEtBQStCcG5CLFNBQW5DLEVBQThDO0FBQzFDdm1CLFlBQUksQ0FBQzJ0QyxxQkFBTCxDQUEyQnpLLFFBQTNCLENBQW9DOTlCLEtBQUssR0FBRyxFQUE1QyxFQUFnREksT0FBaEQsRUFBeURvVyxPQUFPLElBQUksQ0FBcEUsRUFBdUUsQ0FBdkU7QUFDSDs7QUFDRCxVQUFJLENBQUM1YixJQUFJLENBQUNzdkMsV0FBTixJQUFxQixDQUFDdHZDLElBQUksQ0FBQ3V2QyxhQUEzQixJQUE0Q3Z2QyxJQUFJLENBQUNtcEMsUUFBckQsRUFDSTtBQUNKbnBDLFVBQUksQ0FBQ3N2QyxXQUFMLENBQWlCeDFDLEtBQWpCLEdBQXlCNnZCLEdBQUcsQ0FBQyxDQUFDM3BCLElBQUksQ0FBQytvQyxNQUFMLENBQVlsc0IsU0FBYixHQUN0QixDQUFDLEtBQUt6WCxLQUFOLElBQWUsRUFBaEIsR0FBc0IsS0FBSzYvQixHQUFHLENBQUM3L0IsS0FBSyxHQUFHLEVBQVIsS0FBZSxDQUFoQixDQURQLEdBRXZCQSxLQUZzQixDQUE1QjtBQUdBcEYsVUFBSSxDQUFDdXZDLGFBQUwsQ0FBbUJ6MUMsS0FBbkIsR0FBMkI2dkIsR0FBRyxDQUFDbmtCLE9BQUQsQ0FBOUI7QUFDQSxVQUFJeEYsSUFBSSxDQUFDZ2YsSUFBTCxLQUFjdUgsU0FBbEIsRUFDSXZtQixJQUFJLENBQUNnZixJQUFMLENBQVVnbkIsV0FBVixHQUF3QmhtQyxJQUFJLENBQUNpcEMsSUFBTCxDQUFVanFCLElBQVYsQ0FBZWltQixHQUFHLENBQUM3L0IsS0FBSyxJQUFJLEVBQVYsQ0FBbEIsQ0FBeEI7QUFDSixVQUFJcEYsSUFBSSxDQUFDd3ZDLGFBQUwsS0FBdUJqcEIsU0FBM0IsRUFDSXZtQixJQUFJLENBQUN3dkMsYUFBTCxDQUFtQjExQyxLQUFuQixHQUEyQjZ2QixHQUFHLENBQUMvTixPQUFELENBQTlCO0FBQ1A7QUFDRDtBQUNSO0FBQ0E7QUFDQTs7O0FBQ1EsYUFBU3UwQixXQUFULENBQXFCMWxDLEtBQXJCLEVBQTRCO0FBQ3hCLFVBQUkybEMsV0FBVyxHQUFHckosY0FBYyxDQUFDdDhCLEtBQUQsQ0FBaEM7QUFDQSxVQUFJa04sSUFBSSxHQUFHdFMsUUFBUSxDQUFDK3FDLFdBQVcsQ0FBQ3QyQyxLQUFiLENBQVIsSUFBK0IyUSxLQUFLLENBQUM0bEMsS0FBTixJQUFlLENBQTlDLENBQVg7O0FBQ0EsVUFBSTE0QixJQUFJLEdBQUcsSUFBUCxHQUFjLENBQWQsSUFDQ2xOLEtBQUssQ0FBQzlRLEdBQU4sS0FBYyxPQUFkLElBQXlCLENBQUMsUUFBUTZ2QixJQUFSLENBQWE3UixJQUFJLENBQUN2VCxRQUFMLEVBQWIsQ0FEL0IsRUFDK0Q7QUFDM0QrbkMsa0JBQVUsQ0FBQ3gwQixJQUFELENBQVY7QUFDSDtBQUNKO0FBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDUSxhQUFTeGUsSUFBVCxDQUFjb3lDLE9BQWQsRUFBdUI5Z0MsS0FBdkIsRUFBOEJnUyxPQUE5QixFQUF1Qy9VLE9BQXZDLEVBQWdEO0FBQzVDLFVBQUkrQyxLQUFLLFlBQVl0TCxLQUFyQixFQUNJLE9BQU9zTCxLQUFLLENBQUNnZ0MsT0FBTixDQUFjLFVBQVU2RixFQUFWLEVBQWM7QUFBRSxlQUFPbjNDLElBQUksQ0FBQ295QyxPQUFELEVBQVUrRSxFQUFWLEVBQWM3ekIsT0FBZCxFQUF1Qi9VLE9BQXZCLENBQVg7QUFBNkMsT0FBM0UsQ0FBUDtBQUNKLFVBQUk2akMsT0FBTyxZQUFZcHNDLEtBQXZCLEVBQ0ksT0FBT29zQyxPQUFPLENBQUNkLE9BQVIsQ0FBZ0IsVUFBVTExQixFQUFWLEVBQWM7QUFBRSxlQUFPNWIsSUFBSSxDQUFDNGIsRUFBRCxFQUFLdEssS0FBTCxFQUFZZ1MsT0FBWixFQUFxQi9VLE9BQXJCLENBQVg7QUFBMkMsT0FBM0UsQ0FBUDtBQUNKNmpDLGFBQU8sQ0FBQ2dGLGdCQUFSLENBQXlCOWxDLEtBQXpCLEVBQWdDZ1MsT0FBaEMsRUFBeUMvVSxPQUF6Qzs7QUFDQTFILFVBQUksQ0FBQzByQyxTQUFMLENBQWU4RSxJQUFmLENBQW9CO0FBQ2hCakYsZUFBTyxFQUFFQSxPQURPO0FBRWhCOWdDLGFBQUssRUFBRUEsS0FGUztBQUdoQmdTLGVBQU8sRUFBRUEsT0FITztBQUloQi9VLGVBQU8sRUFBRUE7QUFKTyxPQUFwQjtBQU1IOztBQUNELGFBQVMrb0MsYUFBVCxHQUF5QjtBQUNyQjFDLGtCQUFZLENBQUMsVUFBRCxDQUFaO0FBQ0g7QUFDRDtBQUNSO0FBQ0E7OztBQUNRLGFBQVNMLFVBQVQsR0FBc0I7QUFDbEIsVUFBSTF0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZN3JCLElBQWhCLEVBQXNCO0FBQ2xCLFNBQUMsTUFBRCxFQUFTLE9BQVQsRUFBa0IsUUFBbEIsRUFBNEIsT0FBNUIsRUFBcUN1dEIsT0FBckMsQ0FBNkMsVUFBVTMxQixHQUFWLEVBQWU7QUFDeEQzVixlQUFLLENBQUNnbEIsU0FBTixDQUFnQnNtQixPQUFoQixDQUF3QmhuQixJQUF4QixDQUE2QnpqQixJQUFJLENBQUN1ckMsT0FBTCxDQUFhbUYsZ0JBQWIsQ0FBOEIsV0FBVzU3QixHQUFYLEdBQWlCLEdBQS9DLENBQTdCLEVBQWtGLFVBQVVDLEVBQVYsRUFBYztBQUM1RixtQkFBTzViLElBQUksQ0FBQzRiLEVBQUQsRUFBSyxPQUFMLEVBQWMvVSxJQUFJLENBQUM4VSxHQUFELENBQWxCLENBQVg7QUFDSCxXQUZEO0FBR0gsU0FKRDtBQUtIOztBQUNELFVBQUk5VSxJQUFJLENBQUNtcEMsUUFBVCxFQUFtQjtBQUNmd0gsbUJBQVc7QUFDWDtBQUNIOztBQUNELFVBQUlDLGVBQWUsR0FBR3pMLFFBQVEsQ0FBQzBMLFFBQUQsRUFBVyxFQUFYLENBQTlCO0FBQ0E3d0MsVUFBSSxDQUFDbXZDLGdCQUFMLEdBQXdCaEssUUFBUSxDQUFDc0wsYUFBRCxFQUFnQnBGLG1CQUFoQixDQUFoQztBQUNBLFVBQUlyckMsSUFBSSxDQUFDc3VDLGFBQUwsSUFBc0IsQ0FBQyxvQkFBb0I5a0IsSUFBcEIsQ0FBeUI0WSxTQUFTLENBQUNDLFNBQW5DLENBQTNCLEVBQ0lscEMsSUFBSSxDQUFDNkcsSUFBSSxDQUFDc3VDLGFBQU4sRUFBcUIsV0FBckIsRUFBa0MsVUFBVWxuQyxDQUFWLEVBQWE7QUFDL0MsWUFBSXBILElBQUksQ0FBQytvQyxNQUFMLENBQVl0RixJQUFaLEtBQXFCLE9BQXpCLEVBQ0lxTixXQUFXLENBQUMvSixjQUFjLENBQUMzL0IsQ0FBRCxDQUFmLENBQVg7QUFDUCxPQUhHLENBQUo7QUFJSmpPLFVBQUksQ0FBQ3dPLE1BQU0sQ0FBQ1QsUUFBUCxDQUFnQmtDLElBQWpCLEVBQXVCLFNBQXZCLEVBQWtDNDZCLFNBQWxDLENBQUo7QUFDQSxVQUFJLENBQUNoa0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhGLE1BQWIsSUFBdUIsQ0FBQ3ZqQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbEUsTUFBeEMsRUFDSTFyQyxJQUFJLENBQUN3TyxNQUFELEVBQVMsUUFBVCxFQUFtQmlwQyxlQUFuQixDQUFKO0FBQ0osVUFBSWpwQyxNQUFNLENBQUNvcEMsWUFBUCxLQUF3QnhxQixTQUE1QixFQUNJcHRCLElBQUksQ0FBQ3dPLE1BQU0sQ0FBQ1QsUUFBUixFQUFrQixZQUFsQixFQUFnQzhwQyxhQUFoQyxDQUFKLENBREosS0FHSTczQyxJQUFJLENBQUN3TyxNQUFNLENBQUNULFFBQVIsRUFBa0IsT0FBbEIsRUFBMkI4cEMsYUFBM0IsQ0FBSjtBQUNKNzNDLFVBQUksQ0FBQ3dPLE1BQU0sQ0FBQ1QsUUFBUixFQUFrQixPQUFsQixFQUEyQjhwQyxhQUEzQixFQUEwQztBQUFFQyxlQUFPLEVBQUU7QUFBWCxPQUExQyxDQUFKOztBQUNBLFVBQUlqeEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXZHLFVBQVosS0FBMkIsSUFBL0IsRUFBcUM7QUFDakNycEMsWUFBSSxDQUFDNkcsSUFBSSxDQUFDc2YsTUFBTixFQUFjLE9BQWQsRUFBdUJ0ZixJQUFJLENBQUMwc0MsSUFBNUIsQ0FBSjtBQUNBdnpDLFlBQUksQ0FBQzZHLElBQUksQ0FBQ3NmLE1BQU4sRUFBYyxPQUFkLEVBQXVCdGYsSUFBSSxDQUFDMHNDLElBQTVCLENBQUo7QUFDSDs7QUFDRCxVQUFJMXNDLElBQUksQ0FBQ3N1QyxhQUFMLEtBQXVCL25CLFNBQTNCLEVBQXNDO0FBQ2xDcHRCLFlBQUksQ0FBQzZHLElBQUksQ0FBQ2t4QyxRQUFOLEVBQWdCLE9BQWhCLEVBQXlCQyxlQUF6QixDQUFKO0FBQ0FoNEMsWUFBSSxDQUFDNkcsSUFBSSxDQUFDa3hDLFFBQU4sRUFBZ0IsQ0FBQyxPQUFELEVBQVUsV0FBVixDQUFoQixFQUF3Q2YsV0FBeEMsQ0FBSjtBQUNBaDNDLFlBQUksQ0FBQzZHLElBQUksQ0FBQ3N1QyxhQUFOLEVBQXFCLE9BQXJCLEVBQThCOEMsVUFBOUIsQ0FBSjtBQUNIOztBQUNELFVBQUlweEMsSUFBSSxDQUFDcXhDLGFBQUwsS0FBdUI5cUIsU0FBdkIsSUFDQXZtQixJQUFJLENBQUN1dkMsYUFBTCxLQUF1QmhwQixTQUR2QixJQUVBdm1CLElBQUksQ0FBQ3N2QyxXQUFMLEtBQXFCL29CLFNBRnpCLEVBRW9DO0FBQ2hDLFlBQUkrcUIsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVWxxQyxDQUFWLEVBQWE7QUFDdkIsaUJBQU8yL0IsY0FBYyxDQUFDMy9CLENBQUQsQ0FBZCxDQUFrQm1OLE1BQWxCLEVBQVA7QUFDSCxTQUZEOztBQUdBcGIsWUFBSSxDQUFDNkcsSUFBSSxDQUFDcXhDLGFBQU4sRUFBcUIsQ0FBQyxXQUFELENBQXJCLEVBQW9DeEMsVUFBcEMsQ0FBSjtBQUNBMTFDLFlBQUksQ0FBQzZHLElBQUksQ0FBQ3F4QyxhQUFOLEVBQXFCLE1BQXJCLEVBQTZCeEMsVUFBN0IsRUFBeUM7QUFBRW9DLGlCQUFPLEVBQUU7QUFBWCxTQUF6QyxDQUFKO0FBQ0E5M0MsWUFBSSxDQUFDNkcsSUFBSSxDQUFDcXhDLGFBQU4sRUFBcUIsT0FBckIsRUFBOEJFLGFBQTlCLENBQUo7QUFDQXA0QyxZQUFJLENBQUMsQ0FBQzZHLElBQUksQ0FBQ3N2QyxXQUFOLEVBQW1CdHZDLElBQUksQ0FBQ3V2QyxhQUF4QixDQUFELEVBQXlDLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBekMsRUFBNkQrQixPQUE3RCxDQUFKO0FBQ0EsWUFBSXR4QyxJQUFJLENBQUN3dkMsYUFBTCxLQUF1QmpwQixTQUEzQixFQUNJcHRCLElBQUksQ0FBQzZHLElBQUksQ0FBQ3d2QyxhQUFOLEVBQXFCLE9BQXJCLEVBQThCLFlBQVk7QUFBRSxpQkFBT3h2QyxJQUFJLENBQUN3dkMsYUFBTCxJQUFzQnh2QyxJQUFJLENBQUN3dkMsYUFBTCxDQUFtQmo3QixNQUFuQixFQUE3QjtBQUEyRCxTQUF2RyxDQUFKOztBQUNKLFlBQUl2VSxJQUFJLENBQUNnZixJQUFMLEtBQWN1SCxTQUFsQixFQUE2QjtBQUN6QnB0QixjQUFJLENBQUM2RyxJQUFJLENBQUNnZixJQUFOLEVBQVksT0FBWixFQUFxQixVQUFVNVgsQ0FBVixFQUFhO0FBQ2xDeW5DLHNCQUFVLENBQUN6bkMsQ0FBRCxDQUFWO0FBQ0FxcEMseUJBQWE7QUFDaEIsV0FIRyxDQUFKO0FBSUg7QUFDSjs7QUFDRCxVQUFJendDLElBQUksQ0FBQytvQyxNQUFMLENBQVk1ckIsVUFBaEIsRUFDSWhrQixJQUFJLENBQUM2RyxJQUFJLENBQUNzZixNQUFOLEVBQWMsTUFBZCxFQUFzQmt5QixNQUF0QixDQUFKO0FBQ1A7QUFDRDtBQUNSO0FBQ0E7QUFDQTtBQUNBOzs7QUFDUSxhQUFTL0UsVUFBVCxDQUFvQmdGLFFBQXBCLEVBQThCaEIsYUFBOUIsRUFBNkM7QUFDekMsVUFBSWlCLE1BQU0sR0FBR0QsUUFBUSxLQUFLbHJCLFNBQWIsR0FDUHZtQixJQUFJLENBQUN5YSxTQUFMLENBQWVnM0IsUUFBZixDQURPLEdBRVB6eEMsSUFBSSxDQUFDMnRDLHFCQUFMLEtBQ0czdEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLElBQXVCdmQsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLEdBQXNCdmQsSUFBSSxDQUFDNGpDLEdBQWxELEdBQ0s1akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQURqQixHQUVLdmQsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLElBQXVCdGQsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLEdBQXNCdGQsSUFBSSxDQUFDNGpDLEdBQWxELEdBQ0k1akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQURoQixHQUVJdGQsSUFBSSxDQUFDNGpDLEdBTGpCLENBRk47QUFRQSxVQUFJK04sT0FBTyxHQUFHM3hDLElBQUksQ0FBQ2t0QyxXQUFuQjtBQUNBLFVBQUkwRSxRQUFRLEdBQUc1eEMsSUFBSSxDQUFDaXRDLFlBQXBCOztBQUNBLFVBQUk7QUFDQSxZQUFJeUUsTUFBTSxLQUFLbnJCLFNBQWYsRUFBMEI7QUFDdEJ2bUIsY0FBSSxDQUFDa3RDLFdBQUwsR0FBbUJ3RSxNQUFNLENBQUNyb0IsV0FBUCxFQUFuQjtBQUNBcnBCLGNBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CeUUsTUFBTSxDQUFDNW5CLFFBQVAsRUFBcEI7QUFDSDtBQUNKLE9BTEQsQ0FNQSxPQUFPMWlCLENBQVAsRUFBVTtBQUNOO0FBQ0FBLFNBQUMsQ0FBQ3VmLE9BQUYsR0FBWSw0QkFBNEIrcUIsTUFBeEM7QUFDQTF4QyxZQUFJLENBQUMrb0MsTUFBTCxDQUFZakcsWUFBWixDQUF5QjE3QixDQUF6QjtBQUNIOztBQUNELFVBQUlxcEMsYUFBYSxJQUFJendDLElBQUksQ0FBQ2t0QyxXQUFMLEtBQXFCeUUsT0FBMUMsRUFBbUQ7QUFDL0M1RCxvQkFBWSxDQUFDLGNBQUQsQ0FBWjtBQUNBOEQsd0JBQWdCO0FBQ25COztBQUNELFVBQUlwQixhQUFhLEtBQ1p6d0MsSUFBSSxDQUFDa3RDLFdBQUwsS0FBcUJ5RSxPQUFyQixJQUFnQzN4QyxJQUFJLENBQUNpdEMsWUFBTCxLQUFzQjJFLFFBRDFDLENBQWpCLEVBQ3NFO0FBQ2xFN0Qsb0JBQVksQ0FBQyxlQUFELENBQVo7QUFDSDs7QUFDRC90QyxVQUFJLENBQUMyc0MsTUFBTDtBQUNIO0FBQ0Q7QUFDUjtBQUNBO0FBQ0E7OztBQUNRLGFBQVM0RSxhQUFULENBQXVCbnFDLENBQXZCLEVBQTBCO0FBQ3RCLFVBQUlncEMsV0FBVyxHQUFHckosY0FBYyxDQUFDMy9CLENBQUQsQ0FBaEM7QUFDQSxVQUFJLENBQUNncEMsV0FBVyxDQUFDekssU0FBWixDQUFzQnpkLE9BQXRCLENBQThCLE9BQTlCLENBQUwsRUFDSTRwQixpQkFBaUIsQ0FBQzFxQyxDQUFELEVBQUlncEMsV0FBVyxDQUFDeEssU0FBWixDQUFzQm1NLFFBQXRCLENBQStCLFNBQS9CLElBQTRDLENBQTVDLEdBQWdELENBQUMsQ0FBckQsQ0FBakI7QUFDUDtBQUNEO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ1EsYUFBU0QsaUJBQVQsQ0FBMkIxcUMsQ0FBM0IsRUFBOEJpcEMsS0FBOUIsRUFBcUMyQixTQUFyQyxFQUFnRDtBQUM1QyxVQUFJOTNDLE1BQU0sR0FBR2tOLENBQUMsSUFBSTIvQixjQUFjLENBQUMzL0IsQ0FBRCxDQUFoQztBQUNBLFVBQUkwRCxLQUFLLEdBQUdrbkMsU0FBUyxJQUNoQjkzQyxNQUFNLElBQUlBLE1BQU0sQ0FBQ29zQyxVQUFqQixJQUErQnBzQyxNQUFNLENBQUNvc0MsVUFBUCxDQUFrQkgsVUFEdEQ7QUFFQSxVQUFJMTdCLEtBQUssR0FBR3duQyxXQUFXLENBQUMsV0FBRCxDQUF2QjtBQUNBeG5DLFdBQUssQ0FBQzRsQyxLQUFOLEdBQWNBLEtBQWQ7QUFDQXZsQyxXQUFLLElBQUlBLEtBQUssQ0FBQ29uQyxhQUFOLENBQW9Cem5DLEtBQXBCLENBQVQ7QUFDSDs7QUFDRCxhQUFTZ2pDLEtBQVQsR0FBaUI7QUFDYixVQUFJMEUsUUFBUSxHQUFHeHFDLE1BQU0sQ0FBQ1QsUUFBUCxDQUFnQmtyQyxzQkFBaEIsRUFBZjtBQUNBcHlDLFVBQUksQ0FBQ2t1QyxpQkFBTCxHQUF5Qm5JLGFBQWEsQ0FBQyxLQUFELEVBQVEsb0JBQVIsQ0FBdEM7QUFDQS9sQyxVQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJtRSxRQUF2QixHQUFrQyxDQUFDLENBQW5DOztBQUNBLFVBQUksQ0FBQ3J5QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZaHNCLFVBQWpCLEVBQTZCO0FBQ3pCbzFCLGdCQUFRLENBQUNyTCxXQUFULENBQXFCd0wsYUFBYSxFQUFsQztBQUNBdHlDLFlBQUksQ0FBQ3V5QyxjQUFMLEdBQXNCeE0sYUFBYSxDQUFDLEtBQUQsRUFBUSwwQkFBUixDQUFuQzs7QUFDQSxZQUFJL2xDLElBQUksQ0FBQytvQyxNQUFMLENBQVlwckIsV0FBaEIsRUFBNkI7QUFDekIsY0FBSWtyQixFQUFFLEdBQUcySixVQUFVLEVBQW5CO0FBQUEsY0FBdUI3RCxXQUFXLEdBQUc5RixFQUFFLENBQUM4RixXQUF4QztBQUFBLGNBQXFEaHhCLFdBQVcsR0FBR2tyQixFQUFFLENBQUNsckIsV0FBdEU7O0FBQ0EzZCxjQUFJLENBQUN1eUMsY0FBTCxDQUFvQnpMLFdBQXBCLENBQWdDNkgsV0FBaEM7QUFDQTN1QyxjQUFJLENBQUMyZCxXQUFMLEdBQW1CQSxXQUFuQjtBQUNBM2QsY0FBSSxDQUFDMnVDLFdBQUwsR0FBbUJBLFdBQW5CO0FBQ0g7O0FBQ0QzdUMsWUFBSSxDQUFDeXlDLFVBQUwsR0FBa0IxTSxhQUFhLENBQUMsS0FBRCxFQUFRLHNCQUFSLENBQS9CO0FBQ0EvbEMsWUFBSSxDQUFDeXlDLFVBQUwsQ0FBZ0IzTCxXQUFoQixDQUE0QjRMLGFBQWEsRUFBekM7O0FBQ0EsWUFBSSxDQUFDMXlDLElBQUksQ0FBQ3N1QyxhQUFWLEVBQXlCO0FBQ3JCdHVDLGNBQUksQ0FBQ3N1QyxhQUFMLEdBQXFCdkksYUFBYSxDQUFDLEtBQUQsRUFBUSxnQkFBUixDQUFsQztBQUNBL2xDLGNBQUksQ0FBQ3N1QyxhQUFMLENBQW1CK0QsUUFBbkIsR0FBOEIsQ0FBQyxDQUEvQjtBQUNIOztBQUNETSxpQkFBUztBQUNUM3lDLFlBQUksQ0FBQ3l5QyxVQUFMLENBQWdCM0wsV0FBaEIsQ0FBNEI5bUMsSUFBSSxDQUFDc3VDLGFBQWpDO0FBQ0F0dUMsWUFBSSxDQUFDdXlDLGNBQUwsQ0FBb0J6TCxXQUFwQixDQUFnQzltQyxJQUFJLENBQUN5eUMsVUFBckM7QUFDQU4sZ0JBQVEsQ0FBQ3JMLFdBQVQsQ0FBcUI5bUMsSUFBSSxDQUFDdXlDLGNBQTFCO0FBQ0g7O0FBQ0QsVUFBSXZ5QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenlCLFVBQWhCLEVBQTRCO0FBQ3hCNjdCLGdCQUFRLENBQUNyTCxXQUFULENBQXFCOEwsU0FBUyxFQUE5QjtBQUNIOztBQUNEbk4saUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsV0FBekIsRUFBc0NsdUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsT0FBM0QsQ0FBWDtBQUNBZ0MsaUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsU0FBekIsRUFBb0NsdUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTVHLE9BQVosS0FBd0IsSUFBNUQsQ0FBWDtBQUNBc0QsaUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsWUFBekIsRUFBdUNsdUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQVosR0FBeUIsQ0FBaEUsQ0FBWDtBQUNBNWtDLFVBQUksQ0FBQ2t1QyxpQkFBTCxDQUF1QnBILFdBQXZCLENBQW1DcUwsUUFBbkM7QUFDQSxVQUFJVSxZQUFZLEdBQUc3eUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWStKLFFBQVosS0FBeUJ2c0IsU0FBekIsSUFDZnZtQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0osUUFBWixDQUFxQkMsUUFBckIsS0FBa0N4c0IsU0FEdEM7O0FBRUEsVUFBSXZtQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZeEYsTUFBWixJQUFzQnZqQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbEUsTUFBdEMsRUFBOEM7QUFDMUM3a0MsWUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCdEksU0FBdkIsQ0FBaUNDLEdBQWpDLENBQXFDN2xDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4RixNQUFaLEdBQXFCLFFBQXJCLEdBQWdDLFFBQXJFOztBQUNBLFlBQUl2akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhGLE1BQWhCLEVBQXdCO0FBQ3BCLGNBQUksQ0FBQ3NQLFlBQUQsSUFBaUI3eUMsSUFBSSxDQUFDdXJDLE9BQUwsQ0FBYWpGLFVBQWxDLEVBQ0l0bUMsSUFBSSxDQUFDdXJDLE9BQUwsQ0FBYWpGLFVBQWIsQ0FBd0IwTSxZQUF4QixDQUFxQ2h6QyxJQUFJLENBQUNrdUMsaUJBQTFDLEVBQTZEbHVDLElBQUksQ0FBQ3NmLE1BQUwsQ0FBWTJ6QixXQUF6RSxFQURKLEtBRUssSUFBSWp6QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0osUUFBWixLQUF5QnZzQixTQUE3QixFQUNEdm1CLElBQUksQ0FBQytvQyxNQUFMLENBQVkrSixRQUFaLENBQXFCaE0sV0FBckIsQ0FBaUM5bUMsSUFBSSxDQUFDa3VDLGlCQUF0QztBQUNQOztBQUNELFlBQUlsdUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxFLE1BQWhCLEVBQXdCO0FBQ3BCLGNBQUk1aEIsT0FBTyxHQUFHOGlCLGFBQWEsQ0FBQyxLQUFELEVBQVEsbUJBQVIsQ0FBM0I7QUFDQSxjQUFJL2xDLElBQUksQ0FBQ3VyQyxPQUFMLENBQWFqRixVQUFqQixFQUNJdG1DLElBQUksQ0FBQ3VyQyxPQUFMLENBQWFqRixVQUFiLENBQXdCME0sWUFBeEIsQ0FBcUMvdkIsT0FBckMsRUFBOENqakIsSUFBSSxDQUFDdXJDLE9BQW5EO0FBQ0p0b0IsaUJBQU8sQ0FBQzZqQixXQUFSLENBQW9COW1DLElBQUksQ0FBQ3VyQyxPQUF6QjtBQUNBLGNBQUl2ckMsSUFBSSxDQUFDaWlDLFFBQVQsRUFDSWhmLE9BQU8sQ0FBQzZqQixXQUFSLENBQW9COW1DLElBQUksQ0FBQ2lpQyxRQUF6QjtBQUNKaGYsaUJBQU8sQ0FBQzZqQixXQUFSLENBQW9COW1DLElBQUksQ0FBQ2t1QyxpQkFBekI7QUFDSDtBQUNKOztBQUNELFVBQUksQ0FBQ2x1QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbEUsTUFBYixJQUF1QixDQUFDN2tDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4RixNQUF4QyxFQUNJLENBQUN2akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWStKLFFBQVosS0FBeUJ2c0IsU0FBekIsR0FDS3ZtQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0osUUFEakIsR0FFS25yQyxNQUFNLENBQUNULFFBQVAsQ0FBZ0JrQyxJQUZ0QixFQUU0QjA5QixXQUY1QixDQUV3QzltQyxJQUFJLENBQUNrdUMsaUJBRjdDO0FBR1A7O0FBQ0QsYUFBU2dGLFNBQVQsQ0FBbUJ2TixTQUFuQixFQUE4QnRoQyxJQUE5QixFQUFvQzh1QyxTQUFwQyxFQUErQzE1QyxDQUEvQyxFQUFrRDtBQUM5QyxVQUFJMjVDLGFBQWEsR0FBRzVHLFNBQVMsQ0FBQ25vQyxJQUFELEVBQU8sSUFBUCxDQUE3QjtBQUFBLFVBQTJDZ3ZDLFVBQVUsR0FBR3ROLGFBQWEsQ0FBQyxNQUFELEVBQVMsbUJBQW1CSixTQUE1QixFQUF1Q3RoQyxJQUFJLENBQUMwbEIsT0FBTCxHQUFlM2xCLFFBQWYsRUFBdkMsQ0FBckU7QUFDQWl2QyxnQkFBVSxDQUFDOUwsT0FBWCxHQUFxQmxqQyxJQUFyQjtBQUNBZ3ZDLGdCQUFVLENBQUNDLEVBQVgsR0FBZ0I3NUMsQ0FBaEI7QUFDQTQ1QyxnQkFBVSxDQUFDeE0sWUFBWCxDQUF3QixZQUF4QixFQUFzQzdtQyxJQUFJLENBQUNxZCxVQUFMLENBQWdCaFosSUFBaEIsRUFBc0JyRSxJQUFJLENBQUMrb0MsTUFBTCxDQUFZekcsY0FBbEMsQ0FBdEM7O0FBQ0EsVUFBSXFELFNBQVMsQ0FBQ3pkLE9BQVYsQ0FBa0IsUUFBbEIsTUFBZ0MsQ0FBQyxDQUFqQyxJQUNBd2lCLFlBQVksQ0FBQ3JtQyxJQUFELEVBQU9yRSxJQUFJLENBQUM0akMsR0FBWixDQUFaLEtBQWlDLENBRHJDLEVBQ3dDO0FBQ3BDNWpDLFlBQUksQ0FBQ3V6QyxhQUFMLEdBQXFCRixVQUFyQjtBQUNBQSxrQkFBVSxDQUFDek4sU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsT0FBekI7QUFDQXdOLGtCQUFVLENBQUN4TSxZQUFYLENBQXdCLGNBQXhCLEVBQXdDLE1BQXhDO0FBQ0g7O0FBQ0QsVUFBSXVNLGFBQUosRUFBbUI7QUFDZkMsa0JBQVUsQ0FBQ2hCLFFBQVgsR0FBc0IsQ0FBQyxDQUF2Qjs7QUFDQSxZQUFJbUIsY0FBYyxDQUFDbnZDLElBQUQsQ0FBbEIsRUFBMEI7QUFDdEJndkMsb0JBQVUsQ0FBQ3pOLFNBQVgsQ0FBcUJDLEdBQXJCLENBQXlCLFVBQXpCO0FBQ0E3bEMsY0FBSSxDQUFDeXpDLGdCQUFMLEdBQXdCSixVQUF4Qjs7QUFDQSxjQUFJcnpDLElBQUksQ0FBQytvQyxNQUFMLENBQVl0RixJQUFaLEtBQXFCLE9BQXpCLEVBQWtDO0FBQzlCZ0MsdUJBQVcsQ0FBQzROLFVBQUQsRUFBYSxZQUFiLEVBQTJCcnpDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIsQ0FBbkIsS0FDbEMyc0IsWUFBWSxDQUFDcm1DLElBQUQsRUFBT3JFLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBUCxFQUE4QixJQUE5QixDQUFaLEtBQW9ELENBRDdDLENBQVg7QUFFQTBuQix1QkFBVyxDQUFDNE4sVUFBRCxFQUFhLFVBQWIsRUFBeUJyekMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixLQUNoQzJzQixZQUFZLENBQUNybUMsSUFBRCxFQUFPckUsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixDQUFQLEVBQThCLElBQTlCLENBQVosS0FBb0QsQ0FEN0MsQ0FBWDtBQUVBLGdCQUFJNG5CLFNBQVMsS0FBSyxjQUFsQixFQUNJME4sVUFBVSxDQUFDek4sU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsU0FBekI7QUFDUDtBQUNKO0FBQ0osT0FkRCxNQWVLO0FBQ0R3TixrQkFBVSxDQUFDek4sU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsb0JBQXpCO0FBQ0g7O0FBQ0QsVUFBSTdsQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUF6QixFQUFrQztBQUM5QixZQUFJaVEsYUFBYSxDQUFDcnZDLElBQUQsQ0FBYixJQUF1QixDQUFDbXZDLGNBQWMsQ0FBQ252QyxJQUFELENBQTFDLEVBQ0lndkMsVUFBVSxDQUFDek4sU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsU0FBekI7QUFDUDs7QUFDRCxVQUFJN2xDLElBQUksQ0FBQzJkLFdBQUwsSUFDQTNkLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUFaLEtBQTJCLENBRDNCLElBRUFlLFNBQVMsS0FBSyxjQUZkLElBR0F3TixTQUFTLEdBQUcsQ0FBWixLQUFrQixDQUh0QixFQUd5QjtBQUNyQm56QyxZQUFJLENBQUMyZCxXQUFMLENBQWlCZzJCLGtCQUFqQixDQUFvQyxXQUFwQyxFQUFpRCxpQ0FBaUMzekMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWS9GLE9BQVosQ0FBb0IzK0IsSUFBcEIsQ0FBakMsR0FBNkQsU0FBOUc7QUFDSDs7QUFDRDBwQyxrQkFBWSxDQUFDLGFBQUQsRUFBZ0JzRixVQUFoQixDQUFaO0FBQ0EsYUFBT0EsVUFBUDtBQUNIOztBQUNELGFBQVNPLGNBQVQsQ0FBd0JDLFVBQXhCLEVBQW9DO0FBQ2hDQSxnQkFBVSxDQUFDQyxLQUFYO0FBQ0EsVUFBSTl6QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUF6QixFQUNJcU4sV0FBVyxDQUFDK0MsVUFBRCxDQUFYO0FBQ1A7O0FBQ0QsYUFBU0Usb0JBQVQsQ0FBOEIxRCxLQUE5QixFQUFxQztBQUNqQyxVQUFJMkQsVUFBVSxHQUFHM0QsS0FBSyxHQUFHLENBQVIsR0FBWSxDQUFaLEdBQWdCcndDLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUFaLEdBQXlCLENBQTFEO0FBQ0EsVUFBSXFQLFFBQVEsR0FBRzVELEtBQUssR0FBRyxDQUFSLEdBQVlyd0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQXhCLEdBQXFDLENBQUMsQ0FBckQ7O0FBQ0EsV0FBSyxJQUFJbGhCLENBQUMsR0FBR3N3QixVQUFiLEVBQXlCdHdCLENBQUMsSUFBSXV3QixRQUE5QixFQUF3Q3Z3QixDQUFDLElBQUkyc0IsS0FBN0MsRUFBb0Q7QUFDaEQsWUFBSXo0QixLQUFLLEdBQUc1WCxJQUFJLENBQUNzdUMsYUFBTCxDQUFtQjRGLFFBQW5CLENBQTRCeHdCLENBQTVCLENBQVo7QUFDQSxZQUFJeXdCLFVBQVUsR0FBRzlELEtBQUssR0FBRyxDQUFSLEdBQVksQ0FBWixHQUFnQno0QixLQUFLLENBQUNzOEIsUUFBTixDQUFlN3hDLE1BQWYsR0FBd0IsQ0FBekQ7QUFDQSxZQUFJK3hDLFFBQVEsR0FBRy9ELEtBQUssR0FBRyxDQUFSLEdBQVl6NEIsS0FBSyxDQUFDczhCLFFBQU4sQ0FBZTd4QyxNQUEzQixHQUFvQyxDQUFDLENBQXBEOztBQUNBLGFBQUssSUFBSTVJLENBQUMsR0FBRzA2QyxVQUFiLEVBQXlCMTZDLENBQUMsSUFBSTI2QyxRQUE5QixFQUF3QzM2QyxDQUFDLElBQUk0MkMsS0FBN0MsRUFBb0Q7QUFDaEQsY0FBSTN1QixDQUFDLEdBQUc5SixLQUFLLENBQUNzOEIsUUFBTixDQUFlejZDLENBQWYsQ0FBUjtBQUNBLGNBQUlpb0IsQ0FBQyxDQUFDaWtCLFNBQUYsQ0FBWXpkLE9BQVosQ0FBb0IsUUFBcEIsTUFBa0MsQ0FBQyxDQUFuQyxJQUF3Q3NrQixTQUFTLENBQUM5cUIsQ0FBQyxDQUFDNmxCLE9BQUgsQ0FBckQsRUFDSSxPQUFPN2xCLENBQVA7QUFDUDtBQUNKOztBQUNELGFBQU82RSxTQUFQO0FBQ0g7O0FBQ0QsYUFBUzh0QixtQkFBVCxDQUE2QkMsT0FBN0IsRUFBc0NqRSxLQUF0QyxFQUE2QztBQUN6QyxVQUFJa0UsVUFBVSxHQUFHRCxPQUFPLENBQUMzTyxTQUFSLENBQWtCemQsT0FBbEIsQ0FBMEIsT0FBMUIsTUFBdUMsQ0FBQyxDQUF4QyxHQUNYb3NCLE9BQU8sQ0FBQy9NLE9BQVIsQ0FBZ0J6ZCxRQUFoQixFQURXLEdBRVg5cEIsSUFBSSxDQUFDaXRDLFlBRlg7QUFHQSxVQUFJZ0gsUUFBUSxHQUFHNUQsS0FBSyxHQUFHLENBQVIsR0FBWXJ3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbkUsVUFBeEIsR0FBcUMsQ0FBQyxDQUFyRDtBQUNBLFVBQUk0UCxTQUFTLEdBQUduRSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQVosR0FBZ0IsQ0FBQyxDQUFqQzs7QUFDQSxXQUFLLElBQUkzc0IsQ0FBQyxHQUFHNndCLFVBQVUsR0FBR3YwQyxJQUFJLENBQUNpdEMsWUFBL0IsRUFBNkN2cEIsQ0FBQyxJQUFJdXdCLFFBQWxELEVBQTREdndCLENBQUMsSUFBSTh3QixTQUFqRSxFQUE0RTtBQUN4RSxZQUFJNThCLEtBQUssR0FBRzVYLElBQUksQ0FBQ3N1QyxhQUFMLENBQW1CNEYsUUFBbkIsQ0FBNEJ4d0IsQ0FBNUIsQ0FBWjtBQUNBLFlBQUl5d0IsVUFBVSxHQUFHSSxVQUFVLEdBQUd2MEMsSUFBSSxDQUFDaXRDLFlBQWxCLEtBQW1DdnBCLENBQW5DLEdBQ1g0d0IsT0FBTyxDQUFDaEIsRUFBUixHQUFhakQsS0FERixHQUVYQSxLQUFLLEdBQUcsQ0FBUixHQUNJejRCLEtBQUssQ0FBQ3M4QixRQUFOLENBQWU3eEMsTUFBZixHQUF3QixDQUQ1QixHQUVJLENBSlY7QUFLQSxZQUFJb3lDLFlBQVksR0FBRzc4QixLQUFLLENBQUNzOEIsUUFBTixDQUFlN3hDLE1BQWxDOztBQUNBLGFBQUssSUFBSTVJLENBQUMsR0FBRzA2QyxVQUFiLEVBQXlCMTZDLENBQUMsSUFBSSxDQUFMLElBQVVBLENBQUMsR0FBR2c3QyxZQUFkLElBQThCaDdDLENBQUMsS0FBSzQyQyxLQUFLLEdBQUcsQ0FBUixHQUFZb0UsWUFBWixHQUEyQixDQUFDLENBQWpDLENBQXhELEVBQTZGaDdDLENBQUMsSUFBSSs2QyxTQUFsRyxFQUE2RztBQUN6RyxjQUFJOXlCLENBQUMsR0FBRzlKLEtBQUssQ0FBQ3M4QixRQUFOLENBQWV6NkMsQ0FBZixDQUFSO0FBQ0EsY0FBSWlvQixDQUFDLENBQUNpa0IsU0FBRixDQUFZemQsT0FBWixDQUFvQixRQUFwQixNQUFrQyxDQUFDLENBQW5DLElBQ0Fza0IsU0FBUyxDQUFDOXFCLENBQUMsQ0FBQzZsQixPQUFILENBRFQsSUFFQTNtQyxJQUFJLENBQUNncEIsR0FBTCxDQUFTMHFCLE9BQU8sQ0FBQ2hCLEVBQVIsR0FBYTc1QyxDQUF0QixLQUE0Qm1ILElBQUksQ0FBQ2dwQixHQUFMLENBQVN5bUIsS0FBVCxDQUZoQyxFQUdJLE9BQU91RCxjQUFjLENBQUNseUIsQ0FBRCxDQUFyQjtBQUNQO0FBQ0o7O0FBQ0QxaEIsVUFBSSxDQUFDa3NDLFdBQUwsQ0FBaUJzSSxTQUFqQjtBQUNBRSxnQkFBVSxDQUFDWCxvQkFBb0IsQ0FBQ1MsU0FBRCxDQUFyQixFQUFrQyxDQUFsQyxDQUFWO0FBQ0EsYUFBT2p1QixTQUFQO0FBQ0g7O0FBQ0QsYUFBU211QixVQUFULENBQW9CSixPQUFwQixFQUE2QnhuQyxNQUE3QixFQUFxQztBQUNqQyxVQUFJNm5DLFVBQVUsR0FBR0MsUUFBUSxDQUFDMXRDLFFBQVEsQ0FBQzJ0QyxhQUFULElBQTBCM3RDLFFBQVEsQ0FBQ2tDLElBQXBDLENBQXpCO0FBQ0EsVUFBSTByQyxTQUFTLEdBQUdSLE9BQU8sS0FBSy90QixTQUFaLEdBQ1YrdEIsT0FEVSxHQUVWSyxVQUFVLEdBQ056dEMsUUFBUSxDQUFDMnRDLGFBREgsR0FFTjcwQyxJQUFJLENBQUN5ekMsZ0JBQUwsS0FBMEJsdEIsU0FBMUIsSUFBdUNxdUIsUUFBUSxDQUFDNTBDLElBQUksQ0FBQ3l6QyxnQkFBTixDQUEvQyxHQUNJenpDLElBQUksQ0FBQ3l6QyxnQkFEVCxHQUVJenpDLElBQUksQ0FBQ3V6QyxhQUFMLEtBQXVCaHRCLFNBQXZCLElBQW9DcXVCLFFBQVEsQ0FBQzUwQyxJQUFJLENBQUN1ekMsYUFBTixDQUE1QyxHQUNJdnpDLElBQUksQ0FBQ3V6QyxhQURULEdBRUlRLG9CQUFvQixDQUFDam5DLE1BQU0sR0FBRyxDQUFULEdBQWEsQ0FBYixHQUFpQixDQUFDLENBQW5CLENBUnRDOztBQVNBLFVBQUlnb0MsU0FBUyxLQUFLdnVCLFNBQWxCLEVBQTZCO0FBQ3pCdm1CLFlBQUksQ0FBQ3NmLE1BQUwsQ0FBWXcwQixLQUFaO0FBQ0gsT0FGRCxNQUdLLElBQUksQ0FBQ2EsVUFBTCxFQUFpQjtBQUNsQmYsc0JBQWMsQ0FBQ2tCLFNBQUQsQ0FBZDtBQUNILE9BRkksTUFHQTtBQUNEVCwyQkFBbUIsQ0FBQ1MsU0FBRCxFQUFZaG9DLE1BQVosQ0FBbkI7QUFDSDtBQUNKOztBQUNELGFBQVNpb0MsY0FBVCxDQUF3QnA5QixJQUF4QixFQUE4QkMsS0FBOUIsRUFBcUM7QUFDakMsVUFBSW85QixZQUFZLEdBQUcsQ0FBQyxJQUFJcHZDLElBQUosQ0FBUytSLElBQVQsRUFBZUMsS0FBZixFQUFzQixDQUF0QixFQUF5QnVULE1BQXpCLEtBQW9DbnJCLElBQUksQ0FBQ2lwQyxJQUFMLENBQVV2cUIsY0FBOUMsR0FBK0QsQ0FBaEUsSUFBcUUsQ0FBeEY7QUFDQSxVQUFJdTJCLGFBQWEsR0FBR2oxQyxJQUFJLENBQUM4c0MsS0FBTCxDQUFXQyxjQUFYLENBQTBCLENBQUNuMUIsS0FBSyxHQUFHLENBQVIsR0FBWSxFQUFiLElBQW1CLEVBQTdDLEVBQWlERCxJQUFqRCxDQUFwQjtBQUNBLFVBQUk4RyxXQUFXLEdBQUd6ZSxJQUFJLENBQUM4c0MsS0FBTCxDQUFXQyxjQUFYLENBQTBCbjFCLEtBQTFCLEVBQWlDRCxJQUFqQyxDQUFsQjtBQUFBLFVBQTBENjJCLElBQUksR0FBRzdtQyxNQUFNLENBQUNULFFBQVAsQ0FBZ0JrckMsc0JBQWhCLEVBQWpFO0FBQUEsVUFBMkc4QyxZQUFZLEdBQUdsMUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQVosR0FBeUIsQ0FBbko7QUFBQSxVQUFzSnVRLGlCQUFpQixHQUFHRCxZQUFZLEdBQUcscUJBQUgsR0FBMkIsY0FBak47QUFBQSxVQUFpT0UsaUJBQWlCLEdBQUdGLFlBQVksR0FBRyxxQkFBSCxHQUEyQixjQUE1UjtBQUNBLFVBQUkvQixTQUFTLEdBQUc4QixhQUFhLEdBQUcsQ0FBaEIsR0FBb0JELFlBQXBDO0FBQUEsVUFBa0RLLFFBQVEsR0FBRyxDQUE3RCxDQUppQyxDQUtqQzs7QUFDQSxhQUFPbEMsU0FBUyxJQUFJOEIsYUFBcEIsRUFBbUM5QixTQUFTLElBQUlrQyxRQUFRLEVBQXhELEVBQTREO0FBQ3hEN0csWUFBSSxDQUFDMUgsV0FBTCxDQUFpQm9NLFNBQVMsQ0FBQ2lDLGlCQUFELEVBQW9CLElBQUl2dkMsSUFBSixDQUFTK1IsSUFBVCxFQUFlQyxLQUFLLEdBQUcsQ0FBdkIsRUFBMEJ1N0IsU0FBMUIsQ0FBcEIsRUFBMERBLFNBQTFELEVBQXFFa0MsUUFBckUsQ0FBMUI7QUFDSCxPQVJnQyxDQVNqQzs7O0FBQ0EsV0FBS2xDLFNBQVMsR0FBRyxDQUFqQixFQUFvQkEsU0FBUyxJQUFJMTBCLFdBQWpDLEVBQThDMDBCLFNBQVMsSUFBSWtDLFFBQVEsRUFBbkUsRUFBdUU7QUFDbkU3RyxZQUFJLENBQUMxSCxXQUFMLENBQWlCb00sU0FBUyxDQUFDLEVBQUQsRUFBSyxJQUFJdHRDLElBQUosQ0FBUytSLElBQVQsRUFBZUMsS0FBZixFQUFzQnU3QixTQUF0QixDQUFMLEVBQXVDQSxTQUF2QyxFQUFrRGtDLFFBQWxELENBQTFCO0FBQ0gsT0FaZ0MsQ0FhakM7OztBQUNBLFdBQUssSUFBSXJyQixNQUFNLEdBQUd2TCxXQUFXLEdBQUcsQ0FBaEMsRUFBbUN1TCxNQUFNLElBQUksS0FBS2dyQixZQUFmLEtBQzlCaDFDLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUFaLEtBQTJCLENBQTNCLElBQWdDeVEsUUFBUSxHQUFHLENBQVgsS0FBaUIsQ0FEbkIsQ0FBbkMsRUFDMERyckIsTUFBTSxJQUFJcXJCLFFBQVEsRUFENUUsRUFDZ0Y7QUFDNUU3RyxZQUFJLENBQUMxSCxXQUFMLENBQWlCb00sU0FBUyxDQUFDa0MsaUJBQUQsRUFBb0IsSUFBSXh2QyxJQUFKLENBQVMrUixJQUFULEVBQWVDLEtBQUssR0FBRyxDQUF2QixFQUEwQm9TLE1BQU0sR0FBR3ZMLFdBQW5DLENBQXBCLEVBQXFFdUwsTUFBckUsRUFBNkVxckIsUUFBN0UsQ0FBMUI7QUFDSCxPQWpCZ0MsQ0FrQmpDOzs7QUFDQSxVQUFJQyxZQUFZLEdBQUd2UCxhQUFhLENBQUMsS0FBRCxFQUFRLGNBQVIsQ0FBaEM7QUFDQXVQLGtCQUFZLENBQUN4TyxXQUFiLENBQXlCMEgsSUFBekI7QUFDQSxhQUFPOEcsWUFBUDtBQUNIOztBQUNELGFBQVMzQyxTQUFULEdBQXFCO0FBQ2pCLFVBQUkzeUMsSUFBSSxDQUFDc3VDLGFBQUwsS0FBdUIvbkIsU0FBM0IsRUFBc0M7QUFDbEM7QUFDSDs7QUFDRDBmLGVBQVMsQ0FBQ2ptQyxJQUFJLENBQUNzdUMsYUFBTixDQUFULENBSmlCLENBS2pCOztBQUNBLFVBQUl0dUMsSUFBSSxDQUFDMmQsV0FBVCxFQUNJc29CLFNBQVMsQ0FBQ2ptQyxJQUFJLENBQUMyZCxXQUFOLENBQVQ7QUFDSixVQUFJNDNCLElBQUksR0FBR3J1QyxRQUFRLENBQUNrckMsc0JBQVQsRUFBWDs7QUFDQSxXQUFLLElBQUkzNEMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUFoQyxFQUE0Q25yQyxDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLFlBQUlrcUIsQ0FBQyxHQUFHLElBQUkvZCxJQUFKLENBQVM1RixJQUFJLENBQUNrdEMsV0FBZCxFQUEyQmx0QyxJQUFJLENBQUNpdEMsWUFBaEMsRUFBOEMsQ0FBOUMsQ0FBUjtBQUNBdHBCLFNBQUMsQ0FBQzhqQixRQUFGLENBQVd6bkMsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0J4ekMsQ0FBL0I7QUFDQTg3QyxZQUFJLENBQUN6TyxXQUFMLENBQWlCaU8sY0FBYyxDQUFDcHhCLENBQUMsQ0FBQzBGLFdBQUYsRUFBRCxFQUFrQjFGLENBQUMsQ0FBQ21HLFFBQUYsRUFBbEIsQ0FBL0I7QUFDSDs7QUFDRDlwQixVQUFJLENBQUNzdUMsYUFBTCxDQUFtQnhILFdBQW5CLENBQStCeU8sSUFBL0I7QUFDQXYxQyxVQUFJLENBQUN3dUMsSUFBTCxHQUFZeHVDLElBQUksQ0FBQ3N1QyxhQUFMLENBQW1CbkksVUFBL0I7O0FBQ0EsVUFBSW5tQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUFyQixJQUFnQ3pqQyxJQUFJLENBQUMrZCxhQUFMLENBQW1CMWIsTUFBbkIsS0FBOEIsQ0FBbEUsRUFBcUU7QUFDakV5dUMsbUJBQVc7QUFDZDtBQUNKOztBQUNELGFBQVNlLGdCQUFULEdBQTRCO0FBQ3hCLFVBQUk3eEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQVosR0FBeUIsQ0FBekIsSUFDQTVrQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZckYsaUJBQVosS0FBa0MsVUFEdEMsRUFFSTs7QUFDSixVQUFJOFIsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFVNTlCLEtBQVYsRUFBaUI7QUFDcEMsWUFBSTVYLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixLQUF3QmdKLFNBQXhCLElBQ0F2bUIsSUFBSSxDQUFDa3RDLFdBQUwsS0FBcUJsdEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9COEwsV0FBcEIsRUFEckIsSUFFQXpSLEtBQUssR0FBRzVYLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQnVNLFFBQXBCLEVBRlosRUFFNEM7QUFDeEMsaUJBQU8sS0FBUDtBQUNIOztBQUNELGVBQU8sRUFBRTlwQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosS0FBd0JpSixTQUF4QixJQUNMdm1CLElBQUksQ0FBQ2t0QyxXQUFMLEtBQXFCbHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixDQUFvQitMLFdBQXBCLEVBRGhCLElBRUx6UixLQUFLLEdBQUc1WCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0J3TSxRQUFwQixFQUZMLENBQVA7QUFHSCxPQVREOztBQVVBOXBCLFVBQUksQ0FBQ3kxQyx1QkFBTCxDQUE2QnBELFFBQTdCLEdBQXdDLENBQUMsQ0FBekM7QUFDQXJ5QyxVQUFJLENBQUN5MUMsdUJBQUwsQ0FBNkJDLFNBQTdCLEdBQXlDLEVBQXpDOztBQUNBLFdBQUssSUFBSWo4QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO0FBQ3pCLFlBQUksQ0FBQys3QyxnQkFBZ0IsQ0FBQy83QyxDQUFELENBQXJCLEVBQ0k7QUFDSixZQUFJbWUsS0FBSyxHQUFHbXVCLGFBQWEsQ0FBQyxRQUFELEVBQVcsK0JBQVgsQ0FBekI7QUFDQW51QixhQUFLLENBQUM5ZCxLQUFOLEdBQWMsSUFBSThMLElBQUosQ0FBUzVGLElBQUksQ0FBQ2t0QyxXQUFkLEVBQTJCenpDLENBQTNCLEVBQThCcXdCLFFBQTlCLEdBQXlDMWxCLFFBQXpDLEVBQWQ7QUFDQXdULGFBQUssQ0FBQ291QixXQUFOLEdBQW9CbUIsVUFBVSxDQUFDMXRDLENBQUQsRUFBSXVHLElBQUksQ0FBQytvQyxNQUFMLENBQVlwRSxxQkFBaEIsRUFBdUMza0MsSUFBSSxDQUFDaXBDLElBQTVDLENBQTlCO0FBQ0FyeEIsYUFBSyxDQUFDeTZCLFFBQU4sR0FBaUIsQ0FBQyxDQUFsQjs7QUFDQSxZQUFJcnlDLElBQUksQ0FBQ2l0QyxZQUFMLEtBQXNCeHpDLENBQTFCLEVBQTZCO0FBQ3pCbWUsZUFBSyxDQUFDKzlCLFFBQU4sR0FBaUIsSUFBakI7QUFDSDs7QUFDRDMxQyxZQUFJLENBQUN5MUMsdUJBQUwsQ0FBNkIzTyxXQUE3QixDQUF5Q2x2QixLQUF6QztBQUNIO0FBQ0o7O0FBQ0QsYUFBU2crQixVQUFULEdBQXNCO0FBQ2xCLFVBQUlDLFNBQVMsR0FBRzlQLGFBQWEsQ0FBQyxLQUFELEVBQVEsaUJBQVIsQ0FBN0I7QUFDQSxVQUFJK1AsZ0JBQWdCLEdBQUdudUMsTUFBTSxDQUFDVCxRQUFQLENBQWdCa3JDLHNCQUFoQixFQUF2QjtBQUNBLFVBQUkyRCxZQUFKOztBQUNBLFVBQUkvMUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQVosR0FBeUIsQ0FBekIsSUFDQTVrQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZckYsaUJBQVosS0FBa0MsUUFEdEMsRUFDZ0Q7QUFDNUNxUyxvQkFBWSxHQUFHaFEsYUFBYSxDQUFDLE1BQUQsRUFBUyxXQUFULENBQTVCO0FBQ0gsT0FIRCxNQUlLO0FBQ0QvbEMsWUFBSSxDQUFDeTFDLHVCQUFMLEdBQStCMVAsYUFBYSxDQUFDLFFBQUQsRUFBVyxnQ0FBWCxDQUE1QztBQUNBL2xDLFlBQUksQ0FBQ3kxQyx1QkFBTCxDQUE2QjVPLFlBQTdCLENBQTBDLFlBQTFDLEVBQXdEN21DLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqRSxjQUFsRTtBQUNBN3JDLFlBQUksQ0FBQzZHLElBQUksQ0FBQ3kxQyx1QkFBTixFQUErQixRQUEvQixFQUF5QyxVQUFVcnVDLENBQVYsRUFBYTtBQUN0RCxjQUFJbE4sTUFBTSxHQUFHNnNDLGNBQWMsQ0FBQzMvQixDQUFELENBQTNCO0FBQ0EsY0FBSTR1QyxhQUFhLEdBQUczd0MsUUFBUSxDQUFDbkwsTUFBTSxDQUFDSixLQUFSLEVBQWUsRUFBZixDQUE1QjtBQUNBa0csY0FBSSxDQUFDa3NDLFdBQUwsQ0FBaUI4SixhQUFhLEdBQUdoMkMsSUFBSSxDQUFDaXRDLFlBQXRDO0FBQ0FjLHNCQUFZLENBQUMsZUFBRCxDQUFaO0FBQ0gsU0FMRyxDQUFKO0FBTUE4RCx3QkFBZ0I7QUFDaEJrRSxvQkFBWSxHQUFHLzFDLElBQUksQ0FBQ3kxQyx1QkFBcEI7QUFDSDs7QUFDRCxVQUFJUSxTQUFTLEdBQUcxUCxpQkFBaUIsQ0FBQyxVQUFELEVBQWE7QUFBRTJQLGdCQUFRLEVBQUU7QUFBWixPQUFiLENBQWpDO0FBQ0EsVUFBSUMsV0FBVyxHQUFHRixTQUFTLENBQUNHLG9CQUFWLENBQStCLE9BQS9CLEVBQXdDLENBQXhDLENBQWxCO0FBQ0FELGlCQUFXLENBQUN0UCxZQUFaLENBQXlCLFlBQXpCLEVBQXVDN21DLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVocUIsYUFBakQ7O0FBQ0EsVUFBSWpmLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBaEIsRUFBeUI7QUFDckI0NEIsbUJBQVcsQ0FBQ3RQLFlBQVosQ0FBeUIsS0FBekIsRUFBZ0M3bUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9COEwsV0FBcEIsR0FBa0NqbEIsUUFBbEMsRUFBaEM7QUFDSDs7QUFDRCxVQUFJcEUsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFoQixFQUF5QjtBQUNyQjY0QixtQkFBVyxDQUFDdFAsWUFBWixDQUF5QixLQUF6QixFQUFnQzdtQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0IrTCxXQUFwQixHQUFrQ2psQixRQUFsQyxFQUFoQztBQUNBK3hDLG1CQUFXLENBQUNFLFFBQVosR0FDSSxDQUFDLENBQUNyMkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFkLElBQ0l2ZCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0I4TCxXQUFwQixPQUFzQ3JwQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0IrTCxXQUFwQixFQUY5QztBQUdIOztBQUNELFVBQUk0akIsWUFBWSxHQUFHbEgsYUFBYSxDQUFDLEtBQUQsRUFBUSx5QkFBUixDQUFoQztBQUNBa0gsa0JBQVksQ0FBQ25HLFdBQWIsQ0FBeUJpUCxZQUF6QjtBQUNBOUksa0JBQVksQ0FBQ25HLFdBQWIsQ0FBeUJtUCxTQUF6QjtBQUNBSCxzQkFBZ0IsQ0FBQ2hQLFdBQWpCLENBQTZCbUcsWUFBN0I7QUFDQTRJLGVBQVMsQ0FBQy9PLFdBQVYsQ0FBc0JnUCxnQkFBdEI7QUFDQSxhQUFPO0FBQ0hELGlCQUFTLEVBQUVBLFNBRFI7QUFFSE0sbUJBQVcsRUFBRUEsV0FGVjtBQUdISixvQkFBWSxFQUFFQTtBQUhYLE9BQVA7QUFLSDs7QUFDRCxhQUFTTyxXQUFULEdBQXVCO0FBQ25CclEsZUFBUyxDQUFDam1DLElBQUksQ0FBQ2t4QyxRQUFOLENBQVQ7QUFDQWx4QyxVQUFJLENBQUNreEMsUUFBTCxDQUFjcEssV0FBZCxDQUEwQjltQyxJQUFJLENBQUN1MkMsWUFBL0I7O0FBQ0EsVUFBSXYyQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbkUsVUFBaEIsRUFBNEI7QUFDeEI1a0MsWUFBSSxDQUFDdzJDLFlBQUwsR0FBb0IsRUFBcEI7QUFDQXgyQyxZQUFJLENBQUN5MkMsYUFBTCxHQUFxQixFQUFyQjtBQUNIOztBQUNELFdBQUssSUFBSS95QixDQUFDLEdBQUcxakIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQXpCLEVBQXFDbGhCLENBQUMsRUFBdEMsR0FBMkM7QUFDdkMsWUFBSTlMLEtBQUssR0FBR2crQixVQUFVLEVBQXRCO0FBQ0E1MUMsWUFBSSxDQUFDdzJDLFlBQUwsQ0FBa0JoRyxJQUFsQixDQUF1QjU0QixLQUFLLENBQUN1K0IsV0FBN0I7QUFDQW4yQyxZQUFJLENBQUN5MkMsYUFBTCxDQUFtQmpHLElBQW5CLENBQXdCNTRCLEtBQUssQ0FBQ20rQixZQUE5QjtBQUNBLzFDLFlBQUksQ0FBQ2t4QyxRQUFMLENBQWNwSyxXQUFkLENBQTBCbHZCLEtBQUssQ0FBQ2krQixTQUFoQztBQUNIOztBQUNENzFDLFVBQUksQ0FBQ2t4QyxRQUFMLENBQWNwSyxXQUFkLENBQTBCOW1DLElBQUksQ0FBQzAyQyxZQUEvQjtBQUNIOztBQUNELGFBQVNwRSxhQUFULEdBQXlCO0FBQ3JCdHlDLFVBQUksQ0FBQ2t4QyxRQUFMLEdBQWdCbkwsYUFBYSxDQUFDLEtBQUQsRUFBUSxrQkFBUixDQUE3QjtBQUNBL2xDLFVBQUksQ0FBQ3cyQyxZQUFMLEdBQW9CLEVBQXBCO0FBQ0F4MkMsVUFBSSxDQUFDeTJDLGFBQUwsR0FBcUIsRUFBckI7QUFDQXoyQyxVQUFJLENBQUN1MkMsWUFBTCxHQUFvQnhRLGFBQWEsQ0FBQyxNQUFELEVBQVMsc0JBQVQsQ0FBakM7QUFDQS9sQyxVQUFJLENBQUN1MkMsWUFBTCxDQUFrQmIsU0FBbEIsR0FBOEIxMUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXJFLFNBQTFDO0FBQ0Exa0MsVUFBSSxDQUFDMDJDLFlBQUwsR0FBb0IzUSxhQUFhLENBQUMsTUFBRCxFQUFTLHNCQUFULENBQWpDO0FBQ0EvbEMsVUFBSSxDQUFDMDJDLFlBQUwsQ0FBa0JoQixTQUFsQixHQUE4QjExQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZcEYsU0FBMUM7QUFDQTJTLGlCQUFXO0FBQ1h4OUMsWUFBTSxDQUFDRCxjQUFQLENBQXNCbUgsSUFBdEIsRUFBNEIscUJBQTVCLEVBQW1EO0FBQy9DN0YsV0FBRyxFQUFFLGVBQVk7QUFBRSxpQkFBTzZGLElBQUksQ0FBQzIyQyxvQkFBWjtBQUFtQyxTQURQO0FBRS9DcDhDLFdBQUcsRUFBRSxhQUFVMnFDLElBQVYsRUFBZ0I7QUFDakIsY0FBSWxsQyxJQUFJLENBQUMyMkMsb0JBQUwsS0FBOEJ6UixJQUFsQyxFQUF3QztBQUNwQ08sdUJBQVcsQ0FBQ3psQyxJQUFJLENBQUN1MkMsWUFBTixFQUFvQixvQkFBcEIsRUFBMENyUixJQUExQyxDQUFYO0FBQ0FsbEMsZ0JBQUksQ0FBQzIyQyxvQkFBTCxHQUE0QnpSLElBQTVCO0FBQ0g7QUFDSjtBQVA4QyxPQUFuRDtBQVNBcHNDLFlBQU0sQ0FBQ0QsY0FBUCxDQUFzQm1ILElBQXRCLEVBQTRCLHFCQUE1QixFQUFtRDtBQUMvQzdGLFdBQUcsRUFBRSxlQUFZO0FBQUUsaUJBQU82RixJQUFJLENBQUM0MkMsb0JBQVo7QUFBbUMsU0FEUDtBQUUvQ3I4QyxXQUFHLEVBQUUsYUFBVTJxQyxJQUFWLEVBQWdCO0FBQ2pCLGNBQUlsbEMsSUFBSSxDQUFDNDJDLG9CQUFMLEtBQThCMVIsSUFBbEMsRUFBd0M7QUFDcENPLHVCQUFXLENBQUN6bEMsSUFBSSxDQUFDMDJDLFlBQU4sRUFBb0Isb0JBQXBCLEVBQTBDeFIsSUFBMUMsQ0FBWDtBQUNBbGxDLGdCQUFJLENBQUM0MkMsb0JBQUwsR0FBNEIxUixJQUE1QjtBQUNIO0FBQ0o7QUFQOEMsT0FBbkQ7QUFTQWxsQyxVQUFJLENBQUM2MkMsa0JBQUwsR0FBMEI3MkMsSUFBSSxDQUFDdzJDLFlBQUwsQ0FBa0IsQ0FBbEIsQ0FBMUI7QUFDQU0sa0NBQTRCO0FBQzVCLGFBQU85MkMsSUFBSSxDQUFDa3hDLFFBQVo7QUFDSDs7QUFDRCxhQUFTMEIsU0FBVCxHQUFxQjtBQUNqQjV5QyxVQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJ0SSxTQUF2QixDQUFpQ0MsR0FBakMsQ0FBcUMsU0FBckM7QUFDQSxVQUFJN2xDLElBQUksQ0FBQytvQyxNQUFMLENBQVloc0IsVUFBaEIsRUFDSS9jLElBQUksQ0FBQ2t1QyxpQkFBTCxDQUF1QnRJLFNBQXZCLENBQWlDQyxHQUFqQyxDQUFxQyxZQUFyQztBQUNKN2xDLFVBQUksQ0FBQ3F4QyxhQUFMLEdBQXFCdEwsYUFBYSxDQUFDLEtBQUQsRUFBUSxnQkFBUixDQUFsQztBQUNBL2xDLFVBQUksQ0FBQ3F4QyxhQUFMLENBQW1CZ0IsUUFBbkIsR0FBOEIsQ0FBQyxDQUEvQjtBQUNBLFVBQUkwRSxTQUFTLEdBQUdoUixhQUFhLENBQUMsTUFBRCxFQUFTLDBCQUFULEVBQXFDLEdBQXJDLENBQTdCO0FBQ0EsVUFBSWlSLFNBQVMsR0FBR3pRLGlCQUFpQixDQUFDLGdCQUFELEVBQW1CO0FBQ2hELHNCQUFjdm1DLElBQUksQ0FBQ2lwQyxJQUFMLENBQVUvcEI7QUFEd0IsT0FBbkIsQ0FBakM7QUFHQWxmLFVBQUksQ0FBQ3N2QyxXQUFMLEdBQW1CMEgsU0FBUyxDQUFDWixvQkFBVixDQUErQixPQUEvQixFQUF3QyxDQUF4QyxDQUFuQjtBQUNBLFVBQUlhLFdBQVcsR0FBRzFRLGlCQUFpQixDQUFDLGtCQUFELEVBQXFCO0FBQ3BELHNCQUFjdm1DLElBQUksQ0FBQ2lwQyxJQUFMLENBQVU5cEI7QUFENEIsT0FBckIsQ0FBbkM7QUFHQW5mLFVBQUksQ0FBQ3V2QyxhQUFMLEdBQXFCMEgsV0FBVyxDQUFDYixvQkFBWixDQUFpQyxPQUFqQyxFQUEwQyxDQUExQyxDQUFyQjtBQUNBcDJDLFVBQUksQ0FBQ3N2QyxXQUFMLENBQWlCK0MsUUFBakIsR0FBNEJyeUMsSUFBSSxDQUFDdXZDLGFBQUwsQ0FBbUI4QyxRQUFuQixHQUE4QixDQUFDLENBQTNEO0FBQ0FyeUMsVUFBSSxDQUFDc3ZDLFdBQUwsQ0FBaUJ4MUMsS0FBakIsR0FBeUI2dkIsR0FBRyxDQUFDM3BCLElBQUksQ0FBQzJ0QyxxQkFBTCxHQUN2QjN0QyxJQUFJLENBQUMydEMscUJBQUwsQ0FBMkIxaUIsUUFBM0IsRUFEdUIsR0FFdkJqckIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxzQixTQUFaLEdBQ0k3YyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdnJCLFdBRGhCLEdBRUk2eEIsYUFBYSxDQUFDcnZDLElBQUksQ0FBQytvQyxNQUFMLENBQVl2ckIsV0FBYixDQUpLLENBQTVCO0FBS0F4ZCxVQUFJLENBQUN1dkMsYUFBTCxDQUFtQnoxQyxLQUFuQixHQUEyQjZ2QixHQUFHLENBQUMzcEIsSUFBSSxDQUFDMnRDLHFCQUFMLEdBQ3pCM3RDLElBQUksQ0FBQzJ0QyxxQkFBTCxDQUEyQjdpQixVQUEzQixFQUR5QixHQUV6QjlxQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZdHJCLGFBRlksQ0FBOUI7QUFHQXpkLFVBQUksQ0FBQ3N2QyxXQUFMLENBQWlCekksWUFBakIsQ0FBOEIsTUFBOUIsRUFBc0M3bUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTFGLGFBQVosQ0FBMEJqL0IsUUFBMUIsRUFBdEM7QUFDQXBFLFVBQUksQ0FBQ3V2QyxhQUFMLENBQW1CMUksWUFBbkIsQ0FBZ0MsTUFBaEMsRUFBd0M3bUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXZGLGVBQVosQ0FBNEJwL0IsUUFBNUIsRUFBeEM7QUFDQXBFLFVBQUksQ0FBQ3N2QyxXQUFMLENBQWlCekksWUFBakIsQ0FBOEIsS0FBOUIsRUFBcUM3bUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxzQixTQUFaLEdBQXdCLEdBQXhCLEdBQThCLEdBQW5FO0FBQ0E3YyxVQUFJLENBQUNzdkMsV0FBTCxDQUFpQnpJLFlBQWpCLENBQThCLEtBQTlCLEVBQXFDN21DLElBQUksQ0FBQytvQyxNQUFMLENBQVlsc0IsU0FBWixHQUF3QixJQUF4QixHQUErQixJQUFwRTtBQUNBN2MsVUFBSSxDQUFDdXZDLGFBQUwsQ0FBbUIxSSxZQUFuQixDQUFnQyxLQUFoQyxFQUF1QyxHQUF2QztBQUNBN21DLFVBQUksQ0FBQ3V2QyxhQUFMLENBQW1CMUksWUFBbkIsQ0FBZ0MsS0FBaEMsRUFBdUMsSUFBdkM7QUFDQTdtQyxVQUFJLENBQUNxeEMsYUFBTCxDQUFtQnZLLFdBQW5CLENBQStCa1EsU0FBL0I7QUFDQWgzQyxVQUFJLENBQUNxeEMsYUFBTCxDQUFtQnZLLFdBQW5CLENBQStCaVEsU0FBL0I7QUFDQS8yQyxVQUFJLENBQUNxeEMsYUFBTCxDQUFtQnZLLFdBQW5CLENBQStCbVEsV0FBL0I7QUFDQSxVQUFJajNDLElBQUksQ0FBQytvQyxNQUFMLENBQVlsc0IsU0FBaEIsRUFDSTdjLElBQUksQ0FBQ3F4QyxhQUFMLENBQW1CekwsU0FBbkIsQ0FBNkJDLEdBQTdCLENBQWlDLFVBQWpDOztBQUNKLFVBQUk3bEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWpzQixhQUFoQixFQUErQjtBQUMzQjljLFlBQUksQ0FBQ3F4QyxhQUFMLENBQW1CekwsU0FBbkIsQ0FBNkJDLEdBQTdCLENBQWlDLFlBQWpDO0FBQ0EsWUFBSXFSLFdBQVcsR0FBRzNRLGlCQUFpQixDQUFDLGtCQUFELENBQW5DO0FBQ0F2bUMsWUFBSSxDQUFDd3ZDLGFBQUwsR0FBcUIwSCxXQUFXLENBQUNkLG9CQUFaLENBQWlDLE9BQWpDLEVBQTBDLENBQTFDLENBQXJCO0FBQ0FwMkMsWUFBSSxDQUFDd3ZDLGFBQUwsQ0FBbUIxMUMsS0FBbkIsR0FBMkI2dkIsR0FBRyxDQUFDM3BCLElBQUksQ0FBQzJ0QyxxQkFBTCxHQUN6QjN0QyxJQUFJLENBQUMydEMscUJBQUwsQ0FBMkI1aUIsVUFBM0IsRUFEeUIsR0FFekIvcUIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXBHLGNBRlksQ0FBOUI7QUFHQTNpQyxZQUFJLENBQUN3dkMsYUFBTCxDQUFtQjNJLFlBQW5CLENBQWdDLE1BQWhDLEVBQXdDN21DLElBQUksQ0FBQ3V2QyxhQUFMLENBQW1CNEgsWUFBbkIsQ0FBZ0MsTUFBaEMsQ0FBeEM7QUFDQW4zQyxZQUFJLENBQUN3dkMsYUFBTCxDQUFtQjNJLFlBQW5CLENBQWdDLEtBQWhDLEVBQXVDLEdBQXZDO0FBQ0E3bUMsWUFBSSxDQUFDd3ZDLGFBQUwsQ0FBbUIzSSxZQUFuQixDQUFnQyxLQUFoQyxFQUF1QyxJQUF2QztBQUNBN21DLFlBQUksQ0FBQ3F4QyxhQUFMLENBQW1CdkssV0FBbkIsQ0FBK0JmLGFBQWEsQ0FBQyxNQUFELEVBQVMsMEJBQVQsRUFBcUMsR0FBckMsQ0FBNUM7QUFDQS9sQyxZQUFJLENBQUNxeEMsYUFBTCxDQUFtQnZLLFdBQW5CLENBQStCb1EsV0FBL0I7QUFDSDs7QUFDRCxVQUFJLENBQUNsM0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxzQixTQUFqQixFQUE0QjtBQUN4QjtBQUNBN2MsWUFBSSxDQUFDZ2YsSUFBTCxHQUFZK21CLGFBQWEsQ0FBQyxNQUFELEVBQVMsaUJBQVQsRUFBNEIvbEMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWVpbUIsR0FBRyxDQUFDLENBQUNqbEMsSUFBSSxDQUFDMnRDLHFCQUFMLEdBQ25FM3RDLElBQUksQ0FBQ3N2QyxXQUFMLENBQWlCeDFDLEtBRGtELEdBRW5Fa0csSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXZyQixXQUZzRCxJQUV2QyxFQUZzQyxDQUFsQixDQUE1QixDQUF6QjtBQUdBeGQsWUFBSSxDQUFDZ2YsSUFBTCxDQUFVOVQsS0FBVixHQUFrQmxMLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVscUIsV0FBNUI7QUFDQS9lLFlBQUksQ0FBQ2dmLElBQUwsQ0FBVXF6QixRQUFWLEdBQXFCLENBQUMsQ0FBdEI7QUFDQXJ5QyxZQUFJLENBQUNxeEMsYUFBTCxDQUFtQnZLLFdBQW5CLENBQStCOW1DLElBQUksQ0FBQ2dmLElBQXBDO0FBQ0g7O0FBQ0QsYUFBT2hmLElBQUksQ0FBQ3F4QyxhQUFaO0FBQ0g7O0FBQ0QsYUFBU3FCLGFBQVQsR0FBeUI7QUFDckIsVUFBSSxDQUFDMXlDLElBQUksQ0FBQ28zQyxnQkFBVixFQUNJcDNDLElBQUksQ0FBQ28zQyxnQkFBTCxHQUF3QnJSLGFBQWEsQ0FBQyxLQUFELEVBQVEsb0JBQVIsQ0FBckMsQ0FESixLQUdJRSxTQUFTLENBQUNqbUMsSUFBSSxDQUFDbzNDLGdCQUFOLENBQVQ7O0FBQ0osV0FBSyxJQUFJMzlDLENBQUMsR0FBR3VHLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUF6QixFQUFxQ25yQyxDQUFDLEVBQXRDLEdBQTJDO0FBQ3ZDLFlBQUlvOEMsU0FBUyxHQUFHOVAsYUFBYSxDQUFDLEtBQUQsRUFBUSw0QkFBUixDQUE3QjtBQUNBL2xDLFlBQUksQ0FBQ28zQyxnQkFBTCxDQUFzQnRRLFdBQXRCLENBQWtDK08sU0FBbEM7QUFDSDs7QUFDRHdCLG9CQUFjO0FBQ2QsYUFBT3IzQyxJQUFJLENBQUNvM0MsZ0JBQVo7QUFDSDs7QUFDRCxhQUFTQyxjQUFULEdBQTBCO0FBQ3RCLFVBQUksQ0FBQ3IzQyxJQUFJLENBQUNvM0MsZ0JBQVYsRUFBNEI7QUFDeEI7QUFDSDs7QUFDRCxVQUFJMTRCLGNBQWMsR0FBRzFlLElBQUksQ0FBQ2lwQyxJQUFMLENBQVV2cUIsY0FBL0I7O0FBQ0EsVUFBSUwsUUFBUSxHQUFHZ2pCLGNBQWMsQ0FBQ3JoQyxJQUFJLENBQUNpcEMsSUFBTCxDQUFVNXFCLFFBQVYsQ0FBbUJDLFNBQXBCLENBQTdCOztBQUNBLFVBQUlJLGNBQWMsR0FBRyxDQUFqQixJQUFzQkEsY0FBYyxHQUFHTCxRQUFRLENBQUNoYyxNQUFwRCxFQUE0RDtBQUN4RGdjLGdCQUFRLEdBQUdnakIsY0FBYyxDQUFDaGpCLFFBQVEsQ0FBQ2k1QixNQUFULENBQWdCNTRCLGNBQWhCLEVBQWdDTCxRQUFRLENBQUNoYyxNQUF6QyxDQUFELEVBQW1EZ2MsUUFBUSxDQUFDaTVCLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUI1NEIsY0FBbkIsQ0FBbkQsQ0FBekI7QUFDSDs7QUFDRCxXQUFLLElBQUlqbEIsQ0FBQyxHQUFHdUcsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5FLFVBQXpCLEVBQXFDbnJDLENBQUMsRUFBdEMsR0FBMkM7QUFDdkN1RyxZQUFJLENBQUNvM0MsZ0JBQUwsQ0FBc0JsRCxRQUF0QixDQUErQno2QyxDQUEvQixFQUFrQ2k4QyxTQUFsQyxHQUE4Qyx1REFBdURyM0IsUUFBUSxDQUFDbUssSUFBVCxDQUFjLHlDQUFkLENBQXZELEdBQWtILHlCQUFoSztBQUNIO0FBQ0o7QUFDRDs7O0FBQ0EsYUFBU2dxQixVQUFULEdBQXNCO0FBQ2xCeHlDLFVBQUksQ0FBQ2t1QyxpQkFBTCxDQUF1QnRJLFNBQXZCLENBQWlDQyxHQUFqQyxDQUFxQyxVQUFyQztBQUNBLFVBQUk4SSxXQUFXLEdBQUc1SSxhQUFhLENBQUMsS0FBRCxFQUFRLHVCQUFSLENBQS9CO0FBQ0E0SSxpQkFBVyxDQUFDN0gsV0FBWixDQUF3QmYsYUFBYSxDQUFDLE1BQUQsRUFBUyxtQkFBVCxFQUE4Qi9sQyxJQUFJLENBQUNpcEMsSUFBTCxDQUFVcHFCLGdCQUF4QyxDQUFyQztBQUNBLFVBQUlsQixXQUFXLEdBQUdvb0IsYUFBYSxDQUFDLEtBQUQsRUFBUSxpQkFBUixDQUEvQjtBQUNBNEksaUJBQVcsQ0FBQzdILFdBQVosQ0FBd0JucEIsV0FBeEI7QUFDQSxhQUFPO0FBQ0hneEIsbUJBQVcsRUFBRUEsV0FEVjtBQUVIaHhCLG1CQUFXLEVBQUVBO0FBRlYsT0FBUDtBQUlIOztBQUNELGFBQVN1dUIsV0FBVCxDQUFxQnB5QyxLQUFyQixFQUE0Qnk5QyxRQUE1QixFQUFzQztBQUNsQyxVQUFJQSxRQUFRLEtBQUssS0FBSyxDQUF0QixFQUF5QjtBQUFFQSxnQkFBUSxHQUFHLElBQVg7QUFBa0I7O0FBQzdDLFVBQUlsSCxLQUFLLEdBQUdrSCxRQUFRLEdBQUd6OUMsS0FBSCxHQUFXQSxLQUFLLEdBQUdrRyxJQUFJLENBQUNpdEMsWUFBNUM7QUFDQSxVQUFLb0QsS0FBSyxHQUFHLENBQVIsSUFBYXJ3QyxJQUFJLENBQUN3M0MsbUJBQUwsS0FBNkIsSUFBM0MsSUFDQ25ILEtBQUssR0FBRyxDQUFSLElBQWFyd0MsSUFBSSxDQUFDeTNDLG1CQUFMLEtBQTZCLElBRC9DLEVBRUk7QUFDSnozQyxVQUFJLENBQUNpdEMsWUFBTCxJQUFxQm9ELEtBQXJCOztBQUNBLFVBQUlyd0MsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0IsQ0FBcEIsSUFBeUJqdEMsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0IsRUFBakQsRUFBcUQ7QUFDakRqdEMsWUFBSSxDQUFDa3RDLFdBQUwsSUFBb0JsdEMsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0IsRUFBcEIsR0FBeUIsQ0FBekIsR0FBNkIsQ0FBQyxDQUFsRDtBQUNBanRDLFlBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CLENBQUNqdEMsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0IsRUFBckIsSUFBMkIsRUFBL0M7QUFDQWMsb0JBQVksQ0FBQyxjQUFELENBQVo7QUFDQThELHdCQUFnQjtBQUNuQjs7QUFDRGMsZUFBUztBQUNUNUUsa0JBQVksQ0FBQyxlQUFELENBQVo7QUFDQStJLGtDQUE0QjtBQUMvQjs7QUFDRCxhQUFTMUssS0FBVCxDQUFlc0wsa0JBQWYsRUFBbUNDLFNBQW5DLEVBQThDO0FBQzFDLFVBQUlELGtCQUFrQixLQUFLLEtBQUssQ0FBaEMsRUFBbUM7QUFBRUEsMEJBQWtCLEdBQUcsSUFBckI7QUFBNEI7O0FBQ2pFLFVBQUlDLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQUVBLGlCQUFTLEdBQUcsSUFBWjtBQUFtQjs7QUFDL0MzM0MsVUFBSSxDQUFDOEssS0FBTCxDQUFXaFIsS0FBWCxHQUFtQixFQUFuQjtBQUNBLFVBQUlrRyxJQUFJLENBQUNpaUMsUUFBTCxLQUFrQjFiLFNBQXRCLEVBQ0l2bUIsSUFBSSxDQUFDaWlDLFFBQUwsQ0FBY25vQyxLQUFkLEdBQXNCLEVBQXRCO0FBQ0osVUFBSWtHLElBQUksQ0FBQzQzQyxXQUFMLEtBQXFCcnhCLFNBQXpCLEVBQ0l2bUIsSUFBSSxDQUFDNDNDLFdBQUwsQ0FBaUI5OUMsS0FBakIsR0FBeUIsRUFBekI7QUFDSmtHLFVBQUksQ0FBQytkLGFBQUwsR0FBcUIsRUFBckI7QUFDQS9kLFVBQUksQ0FBQzJ0QyxxQkFBTCxHQUE2QnBuQixTQUE3Qjs7QUFDQSxVQUFJb3hCLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQjMzQyxZQUFJLENBQUNrdEMsV0FBTCxHQUFtQmx0QyxJQUFJLENBQUM2M0MsWUFBTCxDQUFrQnh1QixXQUFsQixFQUFuQjtBQUNBcnBCLFlBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CanRDLElBQUksQ0FBQzYzQyxZQUFMLENBQWtCL3RCLFFBQWxCLEVBQXBCO0FBQ0g7O0FBQ0QsVUFBSTlwQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZenlCLFVBQVosS0FBMkIsSUFBL0IsRUFBcUM7QUFDakMsWUFBSXV5QixFQUFFLEdBQUdrRyxlQUFlLEVBQXhCO0FBQUEsWUFBNEIzcEMsS0FBSyxHQUFHeWpDLEVBQUUsQ0FBQ3pqQyxLQUF2QztBQUFBLFlBQThDSSxPQUFPLEdBQUdxakMsRUFBRSxDQUFDcmpDLE9BQTNEO0FBQUEsWUFBb0VvVyxPQUFPLEdBQUdpdEIsRUFBRSxDQUFDanRCLE9BQWpGOztBQUNBc25CLGdCQUFRLENBQUM5OUIsS0FBRCxFQUFRSSxPQUFSLEVBQWlCb1csT0FBakIsQ0FBUjtBQUNIOztBQUNENWIsVUFBSSxDQUFDMnNDLE1BQUw7QUFDQSxVQUFJK0ssa0JBQUosRUFDSTtBQUNBM0osb0JBQVksQ0FBQyxVQUFELENBQVo7QUFDUDs7QUFDRCxhQUFTMUIsS0FBVCxHQUFpQjtBQUNicnNDLFVBQUksQ0FBQ290QyxNQUFMLEdBQWMsS0FBZDs7QUFDQSxVQUFJLENBQUNwdEMsSUFBSSxDQUFDbXBDLFFBQVYsRUFBb0I7QUFDaEIsWUFBSW5wQyxJQUFJLENBQUNrdUMsaUJBQUwsS0FBMkIzbkIsU0FBL0IsRUFBMEM7QUFDdEN2bUIsY0FBSSxDQUFDa3VDLGlCQUFMLENBQXVCdEksU0FBdkIsQ0FBaUNFLE1BQWpDLENBQXdDLE1BQXhDO0FBQ0g7O0FBQ0QsWUFBSTlsQyxJQUFJLENBQUNzZixNQUFMLEtBQWdCaUgsU0FBcEIsRUFBK0I7QUFDM0J2bUIsY0FBSSxDQUFDc2YsTUFBTCxDQUFZc21CLFNBQVosQ0FBc0JFLE1BQXRCLENBQTZCLFFBQTdCO0FBQ0g7QUFDSjs7QUFDRGlJLGtCQUFZLENBQUMsU0FBRCxDQUFaO0FBQ0g7O0FBQ0QsYUFBU3hCLE9BQVQsR0FBbUI7QUFDZixVQUFJdnNDLElBQUksQ0FBQytvQyxNQUFMLEtBQWdCeGlCLFNBQXBCLEVBQ0l3bkIsWUFBWSxDQUFDLFdBQUQsQ0FBWjs7QUFDSixXQUFLLElBQUl0MEMsQ0FBQyxHQUFHdUcsSUFBSSxDQUFDMHJDLFNBQUwsQ0FBZXJwQyxNQUE1QixFQUFvQzVJLENBQUMsRUFBckMsR0FBMEM7QUFDdEMsWUFBSTh6QixDQUFDLEdBQUd2dEIsSUFBSSxDQUFDMHJDLFNBQUwsQ0FBZWp5QyxDQUFmLENBQVI7QUFDQTh6QixTQUFDLENBQUNnZSxPQUFGLENBQVV1TSxtQkFBVixDQUE4QnZxQixDQUFDLENBQUM5aUIsS0FBaEMsRUFBdUM4aUIsQ0FBQyxDQUFDOVEsT0FBekMsRUFBa0Q4USxDQUFDLENBQUM3bEIsT0FBcEQ7QUFDSDs7QUFDRDFILFVBQUksQ0FBQzByQyxTQUFMLEdBQWlCLEVBQWpCOztBQUNBLFVBQUkxckMsSUFBSSxDQUFDNDNDLFdBQVQsRUFBc0I7QUFDbEIsWUFBSTUzQyxJQUFJLENBQUM0M0MsV0FBTCxDQUFpQnRSLFVBQXJCLEVBQ0l0bUMsSUFBSSxDQUFDNDNDLFdBQUwsQ0FBaUJ0UixVQUFqQixDQUE0QkYsV0FBNUIsQ0FBd0NwbUMsSUFBSSxDQUFDNDNDLFdBQTdDO0FBQ0o1M0MsWUFBSSxDQUFDNDNDLFdBQUwsR0FBbUJyeEIsU0FBbkI7QUFDSCxPQUpELE1BS0ssSUFBSXZtQixJQUFJLENBQUNrdUMsaUJBQUwsSUFBMEJsdUMsSUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCNUgsVUFBckQsRUFBaUU7QUFDbEUsWUFBSXRtQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbEUsTUFBWixJQUFzQjdrQyxJQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUI1SCxVQUFqRCxFQUE2RDtBQUN6RCxjQUFJcmpCLE9BQU8sR0FBR2pqQixJQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUI1SCxVQUFyQztBQUNBcmpCLGlCQUFPLENBQUM4MEIsU0FBUixJQUFxQjkwQixPQUFPLENBQUNtakIsV0FBUixDQUFvQm5qQixPQUFPLENBQUM4MEIsU0FBNUIsQ0FBckI7O0FBQ0EsY0FBSTkwQixPQUFPLENBQUNxakIsVUFBWixFQUF3QjtBQUNwQixtQkFBT3JqQixPQUFPLENBQUNrakIsVUFBZjtBQUNJbGpCLHFCQUFPLENBQUNxakIsVUFBUixDQUFtQjBNLFlBQW5CLENBQWdDL3ZCLE9BQU8sQ0FBQ2tqQixVQUF4QyxFQUFvRGxqQixPQUFwRDtBQURKOztBQUVBQSxtQkFBTyxDQUFDcWpCLFVBQVIsQ0FBbUJGLFdBQW5CLENBQStCbmpCLE9BQS9CO0FBQ0g7QUFDSixTQVJELE1BVUlqakIsSUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCNUgsVUFBdkIsQ0FBa0NGLFdBQWxDLENBQThDcG1DLElBQUksQ0FBQ2t1QyxpQkFBbkQ7QUFDUDs7QUFDRCxVQUFJbHVDLElBQUksQ0FBQ2lpQyxRQUFULEVBQW1CO0FBQ2ZqaUMsWUFBSSxDQUFDOEssS0FBTCxDQUFXbEwsSUFBWCxHQUFrQixNQUFsQjtBQUNBLFlBQUlJLElBQUksQ0FBQ2lpQyxRQUFMLENBQWNxRSxVQUFsQixFQUNJdG1DLElBQUksQ0FBQ2lpQyxRQUFMLENBQWNxRSxVQUFkLENBQXlCRixXQUF6QixDQUFxQ3BtQyxJQUFJLENBQUNpaUMsUUFBMUM7QUFDSixlQUFPamlDLElBQUksQ0FBQ2lpQyxRQUFaO0FBQ0g7O0FBQ0QsVUFBSWppQyxJQUFJLENBQUM4SyxLQUFULEVBQWdCO0FBQ1o5SyxZQUFJLENBQUM4SyxLQUFMLENBQVdsTCxJQUFYLEdBQWtCSSxJQUFJLENBQUM4SyxLQUFMLENBQVdrdEMsS0FBN0I7QUFDQWg0QyxZQUFJLENBQUM4SyxLQUFMLENBQVc4NkIsU0FBWCxDQUFxQkUsTUFBckIsQ0FBNEIsaUJBQTVCO0FBQ0E5bEMsWUFBSSxDQUFDOEssS0FBTCxDQUFXbXRDLGVBQVgsQ0FBMkIsVUFBM0I7QUFDSDs7QUFDRCxPQUNJLGdCQURKLEVBRUksdUJBRkosRUFHSSxxQkFISixFQUlJLHFCQUpKLEVBS0ksc0JBTEosRUFNSSxzQkFOSixFQU9JLFVBUEosRUFRSSxRQVJKLEVBU0ksa0JBVEosRUFVSSxnQkFWSixFQVdJLGdCQVhKLEVBWUksTUFaSixFQWFJLGVBYkosRUFjSSxRQWRKLEVBZUksa0JBZkosRUFnQkksZ0JBaEJKLEVBaUJJLFlBakJKLEVBa0JJLFVBbEJKLEVBbUJJLGVBbkJKLEVBb0JJLG1CQXBCSixFQXFCSSxrQkFyQkosRUFzQkksY0F0QkosRUF1QkksY0F2QkosRUF3QkkseUJBeEJKLEVBeUJJLHFCQXpCSixFQTBCSSxvQkExQkosRUEyQkksd0JBM0JKLEVBNEJJLGtCQTVCSixFQTZCSSxRQTdCSixFQThCRXhOLE9BOUJGLENBOEJVLFVBQVVwZixDQUFWLEVBQWE7QUFDbkIsWUFBSTtBQUNBLGlCQUFPcnJCLElBQUksQ0FBQ3FyQixDQUFELENBQVg7QUFDSCxTQUZELENBR0EsT0FBTzBjLENBQVAsRUFBVSxDQUFHO0FBQ2hCLE9BbkNEO0FBb0NIOztBQUNELGFBQVNtUSxjQUFULENBQXdCeFMsSUFBeEIsRUFBOEI7QUFDMUIsVUFBSTFsQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0osUUFBWixJQUF3Qjl5QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0osUUFBWixDQUFxQmYsUUFBckIsQ0FBOEJyTSxJQUE5QixDQUE1QixFQUNJLE9BQU8sSUFBUDtBQUNKLGFBQU8xbEMsSUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCNkQsUUFBdkIsQ0FBZ0NyTSxJQUFoQyxDQUFQO0FBQ0g7O0FBQ0QsYUFBU3NMLGFBQVQsQ0FBdUI1cEMsQ0FBdkIsRUFBMEI7QUFDdEIsVUFBSXBILElBQUksQ0FBQ290QyxNQUFMLElBQWUsQ0FBQ3B0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeEYsTUFBaEMsRUFBd0M7QUFDcEMsWUFBSTRVLGFBQWEsR0FBR3BSLGNBQWMsQ0FBQzMvQixDQUFELENBQWxDO0FBQ0EsWUFBSWd4QyxpQkFBaUIsR0FBR0YsY0FBYyxDQUFDQyxhQUFELENBQXRDO0FBQ0EsWUFBSUUsT0FBTyxHQUFHRixhQUFhLEtBQUtuNEMsSUFBSSxDQUFDOEssS0FBdkIsSUFDVnF0QyxhQUFhLEtBQUtuNEMsSUFBSSxDQUFDaWlDLFFBRGIsSUFFVmppQyxJQUFJLENBQUN1ckMsT0FBTCxDQUFhd0csUUFBYixDQUFzQm9HLGFBQXRCLENBRlUsSUFHVjtBQUNBO0FBQ0Mvd0MsU0FBQyxDQUFDNi9CLElBQUYsSUFDRzcvQixDQUFDLENBQUM2L0IsSUFBRixDQUFPL2UsT0FEVixLQUVJLENBQUM5Z0IsQ0FBQyxDQUFDNi9CLElBQUYsQ0FBTy9lLE9BQVAsQ0FBZWxvQixJQUFJLENBQUM4SyxLQUFwQixDQUFELElBQ0csQ0FBQzFELENBQUMsQ0FBQzYvQixJQUFGLENBQU8vZSxPQUFQLENBQWVsb0IsSUFBSSxDQUFDaWlDLFFBQXBCLENBSFIsQ0FMTDtBQVNBLFlBQUlxVyxTQUFTLEdBQUdseEMsQ0FBQyxDQUFDeEgsSUFBRixLQUFXLE1BQVgsR0FDVnk0QyxPQUFPLElBQ0xqeEMsQ0FBQyxDQUFDbXhDLGFBREosSUFFRSxDQUFDTCxjQUFjLENBQUM5d0MsQ0FBQyxDQUFDbXhDLGFBQUgsQ0FIUCxHQUlWLENBQUNGLE9BQUQsSUFDRSxDQUFDRCxpQkFESCxJQUVFLENBQUNGLGNBQWMsQ0FBQzl3QyxDQUFDLENBQUNteEMsYUFBSCxDQU52QjtBQU9BLFlBQUlDLFNBQVMsR0FBRyxDQUFDeDRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6RixvQkFBWixDQUFpQ21WLElBQWpDLENBQXNDLFVBQVUvUyxJQUFWLEVBQWdCO0FBQ25FLGlCQUFPQSxJQUFJLENBQUNxTSxRQUFMLENBQWNvRyxhQUFkLENBQVA7QUFDSCxTQUZnQixDQUFqQjs7QUFHQSxZQUFJRyxTQUFTLElBQUlFLFNBQWpCLEVBQTRCO0FBQ3hCLGNBQUl4NEMsSUFBSSxDQUFDcXhDLGFBQUwsS0FBdUI5cUIsU0FBdkIsSUFDQXZtQixJQUFJLENBQUN1dkMsYUFBTCxLQUF1QmhwQixTQUR2QixJQUVBdm1CLElBQUksQ0FBQ3N2QyxXQUFMLEtBQXFCL29CLFNBRnJCLElBR0F2bUIsSUFBSSxDQUFDOEssS0FBTCxDQUFXaFIsS0FBWCxLQUFxQixFQUhyQixJQUlBa0csSUFBSSxDQUFDOEssS0FBTCxDQUFXaFIsS0FBWCxLQUFxQnlzQixTQUp6QixFQUlvQztBQUNoQ3NvQixzQkFBVTtBQUNiOztBQUNEN3VDLGNBQUksQ0FBQ3FzQyxLQUFMOztBQUNBLGNBQUlyc0MsSUFBSSxDQUFDK29DLE1BQUwsSUFDQS9vQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQURyQixJQUVBempDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIxYixNQUFuQixLQUE4QixDQUZsQyxFQUVxQztBQUNqQ3JDLGdCQUFJLENBQUNvc0MsS0FBTCxDQUFXLEtBQVg7QUFDQXBzQyxnQkFBSSxDQUFDMnNDLE1BQUw7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFDRCxhQUFTUixVQUFULENBQW9CdU0sT0FBcEIsRUFBNkI7QUFDekIsVUFBSSxDQUFDQSxPQUFELElBQ0MxNEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLElBQXVCbTdCLE9BQU8sR0FBRzE0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0I4TCxXQUFwQixFQURsQyxJQUVDcnBCLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixJQUF1Qm83QixPQUFPLEdBQUcxNEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9CK0wsV0FBcEIsRUFGdEMsRUFHSTtBQUNKLFVBQUlzdkIsVUFBVSxHQUFHRCxPQUFqQjtBQUFBLFVBQTBCRSxTQUFTLEdBQUc1NEMsSUFBSSxDQUFDa3RDLFdBQUwsS0FBcUJ5TCxVQUEzRDtBQUNBMzRDLFVBQUksQ0FBQ2t0QyxXQUFMLEdBQW1CeUwsVUFBVSxJQUFJMzRDLElBQUksQ0FBQ2t0QyxXQUF0Qzs7QUFDQSxVQUFJbHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixJQUNBdGQsSUFBSSxDQUFDa3RDLFdBQUwsS0FBcUJsdEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9CK0wsV0FBcEIsRUFEekIsRUFDNEQ7QUFDeERycEIsWUFBSSxDQUFDaXRDLFlBQUwsR0FBb0Jyc0MsSUFBSSxDQUFDOEksR0FBTCxDQUFTMUosSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9Cd00sUUFBcEIsRUFBVCxFQUF5QzlwQixJQUFJLENBQUNpdEMsWUFBOUMsQ0FBcEI7QUFDSCxPQUhELE1BSUssSUFBSWp0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosSUFDTHZkLElBQUksQ0FBQ2t0QyxXQUFMLEtBQXFCbHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQjhMLFdBQXBCLEVBRHBCLEVBQ3VEO0FBQ3hEcnBCLFlBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CcnNDLElBQUksQ0FBQytJLEdBQUwsQ0FBUzNKLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQnVNLFFBQXBCLEVBQVQsRUFBeUM5cEIsSUFBSSxDQUFDaXRDLFlBQTlDLENBQXBCO0FBQ0g7O0FBQ0QsVUFBSTJMLFNBQUosRUFBZTtBQUNYNTRDLFlBQUksQ0FBQzJzQyxNQUFMO0FBQ0FvQixvQkFBWSxDQUFDLGNBQUQsQ0FBWjtBQUNBOEQsd0JBQWdCO0FBQ25CO0FBQ0o7O0FBQ0QsYUFBU3JGLFNBQVQsQ0FBbUJub0MsSUFBbkIsRUFBeUJxbEMsUUFBekIsRUFBbUM7QUFDL0IsVUFBSUEsUUFBUSxLQUFLLEtBQUssQ0FBdEIsRUFBeUI7QUFBRUEsZ0JBQVEsR0FBRyxJQUFYO0FBQWtCOztBQUM3QyxVQUFJbVAsV0FBVyxHQUFHNzRDLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXBXLElBQWYsRUFBcUJraUIsU0FBckIsRUFBZ0NtakIsUUFBaEMsQ0FBbEIsQ0FGK0IsQ0FFOEI7O0FBQzdELFVBQUsxcEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLElBQ0RzN0IsV0FEQyxJQUVEbk8sWUFBWSxDQUFDbU8sV0FBRCxFQUFjNzRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBMUIsRUFBbUNtc0IsUUFBUSxLQUFLbmpCLFNBQWIsR0FBeUJtakIsUUFBekIsR0FBb0MsQ0FBQzFwQyxJQUFJLENBQUMydkMsY0FBN0UsQ0FBWixHQUEyRyxDQUYzRyxJQUdDM3ZDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixJQUNHdTdCLFdBREgsSUFFR25PLFlBQVksQ0FBQ21PLFdBQUQsRUFBYzc0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQTFCLEVBQW1Db3NCLFFBQVEsS0FBS25qQixTQUFiLEdBQXlCbWpCLFFBQXpCLEdBQW9DLENBQUMxcEMsSUFBSSxDQUFDOHZDLGNBQTdFLENBQVosR0FBMkcsQ0FMbkgsRUFNSSxPQUFPLEtBQVA7QUFDSixVQUFJOXZDLElBQUksQ0FBQytvQyxNQUFMLENBQVlsRyxNQUFaLENBQW1CeGdDLE1BQW5CLEtBQThCLENBQTlCLElBQW1DckMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5HLE9BQVosQ0FBb0J2Z0MsTUFBcEIsS0FBK0IsQ0FBdEUsRUFDSSxPQUFPLElBQVA7QUFDSixVQUFJdzJDLFdBQVcsS0FBS3R5QixTQUFwQixFQUNJLE9BQU8sS0FBUDtBQUNKLFVBQUkyZSxJQUFJLEdBQUdsbEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxHLE1BQVosQ0FBbUJ4Z0MsTUFBbkIsR0FBNEIsQ0FBdkM7QUFBQSxVQUEwQzBCLEtBQUssR0FBR21oQyxJQUFJLEdBQUdsbEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxHLE1BQWYsR0FBd0I3aUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5HLE9BQTFGOztBQUNBLFdBQUssSUFBSW5wQyxDQUFDLEdBQUcsQ0FBUixFQUFXa3FCLENBQUMsR0FBRyxLQUFLLENBQXpCLEVBQTRCbHFCLENBQUMsR0FBR3NLLEtBQUssQ0FBQzFCLE1BQXRDLEVBQThDNUksQ0FBQyxFQUEvQyxFQUFtRDtBQUMvQ2txQixTQUFDLEdBQUc1ZixLQUFLLENBQUN0SyxDQUFELENBQVQ7QUFDQSxZQUFJLE9BQU9rcUIsQ0FBUCxLQUFhLFVBQWIsSUFDQUEsQ0FBQyxDQUFDazFCLFdBQUQsQ0FETCxDQUNtQjtBQURuQixVQUdJLE9BQU8zVCxJQUFQLENBSEosS0FJSyxJQUFJdmhCLENBQUMsWUFBWS9kLElBQWIsSUFDTGl6QyxXQUFXLEtBQUt0eUIsU0FEWCxJQUVMNUMsQ0FBQyxDQUFDcUIsT0FBRixPQUFnQjZ6QixXQUFXLENBQUM3ekIsT0FBWixFQUZmLEVBR0Q7QUFDQSxpQkFBT2tnQixJQUFQLENBSkMsS0FLQSxJQUFJLE9BQU92aEIsQ0FBUCxLQUFhLFFBQWIsSUFBeUJrMUIsV0FBVyxLQUFLdHlCLFNBQTdDLEVBQXdEO0FBQ3pEO0FBQ0EsY0FBSW5PLE1BQU0sR0FBR3BZLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZWtKLENBQWYsRUFBa0I0QyxTQUFsQixFQUE2QixJQUE3QixDQUFiO0FBQ0EsaUJBQU9uTyxNQUFNLElBQUlBLE1BQU0sQ0FBQzRNLE9BQVAsT0FBcUI2ekIsV0FBVyxDQUFDN3pCLE9BQVosRUFBL0IsR0FDRGtnQixJQURDLEdBRUQsQ0FBQ0EsSUFGUDtBQUdILFNBTkksTUFPQSxLQUNMO0FBQ0EsZ0JBQU92aEIsQ0FBUCxNQUFhLFFBQWIsSUFDSWsxQixXQUFXLEtBQUt0eUIsU0FEcEIsSUFFSTVDLENBQUMsQ0FBQ20xQixJQUZOLElBR0luMUIsQ0FBQyxDQUFDbzFCLEVBSE4sSUFJSUYsV0FBVyxDQUFDN3pCLE9BQVosTUFBeUJyQixDQUFDLENBQUNtMUIsSUFBRixDQUFPOXpCLE9BQVAsRUFKN0IsSUFLSTZ6QixXQUFXLENBQUM3ekIsT0FBWixNQUF5QnJCLENBQUMsQ0FBQ28xQixFQUFGLENBQUsvekIsT0FBTCxFQVB4QixFQVFELE9BQU9rZ0IsSUFBUDtBQUNQOztBQUNELGFBQU8sQ0FBQ0EsSUFBUjtBQUNIOztBQUNELGFBQVMwUCxRQUFULENBQWtCbFAsSUFBbEIsRUFBd0I7QUFDcEIsVUFBSTFsQyxJQUFJLENBQUNzdUMsYUFBTCxLQUF1Qi9uQixTQUEzQixFQUNJLE9BQVFtZixJQUFJLENBQUNDLFNBQUwsQ0FBZXpkLE9BQWYsQ0FBdUIsUUFBdkIsTUFBcUMsQ0FBQyxDQUF0QyxJQUNKd2QsSUFBSSxDQUFDQyxTQUFMLENBQWV6ZCxPQUFmLENBQXVCLG9CQUF2QixNQUFpRCxDQUFDLENBRDlDLElBRUpsb0IsSUFBSSxDQUFDc3VDLGFBQUwsQ0FBbUJ5RCxRQUFuQixDQUE0QnJNLElBQTVCLENBRko7QUFHSixhQUFPLEtBQVA7QUFDSDs7QUFDRCxhQUFTOEwsTUFBVCxDQUFnQnBxQyxDQUFoQixFQUFtQjtBQUNmLFVBQUlpeEMsT0FBTyxHQUFHanhDLENBQUMsQ0FBQ2xOLE1BQUYsS0FBYThGLElBQUksQ0FBQ3NmLE1BQWhDOztBQUNBLFVBQUkrNEIsT0FBTyxJQUNQLEVBQUVqeEMsQ0FBQyxDQUFDbXhDLGFBQUYsSUFBbUJMLGNBQWMsQ0FBQzl3QyxDQUFDLENBQUNteEMsYUFBSCxDQUFuQyxDQURKLEVBQzJEO0FBQ3ZEdjRDLFlBQUksQ0FBQ21qQyxPQUFMLENBQWFuakMsSUFBSSxDQUFDc2YsTUFBTCxDQUFZeGxCLEtBQXpCLEVBQWdDLElBQWhDLEVBQXNDc04sQ0FBQyxDQUFDbE4sTUFBRixLQUFhOEYsSUFBSSxDQUFDaWlDLFFBQWxCLEdBQ2hDamlDLElBQUksQ0FBQytvQyxNQUFMLENBQVkvRyxTQURvQixHQUVoQ2hpQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZL3JCLFVBRmxCO0FBR0g7QUFDSjs7QUFDRCxhQUFTZ25CLFNBQVQsQ0FBbUI1OEIsQ0FBbkIsRUFBc0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJZ3BDLFdBQVcsR0FBR3JKLGNBQWMsQ0FBQzMvQixDQUFELENBQWhDO0FBQ0EsVUFBSWl4QyxPQUFPLEdBQUdyNEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTdyQixJQUFaLEdBQ1JxdUIsT0FBTyxDQUFDd0csUUFBUixDQUFpQjNCLFdBQWpCLENBRFEsR0FFUkEsV0FBVyxLQUFLcHdDLElBQUksQ0FBQ3NmLE1BRjNCO0FBR0EsVUFBSW5DLFVBQVUsR0FBR25kLElBQUksQ0FBQytvQyxNQUFMLENBQVk1ckIsVUFBN0I7QUFDQSxVQUFJNjdCLFlBQVksR0FBR2g1QyxJQUFJLENBQUNvdEMsTUFBTCxLQUFnQixDQUFDandCLFVBQUQsSUFBZSxDQUFDazdCLE9BQWhDLENBQW5CO0FBQ0EsVUFBSVksa0JBQWtCLEdBQUdqNUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhGLE1BQVosSUFBc0I4VSxPQUF0QixJQUFpQyxDQUFDbDdCLFVBQTNEOztBQUNBLFVBQUkvVixDQUFDLENBQUNtWixPQUFGLEtBQWMsRUFBZCxJQUFvQjgzQixPQUF4QixFQUFpQztBQUM3QixZQUFJbDdCLFVBQUosRUFBZ0I7QUFDWm5kLGNBQUksQ0FBQ21qQyxPQUFMLENBQWFuakMsSUFBSSxDQUFDc2YsTUFBTCxDQUFZeGxCLEtBQXpCLEVBQWdDLElBQWhDLEVBQXNDczJDLFdBQVcsS0FBS3B3QyxJQUFJLENBQUNpaUMsUUFBckIsR0FDaENqaUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWS9HLFNBRG9CLEdBRWhDaGlDLElBQUksQ0FBQytvQyxNQUFMLENBQVkvckIsVUFGbEI7QUFHQSxpQkFBT296QixXQUFXLENBQUM4SSxJQUFaLEVBQVA7QUFDSCxTQUxELE1BTUs7QUFDRGw1QyxjQUFJLENBQUMwc0MsSUFBTDtBQUNIO0FBQ0osT0FWRCxNQVdLLElBQUl3TCxjQUFjLENBQUM5SCxXQUFELENBQWQsSUFDTDRJLFlBREssSUFFTEMsa0JBRkMsRUFFbUI7QUFDcEIsWUFBSUUsU0FBUyxHQUFHLENBQUMsQ0FBQ241QyxJQUFJLENBQUNxeEMsYUFBUCxJQUNacnhDLElBQUksQ0FBQ3F4QyxhQUFMLENBQW1CVSxRQUFuQixDQUE0QjNCLFdBQTVCLENBREo7O0FBRUEsZ0JBQVFocEMsQ0FBQyxDQUFDbVosT0FBVjtBQUNJLGVBQUssRUFBTDtBQUNJLGdCQUFJNDRCLFNBQUosRUFBZTtBQUNYL3hDLGVBQUMsQ0FBQ2d5QyxjQUFGO0FBQ0F2Syx3QkFBVTtBQUNWd0ssMkJBQWE7QUFDaEIsYUFKRCxNQU1JakksVUFBVSxDQUFDaHFDLENBQUQsQ0FBVjs7QUFDSjs7QUFDSixlQUFLLEVBQUw7QUFBUztBQUNMQSxhQUFDLENBQUNneUMsY0FBRjtBQUNBQyx5QkFBYTtBQUNiOztBQUNKLGVBQUssQ0FBTDtBQUNBLGVBQUssRUFBTDtBQUNJLGdCQUFJaEIsT0FBTyxJQUFJLENBQUNyNEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTVyQixVQUE1QixFQUF3QztBQUNwQy9WLGVBQUMsQ0FBQ2d5QyxjQUFGO0FBQ0FwNUMsa0JBQUksQ0FBQ29zQyxLQUFMO0FBQ0g7O0FBQ0Q7O0FBQ0osZUFBSyxFQUFMO0FBQ0EsZUFBSyxFQUFMO0FBQ0ksZ0JBQUksQ0FBQytNLFNBQUQsSUFBYyxDQUFDZCxPQUFuQixFQUE0QjtBQUN4Qmp4QyxlQUFDLENBQUNneUMsY0FBRjs7QUFDQSxrQkFBSXA1QyxJQUFJLENBQUNzdUMsYUFBTCxLQUF1Qi9uQixTQUF2QixLQUNDcEosVUFBVSxLQUFLLEtBQWYsSUFDSWpXLFFBQVEsQ0FBQzJ0QyxhQUFULElBQTBCRCxRQUFRLENBQUMxdEMsUUFBUSxDQUFDMnRDLGFBQVYsQ0FGdkMsQ0FBSixFQUV1RTtBQUNuRSxvQkFBSXlFLE9BQU8sR0FBR2x5QyxDQUFDLENBQUNtWixPQUFGLEtBQWMsRUFBZCxHQUFtQixDQUFuQixHQUF1QixDQUFDLENBQXRDO0FBQ0Esb0JBQUksQ0FBQ25aLENBQUMsQ0FBQ215QyxPQUFQLEVBQ0k3RSxVQUFVLENBQUNudUIsU0FBRCxFQUFZK3lCLE9BQVosQ0FBVixDQURKLEtBRUs7QUFDRGx5QyxtQkFBQyxDQUFDb3lDLGVBQUY7QUFDQXROLDZCQUFXLENBQUNvTixPQUFELENBQVg7QUFDQTVFLDRCQUFVLENBQUNYLG9CQUFvQixDQUFDLENBQUQsQ0FBckIsRUFBMEIsQ0FBMUIsQ0FBVjtBQUNIO0FBQ0o7QUFDSixhQWRELE1BZUssSUFBSS96QyxJQUFJLENBQUNzdkMsV0FBVCxFQUNEdHZDLElBQUksQ0FBQ3N2QyxXQUFMLENBQWlCd0UsS0FBakI7O0FBQ0o7O0FBQ0osZUFBSyxFQUFMO0FBQ0EsZUFBSyxFQUFMO0FBQ0kxc0MsYUFBQyxDQUFDZ3lDLGNBQUY7QUFDQSxnQkFBSS9JLEtBQUssR0FBR2pwQyxDQUFDLENBQUNtWixPQUFGLEtBQWMsRUFBZCxHQUFtQixDQUFuQixHQUF1QixDQUFDLENBQXBDOztBQUNBLGdCQUFLdmdCLElBQUksQ0FBQ3N1QyxhQUFMLElBQ0Q4QixXQUFXLENBQUNrRCxFQUFaLEtBQW1CL3NCLFNBRG5CLElBRUE2cEIsV0FBVyxLQUFLcHdDLElBQUksQ0FBQzhLLEtBRnJCLElBR0FzbEMsV0FBVyxLQUFLcHdDLElBQUksQ0FBQ2lpQyxRQUh6QixFQUdtQztBQUMvQixrQkFBSTc2QixDQUFDLENBQUNteUMsT0FBTixFQUFlO0FBQ1hueUMsaUJBQUMsQ0FBQ295QyxlQUFGO0FBQ0FyTiwwQkFBVSxDQUFDbnNDLElBQUksQ0FBQ2t0QyxXQUFMLEdBQW1CbUQsS0FBcEIsQ0FBVjtBQUNBcUUsMEJBQVUsQ0FBQ1gsb0JBQW9CLENBQUMsQ0FBRCxDQUFyQixFQUEwQixDQUExQixDQUFWO0FBQ0gsZUFKRCxNQUtLLElBQUksQ0FBQ29GLFNBQUwsRUFDRHpFLFVBQVUsQ0FBQ251QixTQUFELEVBQVk4cEIsS0FBSyxHQUFHLENBQXBCLENBQVY7QUFDUCxhQVhELE1BWUssSUFBSUQsV0FBVyxLQUFLcHdDLElBQUksQ0FBQzYyQyxrQkFBekIsRUFBNkM7QUFDOUMxSyx3QkFBVSxDQUFDbnNDLElBQUksQ0FBQ2t0QyxXQUFMLEdBQW1CbUQsS0FBcEIsQ0FBVjtBQUNILGFBRkksTUFHQSxJQUFJcndDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFBaEIsRUFBNEI7QUFDN0Isa0JBQUksQ0FBQzZpQyxTQUFELElBQWNuNUMsSUFBSSxDQUFDc3ZDLFdBQXZCLEVBQ0l0dkMsSUFBSSxDQUFDc3ZDLFdBQUwsQ0FBaUJ3RSxLQUFqQjtBQUNKakYsd0JBQVUsQ0FBQ3puQyxDQUFELENBQVY7O0FBQ0FwSCxrQkFBSSxDQUFDbXZDLGdCQUFMO0FBQ0g7O0FBQ0Q7O0FBQ0osZUFBSyxDQUFMO0FBQ0ksZ0JBQUlnSyxTQUFKLEVBQWU7QUFDWCxrQkFBSU0sS0FBSyxHQUFHLENBQ1J6NUMsSUFBSSxDQUFDc3ZDLFdBREcsRUFFUnR2QyxJQUFJLENBQUN1dkMsYUFGRyxFQUdSdnZDLElBQUksQ0FBQ3d2QyxhQUhHLEVBSVJ4dkMsSUFBSSxDQUFDZ2YsSUFKRyxFQU1QZ0ssTUFOTyxDQU1BaHBCLElBQUksQ0FBQzJyQyxjQU5MLEVBT1B4MkIsTUFQTyxDQU9BLFVBQVUrVCxDQUFWLEVBQWE7QUFBRSx1QkFBT0EsQ0FBUDtBQUFXLGVBUDFCLENBQVo7QUFRQSxrQkFBSXp2QixDQUFDLEdBQUdnZ0QsS0FBSyxDQUFDdnhCLE9BQU4sQ0FBY2tvQixXQUFkLENBQVI7O0FBQ0Esa0JBQUkzMkMsQ0FBQyxLQUFLLENBQUMsQ0FBWCxFQUFjO0FBQ1Ysb0JBQUlTLE1BQU0sR0FBR3UvQyxLQUFLLENBQUNoZ0QsQ0FBQyxJQUFJMk4sQ0FBQyxDQUFDc3lDLFFBQUYsR0FBYSxDQUFDLENBQWQsR0FBa0IsQ0FBdEIsQ0FBRixDQUFsQjtBQUNBdHlDLGlCQUFDLENBQUNneUMsY0FBRjs7QUFDQSxpQkFBQ2wvQyxNQUFNLElBQUk4RixJQUFJLENBQUNzZixNQUFoQixFQUF3QncwQixLQUF4QjtBQUNIO0FBQ0osYUFmRCxNQWdCSyxJQUFJLENBQUM5ekMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWhzQixVQUFiLElBQ0wvYyxJQUFJLENBQUNzdUMsYUFEQSxJQUVMdHVDLElBQUksQ0FBQ3N1QyxhQUFMLENBQW1CeUQsUUFBbkIsQ0FBNEIzQixXQUE1QixDQUZLLElBR0xocEMsQ0FBQyxDQUFDc3lDLFFBSEQsRUFHVztBQUNadHlDLGVBQUMsQ0FBQ2d5QyxjQUFGOztBQUNBcDVDLGtCQUFJLENBQUNzZixNQUFMLENBQVl3MEIsS0FBWjtBQUNIOztBQUNEO0FBM0ZSO0FBNkZIOztBQUNELFVBQUk5ekMsSUFBSSxDQUFDZ2YsSUFBTCxLQUFjdUgsU0FBZCxJQUEyQjZwQixXQUFXLEtBQUtwd0MsSUFBSSxDQUFDZ2YsSUFBcEQsRUFBMEQ7QUFDdEQsZ0JBQVE1WCxDQUFDLENBQUN6TixHQUFWO0FBQ0ksZUFBS3FHLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqcUIsSUFBVixDQUFlLENBQWYsRUFBa0IrSCxNQUFsQixDQUF5QixDQUF6QixDQUFMO0FBQ0EsZUFBSy9tQixJQUFJLENBQUNpcEMsSUFBTCxDQUFVanFCLElBQVYsQ0FBZSxDQUFmLEVBQWtCK0gsTUFBbEIsQ0FBeUIsQ0FBekIsRUFBNEJ5SyxXQUE1QixFQUFMO0FBQ0l4eEIsZ0JBQUksQ0FBQ2dmLElBQUwsQ0FBVWduQixXQUFWLEdBQXdCaG1DLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqcUIsSUFBVixDQUFlLENBQWYsQ0FBeEI7QUFDQWt3Qiw4QkFBa0I7QUFDbEJ0Qix1QkFBVztBQUNYOztBQUNKLGVBQUs1dEMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixFQUFrQitILE1BQWxCLENBQXlCLENBQXpCLENBQUw7QUFDQSxlQUFLL21CLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqcUIsSUFBVixDQUFlLENBQWYsRUFBa0IrSCxNQUFsQixDQUF5QixDQUF6QixFQUE0QnlLLFdBQTVCLEVBQUw7QUFDSXh4QixnQkFBSSxDQUFDZ2YsSUFBTCxDQUFVZ25CLFdBQVYsR0FBd0JobUMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixDQUF4QjtBQUNBa3dCLDhCQUFrQjtBQUNsQnRCLHVCQUFXO0FBQ1g7QUFaUjtBQWNIOztBQUNELFVBQUl5SyxPQUFPLElBQUlILGNBQWMsQ0FBQzlILFdBQUQsQ0FBN0IsRUFBNEM7QUFDeENyQyxvQkFBWSxDQUFDLFdBQUQsRUFBYzNtQyxDQUFkLENBQVo7QUFDSDtBQUNKOztBQUNELGFBQVMwcEMsV0FBVCxDQUFxQnBMLElBQXJCLEVBQTJCO0FBQ3ZCLFVBQUkxbEMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEtBQThCLENBQTlCLElBQ0NxakMsSUFBSSxLQUNBLENBQUNBLElBQUksQ0FBQ0UsU0FBTCxDQUFlbU0sUUFBZixDQUF3QixlQUF4QixDQUFELElBQ0dyTSxJQUFJLENBQUNFLFNBQUwsQ0FBZW1NLFFBQWYsQ0FBd0Isb0JBQXhCLENBRkgsQ0FEVCxFQUlJO0FBQ0osVUFBSTRILFNBQVMsR0FBR2pVLElBQUksR0FDZEEsSUFBSSxDQUFDNkIsT0FBTCxDQUFhdmlCLE9BQWIsRUFEYyxHQUVkaGxCLElBQUksQ0FBQ3d1QyxJQUFMLENBQVVvTCxpQkFBVixDQUE0QnJTLE9BQTVCLENBQW9DdmlCLE9BQXBDLEVBRk47QUFBQSxVQUVxRDYwQixXQUFXLEdBQUc3NUMsSUFBSSxDQUFDeWEsU0FBTCxDQUFlemEsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixDQUFmLEVBQXNDd0ksU0FBdEMsRUFBaUQsSUFBakQsRUFBdUR2QixPQUF2RCxFQUZuRTtBQUFBLFVBRXFJODBCLGNBQWMsR0FBR2w1QyxJQUFJLENBQUM4SSxHQUFMLENBQVNpd0MsU0FBVCxFQUFvQjM1QyxJQUFJLENBQUMrZCxhQUFMLENBQW1CLENBQW5CLEVBQXNCaUgsT0FBdEIsRUFBcEIsQ0FGdEo7QUFBQSxVQUU0TSswQixZQUFZLEdBQUduNUMsSUFBSSxDQUFDK0ksR0FBTCxDQUFTZ3dDLFNBQVQsRUFBb0IzNUMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixFQUFzQmlILE9BQXRCLEVBQXBCLENBRjNOO0FBR0EsVUFBSWcxQixnQkFBZ0IsR0FBRyxLQUF2QjtBQUNBLFVBQUlDLFFBQVEsR0FBRyxDQUFmO0FBQUEsVUFBa0JDLFFBQVEsR0FBRyxDQUE3Qjs7QUFDQSxXQUFLLElBQUk5WSxDQUFDLEdBQUcwWSxjQUFiLEVBQTZCMVksQ0FBQyxHQUFHMlksWUFBakMsRUFBK0MzWSxDQUFDLElBQUk2SixRQUFRLENBQUNDLEdBQTdELEVBQWtFO0FBQzlELFlBQUksQ0FBQ3NCLFNBQVMsQ0FBQyxJQUFJNW1DLElBQUosQ0FBU3c3QixDQUFULENBQUQsRUFBYyxJQUFkLENBQWQsRUFBbUM7QUFDL0I0WSwwQkFBZ0IsR0FDWkEsZ0JBQWdCLElBQUs1WSxDQUFDLEdBQUcwWSxjQUFKLElBQXNCMVksQ0FBQyxHQUFHMlksWUFEbkQ7QUFFQSxjQUFJM1ksQ0FBQyxHQUFHeVksV0FBSixLQUFvQixDQUFDSSxRQUFELElBQWE3WSxDQUFDLEdBQUc2WSxRQUFyQyxDQUFKLEVBQ0lBLFFBQVEsR0FBRzdZLENBQVgsQ0FESixLQUVLLElBQUlBLENBQUMsR0FBR3lZLFdBQUosS0FBb0IsQ0FBQ0ssUUFBRCxJQUFhOVksQ0FBQyxHQUFHOFksUUFBckMsQ0FBSixFQUNEQSxRQUFRLEdBQUc5WSxDQUFYO0FBQ1A7QUFDSjs7QUFDRCxXQUFLLElBQUkxZCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMWpCLElBQUksQ0FBQytvQyxNQUFMLENBQVluRSxVQUFoQyxFQUE0Q2xoQixDQUFDLEVBQTdDLEVBQWlEO0FBQzdDLFlBQUk5TCxLQUFLLEdBQUc1WCxJQUFJLENBQUNzdUMsYUFBTCxDQUFtQjRGLFFBQW5CLENBQTRCeHdCLENBQTVCLENBQVo7O0FBQ0EsWUFBSXluQixPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVMXhDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUMxQixjQUFJeWdELE9BQU8sR0FBR3ZpQyxLQUFLLENBQUNzOEIsUUFBTixDQUFlejZDLENBQWYsQ0FBZDtBQUFBLGNBQWlDNEssSUFBSSxHQUFHODFDLE9BQU8sQ0FBQzVTLE9BQWhEO0FBQ0EsY0FBSXh1QixTQUFTLEdBQUcxVSxJQUFJLENBQUMyZ0IsT0FBTCxFQUFoQjtBQUNBLGNBQUlvMUIsVUFBVSxHQUFJSCxRQUFRLEdBQUcsQ0FBWCxJQUFnQmxoQyxTQUFTLEdBQUdraEMsUUFBN0IsSUFDWkMsUUFBUSxHQUFHLENBQVgsSUFBZ0JuaEMsU0FBUyxHQUFHbWhDLFFBRGpDOztBQUVBLGNBQUlFLFVBQUosRUFBZ0I7QUFDWkQsbUJBQU8sQ0FBQ3ZVLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLFlBQXRCO0FBQ0EsYUFBQyxTQUFELEVBQVksWUFBWixFQUEwQixVQUExQixFQUFzQzRFLE9BQXRDLENBQThDLFVBQVUvb0IsQ0FBVixFQUFhO0FBQ3ZEeTRCLHFCQUFPLENBQUN2VSxTQUFSLENBQWtCRSxNQUFsQixDQUF5QnBrQixDQUF6QjtBQUNILGFBRkQ7QUFHQSxtQkFBTyxVQUFQO0FBQ0gsV0FORCxNQU9LLElBQUlzNEIsZ0JBQWdCLElBQUksQ0FBQ0ksVUFBekIsRUFDRCxPQUFPLFVBQVA7O0FBQ0osV0FBQyxZQUFELEVBQWUsU0FBZixFQUEwQixVQUExQixFQUFzQyxZQUF0QyxFQUFvRDNQLE9BQXBELENBQTRELFVBQVUvb0IsQ0FBVixFQUFhO0FBQ3JFeTRCLG1CQUFPLENBQUN2VSxTQUFSLENBQWtCRSxNQUFsQixDQUF5QnBrQixDQUF6QjtBQUNILFdBRkQ7O0FBR0EsY0FBSWdrQixJQUFJLEtBQUtuZixTQUFiLEVBQXdCO0FBQ3BCbWYsZ0JBQUksQ0FBQ0UsU0FBTCxDQUFlQyxHQUFmLENBQW1COFQsU0FBUyxJQUFJMzVDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIsQ0FBbkIsRUFBc0JpSCxPQUF0QixFQUFiLEdBQ2IsWUFEYSxHQUViLFVBRk47QUFHQSxnQkFBSTYwQixXQUFXLEdBQUdGLFNBQWQsSUFBMkI1Z0MsU0FBUyxLQUFLOGdDLFdBQTdDLEVBQ0lNLE9BQU8sQ0FBQ3ZVLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLFlBQXRCLEVBREosS0FFSyxJQUFJZ1UsV0FBVyxHQUFHRixTQUFkLElBQTJCNWdDLFNBQVMsS0FBSzhnQyxXQUE3QyxFQUNETSxPQUFPLENBQUN2VSxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixVQUF0QjtBQUNKLGdCQUFJOXNCLFNBQVMsSUFBSWtoQyxRQUFiLEtBQ0NDLFFBQVEsS0FBSyxDQUFiLElBQWtCbmhDLFNBQVMsSUFBSW1oQyxRQURoQyxLQUVBclAsU0FBUyxDQUFDOXhCLFNBQUQsRUFBWThnQyxXQUFaLEVBQXlCRixTQUF6QixDQUZiLEVBR0lRLE9BQU8sQ0FBQ3ZVLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLFNBQXRCO0FBQ1A7QUFDSixTQTlCRDs7QUErQkEsYUFBSyxJQUFJcHNDLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBR2tlLEtBQUssQ0FBQ3M4QixRQUFOLENBQWU3eEMsTUFBbkMsRUFBMkM1SSxDQUFDLEdBQUdDLENBQS9DLEVBQWtERCxDQUFDLEVBQW5ELEVBQXVEO0FBQ25EMHhDLGlCQUFPLENBQUMxeEMsQ0FBRCxFQUFJQyxDQUFKLENBQVA7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsYUFBU20zQyxRQUFULEdBQW9CO0FBQ2hCLFVBQUk3d0MsSUFBSSxDQUFDb3RDLE1BQUwsSUFBZSxDQUFDcHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVlsRSxNQUE1QixJQUFzQyxDQUFDN2tDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4RixNQUF2RCxFQUNJMEksZ0JBQWdCO0FBQ3ZCOztBQUNELGFBQVNTLElBQVQsQ0FBY3RsQyxDQUFkLEVBQWlCcTlCLGVBQWpCLEVBQWtDO0FBQzlCLFVBQUlBLGVBQWUsS0FBSyxLQUFLLENBQTdCLEVBQWdDO0FBQUVBLHVCQUFlLEdBQUd6a0MsSUFBSSxDQUFDcTZDLGdCQUF2QjtBQUEwQzs7QUFDNUUsVUFBSXI2QyxJQUFJLENBQUNtcEMsUUFBTCxLQUFrQixJQUF0QixFQUE0QjtBQUN4QixZQUFJL2hDLENBQUosRUFBTztBQUNIQSxXQUFDLENBQUNneUMsY0FBRjtBQUNBLGNBQUloSixXQUFXLEdBQUdySixjQUFjLENBQUMzL0IsQ0FBRCxDQUFoQztBQUNBZ3BDLHFCQUFXLElBQUlBLFdBQVcsQ0FBQzhJLElBQVosRUFBZjtBQUNIOztBQUNELFlBQUlsNUMsSUFBSSxDQUFDNDNDLFdBQUwsS0FBcUJyeEIsU0FBekIsRUFBb0M7QUFDaEN2bUIsY0FBSSxDQUFDNDNDLFdBQUwsQ0FBaUI5RCxLQUFqQjtBQUNBOXpDLGNBQUksQ0FBQzQzQyxXQUFMLENBQWlCMEMsS0FBakI7QUFDSDs7QUFDRHZNLG9CQUFZLENBQUMsUUFBRCxDQUFaO0FBQ0E7QUFDSDs7QUFDRCxVQUFJL3RDLElBQUksQ0FBQ3NmLE1BQUwsQ0FBWSsyQixRQUFaLElBQXdCcjJDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4RixNQUF4QyxFQUNJO0FBQ0osVUFBSWdYLE9BQU8sR0FBR3Y2QyxJQUFJLENBQUNvdEMsTUFBbkI7QUFDQXB0QyxVQUFJLENBQUNvdEMsTUFBTCxHQUFjLElBQWQ7O0FBQ0EsVUFBSSxDQUFDbU4sT0FBTCxFQUFjO0FBQ1Z2NkMsWUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCdEksU0FBdkIsQ0FBaUNDLEdBQWpDLENBQXFDLE1BQXJDOztBQUNBN2xDLFlBQUksQ0FBQ3NmLE1BQUwsQ0FBWXNtQixTQUFaLENBQXNCQyxHQUF0QixDQUEwQixRQUExQjs7QUFDQWtJLG9CQUFZLENBQUMsUUFBRCxDQUFaO0FBQ0E5Qix3QkFBZ0IsQ0FBQ3hILGVBQUQsQ0FBaEI7QUFDSDs7QUFDRCxVQUFJemtDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFBWixLQUEyQixJQUEzQixJQUFtQ3RXLElBQUksQ0FBQytvQyxNQUFMLENBQVloc0IsVUFBWixLQUEyQixJQUFsRSxFQUF3RTtBQUNwRSxZQUFJL2MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTVyQixVQUFaLEtBQTJCLEtBQTNCLEtBQ0MvVixDQUFDLEtBQUttZixTQUFOLElBQ0csQ0FBQ3ZtQixJQUFJLENBQUNxeEMsYUFBTCxDQUFtQlUsUUFBbkIsQ0FBNEIzcUMsQ0FBQyxDQUFDbXhDLGFBQTlCLENBRkwsQ0FBSixFQUV3RDtBQUNwRHgzQixvQkFBVSxDQUFDLFlBQVk7QUFBRSxtQkFBTy9nQixJQUFJLENBQUNzdkMsV0FBTCxDQUFpQi82QixNQUFqQixFQUFQO0FBQW1DLFdBQWxELEVBQW9ELEVBQXBELENBQVY7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsYUFBU2ltQyxnQkFBVCxDQUEwQjU2QyxJQUExQixFQUFnQztBQUM1QixhQUFPLFVBQVV5RSxJQUFWLEVBQWdCO0FBQ25CLFlBQUlrakMsT0FBTyxHQUFJdm5DLElBQUksQ0FBQytvQyxNQUFMLENBQVksTUFBTW5wQyxJQUFOLEdBQWEsTUFBekIsSUFBbUNJLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXBXLElBQWYsRUFBcUJyRSxJQUFJLENBQUMrb0MsTUFBTCxDQUFZL3JCLFVBQWpDLENBQWxEO0FBQ0EsWUFBSXk5QixjQUFjLEdBQUd6NkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWSxPQUFPbnBDLElBQUksS0FBSyxLQUFULEdBQWlCLEtBQWpCLEdBQXlCLEtBQWhDLElBQXlDLE1BQXJELENBQXJCOztBQUNBLFlBQUkybkMsT0FBTyxLQUFLaGhCLFNBQWhCLEVBQTJCO0FBQ3ZCdm1CLGNBQUksQ0FBQ0osSUFBSSxLQUFLLEtBQVQsR0FBaUIsZ0JBQWpCLEdBQW9DLGdCQUFyQyxDQUFKLEdBQ0kybkMsT0FBTyxDQUFDdGMsUUFBUixLQUFxQixDQUFyQixJQUNJc2MsT0FBTyxDQUFDemMsVUFBUixLQUF1QixDQUQzQixJQUVJeWMsT0FBTyxDQUFDeGMsVUFBUixLQUF1QixDQUgvQjtBQUlIOztBQUNELFlBQUkvcUIsSUFBSSxDQUFDK2QsYUFBVCxFQUF3QjtBQUNwQi9kLGNBQUksQ0FBQytkLGFBQUwsR0FBcUIvZCxJQUFJLENBQUMrZCxhQUFMLENBQW1CNUksTUFBbkIsQ0FBMEIsVUFBVXdPLENBQVYsRUFBYTtBQUFFLG1CQUFPNm9CLFNBQVMsQ0FBQzdvQixDQUFELENBQWhCO0FBQXNCLFdBQS9ELENBQXJCO0FBQ0EsY0FBSSxDQUFDM2pCLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIxYixNQUFwQixJQUE4QnpDLElBQUksS0FBSyxLQUEzQyxFQUNJbXNDLGdCQUFnQixDQUFDeEUsT0FBRCxDQUFoQjtBQUNKcUcscUJBQVc7QUFDZDs7QUFDRCxZQUFJNXRDLElBQUksQ0FBQ3N1QyxhQUFULEVBQXdCO0FBQ3BCM0IsZ0JBQU07QUFDTixjQUFJcEYsT0FBTyxLQUFLaGhCLFNBQWhCLEVBQ0l2bUIsSUFBSSxDQUFDNjJDLGtCQUFMLENBQXdCajNDLElBQXhCLElBQWdDMm5DLE9BQU8sQ0FBQ2xlLFdBQVIsR0FBc0JqbEIsUUFBdEIsRUFBaEMsQ0FESixLQUdJcEUsSUFBSSxDQUFDNjJDLGtCQUFMLENBQXdCb0IsZUFBeEIsQ0FBd0NyNEMsSUFBeEM7QUFDSkksY0FBSSxDQUFDNjJDLGtCQUFMLENBQXdCUixRQUF4QixHQUNJLENBQUMsQ0FBQ29FLGNBQUYsSUFDSWxULE9BQU8sS0FBS2hoQixTQURoQixJQUVJazBCLGNBQWMsQ0FBQ3B4QixXQUFmLE9BQWlDa2UsT0FBTyxDQUFDbGUsV0FBUixFQUh6QztBQUlIO0FBQ0osT0ExQkQ7QUEyQkg7O0FBQ0QsYUFBU2drQixXQUFULEdBQXVCO0FBQ25CLFVBQUlxTixRQUFRLEdBQUcsQ0FDWCxNQURXLEVBRVgsYUFGVyxFQUdYLFlBSFcsRUFJWCxxQkFKVyxFQUtYLFlBTFcsRUFNWCxXQU5XLEVBT1gsWUFQVyxFQVFYLFlBUlcsRUFTWCxVQVRXLEVBVVgsdUJBVlcsRUFXWCxRQVhXLEVBWVgsUUFaVyxFQWFYLGVBYlcsRUFjWCxlQWRXLENBQWY7O0FBZ0JBLFVBQUlDLFVBQVUsR0FBR3paLE9BQVEsQ0FBQ0EsT0FBUSxDQUFDLEVBQUQsRUFBSy9pQyxJQUFJLENBQUN5OEMsS0FBTCxDQUFXejhDLElBQUksQ0FBQzA4QyxTQUFMLENBQWV0UCxPQUFPLENBQUN1UCxPQUFSLElBQW1CLEVBQWxDLENBQVgsQ0FBTCxDQUFULEVBQWtFdFAsY0FBbEUsQ0FBekI7O0FBQ0EsVUFBSTlDLE9BQU8sR0FBRyxFQUFkO0FBQ0Exb0MsVUFBSSxDQUFDK29DLE1BQUwsQ0FBWXR1QixTQUFaLEdBQXdCa2dDLFVBQVUsQ0FBQ2xnQyxTQUFuQztBQUNBemEsVUFBSSxDQUFDK29DLE1BQUwsQ0FBWTFyQixVQUFaLEdBQXlCczlCLFVBQVUsQ0FBQ3Q5QixVQUFwQztBQUNBdmtCLFlBQU0sQ0FBQ0QsY0FBUCxDQUFzQm1ILElBQUksQ0FBQytvQyxNQUEzQixFQUFtQyxRQUFuQyxFQUE2QztBQUN6QzV1QyxXQUFHLEVBQUUsZUFBWTtBQUFFLGlCQUFPNkYsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWpILE9BQW5CO0FBQTZCLFNBRFA7QUFFekN2bkMsV0FBRyxFQUFFLGFBQVV3Z0QsS0FBVixFQUFpQjtBQUNsQi82QyxjQUFJLENBQUMrb0MsTUFBTCxDQUFZakgsT0FBWixHQUFzQmtaLGNBQWMsQ0FBQ0QsS0FBRCxDQUFwQztBQUNIO0FBSndDLE9BQTdDO0FBTUFqaUQsWUFBTSxDQUFDRCxjQUFQLENBQXNCbUgsSUFBSSxDQUFDK29DLE1BQTNCLEVBQW1DLFNBQW5DLEVBQThDO0FBQzFDNXVDLFdBQUcsRUFBRSxlQUFZO0FBQUUsaUJBQU82RixJQUFJLENBQUMrb0MsTUFBTCxDQUFZbEgsUUFBbkI7QUFBOEIsU0FEUDtBQUUxQ3RuQyxXQUFHLEVBQUUsYUFBVXdnRCxLQUFWLEVBQWlCO0FBQ2xCLzZDLGNBQUksQ0FBQytvQyxNQUFMLENBQVlsSCxRQUFaLEdBQXVCbVosY0FBYyxDQUFDRCxLQUFELENBQXJDO0FBQ0g7QUFKeUMsT0FBOUM7QUFNQSxVQUFJRSxRQUFRLEdBQUdOLFVBQVUsQ0FBQ2xYLElBQVgsS0FBb0IsTUFBbkM7O0FBQ0EsVUFBSSxDQUFDa1gsVUFBVSxDQUFDMzlCLFVBQVosS0FBMkIyOUIsVUFBVSxDQUFDcmtDLFVBQVgsSUFBeUIya0MsUUFBcEQsQ0FBSixFQUFtRTtBQUMvRCxZQUFJQyxpQkFBaUIsR0FBR2orQixTQUFTLENBQUN3dUIsYUFBVixDQUF3Qnp1QixVQUF4QixJQUFzQzRrQixRQUFRLENBQUM1a0IsVUFBdkU7QUFDQTByQixlQUFPLENBQUMxckIsVUFBUixHQUNJMjlCLFVBQVUsQ0FBQzU5QixVQUFYLElBQXlCaytCLFFBQXpCLEdBQ00sU0FBU04sVUFBVSxDQUFDNzlCLGFBQVgsR0FBMkIsSUFBM0IsR0FBa0MsRUFBM0MsQ0FETixHQUVNbytCLGlCQUFpQixHQUFHLE1BQXBCLElBQThCUCxVQUFVLENBQUM3OUIsYUFBWCxHQUEyQixJQUEzQixHQUFrQyxFQUFoRSxDQUhWO0FBSUg7O0FBQ0QsVUFBSTY5QixVQUFVLENBQUMxWSxRQUFYLEtBQ0MwWSxVQUFVLENBQUNya0MsVUFBWCxJQUF5QjJrQyxRQUQxQixLQUVBLENBQUNOLFVBQVUsQ0FBQzNZLFNBRmhCLEVBRTJCO0FBQ3ZCLFlBQUltWixnQkFBZ0IsR0FBR2wrQixTQUFTLENBQUN3dUIsYUFBVixDQUF3QnpKLFNBQXhCLElBQXFDSixRQUFRLENBQUNJLFNBQXJFO0FBQ0EwRyxlQUFPLENBQUMxRyxTQUFSLEdBQ0kyWSxVQUFVLENBQUM1OUIsVUFBWCxJQUF5QmsrQixRQUF6QixHQUNNLFNBQVNOLFVBQVUsQ0FBQzc5QixhQUFYLEdBQTJCLE1BQTNCLEdBQW9DLElBQTdDLENBRE4sR0FFTXErQixnQkFBZ0IsSUFBSSxVQUFVUixVQUFVLENBQUM3OUIsYUFBWCxHQUEyQixJQUEzQixHQUFrQyxFQUE1QyxJQUFrRCxJQUF0RCxDQUgxQjtBQUlIOztBQUNEaGtCLFlBQU0sQ0FBQ0QsY0FBUCxDQUFzQm1ILElBQUksQ0FBQytvQyxNQUEzQixFQUFtQyxTQUFuQyxFQUE4QztBQUMxQzV1QyxXQUFHLEVBQUUsZUFBWTtBQUFFLGlCQUFPNkYsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXFTLFFBQW5CO0FBQThCLFNBRFA7QUFFMUM3Z0QsV0FBRyxFQUFFaWdELGdCQUFnQixDQUFDLEtBQUQ7QUFGcUIsT0FBOUM7QUFJQTFoRCxZQUFNLENBQUNELGNBQVAsQ0FBc0JtSCxJQUFJLENBQUMrb0MsTUFBM0IsRUFBbUMsU0FBbkMsRUFBOEM7QUFDMUM1dUMsV0FBRyxFQUFFLGVBQVk7QUFBRSxpQkFBTzZGLElBQUksQ0FBQytvQyxNQUFMLENBQVlzUyxRQUFuQjtBQUE4QixTQURQO0FBRTFDOWdELFdBQUcsRUFBRWlnRCxnQkFBZ0IsQ0FBQyxLQUFEO0FBRnFCLE9BQTlDOztBQUlBLFVBQUljLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBVTE3QyxJQUFWLEVBQWdCO0FBQUUsZUFBTyxVQUFVNHFDLEdBQVYsRUFBZTtBQUMzRHhxQyxjQUFJLENBQUMrb0MsTUFBTCxDQUFZbnBDLElBQUksS0FBSyxLQUFULEdBQWlCLFVBQWpCLEdBQThCLFVBQTFDLElBQXdESSxJQUFJLENBQUN5YSxTQUFMLENBQWUrdkIsR0FBZixFQUFvQixPQUFwQixDQUF4RDtBQUNILFNBRndDO0FBRXJDLE9BRko7O0FBR0ExeEMsWUFBTSxDQUFDRCxjQUFQLENBQXNCbUgsSUFBSSxDQUFDK29DLE1BQTNCLEVBQW1DLFNBQW5DLEVBQThDO0FBQzFDNXVDLFdBQUcsRUFBRSxlQUFZO0FBQUUsaUJBQU82RixJQUFJLENBQUMrb0MsTUFBTCxDQUFZd1MsUUFBbkI7QUFBOEIsU0FEUDtBQUUxQ2hoRCxXQUFHLEVBQUUrZ0QsZ0JBQWdCLENBQUMsS0FBRDtBQUZxQixPQUE5QztBQUlBeGlELFlBQU0sQ0FBQ0QsY0FBUCxDQUFzQm1ILElBQUksQ0FBQytvQyxNQUEzQixFQUFtQyxTQUFuQyxFQUE4QztBQUMxQzV1QyxXQUFHLEVBQUUsZUFBWTtBQUFFLGlCQUFPNkYsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXlTLFFBQW5CO0FBQThCLFNBRFA7QUFFMUNqaEQsV0FBRyxFQUFFK2dELGdCQUFnQixDQUFDLEtBQUQ7QUFGcUIsT0FBOUM7O0FBSUEsVUFBSVgsVUFBVSxDQUFDbFgsSUFBWCxLQUFvQixNQUF4QixFQUFnQztBQUM1QnpqQyxZQUFJLENBQUMrb0MsTUFBTCxDQUFZaHNCLFVBQVosR0FBeUIsSUFBekI7QUFDQS9jLFlBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFBWixHQUF5QixJQUF6QjtBQUNIOztBQUNEeGQsWUFBTSxDQUFDcW9DLE1BQVAsQ0FBY25oQyxJQUFJLENBQUMrb0MsTUFBbkIsRUFBMkJMLE9BQTNCLEVBQW9DaVMsVUFBcEM7O0FBQ0EsV0FBSyxJQUFJbGhELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpaEQsUUFBUSxDQUFDcjRDLE1BQTdCLEVBQXFDNUksQ0FBQyxFQUF0QztBQUNJO0FBQ0F1RyxZQUFJLENBQUMrb0MsTUFBTCxDQUFZMlIsUUFBUSxDQUFDamhELENBQUQsQ0FBcEIsSUFDSXVHLElBQUksQ0FBQytvQyxNQUFMLENBQVkyUixRQUFRLENBQUNqaEQsQ0FBRCxDQUFwQixNQUE2QixJQUE3QixJQUNJdUcsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWTJSLFFBQVEsQ0FBQ2poRCxDQUFELENBQXBCLE1BQTZCLE1BRnJDO0FBRko7O0FBS0Frb0MsV0FBSyxDQUFDeHNCLE1BQU4sQ0FBYSxVQUFVc21DLElBQVYsRUFBZ0I7QUFBRSxlQUFPejdDLElBQUksQ0FBQytvQyxNQUFMLENBQVkwUyxJQUFaLE1BQXNCbDFCLFNBQTdCO0FBQXlDLE9BQXhFLEVBQTBFa2tCLE9BQTFFLENBQWtGLFVBQVVnUixJQUFWLEVBQWdCO0FBQzlGejdDLFlBQUksQ0FBQytvQyxNQUFMLENBQVkwUyxJQUFaLElBQW9CalcsUUFBUSxDQUFDeGxDLElBQUksQ0FBQytvQyxNQUFMLENBQVkwUyxJQUFaLEtBQXFCLEVBQXRCLENBQVIsQ0FBa0NuUyxHQUFsQyxDQUFzQzBFLGNBQXRDLENBQXBCO0FBQ0gsT0FGRDtBQUdBaHVDLFVBQUksQ0FBQ21wQyxRQUFMLEdBQ0ksQ0FBQ25wQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZcnJCLGFBQWIsSUFDSSxDQUFDMWQsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhGLE1BRGpCLElBRUl2akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsUUFGekIsSUFHSSxDQUFDempDLElBQUksQ0FBQytvQyxNQUFMLENBQVluRyxPQUFaLENBQW9CdmdDLE1BSHpCLElBSUksQ0FBQ3JDLElBQUksQ0FBQytvQyxNQUFMLENBQVlsRyxNQUFaLENBQW1CeGdDLE1BSnhCLElBS0ksQ0FBQ3JDLElBQUksQ0FBQytvQyxNQUFMLENBQVlwckIsV0FMakIsSUFNSSxpRUFBaUU2TCxJQUFqRSxDQUFzRTRZLFNBQVMsQ0FBQ0MsU0FBaEYsQ0FQUjs7QUFRQSxXQUFLLElBQUk1b0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLElBQUksQ0FBQytvQyxNQUFMLENBQVl2RSxPQUFaLENBQW9CbmlDLE1BQXhDLEVBQWdENUksQ0FBQyxFQUFqRCxFQUFxRDtBQUNqRCxZQUFJaWlELFVBQVUsR0FBRzE3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdkUsT0FBWixDQUFvQi9xQyxDQUFwQixFQUF1QnVHLElBQXZCLEtBQWdDLEVBQWpEOztBQUNBLGFBQUssSUFBSXJHLEdBQVQsSUFBZ0IraEQsVUFBaEIsRUFBNEI7QUFDeEIsY0FBSS9aLEtBQUssQ0FBQ3paLE9BQU4sQ0FBY3Z1QixHQUFkLElBQXFCLENBQUMsQ0FBMUIsRUFBNkI7QUFDekJxRyxnQkFBSSxDQUFDK29DLE1BQUwsQ0FBWXB2QyxHQUFaLElBQW1CNnJDLFFBQVEsQ0FBQ2tXLFVBQVUsQ0FBQy9oRCxHQUFELENBQVgsQ0FBUixDQUNkMnZDLEdBRGMsQ0FDVjBFLGNBRFUsRUFFZGhsQixNQUZjLENBRVBocEIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXB2QyxHQUFaLENBRk8sQ0FBbkI7QUFHSCxXQUpELE1BS0ssSUFBSSxPQUFPZ2hELFVBQVUsQ0FBQ2hoRCxHQUFELENBQWpCLEtBQTJCLFdBQS9CLEVBQ0RxRyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZcHZDLEdBQVosSUFBbUIraEQsVUFBVSxDQUFDL2hELEdBQUQsQ0FBN0I7QUFDUDtBQUNKOztBQUNELFVBQUksQ0FBQ2doRCxVQUFVLENBQUN6WSxhQUFoQixFQUErQjtBQUMzQmxpQyxZQUFJLENBQUMrb0MsTUFBTCxDQUFZN0csYUFBWixHQUNJeVosWUFBWSxHQUFHaFcsU0FBZixHQUEyQixHQUEzQixHQUFpQzNsQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZN0csYUFEakQ7QUFFSDs7QUFDRDZMLGtCQUFZLENBQUMsZUFBRCxDQUFaO0FBQ0g7O0FBQ0QsYUFBUzROLFlBQVQsR0FBd0I7QUFDcEIsYUFBTzM3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZN3JCLElBQVosR0FDRHF1QixPQUFPLENBQUNxUSxhQUFSLENBQXNCLGNBQXRCLENBREMsR0FFRHJRLE9BRk47QUFHSDs7QUFDRCxhQUFTK0IsV0FBVCxHQUF1QjtBQUNuQixVQUFJLFFBQU90dEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWx5QixNQUFuQixNQUE4QixRQUE5QixJQUNBLE9BQU9vRyxTQUFTLENBQUM0K0IsS0FBVixDQUFnQjc3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbHlCLE1BQTVCLENBQVAsS0FBK0MsV0FEbkQsRUFFSTdXLElBQUksQ0FBQytvQyxNQUFMLENBQVlqRyxZQUFaLENBQXlCLElBQUkzUyxLQUFKLENBQVUsK0JBQStCbndCLElBQUksQ0FBQytvQyxNQUFMLENBQVlseUIsTUFBckQsQ0FBekI7QUFDSjdXLFVBQUksQ0FBQ2lwQyxJQUFMLEdBQVkvSCxPQUFRLENBQUNBLE9BQVEsQ0FBQyxFQUFELEVBQUtqa0IsU0FBUyxDQUFDNCtCLEtBQVYsQ0FBZ0JDLE9BQXJCLENBQVQsRUFBeUMsUUFBTzk3QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbHlCLE1BQW5CLE1BQThCLFFBQTlCLEdBQ3ZEN1csSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWx5QixNQUQyQyxHQUV2RDdXLElBQUksQ0FBQytvQyxNQUFMLENBQVlseUIsTUFBWixLQUF1QixTQUF2QixHQUNJb0csU0FBUyxDQUFDNCtCLEtBQVYsQ0FBZ0I3N0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWx5QixNQUE1QixDQURKLEdBRUkwUCxTQUpVLENBQXBCO0FBS0FraUIsZ0JBQVUsQ0FBQ2QsQ0FBWCxHQUFlLE1BQU0zbkMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixDQUFOLEdBQTBCLEdBQTFCLEdBQWdDaGYsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixDQUFoQyxHQUFvRCxHQUFwRCxHQUEwRGhmLElBQUksQ0FBQ2lwQyxJQUFMLENBQVVqcUIsSUFBVixDQUFlLENBQWYsRUFBa0J3UyxXQUFsQixFQUExRCxHQUE0RixHQUE1RixHQUFrR3h4QixJQUFJLENBQUNpcEMsSUFBTCxDQUFVanFCLElBQVYsQ0FBZSxDQUFmLEVBQWtCd1MsV0FBbEIsRUFBbEcsR0FBb0ksR0FBbko7O0FBQ0EsVUFBSW1wQixVQUFVLEdBQUd6WixPQUFRLENBQUNBLE9BQVEsQ0FBQyxFQUFELEVBQUtzSyxjQUFMLENBQVQsRUFBK0JydEMsSUFBSSxDQUFDeThDLEtBQUwsQ0FBV3o4QyxJQUFJLENBQUMwOEMsU0FBTCxDQUFldFAsT0FBTyxDQUFDdVAsT0FBUixJQUFtQixFQUFsQyxDQUFYLENBQS9CLENBQXpCOztBQUNBLFVBQUlILFVBQVUsQ0FBQzk5QixTQUFYLEtBQXlCMEosU0FBekIsSUFDQXRKLFNBQVMsQ0FBQ3d1QixhQUFWLENBQXdCNXVCLFNBQXhCLEtBQXNDMEosU0FEMUMsRUFDcUQ7QUFDakR2bUIsWUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxzQixTQUFaLEdBQXdCN2MsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVXBzQixTQUFsQztBQUNIOztBQUNEN2MsVUFBSSxDQUFDcWQsVUFBTCxHQUFrQnVyQixtQkFBbUIsQ0FBQzVvQyxJQUFELENBQXJDO0FBQ0FBLFVBQUksQ0FBQ3lhLFNBQUwsR0FBaUIrdUIsZ0JBQWdCLENBQUM7QUFBRVQsY0FBTSxFQUFFL29DLElBQUksQ0FBQytvQyxNQUFmO0FBQXVCRSxZQUFJLEVBQUVqcEMsSUFBSSxDQUFDaXBDO0FBQWxDLE9BQUQsQ0FBakM7QUFDSDs7QUFDRCxhQUFTZ0QsZ0JBQVQsQ0FBMEI4UCxxQkFBMUIsRUFBaUQ7QUFDN0MsVUFBSS83QyxJQUFJLENBQUNrdUMsaUJBQUwsS0FBMkIzbkIsU0FBL0IsRUFDSTtBQUNKd25CLGtCQUFZLENBQUMsdUJBQUQsQ0FBWjtBQUNBLFVBQUl0SixlQUFlLEdBQUdzWCxxQkFBcUIsSUFBSS83QyxJQUFJLENBQUNxNkMsZ0JBQXBEO0FBQ0EsVUFBSTJCLGNBQWMsR0FBRzc4QyxLQUFLLENBQUNnbEIsU0FBTixDQUFnQjgzQixNQUFoQixDQUF1Qng0QixJQUF2QixDQUE0QnpqQixJQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJnRyxRQUFuRCxFQUE4RCxVQUFVZ0ksR0FBVixFQUFldmdELEtBQWYsRUFBc0I7QUFBRSxlQUFPdWdELEdBQUcsR0FBR3ZnRCxLQUFLLENBQUN3Z0QsWUFBbkI7QUFBa0MsT0FBeEgsRUFBMkgsQ0FBM0gsQ0FBckI7QUFBQSxVQUFvSkMsYUFBYSxHQUFHcDhDLElBQUksQ0FBQ2t1QyxpQkFBTCxDQUF1Qk8sV0FBM0w7QUFBQSxVQUF3TTROLFNBQVMsR0FBR3I4QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZL25CLFFBQVosQ0FBcUJpQixLQUFyQixDQUEyQixHQUEzQixDQUFwTjtBQUFBLFVBQXFQcTZCLGlCQUFpQixHQUFHRCxTQUFTLENBQUMsQ0FBRCxDQUFsUjtBQUFBLFVBQXVSRSxtQkFBbUIsR0FBR0YsU0FBUyxDQUFDaDZDLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJnNkMsU0FBUyxDQUFDLENBQUQsQ0FBaEMsR0FBc0MsSUFBblY7QUFBQSxVQUF5VkcsV0FBVyxHQUFHL1gsZUFBZSxDQUFDZ1kscUJBQWhCLEVBQXZXO0FBQUEsVUFBZ1pDLGtCQUFrQixHQUFHLzBDLE1BQU0sQ0FBQ2cxQyxXQUFQLEdBQXFCSCxXQUFXLENBQUNJLE1BQXRjO0FBQUEsVUFBOGNDLFNBQVMsR0FBR1AsaUJBQWlCLEtBQUssT0FBdEIsSUFDcmRBLGlCQUFpQixLQUFLLE9BQXRCLElBQ0dJLGtCQUFrQixHQUFHVixjQUR4QixJQUVHUSxXQUFXLENBQUNNLEdBQVosR0FBa0JkLGNBSDFCO0FBSUEsVUFBSWMsR0FBRyxHQUFHbjFDLE1BQU0sQ0FBQ28xQyxXQUFQLEdBQ05QLFdBQVcsQ0FBQ00sR0FETixJQUVMLENBQUNELFNBQUQsR0FBYXBZLGVBQWUsQ0FBQzBYLFlBQWhCLEdBQStCLENBQTVDLEdBQWdELENBQUNILGNBQUQsR0FBa0IsQ0FGN0QsQ0FBVjtBQUdBdlcsaUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsVUFBekIsRUFBcUMsQ0FBQzJPLFNBQXRDLENBQVg7QUFDQXBYLGlCQUFXLENBQUN6bEMsSUFBSSxDQUFDa3VDLGlCQUFOLEVBQXlCLGFBQXpCLEVBQXdDMk8sU0FBeEMsQ0FBWDtBQUNBLFVBQUk3OEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhGLE1BQWhCLEVBQ0k7QUFDSixVQUFJeVosSUFBSSxHQUFHcjFDLE1BQU0sQ0FBQ3MxQyxXQUFQLEdBQXFCVCxXQUFXLENBQUNRLElBQTVDO0FBQ0EsVUFBSUUsUUFBUSxHQUFHLEtBQWY7QUFDQSxVQUFJQyxPQUFPLEdBQUcsS0FBZDs7QUFDQSxVQUFJWixtQkFBbUIsS0FBSyxRQUE1QixFQUFzQztBQUNsQ1MsWUFBSSxJQUFJLENBQUNaLGFBQWEsR0FBR0ksV0FBVyxDQUFDOU4sS0FBN0IsSUFBc0MsQ0FBOUM7QUFDQXdPLGdCQUFRLEdBQUcsSUFBWDtBQUNILE9BSEQsTUFJSyxJQUFJWCxtQkFBbUIsS0FBSyxPQUE1QixFQUFxQztBQUN0Q1MsWUFBSSxJQUFJWixhQUFhLEdBQUdJLFdBQVcsQ0FBQzlOLEtBQXBDO0FBQ0F5TyxlQUFPLEdBQUcsSUFBVjtBQUNIOztBQUNEMVgsaUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsV0FBekIsRUFBc0MsQ0FBQ2dQLFFBQUQsSUFBYSxDQUFDQyxPQUFwRCxDQUFYO0FBQ0ExWCxpQkFBVyxDQUFDemxDLElBQUksQ0FBQ2t1QyxpQkFBTixFQUF5QixhQUF6QixFQUF3Q2dQLFFBQXhDLENBQVg7QUFDQXpYLGlCQUFXLENBQUN6bEMsSUFBSSxDQUFDa3VDLGlCQUFOLEVBQXlCLFlBQXpCLEVBQXVDaVAsT0FBdkMsQ0FBWDtBQUNBLFVBQUlDLEtBQUssR0FBR3oxQyxNQUFNLENBQUNULFFBQVAsQ0FBZ0JrQyxJQUFoQixDQUFxQnFsQyxXQUFyQixJQUNQOW1DLE1BQU0sQ0FBQ3MxQyxXQUFQLEdBQXFCVCxXQUFXLENBQUNZLEtBRDFCLENBQVo7QUFFQSxVQUFJQyxTQUFTLEdBQUdMLElBQUksR0FBR1osYUFBUCxHQUF1QnowQyxNQUFNLENBQUNULFFBQVAsQ0FBZ0JrQyxJQUFoQixDQUFxQnFsQyxXQUE1RDtBQUNBLFVBQUk2TyxVQUFVLEdBQUdGLEtBQUssR0FBR2hCLGFBQVIsR0FBd0J6MEMsTUFBTSxDQUFDVCxRQUFQLENBQWdCa0MsSUFBaEIsQ0FBcUJxbEMsV0FBOUQ7QUFDQWhKLGlCQUFXLENBQUN6bEMsSUFBSSxDQUFDa3VDLGlCQUFOLEVBQXlCLFdBQXpCLEVBQXNDbVAsU0FBdEMsQ0FBWDtBQUNBLFVBQUlyOUMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWxFLE1BQWhCLEVBQ0k7QUFDSjdrQyxVQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJDLEtBQXZCLENBQTZCMk8sR0FBN0IsR0FBbUNBLEdBQUcsR0FBRyxJQUF6Qzs7QUFDQSxVQUFJLENBQUNPLFNBQUwsRUFBZ0I7QUFDWnI5QyxZQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJDLEtBQXZCLENBQTZCNk8sSUFBN0IsR0FBb0NBLElBQUksR0FBRyxJQUEzQztBQUNBaDlDLFlBQUksQ0FBQ2t1QyxpQkFBTCxDQUF1QkMsS0FBdkIsQ0FBNkJpUCxLQUE3QixHQUFxQyxNQUFyQztBQUNILE9BSEQsTUFJSyxJQUFJLENBQUNFLFVBQUwsRUFBaUI7QUFDbEJ0OUMsWUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2QjZPLElBQTdCLEdBQW9DLE1BQXBDO0FBQ0FoOUMsWUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2QmlQLEtBQTdCLEdBQXFDQSxLQUFLLEdBQUcsSUFBN0M7QUFDSCxPQUhJLE1BSUE7QUFDRCxZQUFJdDJDLEdBQUcsR0FBR3kyQyxxQkFBcUIsRUFBL0IsQ0FEQyxDQUVEOztBQUNBLFlBQUl6MkMsR0FBRyxLQUFLeWYsU0FBWixFQUNJO0FBQ0osWUFBSWkzQixTQUFTLEdBQUc3MUMsTUFBTSxDQUFDVCxRQUFQLENBQWdCa0MsSUFBaEIsQ0FBcUJxbEMsV0FBckM7QUFDQSxZQUFJZ1AsVUFBVSxHQUFHNzhDLElBQUksQ0FBQytJLEdBQUwsQ0FBUyxDQUFULEVBQVk2ekMsU0FBUyxHQUFHLENBQVosR0FBZ0JwQixhQUFhLEdBQUcsQ0FBNUMsQ0FBakI7QUFDQSxZQUFJc0IsWUFBWSxHQUFHLHVDQUFuQjtBQUNBLFlBQUlDLFdBQVcsR0FBRyxzQ0FBbEI7QUFDQSxZQUFJQyxXQUFXLEdBQUc5MkMsR0FBRyxDQUFDKzJDLFFBQUosQ0FBYXg3QyxNQUEvQjtBQUNBLFlBQUl5N0MsV0FBVyxHQUFHLFdBQVd0QixXQUFXLENBQUNRLElBQXZCLEdBQThCLGlCQUFoRDtBQUNBdlgsbUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsV0FBekIsRUFBc0MsS0FBdEMsQ0FBWDtBQUNBekksbUJBQVcsQ0FBQ3psQyxJQUFJLENBQUNrdUMsaUJBQU4sRUFBeUIsWUFBekIsRUFBdUMsSUFBdkMsQ0FBWDtBQUNBcG5DLFdBQUcsQ0FBQ2kzQyxVQUFKLENBQWVMLFlBQVksR0FBRyxHQUFmLEdBQXFCQyxXQUFyQixHQUFtQ0csV0FBbEQsRUFBK0RGLFdBQS9EO0FBQ0E1OUMsWUFBSSxDQUFDa3VDLGlCQUFMLENBQXVCQyxLQUF2QixDQUE2QjZPLElBQTdCLEdBQW9DUyxVQUFVLEdBQUcsSUFBakQ7QUFDQXo5QyxZQUFJLENBQUNrdUMsaUJBQUwsQ0FBdUJDLEtBQXZCLENBQTZCaVAsS0FBN0IsR0FBcUMsTUFBckM7QUFDSDtBQUNKOztBQUNELGFBQVNHLHFCQUFULEdBQWlDO0FBQzdCLFVBQUlTLGFBQWEsR0FBRyxJQUFwQjs7QUFDQSxXQUFLLElBQUl2a0QsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3lOLFFBQVEsQ0FBQysyQyxXQUFULENBQXFCNTdDLE1BQXpDLEVBQWlENUksQ0FBQyxFQUFsRCxFQUFzRDtBQUNsRCxZQUFJeWtELEtBQUssR0FBR2gzQyxRQUFRLENBQUMrMkMsV0FBVCxDQUFxQnhrRCxDQUFyQixDQUFaOztBQUNBLFlBQUk7QUFDQXlrRCxlQUFLLENBQUNMLFFBQU47QUFDSCxTQUZELENBR0EsT0FBTzlhLEdBQVAsRUFBWTtBQUNSO0FBQ0g7O0FBQ0RpYixxQkFBYSxHQUFHRSxLQUFoQjtBQUNBO0FBQ0g7O0FBQ0QsYUFBT0YsYUFBYSxJQUFJLElBQWpCLEdBQXdCQSxhQUF4QixHQUF3Q0csZ0JBQWdCLEVBQS9EO0FBQ0g7O0FBQ0QsYUFBU0EsZ0JBQVQsR0FBNEI7QUFDeEIsVUFBSWhRLEtBQUssR0FBR2puQyxRQUFRLENBQUM2K0IsYUFBVCxDQUF1QixPQUF2QixDQUFaO0FBQ0E3K0IsY0FBUSxDQUFDazNDLElBQVQsQ0FBY3RYLFdBQWQsQ0FBMEJxSCxLQUExQjtBQUNBLGFBQU9BLEtBQUssQ0FBQytQLEtBQWI7QUFDSDs7QUFDRCxhQUFTdlIsTUFBVCxHQUFrQjtBQUNkLFVBQUkzc0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWhzQixVQUFaLElBQTBCL2MsSUFBSSxDQUFDbXBDLFFBQW5DLEVBQ0k7QUFDSjBJLHNCQUFnQjtBQUNoQmlGLGtDQUE0QjtBQUM1Qm5FLGVBQVM7QUFDWjs7QUFDRCxhQUFTMEcsYUFBVCxHQUF5QjtBQUNyQnI1QyxVQUFJLENBQUNzZixNQUFMLENBQVl3MEIsS0FBWjs7QUFDQSxVQUFJbnNDLE1BQU0sQ0FBQ3k2QixTQUFQLENBQWlCQyxTQUFqQixDQUEyQm5hLE9BQTNCLENBQW1DLE1BQW5DLE1BQStDLENBQUMsQ0FBaEQsSUFDQWthLFNBQVMsQ0FBQ2ljLGdCQUFWLEtBQStCOTNCLFNBRG5DLEVBQzhDO0FBQzFDO0FBQ0F4RixrQkFBVSxDQUFDL2dCLElBQUksQ0FBQ3FzQyxLQUFOLEVBQWEsQ0FBYixDQUFWO0FBQ0gsT0FKRCxNQUtLO0FBQ0Ryc0MsWUFBSSxDQUFDcXNDLEtBQUw7QUFDSDtBQUNKOztBQUNELGFBQVMrRSxVQUFULENBQW9CaHFDLENBQXBCLEVBQXVCO0FBQ25CQSxPQUFDLENBQUNneUMsY0FBRjtBQUNBaHlDLE9BQUMsQ0FBQ295QyxlQUFGOztBQUNBLFVBQUk4RSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFVem1DLEdBQVYsRUFBZTtBQUM5QixlQUFPQSxHQUFHLENBQUMrdEIsU0FBSixJQUNIL3RCLEdBQUcsQ0FBQyt0QixTQUFKLENBQWNtTSxRQUFkLENBQXVCLGVBQXZCLENBREcsSUFFSCxDQUFDbDZCLEdBQUcsQ0FBQyt0QixTQUFKLENBQWNtTSxRQUFkLENBQXVCLG9CQUF2QixDQUZFLElBR0gsQ0FBQ2w2QixHQUFHLENBQUMrdEIsU0FBSixDQUFjbU0sUUFBZCxDQUF1QixZQUF2QixDQUhMO0FBSUgsT0FMRDs7QUFNQSxVQUFJM1EsQ0FBQyxHQUFHaUYsVUFBVSxDQUFDVSxjQUFjLENBQUMzL0IsQ0FBRCxDQUFmLEVBQW9CazNDLFlBQXBCLENBQWxCO0FBQ0EsVUFBSWxkLENBQUMsS0FBSzdhLFNBQVYsRUFDSTtBQUNKLFVBQUlyc0IsTUFBTSxHQUFHa25DLENBQWI7QUFDQSxVQUFJeGtCLFlBQVksR0FBSTVjLElBQUksQ0FBQzJ0QyxxQkFBTCxHQUE2QixJQUFJL25DLElBQUosQ0FBUzFMLE1BQU0sQ0FBQ3F0QyxPQUFQLENBQWV2aUIsT0FBZixFQUFULENBQWpEO0FBQ0EsVUFBSXU1QixpQkFBaUIsR0FBRyxDQUFDM2hDLFlBQVksQ0FBQ2tOLFFBQWIsS0FBMEI5cEIsSUFBSSxDQUFDaXRDLFlBQS9CLElBQ3JCcndCLFlBQVksQ0FBQ2tOLFFBQWIsS0FDSTlwQixJQUFJLENBQUNpdEMsWUFBTCxHQUFvQmp0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbkUsVUFBaEMsR0FBNkMsQ0FGN0IsS0FHcEI1a0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsT0FIekI7QUFJQXpqQyxVQUFJLENBQUN5ekMsZ0JBQUwsR0FBd0J2NUMsTUFBeEI7QUFDQSxVQUFJOEYsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsUUFBekIsRUFDSXpqQyxJQUFJLENBQUMrZCxhQUFMLEdBQXFCLENBQUNuQixZQUFELENBQXJCLENBREosS0FFSyxJQUFJNWMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsVUFBekIsRUFBcUM7QUFDdEMsWUFBSSthLGFBQWEsR0FBR2hMLGNBQWMsQ0FBQzUyQixZQUFELENBQWxDO0FBQ0EsWUFBSTRoQyxhQUFKLEVBQ0l4K0MsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQnU1QixNQUFuQixDQUEwQmp5QyxRQUFRLENBQUNtNUMsYUFBRCxDQUFsQyxFQUFtRCxDQUFuRCxFQURKLEtBR0l4K0MsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQnl5QixJQUFuQixDQUF3QjV6QixZQUF4QjtBQUNQLE9BTkksTUFPQSxJQUFJNWMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsT0FBekIsRUFBa0M7QUFDbkMsWUFBSXpqQyxJQUFJLENBQUMrZCxhQUFMLENBQW1CMWIsTUFBbkIsS0FBOEIsQ0FBbEMsRUFBcUM7QUFDakNyQyxjQUFJLENBQUNvc0MsS0FBTCxDQUFXLEtBQVgsRUFBa0IsS0FBbEI7QUFDSDs7QUFDRHBzQyxZQUFJLENBQUMydEMscUJBQUwsR0FBNkIvd0IsWUFBN0I7QUFDQTVjLFlBQUksQ0FBQytkLGFBQUwsQ0FBbUJ5eUIsSUFBbkIsQ0FBd0I1ekIsWUFBeEIsRUFMbUMsQ0FNbkM7O0FBQ0EsWUFBSTh0QixZQUFZLENBQUM5dEIsWUFBRCxFQUFlNWMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixDQUFmLEVBQXNDLElBQXRDLENBQVosS0FBNEQsQ0FBaEUsRUFDSS9kLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIwZ0MsSUFBbkIsQ0FBd0IsVUFBVWpkLENBQVYsRUFBYWtkLENBQWIsRUFBZ0I7QUFBRSxpQkFBT2xkLENBQUMsQ0FBQ3hjLE9BQUYsS0FBYzA1QixDQUFDLENBQUMxNUIsT0FBRixFQUFyQjtBQUFtQyxTQUE3RTtBQUNQO0FBQ0RrcUIsd0JBQWtCOztBQUNsQixVQUFJcVAsaUJBQUosRUFBdUI7QUFDbkIsWUFBSTNGLFNBQVMsR0FBRzU0QyxJQUFJLENBQUNrdEMsV0FBTCxLQUFxQnR3QixZQUFZLENBQUN5TSxXQUFiLEVBQXJDO0FBQ0FycEIsWUFBSSxDQUFDa3RDLFdBQUwsR0FBbUJ0d0IsWUFBWSxDQUFDeU0sV0FBYixFQUFuQjtBQUNBcnBCLFlBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CcndCLFlBQVksQ0FBQ2tOLFFBQWIsRUFBcEI7O0FBQ0EsWUFBSTh1QixTQUFKLEVBQWU7QUFDWDdLLHNCQUFZLENBQUMsY0FBRCxDQUFaO0FBQ0E4RCwwQkFBZ0I7QUFDbkI7O0FBQ0Q5RCxvQkFBWSxDQUFDLGVBQUQsQ0FBWjtBQUNIOztBQUNEK0ksa0NBQTRCO0FBQzVCbkUsZUFBUztBQUNUL0UsaUJBQVcsR0FuRFEsQ0FvRG5COztBQUNBLFVBQUksQ0FBQzJRLGlCQUFELElBQ0F2K0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQVosS0FBcUIsT0FEckIsSUFFQXpqQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbkUsVUFBWixLQUEyQixDQUYvQixFQUdJZ1AsY0FBYyxDQUFDMTVDLE1BQUQsQ0FBZCxDQUhKLEtBSUssSUFBSThGLElBQUksQ0FBQ3l6QyxnQkFBTCxLQUEwQmx0QixTQUExQixJQUNMdm1CLElBQUksQ0FBQ3N2QyxXQUFMLEtBQXFCL29CLFNBRHBCLEVBQytCO0FBQ2hDdm1CLFlBQUksQ0FBQ3l6QyxnQkFBTCxJQUF5Qnp6QyxJQUFJLENBQUN5ekMsZ0JBQUwsQ0FBc0JLLEtBQXRCLEVBQXpCO0FBQ0g7QUFDRCxVQUFJOXpDLElBQUksQ0FBQ3N2QyxXQUFMLEtBQXFCL29CLFNBQXpCLEVBQ0l2bUIsSUFBSSxDQUFDc3ZDLFdBQUwsS0FBcUIvb0IsU0FBckIsSUFBa0N2bUIsSUFBSSxDQUFDc3ZDLFdBQUwsQ0FBaUJ3RSxLQUFqQixFQUFsQzs7QUFDSixVQUFJOXpDLElBQUksQ0FBQytvQyxNQUFMLENBQVl0RyxhQUFoQixFQUErQjtBQUMzQixZQUFJa2MsTUFBTSxHQUFHMytDLElBQUksQ0FBQytvQyxNQUFMLENBQVl0RixJQUFaLEtBQXFCLFFBQXJCLElBQWlDLENBQUN6akMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXp5QixVQUEzRDtBQUNBLFlBQUlzb0MsS0FBSyxHQUFHNStDLElBQUksQ0FBQytvQyxNQUFMLENBQVl0RixJQUFaLEtBQXFCLE9BQXJCLElBQ1J6akMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEtBQThCLENBRHRCLElBRVIsQ0FBQ3JDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFGakI7O0FBR0EsWUFBSXFvQyxNQUFNLElBQUlDLEtBQWQsRUFBcUI7QUFDakJ2Rix1QkFBYTtBQUNoQjtBQUNKOztBQUNENUksbUJBQWE7QUFDaEI7O0FBQ0QsUUFBSW9PLFNBQVMsR0FBRztBQUNaaG9DLFlBQU0sRUFBRSxDQUFDeTJCLFdBQUQsRUFBYytKLGNBQWQsQ0FESTtBQUVaelMsZ0JBQVUsRUFBRSxDQUFDMFIsV0FBRCxFQUFjekksZ0JBQWQsRUFBZ0M2RSxhQUFoQyxDQUZBO0FBR1puMUIsYUFBTyxFQUFFLENBQUNrdkIsVUFBRCxDQUhHO0FBSVpudkIsYUFBTyxFQUFFLENBQUNtdkIsVUFBRDtBQUpHLEtBQWhCOztBQU1BLGFBQVNseUMsR0FBVCxDQUFhbU0sTUFBYixFQUFxQjVNLEtBQXJCLEVBQTRCO0FBQ3hCLFVBQUk0TSxNQUFNLEtBQUssSUFBWCxJQUFtQixRQUFPQSxNQUFQLE1BQWtCLFFBQXpDLEVBQW1EO0FBQy9DNU4sY0FBTSxDQUFDcW9DLE1BQVAsQ0FBY25oQyxJQUFJLENBQUMrb0MsTUFBbkIsRUFBMkJyaUMsTUFBM0I7O0FBQ0EsYUFBSyxJQUFJL00sR0FBVCxJQUFnQitNLE1BQWhCLEVBQXdCO0FBQ3BCLGNBQUltNEMsU0FBUyxDQUFDbGxELEdBQUQsQ0FBVCxLQUFtQjRzQixTQUF2QixFQUNJczRCLFNBQVMsQ0FBQ2xsRCxHQUFELENBQVQsQ0FBZTh3QyxPQUFmLENBQXVCLFVBQVV2aEIsQ0FBVixFQUFhO0FBQUUsbUJBQU9BLENBQUMsRUFBUjtBQUFhLFdBQW5EO0FBQ1A7QUFDSixPQU5ELE1BT0s7QUFDRGxwQixZQUFJLENBQUMrb0MsTUFBTCxDQUFZcmlDLE1BQVosSUFBc0I1TSxLQUF0QjtBQUNBLFlBQUkra0QsU0FBUyxDQUFDbjRDLE1BQUQsQ0FBVCxLQUFzQjZmLFNBQTFCLEVBQ0lzNEIsU0FBUyxDQUFDbjRDLE1BQUQsQ0FBVCxDQUFrQitqQyxPQUFsQixDQUEwQixVQUFVdmhCLENBQVYsRUFBYTtBQUFFLGlCQUFPQSxDQUFDLEVBQVI7QUFBYSxTQUF0RCxFQURKLEtBRUssSUFBSXlZLEtBQUssQ0FBQ3paLE9BQU4sQ0FBY3hoQixNQUFkLElBQXdCLENBQUMsQ0FBN0IsRUFDRDFHLElBQUksQ0FBQytvQyxNQUFMLENBQVlyaUMsTUFBWixJQUFzQjgrQixRQUFRLENBQUMxckMsS0FBRCxDQUE5QjtBQUNQOztBQUNEa0csVUFBSSxDQUFDMnNDLE1BQUw7QUFDQWlCLGlCQUFXLENBQUMsSUFBRCxDQUFYO0FBQ0g7O0FBQ0QsYUFBU2tSLGVBQVQsQ0FBeUJDLFNBQXpCLEVBQW9DbmhDLE1BQXBDLEVBQTRDO0FBQ3hDLFVBQUltOUIsS0FBSyxHQUFHLEVBQVo7QUFDQSxVQUFJZ0UsU0FBUyxZQUFZNS9DLEtBQXpCLEVBQ0k0N0MsS0FBSyxHQUFHZ0UsU0FBUyxDQUFDelYsR0FBVixDQUFjLFVBQVUzbEIsQ0FBVixFQUFhO0FBQUUsZUFBTzNqQixJQUFJLENBQUN5YSxTQUFMLENBQWVrSixDQUFmLEVBQWtCL0YsTUFBbEIsQ0FBUDtBQUFtQyxPQUFoRSxDQUFSLENBREosS0FFSyxJQUFJbWhDLFNBQVMsWUFBWW41QyxJQUFyQixJQUE2QixPQUFPbTVDLFNBQVAsS0FBcUIsUUFBdEQsRUFDRGhFLEtBQUssR0FBRyxDQUFDLzZDLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXNrQyxTQUFmLEVBQTBCbmhDLE1BQTFCLENBQUQsQ0FBUixDQURDLEtBRUEsSUFBSSxPQUFPbWhDLFNBQVAsS0FBcUIsUUFBekIsRUFBbUM7QUFDcEMsZ0JBQVEvK0MsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXRGLElBQXBCO0FBQ0ksZUFBSyxRQUFMO0FBQ0EsZUFBSyxNQUFMO0FBQ0lzWCxpQkFBSyxHQUFHLENBQUMvNkMsSUFBSSxDQUFDeWEsU0FBTCxDQUFlc2tDLFNBQWYsRUFBMEJuaEMsTUFBMUIsQ0FBRCxDQUFSO0FBQ0E7O0FBQ0osZUFBSyxVQUFMO0FBQ0ltOUIsaUJBQUssR0FBR2dFLFNBQVMsQ0FDWjk4QixLQURHLENBQ0dqaUIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXJHLFdBRGYsRUFFSDRHLEdBRkcsQ0FFQyxVQUFVamxDLElBQVYsRUFBZ0I7QUFBRSxxQkFBT3JFLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXBXLElBQWYsRUFBcUJ1WixNQUFyQixDQUFQO0FBQXNDLGFBRnpELENBQVI7QUFHQTs7QUFDSixlQUFLLE9BQUw7QUFDSW05QixpQkFBSyxHQUFHZ0UsU0FBUyxDQUNaOThCLEtBREcsQ0FDR2ppQixJQUFJLENBQUNpcEMsSUFBTCxDQUFVcnFCLGNBRGIsRUFFSDBxQixHQUZHLENBRUMsVUFBVWpsQyxJQUFWLEVBQWdCO0FBQUUscUJBQU9yRSxJQUFJLENBQUN5YSxTQUFMLENBQWVwVyxJQUFmLEVBQXFCdVosTUFBckIsQ0FBUDtBQUFzQyxhQUZ6RCxDQUFSO0FBR0E7QUFkUjtBQWdCSCxPQWpCSSxNQW1CRDVkLElBQUksQ0FBQytvQyxNQUFMLENBQVlqRyxZQUFaLENBQXlCLElBQUkzUyxLQUFKLENBQVUsNEJBQTRCaHlCLElBQUksQ0FBQzA4QyxTQUFMLENBQWVrRSxTQUFmLENBQXRDLENBQXpCO0FBQ0ovK0MsVUFBSSxDQUFDK2QsYUFBTCxHQUFzQi9kLElBQUksQ0FBQytvQyxNQUFMLENBQVloSCxtQkFBWixHQUNoQmdaLEtBRGdCLEdBRWhCQSxLQUFLLENBQUM1bEMsTUFBTixDQUFhLFVBQVV3TyxDQUFWLEVBQWE7QUFBRSxlQUFPQSxDQUFDLFlBQVkvZCxJQUFiLElBQXFCNG1DLFNBQVMsQ0FBQzdvQixDQUFELEVBQUksS0FBSixDQUFyQztBQUFrRCxPQUE5RSxDQUZOO0FBR0EsVUFBSTNqQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUF6QixFQUNJempDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIwZ0MsSUFBbkIsQ0FBd0IsVUFBVWpkLENBQVYsRUFBYWtkLENBQWIsRUFBZ0I7QUFBRSxlQUFPbGQsQ0FBQyxDQUFDeGMsT0FBRixLQUFjMDVCLENBQUMsQ0FBQzE1QixPQUFGLEVBQXJCO0FBQW1DLE9BQTdFO0FBQ1A7O0FBQ0QsYUFBU21lLE9BQVQsQ0FBaUI5K0IsSUFBakIsRUFBdUJvc0MsYUFBdkIsRUFBc0M3eUIsTUFBdEMsRUFBOEM7QUFDMUMsVUFBSTZ5QixhQUFhLEtBQUssS0FBSyxDQUEzQixFQUE4QjtBQUFFQSxxQkFBYSxHQUFHLEtBQWhCO0FBQXdCOztBQUN4RCxVQUFJN3lCLE1BQU0sS0FBSyxLQUFLLENBQXBCLEVBQXVCO0FBQUVBLGNBQU0sR0FBRzVkLElBQUksQ0FBQytvQyxNQUFMLENBQVkvckIsVUFBckI7QUFBa0M7O0FBQzNELFVBQUszWSxJQUFJLEtBQUssQ0FBVCxJQUFjLENBQUNBLElBQWhCLElBQTBCQSxJQUFJLFlBQVlsRixLQUFoQixJQUF5QmtGLElBQUksQ0FBQ2hDLE1BQUwsS0FBZ0IsQ0FBdkUsRUFDSSxPQUFPckMsSUFBSSxDQUFDb3NDLEtBQUwsQ0FBV3FFLGFBQVgsQ0FBUDtBQUNKcU8scUJBQWUsQ0FBQ3o2QyxJQUFELEVBQU91WixNQUFQLENBQWY7QUFDQTVkLFVBQUksQ0FBQzJ0QyxxQkFBTCxHQUNJM3RDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIvZCxJQUFJLENBQUMrZCxhQUFMLENBQW1CMWIsTUFBbkIsR0FBNEIsQ0FBL0MsQ0FESjtBQUVBckMsVUFBSSxDQUFDMnNDLE1BQUw7QUFDQUYsZ0JBQVUsQ0FBQ2xtQixTQUFELEVBQVlrcUIsYUFBWixDQUFWO0FBQ0ExRSxzQkFBZ0I7O0FBQ2hCLFVBQUkvckMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEtBQThCLENBQWxDLEVBQXFDO0FBQ2pDckMsWUFBSSxDQUFDb3NDLEtBQUwsQ0FBVyxLQUFYO0FBQ0g7O0FBQ0R3QixpQkFBVyxDQUFDNkMsYUFBRCxDQUFYO0FBQ0EsVUFBSUEsYUFBSixFQUNJMUMsWUFBWSxDQUFDLFVBQUQsQ0FBWjtBQUNQOztBQUNELGFBQVNpTixjQUFULENBQXdCelIsR0FBeEIsRUFBNkI7QUFDekIsYUFBT0EsR0FBRyxDQUNMOVksS0FERSxHQUVGNlksR0FGRSxDQUVFLFVBQVUwVixJQUFWLEVBQWdCO0FBQ3JCLFlBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFoQixJQUNBLE9BQU9BLElBQVAsS0FBZ0IsUUFEaEIsSUFFQUEsSUFBSSxZQUFZcDVDLElBRnBCLEVBRTBCO0FBQ3RCLGlCQUFPNUYsSUFBSSxDQUFDeWEsU0FBTCxDQUFldWtDLElBQWYsRUFBcUJ6NEIsU0FBckIsRUFBZ0MsSUFBaEMsQ0FBUDtBQUNILFNBSkQsTUFLSyxJQUFJeTRCLElBQUksSUFDVCxRQUFPQSxJQUFQLE1BQWdCLFFBRFgsSUFFTEEsSUFBSSxDQUFDbEcsSUFGQSxJQUdMa0csSUFBSSxDQUFDakcsRUFISixFQUlELE9BQU87QUFDSEQsY0FBSSxFQUFFOTRDLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXVrQyxJQUFJLENBQUNsRyxJQUFwQixFQUEwQnZ5QixTQUExQixDQURIO0FBRUh3eUIsWUFBRSxFQUFFLzRDLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXVrQyxJQUFJLENBQUNqRyxFQUFwQixFQUF3Qnh5QixTQUF4QjtBQUZELFNBQVA7O0FBSUosZUFBT3k0QixJQUFQO0FBQ0gsT0FqQk0sRUFrQkY3cEMsTUFsQkUsQ0FrQkssVUFBVStULENBQVYsRUFBYTtBQUFFLGVBQU9BLENBQVA7QUFBVyxPQWxCL0IsQ0FBUCxDQUR5QixDQW1CZ0I7QUFDNUM7O0FBQ0QsYUFBU3NrQixVQUFULEdBQXNCO0FBQ2xCeHRDLFVBQUksQ0FBQytkLGFBQUwsR0FBcUIsRUFBckI7QUFDQS9kLFVBQUksQ0FBQzRqQyxHQUFMLEdBQVc1akMsSUFBSSxDQUFDeWEsU0FBTCxDQUFlemEsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWW5GLEdBQTNCLEtBQW1DLElBQUloK0IsSUFBSixFQUE5QyxDQUZrQixDQUdsQjs7QUFDQSxVQUFJcTVDLGFBQWEsR0FBR2ovQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZK0YsV0FBWixLQUNmLENBQUM5dUMsSUFBSSxDQUFDOEssS0FBTCxDQUFXbzBDLFFBQVgsS0FBd0IsT0FBeEIsSUFDRWwvQyxJQUFJLENBQUM4SyxLQUFMLENBQVdvMEMsUUFBWCxLQUF3QixVQUQzQixLQUVHbC9DLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3EwQyxXQUZkLElBR0duL0MsSUFBSSxDQUFDOEssS0FBTCxDQUFXaFIsS0FBWCxLQUFxQmtHLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3EwQyxXQUhuQyxHQUlLLElBSkwsR0FLS24vQyxJQUFJLENBQUM4SyxLQUFMLENBQVdoUixLQU5ELENBQXBCO0FBT0EsVUFBSW1sRCxhQUFKLEVBQ0lILGVBQWUsQ0FBQ0csYUFBRCxFQUFnQmovQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZL3JCLFVBQTVCLENBQWY7QUFDSmhkLFVBQUksQ0FBQzYzQyxZQUFMLEdBQ0k3M0MsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEdBQTRCLENBQTVCLEdBQ01yQyxJQUFJLENBQUMrZCxhQUFMLENBQW1CLENBQW5CLENBRE4sR0FFTS9kLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixJQUNFdmQsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9CeUgsT0FBcEIsS0FBZ0NobEIsSUFBSSxDQUFDNGpDLEdBQUwsQ0FBUzVlLE9BQVQsRUFEbEMsR0FFSWhsQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BRmhCLEdBR0l2ZCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosSUFDRXRkLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixDQUFvQjBILE9BQXBCLEtBQWdDaGxCLElBQUksQ0FBQzRqQyxHQUFMLENBQVM1ZSxPQUFULEVBRGxDLEdBRUlobEIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUZoQixHQUdJdGQsSUFBSSxDQUFDNGpDLEdBVHZCO0FBVUE1akMsVUFBSSxDQUFDa3RDLFdBQUwsR0FBbUJsdEMsSUFBSSxDQUFDNjNDLFlBQUwsQ0FBa0J4dUIsV0FBbEIsRUFBbkI7QUFDQXJwQixVQUFJLENBQUNpdEMsWUFBTCxHQUFvQmp0QyxJQUFJLENBQUM2M0MsWUFBTCxDQUFrQi90QixRQUFsQixFQUFwQjtBQUNBLFVBQUk5cEIsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEdBQTRCLENBQWhDLEVBQ0lyQyxJQUFJLENBQUMydEMscUJBQUwsR0FBNkIzdEMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQixDQUFuQixDQUE3QjtBQUNKLFVBQUkvZCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZMkcsT0FBWixLQUF3Qm5wQixTQUE1QixFQUNJdm1CLElBQUksQ0FBQytvQyxNQUFMLENBQVkyRyxPQUFaLEdBQXNCMXZDLElBQUksQ0FBQ3lhLFNBQUwsQ0FBZXphLElBQUksQ0FBQytvQyxNQUFMLENBQVkyRyxPQUEzQixFQUFvQyxLQUFwQyxDQUF0QjtBQUNKLFVBQUkxdkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWThHLE9BQVosS0FBd0J0cEIsU0FBNUIsRUFDSXZtQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZOEcsT0FBWixHQUFzQjd2QyxJQUFJLENBQUN5YSxTQUFMLENBQWV6YSxJQUFJLENBQUMrb0MsTUFBTCxDQUFZOEcsT0FBM0IsRUFBb0MsS0FBcEMsQ0FBdEI7QUFDSjd2QyxVQUFJLENBQUMydkMsY0FBTCxHQUNJLENBQUMsQ0FBQzN2QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQWQsS0FDS3ZkLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQjBOLFFBQXBCLEtBQWlDLENBQWpDLElBQ0dqckIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9CdU4sVUFBcEIsS0FBbUMsQ0FEdEMsSUFFRzlxQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0J3TixVQUFwQixLQUFtQyxDQUgzQyxDQURKO0FBS0EvcUIsVUFBSSxDQUFDOHZDLGNBQUwsR0FDSSxDQUFDLENBQUM5dkMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFkLEtBQ0t0ZCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0IyTixRQUFwQixLQUFpQyxDQUFqQyxJQUNHanJCLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixDQUFvQndOLFVBQXBCLEtBQW1DLENBRHRDLElBRUc5cUIsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9CeU4sVUFBcEIsS0FBbUMsQ0FIM0MsQ0FESjtBQUtIOztBQUNELGFBQVN3aUIsV0FBVCxHQUF1QjtBQUNuQnZ0QyxVQUFJLENBQUM4SyxLQUFMLEdBQWE2d0MsWUFBWSxFQUF6QjtBQUNBOztBQUNBLFVBQUksQ0FBQzM3QyxJQUFJLENBQUM4SyxLQUFWLEVBQWlCO0FBQ2I5SyxZQUFJLENBQUMrb0MsTUFBTCxDQUFZakcsWUFBWixDQUF5QixJQUFJM1MsS0FBSixDQUFVLGlDQUFWLENBQXpCO0FBQ0E7QUFDSCxPQU5rQixDQU9uQjs7O0FBQ0Fud0IsVUFBSSxDQUFDOEssS0FBTCxDQUFXa3RDLEtBQVgsR0FBbUJoNEMsSUFBSSxDQUFDOEssS0FBTCxDQUFXbEwsSUFBOUI7QUFDQUksVUFBSSxDQUFDOEssS0FBTCxDQUFXbEwsSUFBWCxHQUFrQixNQUFsQjtBQUNBSSxVQUFJLENBQUM4SyxLQUFMLENBQVc4NkIsU0FBWCxDQUFxQkMsR0FBckIsQ0FBeUIsaUJBQXpCO0FBQ0E3bEMsVUFBSSxDQUFDc2YsTUFBTCxHQUFjdGYsSUFBSSxDQUFDOEssS0FBbkI7O0FBQ0EsVUFBSTlLLElBQUksQ0FBQytvQyxNQUFMLENBQVk5RyxRQUFoQixFQUEwQjtBQUN0QjtBQUNBamlDLFlBQUksQ0FBQ2lpQyxRQUFMLEdBQWdCOEQsYUFBYSxDQUFDL2xDLElBQUksQ0FBQzhLLEtBQUwsQ0FBV28wQyxRQUFaLEVBQXNCbC9DLElBQUksQ0FBQytvQyxNQUFMLENBQVk3RyxhQUFsQyxDQUE3QjtBQUNBbGlDLFlBQUksQ0FBQ3NmLE1BQUwsR0FBY3RmLElBQUksQ0FBQ2lpQyxRQUFuQjtBQUNBamlDLFlBQUksQ0FBQ2lpQyxRQUFMLENBQWNrZCxXQUFkLEdBQTRCbi9DLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3EwQyxXQUF2QztBQUNBbi9DLFlBQUksQ0FBQ2lpQyxRQUFMLENBQWNvVSxRQUFkLEdBQXlCcjJDLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3VyQyxRQUFwQztBQUNBcjJDLFlBQUksQ0FBQ2lpQyxRQUFMLENBQWNwaEMsUUFBZCxHQUF5QmIsSUFBSSxDQUFDOEssS0FBTCxDQUFXakssUUFBcEM7QUFDQWIsWUFBSSxDQUFDaWlDLFFBQUwsQ0FBY29RLFFBQWQsR0FBeUJyeUMsSUFBSSxDQUFDOEssS0FBTCxDQUFXdW5DLFFBQXBDO0FBQ0FyeUMsWUFBSSxDQUFDaWlDLFFBQUwsQ0FBY3JpQyxJQUFkLEdBQXFCLE1BQXJCO0FBQ0FJLFlBQUksQ0FBQzhLLEtBQUwsQ0FBVys3QixZQUFYLENBQXdCLE1BQXhCLEVBQWdDLFFBQWhDO0FBQ0EsWUFBSSxDQUFDN21DLElBQUksQ0FBQytvQyxNQUFMLENBQVlsRSxNQUFiLElBQXVCN2tDLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3c3QixVQUF0QyxFQUNJdG1DLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3c3QixVQUFYLENBQXNCME0sWUFBdEIsQ0FBbUNoekMsSUFBSSxDQUFDaWlDLFFBQXhDLEVBQWtEamlDLElBQUksQ0FBQzhLLEtBQUwsQ0FBV21vQyxXQUE3RDtBQUNQOztBQUNELFVBQUksQ0FBQ2p6QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZNXJCLFVBQWpCLEVBQ0luZCxJQUFJLENBQUNzZixNQUFMLENBQVl1bkIsWUFBWixDQUF5QixVQUF6QixFQUFxQyxVQUFyQztBQUNKN21DLFVBQUksQ0FBQ3E2QyxnQkFBTCxHQUF3QnI2QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEUsZUFBWixJQUErQnprQyxJQUFJLENBQUNzZixNQUE1RDtBQUNIOztBQUNELGFBQVNxeEIsV0FBVCxHQUF1QjtBQUNuQixVQUFJeU8sU0FBUyxHQUFHcC9DLElBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFBWixHQUNWdFcsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWWhzQixVQUFaLEdBQ0ksTUFESixHQUVJLGdCQUhNLEdBSVYsTUFKTjtBQUtBL2MsVUFBSSxDQUFDNDNDLFdBQUwsR0FBbUI3UixhQUFhLENBQUMsT0FBRCxFQUFVL2xDLElBQUksQ0FBQzhLLEtBQUwsQ0FBVzY2QixTQUFYLEdBQXVCLG1CQUFqQyxDQUFoQztBQUNBM2xDLFVBQUksQ0FBQzQzQyxXQUFMLENBQWlCdkYsUUFBakIsR0FBNEIsQ0FBNUI7QUFDQXJ5QyxVQUFJLENBQUM0M0MsV0FBTCxDQUFpQmg0QyxJQUFqQixHQUF3QncvQyxTQUF4QjtBQUNBcC9DLFVBQUksQ0FBQzQzQyxXQUFMLENBQWlCdkIsUUFBakIsR0FBNEJyMkMsSUFBSSxDQUFDOEssS0FBTCxDQUFXdXJDLFFBQXZDO0FBQ0FyMkMsVUFBSSxDQUFDNDNDLFdBQUwsQ0FBaUIvMkMsUUFBakIsR0FBNEJiLElBQUksQ0FBQzhLLEtBQUwsQ0FBV2pLLFFBQXZDO0FBQ0FiLFVBQUksQ0FBQzQzQyxXQUFMLENBQWlCdUgsV0FBakIsR0FBK0JuL0MsSUFBSSxDQUFDOEssS0FBTCxDQUFXcTBDLFdBQTFDO0FBQ0FuL0MsVUFBSSxDQUFDcS9DLGVBQUwsR0FDSUQsU0FBUyxLQUFLLGdCQUFkLEdBQ00sZUFETixHQUVNQSxTQUFTLEtBQUssTUFBZCxHQUNJLE9BREosR0FFSSxPQUxkOztBQU1BLFVBQUlwL0MsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQjFiLE1BQW5CLEdBQTRCLENBQWhDLEVBQW1DO0FBQy9CckMsWUFBSSxDQUFDNDNDLFdBQUwsQ0FBaUIwSCxZQUFqQixHQUFnQ3QvQyxJQUFJLENBQUM0M0MsV0FBTCxDQUFpQjk5QyxLQUFqQixHQUF5QmtHLElBQUksQ0FBQ3FkLFVBQUwsQ0FBZ0JyZCxJQUFJLENBQUMrZCxhQUFMLENBQW1CLENBQW5CLENBQWhCLEVBQXVDL2QsSUFBSSxDQUFDcS9DLGVBQTVDLENBQXpEO0FBQ0g7O0FBQ0QsVUFBSXIvQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQWhCLEVBQ0l2ZCxJQUFJLENBQUM0M0MsV0FBTCxDQUFpQmx1QyxHQUFqQixHQUF1QjFKLElBQUksQ0FBQ3FkLFVBQUwsQ0FBZ0JyZCxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQTVCLEVBQXFDLE9BQXJDLENBQXZCO0FBQ0osVUFBSXZkLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBaEIsRUFDSXRkLElBQUksQ0FBQzQzQyxXQUFMLENBQWlCanVDLEdBQWpCLEdBQXVCM0osSUFBSSxDQUFDcWQsVUFBTCxDQUFnQnJkLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBNUIsRUFBcUMsT0FBckMsQ0FBdkI7QUFDSixVQUFJdGQsSUFBSSxDQUFDOEssS0FBTCxDQUFXcXNDLFlBQVgsQ0FBd0IsTUFBeEIsQ0FBSixFQUNJbjNDLElBQUksQ0FBQzQzQyxXQUFMLENBQWlCaHVDLElBQWpCLEdBQXdCMUQsTUFBTSxDQUFDbEcsSUFBSSxDQUFDOEssS0FBTCxDQUFXcXNDLFlBQVgsQ0FBd0IsTUFBeEIsQ0FBRCxDQUE5QjtBQUNKbjNDLFVBQUksQ0FBQzhLLEtBQUwsQ0FBV2xMLElBQVgsR0FBa0IsUUFBbEI7QUFDQSxVQUFJSSxJQUFJLENBQUNpaUMsUUFBTCxLQUFrQjFiLFNBQXRCLEVBQ0l2bUIsSUFBSSxDQUFDaWlDLFFBQUwsQ0FBY3JpQyxJQUFkLEdBQXFCLFFBQXJCOztBQUNKLFVBQUk7QUFDQSxZQUFJSSxJQUFJLENBQUM4SyxLQUFMLENBQVd3N0IsVUFBZixFQUNJdG1DLElBQUksQ0FBQzhLLEtBQUwsQ0FBV3c3QixVQUFYLENBQXNCME0sWUFBdEIsQ0FBbUNoekMsSUFBSSxDQUFDNDNDLFdBQXhDLEVBQXFENTNDLElBQUksQ0FBQzhLLEtBQUwsQ0FBV21vQyxXQUFoRTtBQUNQLE9BSEQsQ0FJQSxPQUFPcEssRUFBUCxFQUFXLENBQUc7O0FBQ2QxdkMsVUFBSSxDQUFDNkcsSUFBSSxDQUFDNDNDLFdBQU4sRUFBbUIsUUFBbkIsRUFBNkIsVUFBVXh3QyxDQUFWLEVBQWE7QUFDMUNwSCxZQUFJLENBQUNtakMsT0FBTCxDQUFhNEQsY0FBYyxDQUFDMy9CLENBQUQsQ0FBZCxDQUFrQnROLEtBQS9CLEVBQXNDLEtBQXRDLEVBQTZDa0csSUFBSSxDQUFDcS9DLGVBQWxEO0FBQ0F0UixvQkFBWSxDQUFDLFVBQUQsQ0FBWjtBQUNBQSxvQkFBWSxDQUFDLFNBQUQsQ0FBWjtBQUNILE9BSkcsQ0FBSjtBQUtIOztBQUNELGFBQVNuQixNQUFULENBQWdCeGxDLENBQWhCLEVBQW1CO0FBQ2YsVUFBSXBILElBQUksQ0FBQ290QyxNQUFMLEtBQWdCLElBQXBCLEVBQ0ksT0FBT3B0QyxJQUFJLENBQUNxc0MsS0FBTCxFQUFQO0FBQ0pyc0MsVUFBSSxDQUFDMHNDLElBQUwsQ0FBVXRsQyxDQUFWO0FBQ0g7O0FBQ0QsYUFBUzJtQyxZQUFULENBQXNCdGpDLEtBQXRCLEVBQTZCck0sSUFBN0IsRUFBbUM7QUFDL0I7QUFDQSxVQUFJNEIsSUFBSSxDQUFDK29DLE1BQUwsS0FBZ0J4aUIsU0FBcEIsRUFDSTtBQUNKLFVBQUlnNUIsS0FBSyxHQUFHdi9DLElBQUksQ0FBQytvQyxNQUFMLENBQVl0K0IsS0FBWixDQUFaOztBQUNBLFVBQUk4MEMsS0FBSyxLQUFLaDVCLFNBQVYsSUFBdUJnNUIsS0FBSyxDQUFDbDlDLE1BQU4sR0FBZSxDQUExQyxFQUE2QztBQUN6QyxhQUFLLElBQUk1SSxDQUFDLEdBQUcsQ0FBYixFQUFnQjhsRCxLQUFLLENBQUM5bEQsQ0FBRCxDQUFMLElBQVlBLENBQUMsR0FBRzhsRCxLQUFLLENBQUNsOUMsTUFBdEMsRUFBOEM1SSxDQUFDLEVBQS9DO0FBQ0k4bEQsZUFBSyxDQUFDOWxELENBQUQsQ0FBTCxDQUFTdUcsSUFBSSxDQUFDK2QsYUFBZCxFQUE2Qi9kLElBQUksQ0FBQzhLLEtBQUwsQ0FBV2hSLEtBQXhDLEVBQStDa0csSUFBL0MsRUFBcUQ1QixJQUFyRDtBQURKO0FBRUg7O0FBQ0QsVUFBSXFNLEtBQUssS0FBSyxVQUFkLEVBQTBCO0FBQ3RCekssWUFBSSxDQUFDOEssS0FBTCxDQUFXb25DLGFBQVgsQ0FBeUJELFdBQVcsQ0FBQyxRQUFELENBQXBDLEVBRHNCLENBRXRCOztBQUNBanlDLFlBQUksQ0FBQzhLLEtBQUwsQ0FBV29uQyxhQUFYLENBQXlCRCxXQUFXLENBQUMsT0FBRCxDQUFwQztBQUNIO0FBQ0o7O0FBQ0QsYUFBU0EsV0FBVCxDQUFxQmgzQyxJQUFyQixFQUEyQjtBQUN2QixVQUFJbU0sQ0FBQyxHQUFHRixRQUFRLENBQUMrcUMsV0FBVCxDQUFxQixPQUFyQixDQUFSO0FBQ0E3cUMsT0FBQyxDQUFDbzRDLFNBQUYsQ0FBWXZrRCxJQUFaLEVBQWtCLElBQWxCLEVBQXdCLElBQXhCO0FBQ0EsYUFBT21NLENBQVA7QUFDSDs7QUFDRCxhQUFTb3NDLGNBQVQsQ0FBd0JudkMsSUFBeEIsRUFBOEI7QUFDMUIsV0FBSyxJQUFJNUssQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIxYixNQUF2QyxFQUErQzVJLENBQUMsRUFBaEQsRUFBb0Q7QUFDaEQsWUFBSWl4QyxZQUFZLENBQUMxcUMsSUFBSSxDQUFDK2QsYUFBTCxDQUFtQnRrQixDQUFuQixDQUFELEVBQXdCNEssSUFBeEIsQ0FBWixLQUE4QyxDQUFsRCxFQUNJLE9BQU8sS0FBSzVLLENBQVo7QUFDUDs7QUFDRCxhQUFPLEtBQVA7QUFDSDs7QUFDRCxhQUFTaTZDLGFBQVQsQ0FBdUJydkMsSUFBdkIsRUFBNkI7QUFDekIsVUFBSXJFLElBQUksQ0FBQytvQyxNQUFMLENBQVl0RixJQUFaLEtBQXFCLE9BQXJCLElBQWdDempDLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIxYixNQUFuQixHQUE0QixDQUFoRSxFQUNJLE9BQU8sS0FBUDtBQUNKLGFBQVFxb0MsWUFBWSxDQUFDcm1DLElBQUQsRUFBT3JFLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBUCxDQUFaLElBQTZDLENBQTdDLElBQ0oyc0IsWUFBWSxDQUFDcm1DLElBQUQsRUFBT3JFLElBQUksQ0FBQytkLGFBQUwsQ0FBbUIsQ0FBbkIsQ0FBUCxDQUFaLElBQTZDLENBRGpEO0FBRUg7O0FBQ0QsYUFBUys0Qiw0QkFBVCxHQUF3QztBQUNwQyxVQUFJOTJDLElBQUksQ0FBQytvQyxNQUFMLENBQVloc0IsVUFBWixJQUEwQi9jLElBQUksQ0FBQ21wQyxRQUEvQixJQUEyQyxDQUFDbnBDLElBQUksQ0FBQ2t4QyxRQUFyRCxFQUNJO0FBQ0pseEMsVUFBSSxDQUFDdzJDLFlBQUwsQ0FBa0IvTCxPQUFsQixDQUEwQixVQUFVMEwsV0FBVixFQUF1QjE4QyxDQUF2QixFQUEwQjtBQUNoRCxZQUFJa3FCLENBQUMsR0FBRyxJQUFJL2QsSUFBSixDQUFTNUYsSUFBSSxDQUFDa3RDLFdBQWQsRUFBMkJsdEMsSUFBSSxDQUFDaXRDLFlBQWhDLEVBQThDLENBQTlDLENBQVI7QUFDQXRwQixTQUFDLENBQUM4akIsUUFBRixDQUFXem5DLElBQUksQ0FBQ2l0QyxZQUFMLEdBQW9CeHpDLENBQS9COztBQUNBLFlBQUl1RyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZbkUsVUFBWixHQUF5QixDQUF6QixJQUNBNWtDLElBQUksQ0FBQytvQyxNQUFMLENBQVlyRixpQkFBWixLQUFrQyxRQUR0QyxFQUNnRDtBQUM1QzFqQyxjQUFJLENBQUN5MkMsYUFBTCxDQUFtQmg5QyxDQUFuQixFQUFzQnVzQyxXQUF0QixHQUNJbUIsVUFBVSxDQUFDeGpCLENBQUMsQ0FBQ21HLFFBQUYsRUFBRCxFQUFlOXBCLElBQUksQ0FBQytvQyxNQUFMLENBQVlwRSxxQkFBM0IsRUFBa0Qza0MsSUFBSSxDQUFDaXBDLElBQXZELENBQVYsR0FBeUUsR0FEN0U7QUFFSCxTQUpELE1BS0s7QUFDRGpwQyxjQUFJLENBQUN5MUMsdUJBQUwsQ0FBNkIzN0MsS0FBN0IsR0FBcUM2cEIsQ0FBQyxDQUFDbUcsUUFBRixHQUFhMWxCLFFBQWIsRUFBckM7QUFDSDs7QUFDRCt4QyxtQkFBVyxDQUFDcjhDLEtBQVosR0FBb0I2cEIsQ0FBQyxDQUFDMEYsV0FBRixHQUFnQmpsQixRQUFoQixFQUFwQjtBQUNILE9BWkQ7QUFhQXBFLFVBQUksQ0FBQ3czQyxtQkFBTCxHQUNJeDNDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixLQUF3QmdKLFNBQXhCLEtBQ0t2bUIsSUFBSSxDQUFDa3RDLFdBQUwsS0FBcUJsdEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXhyQixPQUFaLENBQW9COEwsV0FBcEIsRUFBckIsR0FDS3JwQixJQUFJLENBQUNpdEMsWUFBTCxJQUFxQmp0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZeHJCLE9BQVosQ0FBb0J1TSxRQUFwQixFQUQxQixHQUVLOXBCLElBQUksQ0FBQ2t0QyxXQUFMLEdBQW1CbHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl4ckIsT0FBWixDQUFvQjhMLFdBQXBCLEVBSDdCLENBREo7QUFLQXJwQixVQUFJLENBQUN5M0MsbUJBQUwsR0FDSXozQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosS0FBd0JpSixTQUF4QixLQUNLdm1CLElBQUksQ0FBQ2t0QyxXQUFMLEtBQXFCbHRDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6ckIsT0FBWixDQUFvQitMLFdBQXBCLEVBQXJCLEdBQ0tycEIsSUFBSSxDQUFDaXRDLFlBQUwsR0FBb0IsQ0FBcEIsR0FBd0JqdEMsSUFBSSxDQUFDK29DLE1BQUwsQ0FBWXpyQixPQUFaLENBQW9Cd00sUUFBcEIsRUFEN0IsR0FFSzlwQixJQUFJLENBQUNrdEMsV0FBTCxHQUFtQmx0QyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZenJCLE9BQVosQ0FBb0IrTCxXQUFwQixFQUg3QixDQURKO0FBS0g7O0FBQ0QsYUFBU28yQixVQUFULENBQW9CN2hDLE1BQXBCLEVBQTRCO0FBQ3hCLGFBQU81ZCxJQUFJLENBQUMrZCxhQUFMLENBQ0Z1ckIsR0FERSxDQUNFLFVBQVVvVyxJQUFWLEVBQWdCO0FBQUUsZUFBTzEvQyxJQUFJLENBQUNxZCxVQUFMLENBQWdCcWlDLElBQWhCLEVBQXNCOWhDLE1BQXRCLENBQVA7QUFBdUMsT0FEM0QsRUFFRnpJLE1BRkUsQ0FFSyxVQUFVd08sQ0FBVixFQUFhbHFCLENBQWIsRUFBZ0I4dkMsR0FBaEIsRUFBcUI7QUFDN0IsZUFBT3ZwQyxJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUFyQixJQUNIempDLElBQUksQ0FBQytvQyxNQUFMLENBQVl6eUIsVUFEVCxJQUVIaXpCLEdBQUcsQ0FBQ3JoQixPQUFKLENBQVl2RSxDQUFaLE1BQW1CbHFCLENBRnZCO0FBR0gsT0FOTSxFQU9GK3VCLElBUEUsQ0FPR3hvQixJQUFJLENBQUMrb0MsTUFBTCxDQUFZdEYsSUFBWixLQUFxQixPQUFyQixHQUNKempDLElBQUksQ0FBQytvQyxNQUFMLENBQVlyRyxXQURSLEdBRUoxaUMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVXJxQixjQVRULENBQVA7QUFVSDtBQUNEO0FBQ1I7QUFDQTs7O0FBQ1EsYUFBU2d2QixXQUFULENBQXFCNkMsYUFBckIsRUFBb0M7QUFDaEMsVUFBSUEsYUFBYSxLQUFLLEtBQUssQ0FBM0IsRUFBOEI7QUFBRUEscUJBQWEsR0FBRyxJQUFoQjtBQUF1Qjs7QUFDdkQsVUFBSXp3QyxJQUFJLENBQUM0M0MsV0FBTCxLQUFxQnJ4QixTQUFyQixJQUFrQ3ZtQixJQUFJLENBQUNxL0MsZUFBM0MsRUFBNEQ7QUFDeERyL0MsWUFBSSxDQUFDNDNDLFdBQUwsQ0FBaUI5OUMsS0FBakIsR0FDSWtHLElBQUksQ0FBQzJ0QyxxQkFBTCxLQUErQnBuQixTQUEvQixHQUNNdm1CLElBQUksQ0FBQ3FkLFVBQUwsQ0FBZ0JyZCxJQUFJLENBQUMydEMscUJBQXJCLEVBQTRDM3RDLElBQUksQ0FBQ3EvQyxlQUFqRCxDQUROLEdBRU0sRUFIVjtBQUlIOztBQUNEci9DLFVBQUksQ0FBQzhLLEtBQUwsQ0FBV2hSLEtBQVgsR0FBbUIybEQsVUFBVSxDQUFDei9DLElBQUksQ0FBQytvQyxNQUFMLENBQVkvckIsVUFBYixDQUE3Qjs7QUFDQSxVQUFJaGQsSUFBSSxDQUFDaWlDLFFBQUwsS0FBa0IxYixTQUF0QixFQUFpQztBQUM3QnZtQixZQUFJLENBQUNpaUMsUUFBTCxDQUFjbm9DLEtBQWQsR0FBc0IybEQsVUFBVSxDQUFDei9DLElBQUksQ0FBQytvQyxNQUFMLENBQVkvRyxTQUFiLENBQWhDO0FBQ0g7O0FBQ0QsVUFBSXlPLGFBQWEsS0FBSyxLQUF0QixFQUNJMUMsWUFBWSxDQUFDLGVBQUQsQ0FBWjtBQUNQOztBQUNELGFBQVNvRCxlQUFULENBQXlCL3BDLENBQXpCLEVBQTRCO0FBQ3hCLFVBQUlncEMsV0FBVyxHQUFHckosY0FBYyxDQUFDMy9CLENBQUQsQ0FBaEM7QUFDQSxVQUFJdTRDLFdBQVcsR0FBRzMvQyxJQUFJLENBQUN1MkMsWUFBTCxDQUFrQnhFLFFBQWxCLENBQTJCM0IsV0FBM0IsQ0FBbEI7QUFDQSxVQUFJd1AsV0FBVyxHQUFHNS9DLElBQUksQ0FBQzAyQyxZQUFMLENBQWtCM0UsUUFBbEIsQ0FBMkIzQixXQUEzQixDQUFsQjs7QUFDQSxVQUFJdVAsV0FBVyxJQUFJQyxXQUFuQixFQUFnQztBQUM1QjFULG1CQUFXLENBQUN5VCxXQUFXLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBcEIsQ0FBWDtBQUNILE9BRkQsTUFHSyxJQUFJMy9DLElBQUksQ0FBQ3cyQyxZQUFMLENBQWtCdHVCLE9BQWxCLENBQTBCa29CLFdBQTFCLEtBQTBDLENBQTlDLEVBQWlEO0FBQ2xEQSxtQkFBVyxDQUFDNzdCLE1BQVo7QUFDSCxPQUZJLE1BR0EsSUFBSTY3QixXQUFXLENBQUN4SyxTQUFaLENBQXNCbU0sUUFBdEIsQ0FBK0IsU0FBL0IsQ0FBSixFQUErQztBQUNoRC94QyxZQUFJLENBQUNtc0MsVUFBTCxDQUFnQm5zQyxJQUFJLENBQUNrdEMsV0FBTCxHQUFtQixDQUFuQztBQUNILE9BRkksTUFHQSxJQUFJa0QsV0FBVyxDQUFDeEssU0FBWixDQUFzQm1NLFFBQXRCLENBQStCLFdBQS9CLENBQUosRUFBaUQ7QUFDbEQveEMsWUFBSSxDQUFDbXNDLFVBQUwsQ0FBZ0Juc0MsSUFBSSxDQUFDa3RDLFdBQUwsR0FBbUIsQ0FBbkM7QUFDSDtBQUNKOztBQUNELGFBQVM4QixXQUFULENBQXFCNW5DLENBQXJCLEVBQXdCO0FBQ3BCQSxPQUFDLENBQUNneUMsY0FBRjtBQUNBLFVBQUl5RyxTQUFTLEdBQUd6NEMsQ0FBQyxDQUFDeEgsSUFBRixLQUFXLFNBQTNCO0FBQUEsVUFBc0N3d0MsV0FBVyxHQUFHckosY0FBYyxDQUFDMy9CLENBQUQsQ0FBbEU7QUFBQSxVQUF1RTBELEtBQUssR0FBR3NsQyxXQUEvRTs7QUFDQSxVQUFJcHdDLElBQUksQ0FBQ2dmLElBQUwsS0FBY3VILFNBQWQsSUFBMkI2cEIsV0FBVyxLQUFLcHdDLElBQUksQ0FBQ2dmLElBQXBELEVBQTBEO0FBQ3REaGYsWUFBSSxDQUFDZ2YsSUFBTCxDQUFVZ25CLFdBQVYsR0FDSWhtQyxJQUFJLENBQUNpcEMsSUFBTCxDQUFVanFCLElBQVYsQ0FBZWltQixHQUFHLENBQUNqbEMsSUFBSSxDQUFDZ2YsSUFBTCxDQUFVZ25CLFdBQVYsS0FBMEJobUMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixDQUEzQixDQUFsQixDQURKO0FBRUg7O0FBQ0QsVUFBSXRWLEdBQUcsR0FBR2dTLFVBQVUsQ0FBQzVRLEtBQUssQ0FBQ3FzQyxZQUFOLENBQW1CLEtBQW5CLENBQUQsQ0FBcEI7QUFBQSxVQUFpRHh0QyxHQUFHLEdBQUcrUixVQUFVLENBQUM1USxLQUFLLENBQUNxc0MsWUFBTixDQUFtQixLQUFuQixDQUFELENBQWpFO0FBQUEsVUFBOEZ2dEMsSUFBSSxHQUFHOFIsVUFBVSxDQUFDNVEsS0FBSyxDQUFDcXNDLFlBQU4sQ0FBbUIsTUFBbkIsQ0FBRCxDQUEvRztBQUFBLFVBQTZJMkksUUFBUSxHQUFHejZDLFFBQVEsQ0FBQ3lGLEtBQUssQ0FBQ2hSLEtBQVAsRUFBYyxFQUFkLENBQWhLO0FBQUEsVUFBbUx1MkMsS0FBSyxHQUFHanBDLENBQUMsQ0FBQ2lwQyxLQUFGLEtBQ3RMd1AsU0FBUyxHQUFJejRDLENBQUMsQ0FBQzI0QyxLQUFGLEtBQVksRUFBWixHQUFpQixDQUFqQixHQUFxQixDQUFDLENBQTFCLEdBQStCLENBRDhJLENBQTNMO0FBRUEsVUFBSXZnRCxRQUFRLEdBQUdzZ0QsUUFBUSxHQUFHbDJDLElBQUksR0FBR3ltQyxLQUFqQzs7QUFDQSxVQUFJLE9BQU92bEMsS0FBSyxDQUFDaFIsS0FBYixLQUF1QixXQUF2QixJQUFzQ2dSLEtBQUssQ0FBQ2hSLEtBQU4sQ0FBWXVJLE1BQVosS0FBdUIsQ0FBakUsRUFBb0U7QUFDaEUsWUFBSTI5QyxVQUFVLEdBQUdsMUMsS0FBSyxLQUFLOUssSUFBSSxDQUFDc3ZDLFdBQWhDO0FBQUEsWUFBNkMyUSxZQUFZLEdBQUduMUMsS0FBSyxLQUFLOUssSUFBSSxDQUFDdXZDLGFBQTNFOztBQUNBLFlBQUkvdkMsUUFBUSxHQUFHa0ssR0FBZixFQUFvQjtBQUNoQmxLLGtCQUFRLEdBQ0ptSyxHQUFHLEdBQ0NuSyxRQURKLEdBRUl5bEMsR0FBRyxDQUFDLENBQUMrYSxVQUFGLENBRlAsSUFHSy9hLEdBQUcsQ0FBQythLFVBQUQsQ0FBSCxJQUFtQi9hLEdBQUcsQ0FBQyxDQUFDamxDLElBQUksQ0FBQ2dmLElBQVAsQ0FIM0IsQ0FESjtBQUtBLGNBQUlpaEMsWUFBSixFQUNJbk8saUJBQWlCLENBQUN2ckIsU0FBRCxFQUFZLENBQUMsQ0FBYixFQUFnQnZtQixJQUFJLENBQUNzdkMsV0FBckIsQ0FBakI7QUFDUCxTQVJELE1BU0ssSUFBSTl2QyxRQUFRLEdBQUdtSyxHQUFmLEVBQW9CO0FBQ3JCbkssa0JBQVEsR0FDSnNMLEtBQUssS0FBSzlLLElBQUksQ0FBQ3N2QyxXQUFmLEdBQTZCOXZDLFFBQVEsR0FBR21LLEdBQVgsR0FBaUJzN0IsR0FBRyxDQUFDLENBQUNqbEMsSUFBSSxDQUFDZ2YsSUFBUCxDQUFqRCxHQUFnRXRWLEdBRHBFO0FBRUEsY0FBSXUyQyxZQUFKLEVBQ0luTyxpQkFBaUIsQ0FBQ3ZyQixTQUFELEVBQVksQ0FBWixFQUFldm1CLElBQUksQ0FBQ3N2QyxXQUFwQixDQUFqQjtBQUNQOztBQUNELFlBQUl0dkMsSUFBSSxDQUFDZ2YsSUFBTCxJQUNBZ2hDLFVBREEsS0FFQ3AyQyxJQUFJLEtBQUssQ0FBVCxHQUNLcEssUUFBUSxHQUFHc2dELFFBQVgsS0FBd0IsRUFEN0IsR0FFS2wvQyxJQUFJLENBQUNncEIsR0FBTCxDQUFTcHFCLFFBQVEsR0FBR3NnRCxRQUFwQixJQUFnQ2wyQyxJQUp0QyxDQUFKLEVBSWlEO0FBQzdDNUosY0FBSSxDQUFDZ2YsSUFBTCxDQUFVZ25CLFdBQVYsR0FDSWhtQyxJQUFJLENBQUNpcEMsSUFBTCxDQUFVanFCLElBQVYsQ0FBZWltQixHQUFHLENBQUNqbEMsSUFBSSxDQUFDZ2YsSUFBTCxDQUFVZ25CLFdBQVYsS0FBMEJobUMsSUFBSSxDQUFDaXBDLElBQUwsQ0FBVWpxQixJQUFWLENBQWUsQ0FBZixDQUEzQixDQUFsQixDQURKO0FBRUg7O0FBQ0RsVSxhQUFLLENBQUNoUixLQUFOLEdBQWM2dkIsR0FBRyxDQUFDbnFCLFFBQUQsQ0FBakI7QUFDSDtBQUNKOztBQUNEMnRDLFFBQUk7QUFDSixXQUFPbnRDLElBQVA7QUFDSDtBQUNEOzs7QUFDQSxXQUFTa2dELFVBQVQsQ0FBb0JDLFFBQXBCLEVBQThCcFgsTUFBOUIsRUFBc0M7QUFDbEM7QUFDQSxRQUFJcVgsS0FBSyxHQUFHamhELEtBQUssQ0FBQ2dsQixTQUFOLENBQWdCc00sS0FBaEIsQ0FDUGhOLElBRE8sQ0FDRjA4QixRQURFLEVBRVBockMsTUFGTyxDQUVBLFVBQVUrVCxDQUFWLEVBQWE7QUFBRSxhQUFPQSxDQUFDLFlBQVltM0IsV0FBcEI7QUFBa0MsS0FGakQsQ0FBWjtBQUdBLFFBQUlDLFNBQVMsR0FBRyxFQUFoQjs7QUFDQSxTQUFLLElBQUk3bUQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJtRCxLQUFLLENBQUMvOUMsTUFBMUIsRUFBa0M1SSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25DLFVBQUl5c0MsSUFBSSxHQUFHa2EsS0FBSyxDQUFDM21ELENBQUQsQ0FBaEI7O0FBQ0EsVUFBSTtBQUNBLFlBQUl5c0MsSUFBSSxDQUFDaVIsWUFBTCxDQUFrQixjQUFsQixNQUFzQyxJQUExQyxFQUNJOztBQUNKLFlBQUlqUixJQUFJLENBQUNnYSxVQUFMLEtBQW9CMzVCLFNBQXhCLEVBQW1DO0FBQy9CMmYsY0FBSSxDQUFDZ2EsVUFBTCxDQUFnQjNULE9BQWhCOztBQUNBckcsY0FBSSxDQUFDZ2EsVUFBTCxHQUFrQjM1QixTQUFsQjtBQUNIOztBQUNEMmYsWUFBSSxDQUFDZ2EsVUFBTCxHQUFrQjVVLGlCQUFpQixDQUFDcEYsSUFBRCxFQUFPNkMsTUFBTSxJQUFJLEVBQWpCLENBQW5DO0FBQ0F1WCxpQkFBUyxDQUFDOVAsSUFBVixDQUFldEssSUFBSSxDQUFDZ2EsVUFBcEI7QUFDSCxPQVRELENBVUEsT0FBTzk0QyxDQUFQLEVBQVU7QUFDTjFILGVBQU8sQ0FBQ21MLEtBQVIsQ0FBY3pELENBQWQ7QUFDSDtBQUNKOztBQUNELFdBQU9rNUMsU0FBUyxDQUFDaitDLE1BQVYsS0FBcUIsQ0FBckIsR0FBeUJpK0MsU0FBUyxDQUFDLENBQUQsQ0FBbEMsR0FBd0NBLFNBQS9DO0FBQ0g7QUFDRDs7O0FBQ0EsTUFBSSxPQUFPRCxXQUFQLEtBQXVCLFdBQXZCLElBQ0EsT0FBT0UsY0FBUCxLQUEwQixXQUQxQixJQUVBLE9BQU9DLFFBQVAsS0FBb0IsV0FGeEIsRUFFcUM7QUFDakM7QUFDQUQsa0JBQWMsQ0FBQ3A4QixTQUFmLENBQXlCbEgsU0FBekIsR0FBcUN1akMsUUFBUSxDQUFDcjhCLFNBQVQsQ0FBbUJsSCxTQUFuQixHQUErQixVQUFVOHJCLE1BQVYsRUFBa0I7QUFDbEYsYUFBT21YLFVBQVUsQ0FBQyxJQUFELEVBQU9uWCxNQUFQLENBQWpCO0FBQ0gsS0FGRDs7QUFHQXNYLGVBQVcsQ0FBQ2w4QixTQUFaLENBQXNCbEgsU0FBdEIsR0FBa0MsVUFBVThyQixNQUFWLEVBQWtCO0FBQ2hELGFBQU9tWCxVQUFVLENBQUMsQ0FBQyxJQUFELENBQUQsRUFBU25YLE1BQVQsQ0FBakI7QUFDSCxLQUZEO0FBR0g7QUFDRDs7O0FBQ0EsTUFBSTlyQixTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFVd2pDLFFBQVYsRUFBb0IxWCxNQUFwQixFQUE0QjtBQUN4QyxRQUFJLE9BQU8wWCxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQzlCLGFBQU9QLFVBQVUsQ0FBQ3Y0QyxNQUFNLENBQUNULFFBQVAsQ0FBZ0J3cEMsZ0JBQWhCLENBQWlDK1AsUUFBakMsQ0FBRCxFQUE2QzFYLE1BQTdDLENBQWpCO0FBQ0gsS0FGRCxNQUdLLElBQUkwWCxRQUFRLFlBQVlDLElBQXhCLEVBQThCO0FBQy9CLGFBQU9SLFVBQVUsQ0FBQyxDQUFDTyxRQUFELENBQUQsRUFBYTFYLE1BQWIsQ0FBakI7QUFDSCxLQUZJLE1BR0E7QUFDRCxhQUFPbVgsVUFBVSxDQUFDTyxRQUFELEVBQVcxWCxNQUFYLENBQWpCO0FBQ0g7QUFDSixHQVZEO0FBV0E7OztBQUNBOXJCLFdBQVMsQ0FBQ3d1QixhQUFWLEdBQTBCLEVBQTFCO0FBQ0F4dUIsV0FBUyxDQUFDNCtCLEtBQVYsR0FBa0I7QUFDZGxxQixNQUFFLEVBQUV1UCxPQUFRLENBQUMsRUFBRCxFQUFLNEQsT0FBTCxDQURFO0FBRWRnWCxXQUFPLEVBQUU1YSxPQUFRLENBQUMsRUFBRCxFQUFLNEQsT0FBTDtBQUZILEdBQWxCOztBQUlBN25CLFdBQVMsQ0FBQzBqQyxRQUFWLEdBQXFCLFVBQVUxWCxJQUFWLEVBQWdCO0FBQ2pDaHNCLGFBQVMsQ0FBQzQrQixLQUFWLENBQWdCQyxPQUFoQixHQUEwQjVhLE9BQVEsQ0FBQ0EsT0FBUSxDQUFDLEVBQUQsRUFBS2prQixTQUFTLENBQUM0K0IsS0FBVixDQUFnQkMsT0FBckIsQ0FBVCxFQUF3QzdTLElBQXhDLENBQWxDO0FBQ0gsR0FGRDs7QUFHQWhzQixXQUFTLENBQUMyakMsV0FBVixHQUF3QixVQUFVN1gsTUFBVixFQUFrQjtBQUN0QzlyQixhQUFTLENBQUN3dUIsYUFBVixHQUEwQnZLLE9BQVEsQ0FBQ0EsT0FBUSxDQUFDLEVBQUQsRUFBS2prQixTQUFTLENBQUN3dUIsYUFBZixDQUFULEVBQXdDMUMsTUFBeEMsQ0FBbEM7QUFDSCxHQUZEOztBQUdBOXJCLFdBQVMsQ0FBQ3hDLFNBQVYsR0FBc0IrdUIsZ0JBQWdCLENBQUMsRUFBRCxDQUF0QztBQUNBdnNCLFdBQVMsQ0FBQ0ksVUFBVixHQUF1QnVyQixtQkFBbUIsQ0FBQyxFQUFELENBQTFDO0FBQ0EzckIsV0FBUyxDQUFDeXRCLFlBQVYsR0FBeUJBLFlBQXpCO0FBQ0E7O0FBQ0EsTUFBSSxPQUFPbVcsTUFBUCxLQUFrQixXQUFsQixJQUFpQyxPQUFPQSxNQUFNLENBQUM3bkQsRUFBZCxLQUFxQixXQUExRCxFQUF1RTtBQUNuRTZuRCxVQUFNLENBQUM3bkQsRUFBUCxDQUFVaWtCLFNBQVYsR0FBc0IsVUFBVThyQixNQUFWLEVBQWtCO0FBQ3BDLGFBQU9tWCxVQUFVLENBQUMsSUFBRCxFQUFPblgsTUFBUCxDQUFqQjtBQUNILEtBRkQ7QUFHSCxHQWpsRmdCLENBa2xGakI7OztBQUNBbmpDLE1BQUksQ0FBQ3VlLFNBQUwsQ0FBZTI4QixPQUFmLEdBQXlCLFVBQVV0UyxJQUFWLEVBQWdCO0FBQ3JDLFdBQU8sSUFBSTVvQyxJQUFKLENBQVMsS0FBS3lqQixXQUFMLEVBQVQsRUFBNkIsS0FBS1MsUUFBTCxFQUE3QixFQUE4QyxLQUFLQyxPQUFMLE1BQWtCLE9BQU95a0IsSUFBUCxLQUFnQixRQUFoQixHQUEyQm5wQyxRQUFRLENBQUNtcEMsSUFBRCxFQUFPLEVBQVAsQ0FBbkMsR0FBZ0RBLElBQWxFLENBQTlDLENBQVA7QUFDSCxHQUZEOztBQUdBLE1BQUksT0FBTzdtQyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0FBQy9CQSxVQUFNLENBQUNzVixTQUFQLEdBQW1CQSxTQUFuQjtBQUNIOztBQUVELFNBQU9BLFNBQVA7QUFFSCxDQWhtRkEsQ0FBRCxDOzs7Ozs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSThqQyxHQUFHLEdBQUksWUFBVztBQUNsQixNQUFJQyxlQUFlLEdBQUcseUNBQXRCO0FBQ0EsTUFBSUMsd0JBQXdCLEdBQUcsc0RBQS9CO0FBQ0EsTUFBSUMsd0JBQXdCLEdBQUcsMkRBQS9CO0FBQ0EsTUFBSUMsNEJBQUosQ0FKa0IsQ0FJZ0I7O0FBRWxDLFdBQVNDLG9CQUFULENBQThCbEQsS0FBOUIsRUFBcUM7QUFDakMsUUFBSW1ELEtBQUssR0FBR25ELEtBQUssQ0FBQ0wsUUFBTixJQUFrQkssS0FBSyxDQUFDbUQsS0FBeEIsSUFBaUMsRUFBN0M7QUFDQSxRQUFJQyxPQUFPLEdBQUcsRUFBZDs7QUFDQSxTQUFLLElBQUk3bkQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRuRCxLQUFLLENBQUNoL0MsTUFBMUIsRUFBa0M1SSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25DO0FBQ0EsVUFBSThuRCxZQUFZLEdBQUdDLDJCQUEyQixDQUFDSCxLQUFLLENBQUM1bkQsQ0FBRCxDQUFMLENBQVM4bkQsWUFBVixDQUE5Qzs7QUFDQSxVQUFJLENBQUNELE9BQU8sQ0FBQ0MsWUFBRCxDQUFaLEVBQTRCO0FBQ3hCRCxlQUFPLENBQUNDLFlBQUQsQ0FBUCxHQUF3QixFQUF4QjtBQUNIOztBQUNERCxhQUFPLENBQUNDLFlBQUQsQ0FBUCxDQUFzQi9RLElBQXRCLENBQTJCO0FBQ3ZCME4sYUFBSyxFQUFFQSxLQURnQjtBQUV2Qmo4QyxhQUFLLEVBQUV4SSxDQUZnQjtBQUd2QjAwQyxhQUFLLEVBQUVrVCxLQUFLLENBQUM1bkQsQ0FBRCxDQUFMLENBQVMwMEM7QUFITyxPQUEzQjtBQUtIOztBQUNELFdBQU9tVCxPQUFQO0FBQ0g7O0FBRUQsV0FBU0csUUFBVCxDQUFrQnZELEtBQWxCLEVBQXlCdUMsUUFBekIsRUFBbUM7QUFDL0IsUUFBSVksS0FBSyxHQUFHbkQsS0FBSyxDQUFDTCxRQUFOLElBQWtCSyxLQUFLLENBQUNtRCxLQUF4QixJQUFpQyxFQUE3QztBQUNBLFFBQUlDLE9BQU8sR0FBRyxFQUFkLENBRitCLENBRy9COztBQUNBYixZQUFRLEdBQUdBLFFBQVEsQ0FBQ2p2QixXQUFULEVBQVg7O0FBQ0EsU0FBSyxJQUFJLzNCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0bkQsS0FBSyxDQUFDaC9DLE1BQTFCLEVBQWtDNUksQ0FBQyxFQUFuQyxFQUF1QztBQUNuQyxVQUFJOG5ELFlBQVksR0FBR0YsS0FBSyxDQUFDNW5ELENBQUQsQ0FBTCxDQUFTOG5ELFlBQTVCLENBRG1DLENBRW5DOztBQUNBLFVBQUlBLFlBQVksS0FBS0EsWUFBWSxJQUFJZCxRQUFoQixJQUE0QmMsWUFBWSxJQUFJRyxjQUFjLENBQUNqQixRQUFELENBQTFELElBQXdFYyxZQUFZLElBQUlJLGtCQUFrQixDQUFDbEIsUUFBRCxDQUEvRyxDQUFoQixFQUE0STtBQUN4SWEsZUFBTyxDQUFDOVEsSUFBUixDQUFhO0FBQ1QwTixlQUFLLEVBQUVBLEtBREU7QUFFVGo4QyxlQUFLLEVBQUV4SSxDQUZFO0FBR1QwMEMsZUFBSyxFQUFFa1QsS0FBSyxDQUFDNW5ELENBQUQsQ0FBTCxDQUFTMDBDO0FBSFAsU0FBYjtBQUtIO0FBQ0o7O0FBQ0QsV0FBT21ULE9BQVA7QUFDSDs7QUFFRCxXQUFTTSxPQUFULENBQWlCMUQsS0FBakIsRUFBd0J1QyxRQUF4QixFQUFrQztBQUM5QixRQUFJWSxLQUFLLEdBQUduRCxLQUFLLENBQUNMLFFBQU4sSUFBa0JLLEtBQUssQ0FBQ21ELEtBQXhCLElBQWlDLEVBQTdDO0FBQ0EsUUFBSXAvQyxLQUFLLEdBQUdvL0MsS0FBSyxDQUFDaC9DLE1BQWxCO0FBQ0EsUUFBSXcvQyxpQkFBaUIsR0FBR0Msb0JBQW9CLENBQUM1RCxLQUFELEVBQVF1QyxRQUFSLEVBQWtCWSxLQUFsQixFQUF5QnAvQyxLQUF6QixDQUE1Qzs7QUFFQSxRQUFJLENBQUM0L0MsaUJBQUwsRUFBd0I7QUFDcEJFLG9CQUFjLENBQUM3RCxLQUFELEVBQVF1QyxRQUFSLEVBQWtCeCtDLEtBQWxCLENBQWQ7QUFDSDs7QUFFRCxXQUFPO0FBQ0hpOEMsV0FBSyxFQUFFQSxLQURKO0FBRUhqOEMsV0FBSyxFQUFFQSxLQUZKO0FBR0hrc0MsV0FBSyxFQUFFa1QsS0FBSyxDQUFDcC9DLEtBQUQsQ0FBTCxDQUFha3NDO0FBSGpCLEtBQVA7QUFLSDs7QUFBQTs7QUFFRCxXQUFTNFQsY0FBVCxDQUF3QjdELEtBQXhCLEVBQStCdUMsUUFBL0IsRUFBeUN4K0MsS0FBekMsRUFBZ0Q7QUFDNUMsUUFBSWk4QyxLQUFLLENBQUNILFVBQVYsRUFBc0I7QUFDbEJHLFdBQUssQ0FBQ0gsVUFBTixDQUFpQjBDLFFBQVEsR0FBRyxNQUE1QixFQUFvQ3grQyxLQUFwQztBQUNILEtBRkQsTUFFTztBQUNIaThDLFdBQUssQ0FBQzBELE9BQU4sQ0FBY25CLFFBQWQsRUFBd0IsSUFBeEIsRUFBOEJ4K0MsS0FBOUI7QUFDSDtBQUNKLEdBakVpQixDQW1FbEI7OztBQUNBLFdBQVM2L0Msb0JBQVQsQ0FBOEI1RCxLQUE5QixFQUFxQ3VDLFFBQXJDLEVBQStDWSxLQUEvQyxFQUFzRHAvQyxLQUF0RCxFQUE2RDtBQUN6RCxRQUFJKy9DLG1CQUFKO0FBQ0EsUUFBSUMsbUJBQUo7O0FBRUEsUUFBSWhCLHdCQUF3QixDQUFDbjhCLElBQXpCLENBQThCMjdCLFFBQTlCLENBQUosRUFBNkM7QUFDekN1Qix5QkFBbUIsR0FBR3ZCLFFBQXRCO0FBQ0F3Qix5QkFBbUIsR0FBR0MsMkJBQTJCLENBQUN6QixRQUFELENBQWpEO0FBQ0gsS0FIRCxNQUdPLElBQUlTLHdCQUF3QixDQUFDcDhCLElBQXpCLENBQThCMjdCLFFBQTlCLENBQUosRUFBNkM7QUFDaER1Qix5QkFBbUIsR0FBR1IsMkJBQTJCLENBQUNmLFFBQUQsQ0FBakQ7QUFDQXdCLHlCQUFtQixHQUFHeEIsUUFBdEI7QUFDSCxLQUhNLE1BR0E7QUFDSCxhQUFPLEtBQVAsQ0FERyxDQUNXO0FBQ2pCOztBQUVELFFBQUksQ0FBQ1UsNEJBQUwsRUFBbUM7QUFDL0I7QUFDQVksb0JBQWMsQ0FBQzdELEtBQUQsRUFBUThELG1CQUFSLEVBQTZCLy9DLEtBQTdCLENBQWQ7O0FBQ0EsVUFBSW8vQyxLQUFLLENBQUNoL0MsTUFBTixJQUFnQkosS0FBcEIsRUFBMkI7QUFDdkJrL0Msb0NBQTRCLEdBQUcsSUFBL0I7QUFDSDtBQUNKOztBQUNELFFBQUlBLDRCQUFKLEVBQWtDO0FBQzlCWSxvQkFBYyxDQUFDN0QsS0FBRCxFQUFRK0QsbUJBQVIsRUFBNkJoZ0QsS0FBN0IsQ0FBZDtBQUNIOztBQUVELFdBQU8sSUFBUDtBQUNIOztBQUVELFdBQVN1L0MsMkJBQVQsQ0FBcUNmLFFBQXJDLEVBQStDO0FBQzNDLFdBQU9BLFFBQVEsQ0FBQ24xQixPQUFULENBQWlCNDFCLHdCQUFqQixFQUEyQyxVQUFVbjBDLEtBQVYsRUFBaUJvMUMsU0FBakIsRUFBNEJDLFNBQTVCLEVBQXVDQyxTQUF2QyxFQUFrRDtBQUNoRyxhQUFPRixTQUFTLEdBQUcsSUFBWixHQUFtQkUsU0FBMUI7QUFDSCxLQUZNLENBQVA7QUFHSDs7QUFFRCxXQUFTSCwyQkFBVCxDQUFxQ3pCLFFBQXJDLEVBQStDO0FBQzNDLFdBQU9BLFFBQVEsQ0FBQ24xQixPQUFULENBQWlCMjFCLHdCQUFqQixFQUEyQyxVQUFTbDBDLEtBQVQsRUFBZ0JvMUMsU0FBaEIsRUFBMkJDLFNBQTNCLEVBQXNDO0FBQ3BGLGFBQU8sTUFBTUEsU0FBYjtBQUNILEtBRk0sQ0FBUDtBQUdIOztBQUVELFdBQVNFLFVBQVQsQ0FBb0J0RCxJQUFwQixFQUEwQjtBQUN0QixRQUFJZCxLQUFLLEdBQUdjLElBQUksQ0FBQ2QsS0FBakI7O0FBQ0EsUUFBSUEsS0FBSyxDQUFDcUUsVUFBVixFQUFzQjtBQUNsQnJFLFdBQUssQ0FBQ3FFLFVBQU4sQ0FBaUJ2RCxJQUFJLENBQUMvOEMsS0FBdEI7QUFDSCxLQUZELE1BRU8sSUFBSWk4QyxLQUFLLENBQUNvRSxVQUFWLEVBQXNCO0FBQ3pCcEUsV0FBSyxDQUFDb0UsVUFBTixDQUFpQnRELElBQUksQ0FBQy84QyxLQUF0QjtBQUNIO0FBQ0o7O0FBRUQsV0FBU3VnRCxNQUFULENBQWdCQyxJQUFoQixFQUFzQkMsR0FBdEIsRUFBMkI7QUFDdkIsU0FBSyxJQUFJL29ELEdBQVQsSUFBZ0Irb0QsR0FBaEIsRUFBcUI7QUFDakIsVUFBSSxDQUFDQSxHQUFHLENBQUNuZ0QsY0FBSixDQUFtQjVJLEdBQW5CLENBQUwsRUFDSTtBQUNKOG9ELFVBQUksQ0FBQzlvRCxHQUFELENBQUosR0FBWStvRCxHQUFHLENBQUMvb0QsR0FBRCxDQUFmO0FBQ0g7O0FBQ0QsV0FBTzhvRCxJQUFQO0FBQ0g7O0FBRUQsV0FBU0UsZUFBVCxDQUF5QnRCLEtBQXpCLEVBQWdDO0FBQzVCLFFBQUl1QixTQUFTLEdBQUcsRUFBaEI7O0FBQ0EsU0FBSyxJQUFJbnBELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0bkQsS0FBSyxDQUFDaC9DLE1BQTFCLEVBQWtDNUksQ0FBQyxFQUFuQyxFQUF1QztBQUNuQytvRCxZQUFNLENBQUNJLFNBQUQsRUFBWUMsa0JBQWtCLENBQUN4QixLQUFLLENBQUM1bkQsQ0FBRCxDQUFMLENBQVMwMEMsS0FBVixDQUE5QixDQUFOO0FBQ0g7O0FBQ0QsV0FBT3lVLFNBQVA7QUFDSDs7QUFFRCxXQUFTQyxrQkFBVCxDQUE0QjFVLEtBQTVCLEVBQW1DO0FBQy9CLFFBQUkyVSxRQUFRLEdBQUcsRUFBZjs7QUFDQSxTQUFLLElBQUlycEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzAwQyxLQUFLLENBQUM5ckMsTUFBMUIsRUFBa0M1SSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25DcXBELGNBQVEsQ0FBQzNVLEtBQUssQ0FBQzEwQyxDQUFELENBQU4sQ0FBUixHQUFxQjAwQyxLQUFLLENBQUM0VSxXQUFXLENBQUM1VSxLQUFLLENBQUMxMEMsQ0FBRCxDQUFOLENBQVosQ0FBMUI7QUFDSDs7QUFDRCxXQUFPcXBELFFBQVA7QUFDSCxHQTVJaUIsQ0E4SWxCO0FBQ0E7OztBQUNBLFdBQVNwQixjQUFULENBQXdCakIsUUFBeEIsRUFBa0M7QUFDOUIsUUFBSXVDLElBQUksR0FBRyxFQUFYO0FBQ0EsUUFBSUMsU0FBUyxHQUFHLENBQWhCOztBQUVBLFdBQU8sQ0FBQ2wyQyxLQUFLLEdBQUdpMEMsZUFBZSxDQUFDbDhCLElBQWhCLENBQXFCMjdCLFFBQXJCLENBQVQsS0FBNEMsSUFBbkQsRUFBeUQ7QUFDckQsVUFBSTF6QyxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWEsRUFBakIsRUFDSTtBQUNKaTJDLFVBQUksSUFBSXZDLFFBQVEsQ0FBQ3gzQixTQUFULENBQW1CZzZCLFNBQW5CLEVBQThCbDJDLEtBQUssQ0FBQzlLLEtBQXBDLENBQVI7QUFDQStnRCxVQUFJLElBQUl2QyxRQUFRLENBQUNoMUIsTUFBVCxDQUFnQjFlLEtBQUssQ0FBQzlLLEtBQU4sR0FBYzhLLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzFLLE1BQXZDLEVBQStDMEssS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTMUssTUFBeEQsQ0FBUjtBQUNBMmdELFVBQUksSUFBSXZDLFFBQVEsQ0FBQ2gxQixNQUFULENBQWdCMWUsS0FBSyxDQUFDOUssS0FBdEIsRUFBNkI4SyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVMxSyxNQUF0QyxDQUFSO0FBQ0E0Z0QsZUFBUyxHQUFHbDJDLEtBQUssQ0FBQzlLLEtBQU4sR0FBYzhLLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBUzFLLE1BQW5DO0FBQ0g7O0FBQ0QyZ0QsUUFBSSxJQUFJdkMsUUFBUSxDQUFDaDFCLE1BQVQsQ0FBZ0J3M0IsU0FBaEIsQ0FBUjtBQUVBLFdBQU9ELElBQVA7QUFDSDs7QUFBQSxHQS9KaUIsQ0FpS2xCOztBQUNBLFdBQVNyQixrQkFBVCxDQUE0QmxCLFFBQTVCLEVBQXNDO0FBQ2xDLFFBQUlRLHdCQUF3QixDQUFDbjhCLElBQXpCLENBQThCMjdCLFFBQTlCLENBQUosRUFBNkM7QUFDekMsYUFBT3lCLDJCQUEyQixDQUFDekIsUUFBRCxDQUFsQztBQUNIOztBQUNELFdBQU9BLFFBQVA7QUFDSDs7QUFFRCxXQUFTeUMsa0JBQVQsQ0FBNEJsRSxJQUE1QixFQUFrQ21FLFVBQWxDLEVBQThDO0FBQzFDLFNBQUssSUFBSXhwRCxHQUFULElBQWdCd3BELFVBQWhCLEVBQTRCO0FBQ3hCLFVBQUlycEQsS0FBSyxHQUFHcXBELFVBQVUsQ0FBQ3hwRCxHQUFELENBQXRCO0FBQ0EsVUFBSXlwRCxjQUFjLEdBQUd0cEQsS0FBSyxDQUFDb3VCLE9BQU4sQ0FBYyxhQUFkLENBQXJCLENBRndCLENBSXhCOztBQUNBODJCLFVBQUksQ0FBQzdRLEtBQUwsQ0FBV1MsY0FBWCxDQUEwQmoxQyxHQUExQjs7QUFDQSxVQUFJeXBELGNBQWMsR0FBRyxDQUFyQixFQUF3QjtBQUNwQnBFLFlBQUksQ0FBQzdRLEtBQUwsQ0FBV2tWLFdBQVgsQ0FBdUIxcEQsR0FBdkIsRUFBNEJHLEtBQUssQ0FBQzJ4QixNQUFOLENBQWEsQ0FBYixFQUFnQjIzQixjQUFoQixDQUE1QixFQUE2RCxXQUE3RDtBQUNILE9BRkQsTUFFTztBQUNIcEUsWUFBSSxDQUFDN1EsS0FBTCxDQUFXa1YsV0FBWCxDQUF1QjFwRCxHQUF2QixFQUE0QkcsS0FBNUI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsV0FBU2lwRCxXQUFULENBQXFCcjhCLEdBQXJCLEVBQTBCO0FBQ3RCLFdBQU9BLEdBQUcsQ0FBQzRFLE9BQUosQ0FBWSxXQUFaLEVBQXlCLFVBQVV2ZSxLQUFWLEVBQWlCdTJDLFFBQWpCLEVBQTJCO0FBQ3ZELGFBQU9BLFFBQVEsQ0FBQ2h5QixXQUFULEVBQVA7QUFDSCxLQUZNLENBQVA7QUFHSDs7QUFFRCxXQUFTaXlCLGdDQUFULENBQTBDQyxRQUExQyxFQUFvRDtBQUNoRCxRQUFJQyxRQUFRLEdBQUcsRUFBZjs7QUFDQSxTQUFLLElBQUk5cEQsR0FBVCxJQUFnQjZwRCxRQUFoQixFQUEwQjtBQUN0QkMsY0FBUSxDQUFDQyxXQUFXLENBQUMvcEQsR0FBRCxDQUFaLENBQVIsR0FBNkI2cEQsUUFBUSxDQUFDN3BELEdBQUQsQ0FBckM7QUFDSDs7QUFDRCxXQUFPOHBELFFBQVA7QUFDSDs7QUFFRCxXQUFTQyxXQUFULENBQXFCaDlCLEdBQXJCLEVBQTBCO0FBQ3RCLFdBQU9BLEdBQUcsQ0FBQzRFLE9BQUosQ0FBWSxVQUFaLEVBQXdCLFVBQVN2ZSxLQUFULEVBQWdCdTJDLFFBQWhCLEVBQTBCO0FBQ3JELGFBQU8sTUFBTUEsUUFBUSxDQUFDOXhCLFdBQVQsRUFBYjtBQUNILEtBRk0sQ0FBUDtBQUdIOztBQUVELE1BQUlteUIsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBUzc4QyxHQUFULEVBQWM7QUFDcEIsU0FBS0EsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsU0FBS3MzQyxJQUFMLEdBQVksS0FBS3QzQyxHQUFMLENBQVNzM0MsSUFBVCxJQUFpQixLQUFLdDNDLEdBQUwsQ0FBU3N2QyxvQkFBVCxDQUE4QixNQUE5QixFQUFzQyxDQUF0QyxDQUE3QjtBQUNBLFNBQUt3TixNQUFMLEdBQWMsS0FBSzk4QyxHQUFMLENBQVNtM0MsV0FBVCxJQUF3QixFQUF0QztBQUNILEdBSkQ7O0FBTUEwRixLQUFHLENBQUN4L0IsU0FBSixHQUFnQjtBQUNaO0FBQ0FocUIsT0FBRyxFQUFFLGFBQVNzbUQsUUFBVCxFQUFtQjtBQUNwQixVQUFJLENBQUMsS0FBS29ELFlBQVYsRUFBd0I7QUFDcEIsZUFBTyxFQUFQO0FBQ0g7O0FBQ0QsVUFBSXBELFFBQUosRUFBYztBQUNWLGVBQU9rQyxlQUFlLENBQUNsQixRQUFRLENBQUMsS0FBS29DLFlBQU4sRUFBb0JwRCxRQUFwQixDQUFULENBQXRCO0FBQ0g7O0FBQ0QsVUFBSVksS0FBSyxHQUFHRCxvQkFBb0IsQ0FBQyxLQUFLeUMsWUFBTixDQUFoQzs7QUFDQSxXQUFLcEQsUUFBTCxJQUFpQlksS0FBakIsRUFBd0I7QUFDcEJBLGFBQUssQ0FBQ1osUUFBRCxDQUFMLEdBQWtCa0MsZUFBZSxDQUFDdEIsS0FBSyxDQUFDWixRQUFELENBQU4sQ0FBakM7QUFDSDs7QUFDRCxhQUFPWSxLQUFQO0FBQ0gsS0FkVztBQWVaO0FBQ0F5QyxVQUFNLEVBQUUsZ0JBQVNyRCxRQUFULEVBQW1CO0FBQ3ZCLFVBQUkwQyxVQUFVLEdBQUcsRUFBakI7O0FBQ0EsV0FBSyxJQUFJMXBELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS21xRCxNQUFMLENBQVl2aEQsTUFBaEMsRUFBd0M1SSxDQUFDLEVBQXpDLEVBQTZDO0FBQ3pDK29ELGNBQU0sQ0FBQ1csVUFBRCxFQUFhUixlQUFlLENBQUNsQixRQUFRLENBQUMsS0FBS21DLE1BQUwsQ0FBWW5xRCxDQUFaLENBQUQsRUFBaUJnbkQsUUFBakIsQ0FBVCxDQUE1QixDQUFOO0FBQ0g7O0FBQ0QsYUFBTzBDLFVBQVA7QUFDSCxLQXRCVztBQXVCWjtBQUNBNW9ELE9BQUcsRUFBRSxhQUFTa21ELFFBQVQsRUFBbUIwQyxVQUFuQixFQUErQjtBQUNoQyxVQUFJLENBQUMsS0FBS1UsWUFBVixFQUF3QjtBQUNwQixhQUFLQSxZQUFMLEdBQW9CLEtBQUtFLFlBQUwsRUFBcEI7QUFDSDs7QUFDRFosZ0JBQVUsR0FBR0ksZ0NBQWdDLENBQUNKLFVBQUQsQ0FBN0M7QUFDQSxVQUFJOUIsS0FBSyxHQUFHSSxRQUFRLENBQUMsS0FBS29DLFlBQU4sRUFBb0JwRCxRQUFwQixDQUFwQjs7QUFDQSxVQUFJLENBQUNZLEtBQUssQ0FBQ2gvQyxNQUFYLEVBQW1CO0FBQ2ZnL0MsYUFBSyxHQUFHLENBQUNPLE9BQU8sQ0FBQyxLQUFLaUMsWUFBTixFQUFvQnBELFFBQXBCLENBQVIsQ0FBUjtBQUNIOztBQUNELFdBQUssSUFBSWhuRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNG5ELEtBQUssQ0FBQ2gvQyxNQUExQixFQUFrQzVJLENBQUMsRUFBbkMsRUFBdUM7QUFDbkN5cEQsMEJBQWtCLENBQUM3QixLQUFLLENBQUM1bkQsQ0FBRCxDQUFOLEVBQVcwcEQsVUFBWCxDQUFsQjtBQUNIO0FBQ0osS0FwQ1c7QUFxQ1o7QUFDQXJkLFVBQU0sRUFBRSxnQkFBUzJhLFFBQVQsRUFBbUI7QUFDdkIsVUFBSSxDQUFDLEtBQUtvRCxZQUFWLEVBQ0k7O0FBQ0osVUFBSSxDQUFDcEQsUUFBTCxFQUFlO0FBQ1gsYUFBS3VELFlBQUwsQ0FBa0IsS0FBS0gsWUFBdkI7O0FBQ0EsZUFBTyxLQUFLQSxZQUFaO0FBQ0E7QUFDSDs7QUFDRCxVQUFJeEMsS0FBSyxHQUFHSSxRQUFRLENBQUMsS0FBS29DLFlBQU4sRUFBb0JwRCxRQUFwQixDQUFwQjs7QUFDQSxXQUFLLElBQUlobkQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRuRCxLQUFLLENBQUNoL0MsTUFBMUIsRUFBa0M1SSxDQUFDLEVBQW5DLEVBQXVDO0FBQ25DNm9ELGtCQUFVLENBQUNqQixLQUFLLENBQUM1bkQsQ0FBRCxDQUFOLENBQVY7QUFDSDs7QUFDRCxhQUFPNG5ELEtBQUssQ0FBQ2gvQyxNQUFiO0FBQ0gsS0FuRFc7QUFvRFowaEQsZ0JBQVksRUFBRSx3QkFBVztBQUNyQixVQUFJRSxTQUFTLEdBQUcsS0FBS245QyxHQUFMLENBQVNpL0IsYUFBVCxDQUF1QixPQUF2QixDQUFoQjtBQUNBa2UsZUFBUyxDQUFDcmtELElBQVYsR0FBaUIsVUFBakI7QUFDQXFrRCxlQUFTLENBQUNDLEdBQVYsR0FBZ0IsWUFBaEI7QUFDQSxXQUFLOUYsSUFBTCxDQUFVdFgsV0FBVixDQUFzQm1kLFNBQXRCO0FBQ0EsYUFBT0EsU0FBUyxDQUFDL0YsS0FBakI7QUFDSCxLQTFEVztBQTJEWjhGLGdCQUFZLEVBQUUsc0JBQVM5RixLQUFULEVBQWdCO0FBQzFCLFVBQUloWSxJQUFJLEdBQUdnWSxLQUFLLENBQUNpRyxTQUFqQjtBQUNBamUsVUFBSSxDQUFDSSxVQUFMLENBQWdCRixXQUFoQixDQUE0QkYsSUFBNUI7QUFDSDtBQTlEVyxHQUFoQjtBQWlFQSxNQUFJcjJCLE9BQU8sR0FBRyxJQUFJOHpDLEdBQUosQ0FBUXo4QyxRQUFSLENBQWQ7O0FBQ0EySSxTQUFPLENBQUN1MEMsV0FBUixHQUFzQixVQUFTdDlDLEdBQVQsRUFBYztBQUNoQyxXQUFPLElBQUk2OEMsR0FBSixDQUFRNzhDLEdBQVIsQ0FBUDtBQUNILEdBRkQ7O0FBR0EsU0FBTytJLE9BQVA7QUFDSCxDQXhSUyxFQUFWOztBQTBSQSxTQUFpQzVTLE1BQU0sQ0FBQzRTLE9BQXhDLEtBQW9ENVMsTUFBTSxDQUFDNFMsT0FBUCxHQUFpQmt4QyxHQUFyRSxFLENBQTJFLG1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtJQUNNaCtCLFU7Ozs7Ozs7O0FBQ0o7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7eUJBRUl0aUIsTSxFQUNBb0osSyxFQUtBO0FBQUEsVUFKQUUsaUJBSUEsdUVBSm9CLEdBSXBCO0FBQUEsVUFIQUMsZ0JBR0EsdUVBSG1CLEdBR25CO0FBQUEsVUFGQUMsa0JBRUEsdUVBRnFCLEtBRXJCO0FBQUEsVUFEQXVjLEtBQ0EsdUVBRFEsSUFDUjtBQUNBLFVBQU1DLE9BQU8sR0FBRzVjLEtBQUksQ0FBQ3hILE1BQXJCOztBQUNBLFVBQUksTUFBTW9rQixPQUFWLEVBQW1CO0FBQ2pCLFlBQUlELEtBQUosRUFBVyxPQUFPRSxHQUFQLENBQVgsQ0FDQTtBQURBLGFBR0UsTUFBTTtBQUNKenJCLGdCQUFJLEVBQUUsV0FERjtBQUVKMHJCLG1CQUFPO0FBRkgsV0FBTjtBQUlILE9BVkQsQ0FZQTs7O0FBQ0EsVUFBSUMsaUJBQWlCLEdBQUcsQ0FBeEI7QUFDQSxVQUFJQyxnQkFBZ0IsR0FBRyxDQUF2QjtBQUNBLFVBQUlDLFlBQVksR0FBRyxLQUFuQjs7QUFDQSxXQUFLLElBQUlydEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2d0QixPQUFwQixFQUE2QixFQUFFaHRCLENBQS9CLEVBQWtDO0FBQ2hDLFlBQU1pcUIsQ0FBQyxHQUFHN1osS0FBSSxDQUFDa2QsTUFBTCxDQUFZdHRCLENBQVosQ0FBVjs7QUFDQSxZQUFJaXFCLENBQUMsSUFBSSxHQUFMLElBQVlBLENBQUMsSUFBSSxHQUFyQixFQUEwQjtBQUN4QixjQUFJb0QsWUFBSixFQUFrQixFQUFFRCxnQkFBRixDQUFsQixLQUNLLEVBQUVELGlCQUFGO0FBQ04sU0FIRCxNQUdPLElBQUlsRCxDQUFDLElBQUksR0FBVCxFQUFjb0QsWUFBWSxHQUFHLElBQWY7QUFDdEI7O0FBRUQsVUFBSUUsR0FBRyxHQUFHakUsVUFBVSxDQUFDa0UsTUFBWCxDQUFrQnhtQixNQUFsQixFQUEwQm9tQixnQkFBMUIsQ0FBVjs7QUFDQSxVQUFJSyxLQUFLLEdBQUduRSxVQUFVLENBQUNvRSxZQUFYLENBQXdCSCxHQUF4QixDQUFaLENBekJBLENBMkJBOzs7QUFDQSxVQUFJSSxLQUFLLEdBQUdGLEtBQUssQ0FBQzdrQixNQUFsQjtBQUNBLFVBQUlnbEIsZ0JBQWdCLEdBQUcsQ0FBdkI7QUFDQSxVQUFJQyxlQUFlLEdBQUcsQ0FBdEI7QUFDQVIsa0JBQVksR0FBRyxLQUFmOztBQUNBLFdBQUssSUFBSXJ0QixFQUFDLEdBQUcsQ0FBYixFQUFnQkEsRUFBQyxHQUFHMnRCLEtBQXBCLEVBQTJCLEVBQUUzdEIsRUFBN0IsRUFBZ0M7QUFDOUIsWUFBSXl0QixLQUFLLENBQUN6dEIsRUFBRCxDQUFMLElBQVksR0FBaEIsRUFBcUJxdEIsWUFBWSxHQUFHLElBQWYsQ0FBckIsS0FDSztBQUNILGNBQUlBLFlBQUosRUFBa0IsRUFBRVEsZUFBRixDQUFsQixLQUNLLEVBQUVELGdCQUFGO0FBQ047QUFDRixPQXRDRCxDQXdDQTs7O0FBQ0EsVUFBSUEsZ0JBQWdCLEdBQUdULGlCQUF2QixFQUEwQztBQUN4QyxZQUFJSixLQUFKLEVBQVcsT0FBTy9sQixNQUFNLENBQUMyRCxRQUFQLEVBQVAsQ0FBWCxDQUNBO0FBREEsYUFHRSxNQUFNO0FBQ0puSixnQkFBSSxFQUFFLFdBREY7QUFFSjByQixtQkFBTztBQUZILFdBQU47QUFJSCxPQWpERCxDQW1EQTs7O0FBQ0EsVUFBSVcsZUFBZSxHQUFHVCxnQkFBdEIsRUFBd0M7QUFDdENHLFdBQUcsR0FBR2pFLFVBQVUsQ0FBQ2tFLE1BQVgsQ0FBa0JELEdBQWxCLEVBQXVCSCxnQkFBdkIsQ0FBTjtBQUNBSyxhQUFLLEdBQUduRSxVQUFVLENBQUNvRSxZQUFYLENBQXdCSCxHQUF4QixDQUFSO0FBQ0FJLGFBQUssR0FBR0YsS0FBSyxDQUFDN2tCLE1BQWQsQ0FIc0MsQ0FLdEM7O0FBQ0FnbEIsd0JBQWdCLEdBQUcsQ0FBbkI7QUFDQUMsdUJBQWUsR0FBRyxDQUFsQjtBQUNBUixvQkFBWSxHQUFHLEtBQWY7O0FBQ0EsYUFBSyxJQUFJcnRCLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUcydEIsS0FBcEIsRUFBMkIsRUFBRTN0QixHQUE3QixFQUFnQztBQUM5QixjQUFJeXRCLEtBQUssQ0FBQ3p0QixHQUFELENBQUwsSUFBWSxHQUFoQixFQUFxQnF0QixZQUFZLEdBQUcsSUFBZixDQUFyQixLQUNLO0FBQ0gsZ0JBQUlBLFlBQUosRUFBa0IsRUFBRVEsZUFBRixDQUFsQixLQUNLLEVBQUVELGdCQUFGO0FBQ047QUFDRixTQWZxQyxDQWlCdEM7OztBQUNBLFlBQUlBLGdCQUFnQixHQUFHVCxpQkFBdkIsRUFBMEM7QUFDeEMsY0FBSUosS0FBSixFQUFXLE9BQU8vbEIsTUFBTSxDQUFDMkQsUUFBUCxFQUFQLENBQVgsQ0FDQTtBQURBLGVBR0UsTUFBTTtBQUNKbkosa0JBQUksRUFBRSxXQURGO0FBRUowckIscUJBQU87QUFGSCxhQUFOO0FBSUg7QUFDRjs7QUFFRCxVQUFJYyxRQUFRLEdBQUcsR0FBZjtBQUFBLFVBQ0VDLFNBQVMsR0FBRyxHQURkO0FBRUEsVUFBSUMsS0FBSyxHQUFHLENBQVo7QUFBQSxVQUNFQyxNQUFNLEdBQUcsQ0FEWDtBQUFBLFVBRUVDLFFBQVEsR0FBRyxDQUZiO0FBR0EsVUFBSWhlLEtBQUksQ0FBQ2tkLE1BQUwsQ0FBWSxDQUFaLEtBQWtCLEdBQXRCLEVBQTJCVSxRQUFRLEdBQUcsR0FBWDtBQUUzQixVQUFNSyxRQUFRLEdBQUdMLFFBQWpCO0FBQ0EsVUFBTU0sVUFBVSxHQUFHaEYsVUFBVSxDQUFDaUYsUUFBWCxDQUFvQmhCLEdBQXBCLElBQTJCLENBQTlDO0FBQ0EsVUFBSWlCLFdBQVcsR0FBR2IsS0FBSyxHQUFHLENBQVIsSUFBYXZkLEtBQUksQ0FBQ3FlLE9BQUwsQ0FBYSxHQUFiLEtBQXFCLENBQXBEO0FBQ0EsVUFBSUMsU0FBUyxHQUFHLEtBQWhCO0FBQ0EsVUFBSUMsVUFBVSxHQUFHLEtBQWpCO0FBQ0EsVUFBSUMsUUFBUSxHQUFHLEtBQWY7QUFDQXZCLGtCQUFZLEdBQUcsS0FBZjtBQUVBLFVBQUl0ZixHQUFHLEdBQUcsSUFBSXJJLEtBQUosQ0FBVXNuQixPQUFWLENBQVY7O0FBRUEsV0FBSyxJQUFJNkIsT0FBTyxHQUFHLENBQW5CLEVBQXNCQSxPQUFPLEdBQUc3QixPQUFoQyxFQUF5QyxFQUFFNkIsT0FBM0MsRUFBb0Q7QUFDbEQsWUFBSTVFLEVBQUMsR0FBRzdaLEtBQUksQ0FBQ2tkLE1BQUwsQ0FBWXVCLE9BQVosQ0FBUjs7QUFDQSxnQkFBUTVFLEVBQVI7QUFDRSxlQUFLLEdBQUw7QUFDRSxjQUFFa0QsaUJBQUY7O0FBQ0EsZ0JBQUlBLGlCQUFpQixHQUFHUyxnQkFBcEIsSUFBd0NNLEtBQUssR0FBR1AsS0FBcEQsRUFBMkQ7QUFDekQ1ZixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjVixLQUFLLENBQUNTLEtBQUQsQ0FBbkI7QUFDQSxnQkFBRUEsS0FBRjtBQUNBUyx3QkFBVSxHQUFHLElBQWI7QUFDRCxhQUpELE1BSU87QUFDTDVnQixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDQU8sdUJBQVMsR0FBRyxJQUFaO0FBQ0Q7O0FBQ0QsY0FBRVAsTUFBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUNFLGNBQUVoQixpQkFBRjs7QUFDQSxnQkFBSUEsaUJBQWlCLEdBQUdTLGdCQUFwQixJQUF3Q00sS0FBSyxHQUFHUCxLQUFwRCxFQUEyRDtBQUN6RDVmLGlCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNWLEtBQUssQ0FBQ1MsS0FBRCxDQUFuQjtBQUNBLGdCQUFFQSxLQUFGO0FBQ0FTLHdCQUFVLEdBQUcsSUFBYjtBQUNELGFBSkQsTUFJTztBQUNMNWdCLGlCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQ0VkLFlBQVksSUFDWjdjLGtCQURBLElBRUE4WSxVQUFVLENBQUNpRixRQUFYLENBQW9CaEIsR0FBcEIsS0FBNEIsQ0FGNUIsR0FHSSxHQUhKLEdBSUlTLFFBTE47QUFNQSxrQkFBSSxDQUFDWCxZQUFMLEVBQW1CZSxRQUFRLEdBQUdTLE9BQVg7QUFDcEI7O0FBQ0QsY0FBRVYsTUFBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUNFLGdCQUFJTyxTQUFTLElBQUlSLEtBQUssR0FBRyxDQUF6QixFQUE0Qm5nQixHQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWM3ZCxpQkFBZCxDQUE1QixLQUNLO0FBQ0h2QyxpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjSCxRQUFkO0FBQ0Esa0JBQUksQ0FBQ1gsWUFBTCxFQUFtQmUsUUFBUSxHQUFHUyxPQUFYO0FBQ3BCO0FBQ0QsY0FBRVYsTUFBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUNFLGdCQUFJLENBQUNRLFVBQUQsSUFBZVYsU0FBUyxJQUFJLEdBQWhDLEVBQXFDO0FBQ25DLGtCQUFJSyxVQUFKLEVBQWdCTCxTQUFTLEdBQUcsR0FBWjtBQUNoQmxnQixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjSCxRQUFkO0FBQ0FJLHNCQUFRLEdBQUdmLFlBQVksR0FBRyxDQUFDLENBQUosR0FBUXdCLE9BQS9CO0FBQ0QsYUFKRCxNQUlPOWdCLEdBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY0csVUFBVSxHQUFHLEdBQUgsR0FBU04sUUFBakM7O0FBQ1AsY0FBRUcsTUFBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUNFLGdCQUFJLENBQUNRLFVBQUQsSUFBZVYsU0FBUyxJQUFJLEdBQWhDLEVBQXFDO0FBQ25DQSx1QkFBUyxHQUFHSyxVQUFVLEdBQUcsR0FBSCxHQUFTLEdBQS9CO0FBQ0F2Z0IsaUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBY0gsUUFBZDtBQUNBSSxzQkFBUSxHQUFHZixZQUFZLEdBQUcsQ0FBQyxDQUFKLEdBQVF3QixPQUEvQjtBQUNELGFBSkQsTUFJTzlnQixHQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNHLFVBQVUsR0FBRyxHQUFILEdBQVMsR0FBakM7O0FBQ1AsY0FBRUgsTUFBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUNFLGdCQUFJLENBQUNRLFVBQUQsSUFBZVYsU0FBUyxJQUFJLEdBQWhDLEVBQXFDO0FBQ25DQSx1QkFBUyxHQUFHLEdBQVo7QUFDQWxnQixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjSCxRQUFkO0FBQ0FJLHNCQUFRLEdBQUdmLFlBQVksR0FBRyxDQUFDLENBQUosR0FBUXdCLE9BQS9CO0FBQ0QsYUFKRCxNQUlPO0FBQ0w5Z0IsaUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0Q7O0FBQ0QsY0FBRUEsTUFBRjtBQUNBO0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBSyxHQUFMO0FBQ0UsZ0JBQUksQ0FBQ1EsVUFBRCxJQUFlVixTQUFTLElBQUksR0FBaEMsRUFBcUM7QUFDbkMsa0JBQUlLLFVBQUosRUFBZ0JMLFNBQVMsR0FBRyxHQUFaO0FBQ2hCbGdCLGlCQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNILFFBQWQ7QUFDQUksc0JBQVEsR0FBR2YsWUFBWSxHQUFHLENBQUMsQ0FBSixHQUFRd0IsT0FBL0I7QUFDRCxhQUpELE1BSU87QUFDTCxrQkFBSVAsVUFBSixFQUFnQjtBQUNkdmdCLG1CQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNELGVBRkQsTUFFTztBQUNMcGdCLG1CQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNkLFlBQVksR0FBRyxHQUFILEdBQVNXLFFBQW5DO0FBQ0Q7QUFDRjs7QUFDRCxjQUFFRyxNQUFGO0FBQ0E7O0FBRUYsZUFBSyxHQUFMO0FBQ0UsZ0JBQUlHLFVBQUosRUFBZ0I7QUFDZHZnQixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDRCxhQUZELE1BRU87QUFDTHBnQixpQkFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjZCxZQUFZLEdBQUcsR0FBSCxHQUFTVyxRQUFuQztBQUNEOztBQUNELGNBQUVHLE1BQUY7QUFDQTs7QUFFRixlQUFLLEdBQUw7QUFDRSxnQkFBSVUsT0FBTyxHQUFHN0IsT0FBTyxHQUFHLENBQXBCLElBQXlCNWMsS0FBSSxDQUFDa2QsTUFBTCxDQUFZdUIsT0FBTyxHQUFHLENBQXRCLEtBQTRCLEdBQXpELEVBQThEO0FBQzVELGtCQUFJUCxVQUFKLEVBQWdCO0FBQ2R2Z0IsbUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FwZ0IsbUJBQUcsQ0FBQ29nQixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCLEdBQWxCO0FBQ0QsZUFIRCxNQUdPO0FBQ0xwZ0IsbUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FwZ0IsbUJBQUcsQ0FBQ29nQixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCLEdBQWxCO0FBQ0Q7O0FBQ0RBLG9CQUFNLElBQUksQ0FBVjtBQUNBLGdCQUFFVSxPQUFGO0FBQ0QsYUFWRCxNQVVPO0FBQ0w5Z0IsaUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0EsZ0JBQUVBLE1BQUY7QUFDRDs7QUFDRDs7QUFDRixlQUFLLEdBQUw7QUFDRSxnQkFBSVUsT0FBTyxHQUFHN0IsT0FBTyxHQUFHLENBQXBCLElBQXlCNWMsS0FBSSxDQUFDa2QsTUFBTCxDQUFZdUIsT0FBTyxHQUFHLENBQXRCLEtBQTRCLEdBQXpELEVBQThEO0FBQzVELGtCQUFJUCxVQUFKLEVBQWdCO0FBQ2R2Z0IsbUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FwZ0IsbUJBQUcsQ0FBQ29nQixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCLEdBQWxCO0FBQ0QsZUFIRCxNQUdPO0FBQ0xwZ0IsbUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0FwZ0IsbUJBQUcsQ0FBQ29nQixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCLEdBQWxCO0FBQ0Q7O0FBQ0RBLG9CQUFNLElBQUksQ0FBVjtBQUNBLGdCQUFFVSxPQUFGO0FBQ0QsYUFWRCxNQVVPO0FBQ0w5Z0IsaUJBQUcsQ0FBQ29nQixNQUFELENBQUgsR0FBYyxHQUFkO0FBQ0EsZ0JBQUVBLE1BQUY7QUFDRDs7QUFDRDs7QUFFRixlQUFLLEdBQUw7QUFDRXBnQixlQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWMsR0FBZDtBQUNBLGNBQUVBLE1BQUY7QUFDQTs7QUFFRixlQUFLLEdBQUw7QUFDRXBnQixlQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNLLFdBQVcsR0FBR2plLGdCQUFILEdBQXNCeWQsUUFBL0M7QUFDQUEsb0JBQVEsR0FBRyxHQUFYO0FBQ0FYLHdCQUFZLEdBQUcsSUFBZjtBQUNBLGNBQUVhLEtBQUY7QUFDQSxjQUFFQyxNQUFGO0FBQ0E7O0FBRUYsZUFBSyxHQUFMO0FBQ0VwZ0IsZUFBRyxDQUFDb2dCLE1BQUQsQ0FBSCxHQUFjLEdBQWQ7QUFDQSxjQUFFQSxNQUFGO0FBQ0E7O0FBRUY7QUFDRXBnQixlQUFHLENBQUNvZ0IsTUFBRCxDQUFILEdBQWNsRSxFQUFkO0FBQ0EsY0FBRWtFLE1BQUY7QUFDQTtBQTVLSjtBQThLRDs7QUFFRCxVQUFJRixTQUFTLElBQUksR0FBakIsRUFBc0I7QUFDcEIsWUFBSUcsUUFBUSxHQUFHLENBQWYsRUFBa0JBLFFBQVEsR0FBR0QsTUFBWDs7QUFDbEIsZUFBT0MsUUFBUSxJQUFJcEIsT0FBbkI7QUFBNEIsWUFBRW9CLFFBQUY7QUFBNUI7O0FBQ0EsWUFBSXJnQixHQUFHLENBQUNxZ0IsUUFBRCxDQUFILElBQWlCQyxRQUFyQixFQUErQnRnQixHQUFHLENBQUNxZ0IsUUFBRCxDQUFILEdBQWdCSCxTQUFoQjtBQUNoQzs7QUFFRCxhQUFPbGdCLEdBQUcsQ0FBQ2doQixJQUFKLENBQVMsRUFBVCxDQUFQO0FBQ0Q7OzsyQkFFYS9uQixNLEVBQVFpb0IsUyxFQUFXQyxZLEVBQWM7QUFDN0MsVUFBSUEsWUFBSixFQUFrQkQsU0FBUyxHQUFHLENBQUNBLFNBQWI7QUFDbEIsVUFBSUUsUUFBUSxHQUFHLENBQUMsS0FBS25vQixNQUFOLEVBQWN3aEIsS0FBZCxDQUFvQixHQUFwQixDQUFmO0FBQ0EsYUFBTyxFQUNMMkcsUUFBUSxDQUFDLENBQUQsQ0FBUixHQUNBLEdBREEsSUFFQ0EsUUFBUSxDQUFDLENBQUQsQ0FBUixHQUFjLENBQUNBLFFBQVEsQ0FBQyxDQUFELENBQVQsR0FBZUYsU0FBN0IsR0FBeUNBLFNBRjFDLENBREssQ0FBUDtBQUtEOzs7MkJBRWFqb0IsTSxFQUFRaW9CLFMsRUFBVztBQUMvQixhQUFPM0YsVUFBVSxDQUFDMEYsTUFBWCxDQUNMN25CLElBQUksQ0FBQ2lvQixLQUFMLENBQVc5RixVQUFVLENBQUMwRixNQUFYLENBQWtCaG9CLE1BQWxCLEVBQTBCaW9CLFNBQTFCLEVBQXFDLEtBQXJDLENBQVgsQ0FESyxFQUVMQSxTQUZLLEVBR0wsSUFISyxDQUFQO0FBS0Q7OztpQ0FFbUJqb0IsTSxFQUFRO0FBQzFCLFVBQU1xb0IsTUFBTSxHQUFHL0YsVUFBVSxDQUFDaUYsUUFBWCxDQUFvQnZuQixNQUFwQixDQUFmOztBQUNBLFVBQUlzb0IsS0FBSyxHQUFHLEVBQVo7O0FBRUEsVUFBSUQsTUFBTSxLQUFLLENBQWYsRUFBa0I7QUFDaEIsWUFBSWhkLE1BQU0sR0FBR2dkLE1BQU0sR0FBRyxDQUFULGFBQWdCLENBQUMsQ0FBRCxHQUFLcm9CLE1BQU0sQ0FBQzJELFFBQVAsRUFBckIsSUFBMkMzRCxNQUFNLENBQUMyRCxRQUFQLEVBQXhEO0FBRUEsWUFBSTBILE1BQU0sQ0FBQ3pKLE1BQVAsR0FBZ0IsQ0FBaEIsSUFBcUJ5SixNQUFNLENBQUNpYixNQUFQLENBQWMsQ0FBZCxLQUFvQixHQUE3QyxFQUNFamIsTUFBTSxHQUFHQSxNQUFNLENBQUNtZCxTQUFQLENBQWlCLENBQWpCLENBQVQsQ0FKYyxDQU1oQjs7QUFDQUYsYUFBSyxHQUFHamQsTUFBTSxDQUFDbVcsS0FBUCxDQUFhLEVBQWIsQ0FBUjtBQUNEOztBQUVELGFBQU84RyxLQUFQO0FBQ0Q7QUFFRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7NkJBQ2tCRyxDLEVBQUc7QUFDakIsYUFBTyxDQUFDQSxDQUFDLEdBQUcsQ0FBTCxLQUFXQSxDQUFDLEdBQUcsQ0FBZixLQUFxQixDQUFDQSxDQUE3QjtBQUNEOzs7Ozs7ZUFHWW5HLFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1dmOzs7O0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7ZUFJZUEsbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNZ2QsYUFBYSxHQUFHLE9BQXRCO0FBQ0EsSUFBTUMsaUJBQWlCLEdBQUcsSUFBMUI7QUFDQSxJQUFNQyxlQUFlLEdBQUcsa0NBQXhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFNQyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFBeFosR0FBRyxFQUFJO0FBQ3pCLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDOEssV0FBSixFQUFQLElBQTRCOUssR0FBRyxJQUFJQSxHQUFHLENBQUM0SyxXQUFKLEVBQTFDO0FBQ0QsQ0FGRDtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLElBQU02TyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFBelosR0FBRyxFQUFJO0FBQ3pCLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDNEssV0FBSixFQUFQLElBQTRCNUssR0FBRyxJQUFJQSxHQUFHLENBQUM4SyxXQUFKLEVBQTFDO0FBQ0QsQ0FGRDs7QUFJQSxJQUFNNE8sZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFDNVosS0FBRCxFQUFRaGYsR0FBUixFQUFhL04sQ0FBYixFQUFnQml0QixHQUFoQixFQUF3QjtBQUMvQyxNQUFJLENBQUNGLEtBQUwsRUFBWTtBQUNWLFFBQU02OUIsSUFBSSxHQUFHMzlCLEdBQUcsQ0FBQ0ssTUFBSixDQUFXdHRCLENBQVgsQ0FBYjtBQUNBLFFBQU0wZSxHQUFHLEdBQUcxZSxDQUFDLEdBQUcsQ0FBaEI7QUFDQSxVQUFNO0FBQ0p3QixVQUFJLEVBQUUsaUJBREY7QUFFSjByQixhQUFPLCtEQUF1RHhPLEdBQXZELHlCQUF1RWtzQyxJQUF2RSxPQUZIO0FBR0psc0MsU0FBRyxFQUFIQSxHQUhJO0FBSUprc0MsVUFBSSxFQUFKQTtBQUpJLEtBQU47QUFNRCxHQVRELE1BU083OEMsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVMsR0FBVDtBQUNSLENBWEQ7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0lBQ01xbkIsVTs7Ozs7Ozs7QUFDSjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO3lCQUNjNEYsRyxFQUFLN2MsSyxFQUFvQjtBQUFBLFVBQWQyYyxLQUFjLHVFQUFOLElBQU07QUFDbkNFLFNBQUcsR0FBR3hnQixNQUFNLENBQUN3Z0IsR0FBRCxDQUFaO0FBQ0E3YyxXQUFJLEdBQUczRCxNQUFNLENBQUMyRCxLQUFELENBQWI7QUFDQSxVQUFNNGMsT0FBTyxHQUFHNWMsS0FBSSxDQUFDeEgsTUFBckI7QUFDQSxVQUFNaStCLE1BQU0sR0FBRzVaLEdBQUcsQ0FBQ3JrQixNQUFuQjs7QUFFQSxVQUFJaStCLE1BQU0sR0FBRzdaLE9BQWIsRUFBc0I7QUFDcEIsWUFBSUQsS0FBSixFQUFXLE9BQU9FLEdBQVAsQ0FBWCxDQUNBO0FBREEsYUFHRSxNQUFNO0FBQ0p6ckIsZ0JBQUksRUFBRSxxQkFERjtBQUVKMHJCLG1CQUFPO0FBRkgsV0FBTjtBQUlIOztBQUVELFVBQU1uZixHQUFHLEdBQUcsSUFBSXJJLEtBQUosQ0FBVXNuQixPQUFWLENBQVo7QUFDQSxVQUFJdE8sR0FBRyxHQUFHLENBQVYsQ0FqQm1DLENBaUJ2Qjs7QUFDWixVQUFJb29CLFFBQVEsR0FBRyxFQUFmOztBQUVBLFdBQUssSUFBSTltQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ3RCLE9BQXBCLEVBQTZCaHRCLENBQUMsRUFBOUIsRUFBa0M7QUFDaEM4bUMsZ0JBQVEsR0FBRzEyQixLQUFJLENBQUNrZCxNQUFMLENBQVl0dEIsQ0FBWixDQUFYOztBQUNBLGdCQUFROG1DLFFBQVI7QUFDRSxlQUFLLEdBQUw7QUFBVTtBQUNSLzRCLGVBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTMGUsR0FBRyxHQUFHbW9CLE1BQU4sR0FBZTVaLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFmLEdBQWlDLEdBQTFDO0FBQ0EsY0FBRUEsR0FBRjtBQUNBOztBQUVGLGVBQUssR0FBTDtBQUFVO0FBQ1IsZ0JBQUlBLEdBQUcsR0FBR21vQixNQUFWLEVBQWtCO0FBQ2hCLGtCQUFNZ2tCLElBQUksR0FBRzU5QixHQUFHLENBQUNLLE1BQUosQ0FBVzVPLEdBQVgsQ0FBYjtBQUNBLGtCQUFJZ29CLFdBQVcsQ0FBQ21rQixJQUFELENBQWYsRUFBdUI5OEMsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVM2cUQsSUFBVCxDQUF2QixLQUNLLElBQUlwa0IsV0FBVyxDQUFDb2tCLElBQUQsQ0FBZixFQUF1Qjk4QyxHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzZxRCxJQUFJLENBQUNoekIsV0FBTCxFQUFULENBQXZCLEtBQ0E4TyxnQkFBZ0IsQ0FBQzVaLEtBQUQsRUFBUWhmLEdBQVIsRUFBYS9OLENBQWIsRUFBZ0JpdEIsR0FBaEIsQ0FBaEI7QUFDTixhQUxELE1BS09sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUNQLGNBQUUwZSxHQUFGO0FBQ0E7O0FBRUYsZUFBSyxHQUFMO0FBQVU7QUFDUixnQkFBSUEsR0FBRyxHQUFHbW9CLE1BQVYsRUFBa0I7QUFDaEIsa0JBQU1na0IsS0FBSSxHQUFHNTlCLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFiOztBQUNBLGtCQUFJZ29CLFdBQVcsQ0FBQ21rQixLQUFELENBQVgsSUFBcUJwa0IsV0FBVyxDQUFDb2tCLEtBQUQsQ0FBcEMsRUFBNEM5OEMsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVM2cUQsS0FBVCxDQUE1QyxLQUNLbGtCLGdCQUFnQixDQUFDNVosS0FBRCxFQUFRaGYsR0FBUixFQUFhL04sQ0FBYixFQUFnQml0QixHQUFoQixDQUFoQjtBQUNOLGFBSkQsTUFJT2xmLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTLEdBQVQ7O0FBQ1AsY0FBRTBlLEdBQUY7QUFDQTs7QUFDRixlQUFLLEdBQUw7QUFBVTtBQUNSLGdCQUFJQSxHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQixrQkFBTWdrQixNQUFJLEdBQUc1OUIsR0FBRyxDQUFDSyxNQUFKLENBQVc1TyxHQUFYLENBQWI7O0FBQ0Esa0JBQUk0bkIsYUFBYSxDQUFDdlcsSUFBZCxDQUFtQjg2QixNQUFuQixDQUFKLEVBQThCOThDLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTNnFELE1BQVQsQ0FBOUIsS0FDS2xrQixnQkFBZ0IsQ0FBQzVaLEtBQUQsRUFBUWhmLEdBQVIsRUFBYS9OLENBQWIsRUFBZ0JpdEIsR0FBaEIsQ0FBaEI7QUFDTixhQUpELE1BSU9sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUNQLGNBQUUwZSxHQUFGO0FBQ0E7O0FBQ0YsZUFBSyxHQUFMO0FBQVU7QUFDUixnQkFBSUEsR0FBRyxHQUFHbW9CLE1BQVYsRUFBa0I7QUFDaEIsa0JBQU1na0IsTUFBSSxHQUFHNTlCLEdBQUcsQ0FBQ0ssTUFBSixDQUFXNU8sR0FBWCxDQUFiOztBQUNBLGtCQUFJZ29CLFdBQVcsQ0FBQ21rQixNQUFELENBQVgsSUFBcUJ2a0IsYUFBYSxDQUFDdlcsSUFBZCxDQUFtQjg2QixNQUFuQixDQUF6QixFQUFtRDk4QyxHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzZxRCxNQUFULENBQW5ELEtBQ0ssSUFBSXBrQixXQUFXLENBQUNva0IsTUFBRCxDQUFmLEVBQXVCOThDLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTNnFELE1BQUksQ0FBQ2h6QixXQUFMLEVBQVQsQ0FBdkIsS0FDQThPLGdCQUFnQixDQUFDNVosS0FBRCxFQUFRaGYsR0FBUixFQUFhL04sQ0FBYixFQUFnQml0QixHQUFoQixDQUFoQjtBQUNOLGFBTEQsTUFLT2xmLEdBQUcsQ0FBQy9OLENBQUQsQ0FBSCxHQUFTLEdBQVQ7O0FBQ1AsY0FBRTBlLEdBQUY7QUFDQTs7QUFDRixlQUFLLEdBQUw7QUFBVTtBQUNSLGdCQUFJQSxHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQixrQkFBTWdrQixNQUFJLEdBQUc1OUIsR0FBRyxDQUFDSyxNQUFKLENBQVc1TyxHQUFYLENBQWI7O0FBQ0Esa0JBQ0Vnb0IsV0FBVyxDQUFDbWtCLE1BQUQsQ0FBWCxJQUNBcGtCLFdBQVcsQ0FBQ29rQixNQUFELENBRFgsSUFFQXZrQixhQUFhLENBQUN2VyxJQUFkLENBQW1CODZCLE1BQW5CLENBSEYsRUFLRTk4QyxHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzZxRCxNQUFULENBTEYsS0FNS2xrQixnQkFBZ0IsQ0FBQzVaLEtBQUQsRUFBUWhmLEdBQVIsRUFBYS9OLENBQWIsRUFBZ0JpdEIsR0FBaEIsQ0FBaEI7QUFDTixhQVRELE1BU09sZixHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUyxHQUFUOztBQUNQLGNBQUUwZSxHQUFGO0FBQ0E7QUFFQTs7QUFDRixlQUFLLEdBQUw7QUFBVTtBQUNSLGdCQUFJQSxHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQixrQkFBTWdrQixNQUFJLEdBQUc1OUIsR0FBRyxDQUFDSyxNQUFKLENBQVc1TyxHQUFYLENBQWI7O0FBQ0Esa0JBQUkrbkIsV0FBVyxDQUFDb2tCLE1BQUQsQ0FBZixFQUF1Qjk4QyxHQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzZxRCxNQUFJLENBQUNoekIsV0FBTCxFQUFULENBQXZCLEtBQ0ssSUFDSDZPLFdBQVcsQ0FBQ21rQixNQUFELENBQVgsSUFDQXZrQixhQUFhLENBQUN2VyxJQUFkLENBQW1CODZCLE1BQW5CLENBREEsSUFFQXRrQixpQkFBaUIsQ0FBQ3hXLElBQWxCLENBQXVCODZCLE1BQXZCLENBRkEsSUFHQXJrQixlQUFlLENBQUMvWCxPQUFoQixDQUF3Qm84QixNQUF4QixJQUFnQyxDQUFDLENBSjlCLEVBTUg5OEMsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVM2cUQsTUFBVCxDQU5HLEtBT0Fsa0IsZ0JBQWdCLENBQUM1WixLQUFELEVBQVFoZixHQUFSLEVBQWEvTixDQUFiLEVBQWdCaXRCLEdBQWhCLENBQWhCO0FBQ04sYUFYRCxNQVdPbGYsR0FBRyxDQUFDL04sQ0FBRCxDQUFILEdBQVMsR0FBVDs7QUFDUCxjQUFFMGUsR0FBRjtBQUNBOztBQUNGO0FBQ0UzUSxlQUFHLENBQUMvTixDQUFELENBQUgsR0FBUzhtQyxRQUFUO0FBQ0E7QUF6RUo7QUEyRUQ7O0FBRUQsVUFBSXBvQixHQUFHLEdBQUdtb0IsTUFBVixFQUFrQjtBQUNoQixZQUFJLENBQUM5WixLQUFMLEVBQVk7QUFDVixnQkFBTTtBQUFFdnJCLGdCQUFJLEVBQUUsV0FBUjtBQUFxQjByQixtQkFBTyxFQUFFO0FBQTlCLFdBQU47QUFDRDtBQUNGOztBQUVELGFBQU9uZixHQUFHLENBQUNnaEIsSUFBSixDQUFTLEVBQVQsQ0FBUDtBQUNEOzs7Ozs7ZUFHWTFILFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEtmOzs7O0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7ZUFJZUEsbUI7Ozs7Ozs7Ozs7Ozs7QUNWRjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQSxTQUFTeWpDLGFBQVQsQ0FBdUJDLFVBQXZCLEVBQW1DO0FBQ2pDO0FBQ0E7QUFDQSxNQUFJLE9BQU9BLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEMsUUFBSTtBQUNGLGFBQU9ELGFBQWEsQ0FBQ3BtRCxJQUFJLENBQUN5OEMsS0FBTCxDQUFXNEosVUFBWCxDQUFELENBQXBCO0FBQ0QsS0FGRCxDQUVFLE9BQU96aEIsR0FBUCxFQUFZO0FBQ1osYUFBT3loQixVQUFQO0FBQ0Q7QUFDRixHQU5ELE1BTU8sSUFBSXJsRCxLQUFLLENBQUNzRCxPQUFOLENBQWMraEQsVUFBZCxDQUFKLEVBQStCO0FBQ3BDO0FBQ0EsV0FBT0EsVUFBVSxDQUFDbGIsR0FBWCxDQUFlLFVBQUFrQixHQUFHO0FBQUEsYUFBSStaLGFBQWEsQ0FBQy9aLEdBQUQsQ0FBakI7QUFBQSxLQUFsQixDQUFQO0FBQ0QsR0FITSxNQUdBLElBQUksUUFBT2dhLFVBQVAsTUFBc0IsUUFBdEIsSUFBa0NBLFVBQVUsS0FBSyxJQUFyRCxFQUEyRDtBQUNoRTtBQUNBO0FBQ0EsV0FBTzFyRCxNQUFNLENBQUNTLElBQVAsQ0FBWWlyRCxVQUFaLEVBQXdCdkksTUFBeEIsQ0FBK0IsVUFBQzE4QyxHQUFELEVBQU01RixHQUFOLEVBQWM7QUFDbEQ0RixTQUFHLENBQUM1RixHQUFELENBQUgsR0FBVzRxRCxhQUFhLENBQUNDLFVBQVUsQ0FBQzdxRCxHQUFELENBQVgsQ0FBeEI7QUFDQSxhQUFPNEYsR0FBUDtBQUNELEtBSE0sRUFHSixFQUhJLENBQVA7QUFJRCxHQVBNLE1BT0E7QUFDTDtBQUNBLFdBQU9pbEQsVUFBUDtBQUNEO0FBQ0Y7O0FBRUR2bkQsTUFBTSxDQUFDNFMsT0FBUCxHQUFpQjtBQUFFMDBDLGVBQWEsRUFBYkE7QUFBRixDQUFqQixDOzs7Ozs7Ozs7OztBQy9CQTtBQUNBLDBDQUEwQyxtQkFBTyxDQUFDLHNKQUEwRyxFOzs7Ozs7Ozs7Ozs7QUNENUo7QUFDQSx1REFBdUQsbUJBQU8sQ0FBQyxnTUFBd0gsRTs7Ozs7Ozs7Ozs7O0FDRHZMO0FBQ0EsbURBQW1ELG1CQUFPLENBQUMsb0xBQW9ILEU7Ozs7Ozs7Ozs7OztBQ0QvSyxxRkFBdUMsbUJBQU8sQ0FBQyxzSkFBMEcsRTs7Ozs7Ozs7Ozs7O0FDQXpKLCtFQUFpQyxtQkFBTyxDQUFDLCtIQUFvRyxFOzs7Ozs7Ozs7Ozs7O0FDQzdJLGNBQWMsbUJBQU8sQ0FBQyx5SUFBcUQ7O0FBRTNFLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUZBQXNDOztBQUUzRDs7QUFFQSxHQUFHLEtBQVUsRUFBRSxFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJmOzs7O0FBRUE7QUFDQSxJQUFJL2xELE9BQU0sR0FBR3NCLGNBQUt0QixNQUFsQjtlQUVlQSxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3VELEtBQVQsQ0FBZWIsSUFBZixFQUFxQnVqRCxPQUFyQixFQUE4QmhxRCxJQUE5QixFQUFvQztBQUNsQyxVQUFRQSxJQUFJLENBQUM0SCxNQUFiO0FBQ0UsU0FBSyxDQUFMO0FBQVEsYUFBT25CLElBQUksQ0FBQ3VpQixJQUFMLENBQVVnaEMsT0FBVixDQUFQOztBQUNSLFNBQUssQ0FBTDtBQUFRLGFBQU92akQsSUFBSSxDQUFDdWlCLElBQUwsQ0FBVWdoQyxPQUFWLEVBQW1CaHFELElBQUksQ0FBQyxDQUFELENBQXZCLENBQVA7O0FBQ1IsU0FBSyxDQUFMO0FBQVEsYUFBT3lHLElBQUksQ0FBQ3VpQixJQUFMLENBQVVnaEMsT0FBVixFQUFtQmhxRCxJQUFJLENBQUMsQ0FBRCxDQUF2QixFQUE0QkEsSUFBSSxDQUFDLENBQUQsQ0FBaEMsQ0FBUDs7QUFDUixTQUFLLENBQUw7QUFBUSxhQUFPeUcsSUFBSSxDQUFDdWlCLElBQUwsQ0FBVWdoQyxPQUFWLEVBQW1CaHFELElBQUksQ0FBQyxDQUFELENBQXZCLEVBQTRCQSxJQUFJLENBQUMsQ0FBRCxDQUFoQyxFQUFxQ0EsSUFBSSxDQUFDLENBQUQsQ0FBekMsQ0FBUDtBQUpWOztBQU1BLFNBQU95RyxJQUFJLENBQUNhLEtBQUwsQ0FBVzBpRCxPQUFYLEVBQW9CaHFELElBQXBCLENBQVA7QUFDRDs7ZUFFY3NILEs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJmOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJTyxXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FBekI7QUFFQTs7QUFDQSxJQUFJNWhCLGNBQWMsR0FBR0QsV0FBVyxDQUFDQyxjQUFqQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU2EsYUFBVCxDQUF1QnRKLEtBQXZCLEVBQThCcUosU0FBOUIsRUFBeUM7QUFDdkMsTUFBSVgsS0FBSyxHQUFHLHNCQUFRMUksS0FBUixDQUFaO0FBQUEsTUFDSTRJLEtBQUssR0FBRyxDQUFDRixLQUFELElBQVUsMEJBQVkxSSxLQUFaLENBRHRCO0FBQUEsTUFFSThJLE1BQU0sR0FBRyxDQUFDSixLQUFELElBQVUsQ0FBQ0UsS0FBWCxJQUFvQix1QkFBUzVJLEtBQVQsQ0FGakM7QUFBQSxNQUdJZ0osTUFBTSxHQUFHLENBQUNOLEtBQUQsSUFBVSxDQUFDRSxLQUFYLElBQW9CLENBQUNFLE1BQXJCLElBQStCLDJCQUFhOUksS0FBYixDQUg1QztBQUFBLE1BSUlrSixXQUFXLEdBQUdSLEtBQUssSUFBSUUsS0FBVCxJQUFrQkUsTUFBbEIsSUFBNEJFLE1BSjlDO0FBQUEsTUFLSUcsTUFBTSxHQUFHRCxXQUFXLEdBQUcsd0JBQVVsSixLQUFLLENBQUN1SSxNQUFoQixFQUF3QjZELE1BQXhCLENBQUgsR0FBcUMsRUFMN0Q7QUFBQSxNQU1JN0QsTUFBTSxHQUFHWSxNQUFNLENBQUNaLE1BTnBCOztBQVFBLE9BQUssSUFBSTFJLEdBQVQsSUFBZ0JHLEtBQWhCLEVBQXVCO0FBQ3JCLFFBQUksQ0FBQ3FKLFNBQVMsSUFBSVosY0FBYyxDQUFDa2hCLElBQWYsQ0FBb0IzcEIsS0FBcEIsRUFBMkJILEdBQTNCLENBQWQsS0FDQSxFQUFFcUosV0FBVyxNQUNWO0FBQ0FySixPQUFHLElBQUksUUFBUCxJQUNBO0FBQ0NpSixVQUFNLEtBQUtqSixHQUFHLElBQUksUUFBUCxJQUFtQkEsR0FBRyxJQUFJLFFBQS9CLENBRlAsSUFHQTtBQUNDbUosVUFBTSxLQUFLbkosR0FBRyxJQUFJLFFBQVAsSUFBbUJBLEdBQUcsSUFBSSxZQUExQixJQUEwQ0EsR0FBRyxJQUFJLFlBQXRELENBSlAsSUFLQTtBQUNBLDBCQUFRQSxHQUFSLEVBQWEwSSxNQUFiLENBUlUsQ0FBYixDQURKLEVBVVE7QUFDTlksWUFBTSxDQUFDdXRDLElBQVAsQ0FBWTcyQyxHQUFaO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPc0osTUFBUDtBQUNEOztlQUVjRyxhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hEZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTYSxRQUFULENBQWtCRixLQUFsQixFQUF5QkMsUUFBekIsRUFBbUM7QUFDakMsTUFBSS9CLEtBQUssR0FBRyxDQUFDLENBQWI7QUFBQSxNQUNJSSxNQUFNLEdBQUcwQixLQUFLLElBQUksSUFBVCxHQUFnQixDQUFoQixHQUFvQkEsS0FBSyxDQUFDMUIsTUFEdkM7QUFBQSxNQUVJWSxNQUFNLEdBQUc5RCxLQUFLLENBQUNrRCxNQUFELENBRmxCOztBQUlBLFNBQU8sRUFBRUosS0FBRixHQUFVSSxNQUFqQixFQUF5QjtBQUN2QlksVUFBTSxDQUFDaEIsS0FBRCxDQUFOLEdBQWdCK0IsUUFBUSxDQUFDRCxLQUFLLENBQUM5QixLQUFELENBQU4sRUFBZUEsS0FBZixFQUFzQjhCLEtBQXRCLENBQXhCO0FBQ0Q7O0FBQ0QsU0FBT2QsTUFBUDtBQUNEOztlQUVjZ0IsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQmY7O0FBQ0E7Ozs7QUFFQTtBQUNBLElBQUkzQixXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FBekI7QUFFQTs7QUFDQSxJQUFJNWhCLGNBQWMsR0FBR0QsV0FBVyxDQUFDQyxjQUFqQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNpTCxXQUFULENBQXFCeE0sTUFBckIsRUFBNkJySCxHQUE3QixFQUFrQ0csS0FBbEMsRUFBeUM7QUFDdkMsTUFBSTJULFFBQVEsR0FBR3pNLE1BQU0sQ0FBQ3JILEdBQUQsQ0FBckI7O0FBQ0EsTUFBSSxFQUFFNEksY0FBYyxDQUFDa2hCLElBQWYsQ0FBb0J6aUIsTUFBcEIsRUFBNEJySCxHQUE1QixLQUFvQyxpQkFBRzhULFFBQUgsRUFBYTNULEtBQWIsQ0FBdEMsS0FDQ0EsS0FBSyxLQUFLeXNCLFNBQVYsSUFBdUIsRUFBRTVzQixHQUFHLElBQUlxSCxNQUFULENBRDVCLEVBQytDO0FBQzdDLGtDQUFnQkEsTUFBaEIsRUFBd0JySCxHQUF4QixFQUE2QkcsS0FBN0I7QUFDRDtBQUNGOztlQUVjMFQsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQmY7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTdk0sZUFBVCxDQUF5QkQsTUFBekIsRUFBaUNySCxHQUFqQyxFQUFzQ0csS0FBdEMsRUFBNkM7QUFDM0MsTUFBSUgsR0FBRyxJQUFJLFdBQVAsSUFBc0JkLHVCQUExQixFQUEwQztBQUN4QyxpQ0FBZW1JLE1BQWYsRUFBdUJySCxHQUF2QixFQUE0QjtBQUMxQixzQkFBZ0IsSUFEVTtBQUUxQixvQkFBYyxJQUZZO0FBRzFCLGVBQVNHLEtBSGlCO0FBSTFCLGtCQUFZO0FBSmMsS0FBNUI7QUFNRCxHQVBELE1BT087QUFDTGtILFVBQU0sQ0FBQ3JILEdBQUQsQ0FBTixHQUFjRyxLQUFkO0FBQ0Q7QUFDRjs7ZUFFY21ILGU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeEJmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJNUMsT0FBTyxHQUFHLGVBQWQ7QUFBQSxJQUNJQyxZQUFZLEdBQUcsb0JBRG5CO0FBR0E7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHQyxtQkFBU0EsaUJBQU9rbUQsV0FBaEIsR0FBOEJuK0IsU0FBbkQ7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTNW5CLFVBQVQsQ0FBb0I3RSxLQUFwQixFQUEyQjtBQUN6QixNQUFJQSxLQUFLLElBQUksSUFBYixFQUFtQjtBQUNqQixXQUFPQSxLQUFLLEtBQUt5c0IsU0FBVixHQUFzQmpvQixZQUF0QixHQUFxQ0QsT0FBNUM7QUFDRDs7QUFDRCxTQUFRRSxjQUFjLElBQUlBLGNBQWMsSUFBSXpGLE1BQU0sQ0FBQ2dCLEtBQUQsQ0FBM0MsR0FDSCx3QkFBVUEsS0FBVixDQURHLEdBRUgsNkJBQWVBLEtBQWYsQ0FGSjtBQUdEOztlQUVjNkUsVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQmY7O0FBQ0E7Ozs7QUFFQTtBQUNBLElBQUlnUixPQUFPLEdBQUcsb0JBQWQ7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTRCxlQUFULENBQXlCNVYsS0FBekIsRUFBZ0M7QUFDOUIsU0FBTywyQkFBYUEsS0FBYixLQUF1Qix5QkFBV0EsS0FBWCxLQUFxQjZWLE9BQW5EO0FBQ0Q7O2VBRWNELGU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJmOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOUIsWUFBWSxHQUFHLHFCQUFuQjtBQUVBOztBQUNBLElBQUlDLFlBQVksR0FBRyw2QkFBbkI7QUFFQTs7QUFDQSxJQUFJQyxTQUFTLEdBQUc1TixRQUFRLENBQUNpa0IsU0FBekI7QUFBQSxJQUNJN2hCLFdBQVcsR0FBR3hKLE1BQU0sQ0FBQ3FyQixTQUR6QjtBQUdBOztBQUNBLElBQUlwVyxZQUFZLEdBQUdELFNBQVMsQ0FBQzFKLFFBQTdCO0FBRUE7O0FBQ0EsSUFBSTdCLGNBQWMsR0FBR0QsV0FBVyxDQUFDQyxjQUFqQztBQUVBOztBQUNBLElBQUl5TCxVQUFVLEdBQUd4QixNQUFNLENBQUMsTUFDdEJ1QixZQUFZLENBQUMwVixJQUFiLENBQWtCbGhCLGNBQWxCLEVBQWtDK29CLE9BQWxDLENBQTBDMWQsWUFBMUMsRUFBd0QsTUFBeEQsRUFDQzBkLE9BREQsQ0FDUyx3REFEVCxFQUNtRSxPQURuRSxDQURzQixHQUV3RCxHQUZ6RCxDQUF2QjtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUzNkLFlBQVQsQ0FBc0I3VCxLQUF0QixFQUE2QjtBQUMzQixNQUFJLENBQUMsdUJBQVNBLEtBQVQsQ0FBRCxJQUFvQix1QkFBU0EsS0FBVCxDQUF4QixFQUF5QztBQUN2QyxXQUFPLEtBQVA7QUFDRDs7QUFDRCxNQUFJbVIsT0FBTyxHQUFHLHlCQUFXblIsS0FBWCxJQUFvQmtVLFVBQXBCLEdBQWlDSCxZQUEvQztBQUNBLFNBQU81QyxPQUFPLENBQUN1ZSxJQUFSLENBQWEsdUJBQVMxdkIsS0FBVCxDQUFiLENBQVA7QUFDRDs7ZUFFYzZULFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUNmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJZ0MsT0FBTyxHQUFHLG9CQUFkO0FBQUEsSUFDSVksUUFBUSxHQUFHLGdCQURmO0FBQUEsSUFFSUMsT0FBTyxHQUFHLGtCQUZkO0FBQUEsSUFHSUMsT0FBTyxHQUFHLGVBSGQ7QUFBQSxJQUlJL00sUUFBUSxHQUFHLGdCQUpmO0FBQUEsSUFLSXJDLE9BQU8sR0FBRyxtQkFMZDtBQUFBLElBTUlxUCxNQUFNLEdBQUcsY0FOYjtBQUFBLElBT0lDLFNBQVMsR0FBRyxpQkFQaEI7QUFBQSxJQVFJQyxTQUFTLEdBQUcsaUJBUmhCO0FBQUEsSUFTSUMsU0FBUyxHQUFHLGlCQVRoQjtBQUFBLElBVUlDLE1BQU0sR0FBRyxjQVZiO0FBQUEsSUFXSUMsU0FBUyxHQUFHLGlCQVhoQjtBQUFBLElBWUlDLFVBQVUsR0FBRyxrQkFaakI7QUFjQSxJQUFJQyxjQUFjLEdBQUcsc0JBQXJCO0FBQUEsSUFDSUMsV0FBVyxHQUFHLG1CQURsQjtBQUFBLElBRUlDLFVBQVUsR0FBRyx1QkFGakI7QUFBQSxJQUdJQyxVQUFVLEdBQUcsdUJBSGpCO0FBQUEsSUFJSUMsT0FBTyxHQUFHLG9CQUpkO0FBQUEsSUFLSUMsUUFBUSxHQUFHLHFCQUxmO0FBQUEsSUFNSUMsUUFBUSxHQUFHLHFCQU5mO0FBQUEsSUFPSUMsUUFBUSxHQUFHLHFCQVBmO0FBQUEsSUFRSUMsZUFBZSxHQUFHLDRCQVJ0QjtBQUFBLElBU0lDLFNBQVMsR0FBRyxzQkFUaEI7QUFBQSxJQVVJQyxTQUFTLEdBQUcsc0JBVmhCO0FBWUE7O0FBQ0EsSUFBSUMsY0FBYyxHQUFHLEVBQXJCO0FBQ0FBLGNBQWMsQ0FBQ1QsVUFBRCxDQUFkLEdBQTZCUyxjQUFjLENBQUNSLFVBQUQsQ0FBZCxHQUM3QlEsY0FBYyxDQUFDUCxPQUFELENBQWQsR0FBMEJPLGNBQWMsQ0FBQ04sUUFBRCxDQUFkLEdBQzFCTSxjQUFjLENBQUNMLFFBQUQsQ0FBZCxHQUEyQkssY0FBYyxDQUFDSixRQUFELENBQWQsR0FDM0JJLGNBQWMsQ0FBQ0gsZUFBRCxDQUFkLEdBQWtDRyxjQUFjLENBQUNGLFNBQUQsQ0FBZCxHQUNsQ0UsY0FBYyxDQUFDRCxTQUFELENBQWQsR0FBNEIsSUFKNUI7QUFLQUMsY0FBYyxDQUFDakMsT0FBRCxDQUFkLEdBQTBCaUMsY0FBYyxDQUFDckIsUUFBRCxDQUFkLEdBQzFCcUIsY0FBYyxDQUFDWCxjQUFELENBQWQsR0FBaUNXLGNBQWMsQ0FBQ3BCLE9BQUQsQ0FBZCxHQUNqQ29CLGNBQWMsQ0FBQ1YsV0FBRCxDQUFkLEdBQThCVSxjQUFjLENBQUNuQixPQUFELENBQWQsR0FDOUJtQixjQUFjLENBQUNsTyxRQUFELENBQWQsR0FBMkJrTyxjQUFjLENBQUN2USxPQUFELENBQWQsR0FDM0J1USxjQUFjLENBQUNsQixNQUFELENBQWQsR0FBeUJrQixjQUFjLENBQUNqQixTQUFELENBQWQsR0FDekJpQixjQUFjLENBQUNoQixTQUFELENBQWQsR0FBNEJnQixjQUFjLENBQUNmLFNBQUQsQ0FBZCxHQUM1QmUsY0FBYyxDQUFDZCxNQUFELENBQWQsR0FBeUJjLGNBQWMsQ0FBQ2IsU0FBRCxDQUFkLEdBQ3pCYSxjQUFjLENBQUNaLFVBQUQsQ0FBZCxHQUE2QixLQVA3QjtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNWLGdCQUFULENBQTBCeFcsS0FBMUIsRUFBaUM7QUFDL0IsU0FBTywyQkFBYUEsS0FBYixLQUNMLHVCQUFTQSxLQUFLLENBQUN1SSxNQUFmLENBREssSUFDcUIsQ0FBQyxDQUFDdVAsY0FBYyxDQUFDLHlCQUFXOVgsS0FBWCxDQUFELENBRDVDO0FBRUQ7O2VBRWN3VyxnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRGY7O0FBQ0E7Ozs7QUFFQTtBQUNBLElBQUloTyxXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FBekI7QUFFQTs7QUFDQSxJQUFJNWhCLGNBQWMsR0FBR0QsV0FBVyxDQUFDQyxjQUFqQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVM2UCxRQUFULENBQWtCcFIsTUFBbEIsRUFBMEI7QUFDeEIsTUFBSSxDQUFDLDBCQUFZQSxNQUFaLENBQUwsRUFBMEI7QUFDeEIsV0FBTyx5QkFBV0EsTUFBWCxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSWlDLE1BQU0sR0FBRyxFQUFiOztBQUNBLE9BQUssSUFBSXRKLEdBQVQsSUFBZ0JiLE1BQU0sQ0FBQ2tJLE1BQUQsQ0FBdEIsRUFBZ0M7QUFDOUIsUUFBSXVCLGNBQWMsQ0FBQ2toQixJQUFmLENBQW9CemlCLE1BQXBCLEVBQTRCckgsR0FBNUIsS0FBb0NBLEdBQUcsSUFBSSxhQUEvQyxFQUE4RDtBQUM1RHNKLFlBQU0sQ0FBQ3V0QyxJQUFQLENBQVk3MkMsR0FBWjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBT3NKLE1BQVA7QUFDRDs7ZUFFY21QLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJOVAsV0FBVyxHQUFHeEosTUFBTSxDQUFDcXJCLFNBQXpCO0FBRUE7O0FBQ0EsSUFBSTVoQixjQUFjLEdBQUdELFdBQVcsQ0FBQ0MsY0FBakM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTaU4sVUFBVCxDQUFvQnhPLE1BQXBCLEVBQTRCO0FBQzFCLE1BQUksQ0FBQyx1QkFBU0EsTUFBVCxDQUFMLEVBQXVCO0FBQ3JCLFdBQU8sMkJBQWFBLE1BQWIsQ0FBUDtBQUNEOztBQUNELE1BQUlnUixPQUFPLEdBQUcsMEJBQVloUixNQUFaLENBQWQ7QUFBQSxNQUNJaUMsTUFBTSxHQUFHLEVBRGI7O0FBR0EsT0FBSyxJQUFJdEosR0FBVCxJQUFnQnFILE1BQWhCLEVBQXdCO0FBQ3RCLFFBQUksRUFBRXJILEdBQUcsSUFBSSxhQUFQLEtBQXlCcVksT0FBTyxJQUFJLENBQUN6UCxjQUFjLENBQUNraEIsSUFBZixDQUFvQnppQixNQUFwQixFQUE0QnJILEdBQTVCLENBQXJDLENBQUYsQ0FBSixFQUErRTtBQUM3RXNKLFlBQU0sQ0FBQ3V0QyxJQUFQLENBQVk3MkMsR0FBWjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBT3NKLE1BQVA7QUFDRDs7ZUFFY3VNLFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU3FELGNBQVQsQ0FBd0I3UixNQUF4QixFQUFnQztBQUM5QixTQUFPLFVBQVNySCxHQUFULEVBQWM7QUFDbkIsV0FBT3FILE1BQU0sSUFBSSxJQUFWLEdBQWlCdWxCLFNBQWpCLEdBQTZCdmxCLE1BQU0sQ0FBQ3JILEdBQUQsQ0FBMUM7QUFDRCxHQUZEO0FBR0Q7O2VBRWNrWixjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2JmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMvUSxRQUFULENBQWtCWixJQUFsQixFQUF3QnlOLEtBQXhCLEVBQStCO0FBQzdCLFNBQU8sMEJBQVksdUJBQVN6TixJQUFULEVBQWV5TixLQUFmLEVBQXNCOU0saUJBQXRCLENBQVosRUFBNkNYLElBQUksR0FBRyxFQUFwRCxDQUFQO0FBQ0Q7O2VBRWNZLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUlnTixlQUFlLEdBQUcsQ0FBQ2pXLHVCQUFELEdBQWtCZ0osaUJBQWxCLEdBQTZCLFVBQVNYLElBQVQsRUFBZTRLLE1BQWYsRUFBdUI7QUFDeEUsU0FBTyw2QkFBZTVLLElBQWYsRUFBcUIsVUFBckIsRUFBaUM7QUFDdEMsb0JBQWdCLElBRHNCO0FBRXRDLGtCQUFjLEtBRndCO0FBR3RDLGFBQVMsdUJBQVM0SyxNQUFULENBSDZCO0FBSXRDLGdCQUFZO0FBSjBCLEdBQWpDLENBQVA7QUFNRCxDQVBEO2VBU2VnRCxlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTNUwsU0FBVCxDQUFtQjRnQixDQUFuQixFQUFzQjlmLFFBQXRCLEVBQWdDO0FBQzlCLE1BQUkvQixLQUFLLEdBQUcsQ0FBQyxDQUFiO0FBQUEsTUFDSWdCLE1BQU0sR0FBRzlELEtBQUssQ0FBQzJrQixDQUFELENBRGxCOztBQUdBLFNBQU8sRUFBRTdoQixLQUFGLEdBQVU2aEIsQ0FBakIsRUFBb0I7QUFDbEI3Z0IsVUFBTSxDQUFDaEIsS0FBRCxDQUFOLEdBQWdCK0IsUUFBUSxDQUFDL0IsS0FBRCxDQUF4QjtBQUNEOztBQUNELFNBQU9nQixNQUFQO0FBQ0Q7O2VBRWNDLFM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJmOztBQUNBOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJNFAsUUFBUSxHQUFHLElBQUksQ0FBbkI7QUFFQTs7QUFDQSxJQUFJQyxXQUFXLEdBQUd2VSxtQkFBU0EsaUJBQU8ybEIsU0FBaEIsR0FBNEJvQyxTQUE5QztBQUFBLElBQ0l2VCxjQUFjLEdBQUdELFdBQVcsR0FBR0EsV0FBVyxDQUFDM08sUUFBZixHQUEwQm1pQixTQUQxRDtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU3BpQixZQUFULENBQXNCckssS0FBdEIsRUFBNkI7QUFDM0I7QUFDQSxNQUFJLE9BQU9BLEtBQVAsSUFBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsV0FBT0EsS0FBUDtBQUNEOztBQUNELE1BQUksc0JBQVFBLEtBQVIsQ0FBSixFQUFvQjtBQUNsQjtBQUNBLFdBQU8sdUJBQVNBLEtBQVQsRUFBZ0JxSyxZQUFoQixJQUFnQyxFQUF2QztBQUNEOztBQUNELE1BQUksdUJBQVNySyxLQUFULENBQUosRUFBcUI7QUFDbkIsV0FBT2taLGNBQWMsR0FBR0EsY0FBYyxDQUFDeVEsSUFBZixDQUFvQjNwQixLQUFwQixDQUFILEdBQWdDLEVBQXJEO0FBQ0Q7O0FBQ0QsTUFBSW1KLE1BQU0sR0FBSW5KLEtBQUssR0FBRyxFQUF0QjtBQUNBLFNBQVFtSixNQUFNLElBQUksR0FBVixJQUFrQixJQUFJbkosS0FBTCxJQUFlLENBQUNnWixRQUFsQyxHQUE4QyxJQUE5QyxHQUFxRDdQLE1BQTVEO0FBQ0Q7O2VBRWNrQixZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrTSxTQUFULENBQW1CblAsSUFBbkIsRUFBeUI7QUFDdkIsU0FBTyxVQUFTcEgsS0FBVCxFQUFnQjtBQUNyQixXQUFPb0gsSUFBSSxDQUFDcEgsS0FBRCxDQUFYO0FBQ0QsR0FGRDtBQUdEOztlQUVjdVcsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiZjs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2pFLFVBQVQsQ0FBb0JwTCxNQUFwQixFQUE0QnNNLEtBQTVCLEVBQW1DO0FBQ2pDLFNBQU8sdUJBQVNBLEtBQVQsRUFBZ0IsVUFBUzNULEdBQVQsRUFBYztBQUNuQyxXQUFPcUgsTUFBTSxDQUFDckgsR0FBRCxDQUFiO0FBQ0QsR0FGTSxDQUFQO0FBR0Q7O2VBRWN5UyxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xCZjs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2UsVUFBVCxDQUFvQmIsTUFBcEIsRUFBNEJnQixLQUE1QixFQUFtQ3RNLE1BQW5DLEVBQTJDdU0sVUFBM0MsRUFBdUQ7QUFDckQsTUFBSUYsS0FBSyxHQUFHLENBQUNyTSxNQUFiO0FBQ0FBLFFBQU0sS0FBS0EsTUFBTSxHQUFHLEVBQWQsQ0FBTjtBQUVBLE1BQUlpQixLQUFLLEdBQUcsQ0FBQyxDQUFiO0FBQUEsTUFDSUksTUFBTSxHQUFHaUwsS0FBSyxDQUFDakwsTUFEbkI7O0FBR0EsU0FBTyxFQUFFSixLQUFGLEdBQVVJLE1BQWpCLEVBQXlCO0FBQ3ZCLFFBQUkxSSxHQUFHLEdBQUcyVCxLQUFLLENBQUNyTCxLQUFELENBQWY7QUFFQSxRQUFJekMsUUFBUSxHQUFHK04sVUFBVSxHQUNyQkEsVUFBVSxDQUFDdk0sTUFBTSxDQUFDckgsR0FBRCxDQUFQLEVBQWMyUyxNQUFNLENBQUMzUyxHQUFELENBQXBCLEVBQTJCQSxHQUEzQixFQUFnQ3FILE1BQWhDLEVBQXdDc0wsTUFBeEMsQ0FEVyxHQUVyQmlhLFNBRko7O0FBSUEsUUFBSS9tQixRQUFRLEtBQUsrbUIsU0FBakIsRUFBNEI7QUFDMUIvbUIsY0FBUSxHQUFHOE0sTUFBTSxDQUFDM1MsR0FBRCxDQUFqQjtBQUNEOztBQUNELFFBQUkwVCxLQUFKLEVBQVc7QUFDVCxvQ0FBZ0JyTSxNQUFoQixFQUF3QnJILEdBQXhCLEVBQTZCNkYsUUFBN0I7QUFDRCxLQUZELE1BRU87QUFDTCxnQ0FBWXdCLE1BQVosRUFBb0JySCxHQUFwQixFQUF5QjZGLFFBQXpCO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPd0IsTUFBUDtBQUNEOztlQUVjbU0sVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q2Y7Ozs7QUFFQTtBQUNBLElBQUlvQixVQUFVLEdBQUd6TyxjQUFLLG9CQUFMLENBQWpCO2VBRWV5TyxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xmOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTckIsY0FBVCxDQUF3QnVCLFFBQXhCLEVBQWtDO0FBQ2hDLFNBQU8sdUJBQVMsVUFBU3pOLE1BQVQsRUFBaUJ3TixPQUFqQixFQUEwQjtBQUN4QyxRQUFJdk0sS0FBSyxHQUFHLENBQUMsQ0FBYjtBQUFBLFFBQ0lJLE1BQU0sR0FBR21NLE9BQU8sQ0FBQ25NLE1BRHJCO0FBQUEsUUFFSWtMLFVBQVUsR0FBR2xMLE1BQU0sR0FBRyxDQUFULEdBQWFtTSxPQUFPLENBQUNuTSxNQUFNLEdBQUcsQ0FBVixDQUFwQixHQUFtQ2trQixTQUZwRDtBQUFBLFFBR0kxYSxLQUFLLEdBQUd4SixNQUFNLEdBQUcsQ0FBVCxHQUFhbU0sT0FBTyxDQUFDLENBQUQsQ0FBcEIsR0FBMEIrWCxTQUh0QztBQUtBaFosY0FBVSxHQUFJa0IsUUFBUSxDQUFDcE0sTUFBVCxHQUFrQixDQUFsQixJQUF1QixPQUFPa0wsVUFBUCxJQUFxQixVQUE3QyxJQUNSbEwsTUFBTSxJQUFJa0wsVUFERixJQUVUZ1osU0FGSjs7QUFJQSxRQUFJMWEsS0FBSyxJQUFJLDZCQUFlMkMsT0FBTyxDQUFDLENBQUQsQ0FBdEIsRUFBMkJBLE9BQU8sQ0FBQyxDQUFELENBQWxDLEVBQXVDM0MsS0FBdkMsQ0FBYixFQUE0RDtBQUMxRDBCLGdCQUFVLEdBQUdsTCxNQUFNLEdBQUcsQ0FBVCxHQUFha2tCLFNBQWIsR0FBeUJoWixVQUF0QztBQUNBbEwsWUFBTSxHQUFHLENBQVQ7QUFDRDs7QUFDRHJCLFVBQU0sR0FBR2xJLE1BQU0sQ0FBQ2tJLE1BQUQsQ0FBZjs7QUFDQSxXQUFPLEVBQUVpQixLQUFGLEdBQVVJLE1BQWpCLEVBQXlCO0FBQ3ZCLFVBQUlpSyxNQUFNLEdBQUdrQyxPQUFPLENBQUN2TSxLQUFELENBQXBCOztBQUNBLFVBQUlxSyxNQUFKLEVBQVk7QUFDVm1DLGdCQUFRLENBQUN6TixNQUFELEVBQVNzTCxNQUFULEVBQWlCckssS0FBakIsRUFBd0JzTCxVQUF4QixDQUFSO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPdk0sTUFBUDtBQUNELEdBdEJNLENBQVA7QUF1QkQ7O2VBRWNrTSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDZjs7OztBQUVBO0FBQ0EsSUFBSTVLLFdBQVcsR0FBR3hKLE1BQU0sQ0FBQ3FyQixTQUF6QjtBQUVBOztBQUNBLElBQUk1aEIsY0FBYyxHQUFHRCxXQUFXLENBQUNDLGNBQWpDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVN5SixzQkFBVCxDQUFnQ3lCLFFBQWhDLEVBQTBDazNDLFFBQTFDLEVBQW9EaHJELEdBQXBELEVBQXlEcUgsTUFBekQsRUFBaUU7QUFDL0QsTUFBSXlNLFFBQVEsS0FBSzhZLFNBQWIsSUFDQyxpQkFBRzlZLFFBQUgsRUFBYW5MLFdBQVcsQ0FBQzNJLEdBQUQsQ0FBeEIsS0FBa0MsQ0FBQzRJLGNBQWMsQ0FBQ2toQixJQUFmLENBQW9CemlCLE1BQXBCLEVBQTRCckgsR0FBNUIsQ0FEeEMsRUFDMkU7QUFDekUsV0FBT2dyRCxRQUFQO0FBQ0Q7O0FBQ0QsU0FBT2wzQyxRQUFQO0FBQ0Q7O2VBRWN6QixzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QmY7Ozs7QUFFQSxJQUFJblQsY0FBYyxHQUFJLFlBQVc7QUFDL0IsTUFBSTtBQUNGLFFBQUlxSSxJQUFJLEdBQUcsd0JBQVVwSSxNQUFWLEVBQWtCLGdCQUFsQixDQUFYO0FBQ0FvSSxRQUFJLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULENBQUo7QUFDQSxXQUFPQSxJQUFQO0FBQ0QsR0FKRCxDQUlFLE9BQU9rRyxDQUFQLEVBQVUsQ0FBRTtBQUNmLENBTnFCLEVBQXRCOztlQVFldk8sYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWZjs7OztBQUVBO0FBQ0EsSUFBSStaLFdBQVcsR0FBRztBQUNoQixPQUFLLE9BRFc7QUFFaEIsT0FBSyxNQUZXO0FBR2hCLE9BQUssTUFIVztBQUloQixPQUFLLFFBSlc7QUFLaEIsT0FBSztBQUxXLENBQWxCO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUQsY0FBYyxHQUFHLDZCQUFlQyxXQUFmLENBQXJCO2VBRWVELGM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJmO0FBQ0EsSUFBSVIsYUFBYSxHQUFHO0FBQ2xCLFFBQU0sSUFEWTtBQUVsQixPQUFLLEdBRmE7QUFHbEIsUUFBTSxHQUhZO0FBSWxCLFFBQU0sR0FKWTtBQUtsQixZQUFVLE9BTFE7QUFNbEIsWUFBVTtBQU5RLENBQXBCO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU3hGLGdCQUFULENBQTBCaTRDLEdBQTFCLEVBQStCO0FBQzdCLFNBQU8sT0FBT3p5QyxhQUFhLENBQUN5eUMsR0FBRCxDQUEzQjtBQUNEOztlQUVjajRDLGdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckJmO0FBQ0EsSUFBSTFNLFVBQVUsR0FBRyxRQUFPd0IsTUFBUCx5Q0FBT0EsTUFBUCxNQUFpQixRQUFqQixJQUE2QkEsTUFBN0IsSUFBdUNBLE1BQU0sQ0FBQzNJLE1BQVAsS0FBa0JBLE1BQXpELElBQW1FMkksTUFBcEY7ZUFFZXhCLFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hmOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNrQixTQUFULENBQW1CSCxNQUFuQixFQUEyQnJILEdBQTNCLEVBQWdDO0FBQzlCLE1BQUlHLEtBQUssR0FBRyx1QkFBU2tILE1BQVQsRUFBaUJySCxHQUFqQixDQUFaO0FBQ0EsU0FBTywyQkFBYUcsS0FBYixJQUFzQkEsS0FBdEIsR0FBOEJ5c0IsU0FBckM7QUFDRDs7ZUFFY3BsQixTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hCZjs7OztBQUVBO0FBQ0EsSUFBSStRLFlBQVksR0FBRyxzQkFBUXBaLE1BQU0sQ0FBQ0MsY0FBZixFQUErQkQsTUFBL0IsQ0FBbkI7ZUFFZW9aLFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTGY7Ozs7QUFFQTtBQUNBLElBQUk1UCxXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FBekI7QUFFQTs7QUFDQSxJQUFJNWhCLGNBQWMsR0FBR0QsV0FBVyxDQUFDQyxjQUFqQztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSTRMLG9CQUFvQixHQUFHN0wsV0FBVyxDQUFDOEIsUUFBdkM7QUFFQTs7QUFDQSxJQUFJN0YsY0FBYyxHQUFHQyxtQkFBU0EsaUJBQU9rbUQsV0FBaEIsR0FBOEJuK0IsU0FBbkQ7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTOW5CLFNBQVQsQ0FBbUIzRSxLQUFuQixFQUEwQjtBQUN4QixNQUFJc1UsS0FBSyxHQUFHN0wsY0FBYyxDQUFDa2hCLElBQWYsQ0FBb0IzcEIsS0FBcEIsRUFBMkJ5RSxjQUEzQixDQUFaO0FBQUEsTUFDSWlELEdBQUcsR0FBRzFILEtBQUssQ0FBQ3lFLGNBQUQsQ0FEZjs7QUFHQSxNQUFJO0FBQ0Z6RSxTQUFLLENBQUN5RSxjQUFELENBQUwsR0FBd0Jnb0IsU0FBeEI7QUFDQSxRQUFJM2IsUUFBUSxHQUFHLElBQWY7QUFDRCxHQUhELENBR0UsT0FBT3hELENBQVAsRUFBVSxDQUFFOztBQUVkLE1BQUluRSxNQUFNLEdBQUdrTCxvQkFBb0IsQ0FBQ3NWLElBQXJCLENBQTBCM3BCLEtBQTFCLENBQWI7O0FBQ0EsTUFBSThRLFFBQUosRUFBYztBQUNaLFFBQUl3RCxLQUFKLEVBQVc7QUFDVHRVLFdBQUssQ0FBQ3lFLGNBQUQsQ0FBTCxHQUF3QmlELEdBQXhCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTzFILEtBQUssQ0FBQ3lFLGNBQUQsQ0FBWjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTzBFLE1BQVA7QUFDRDs7ZUFFY3hFLFM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTaVAsUUFBVCxDQUFrQjFNLE1BQWxCLEVBQTBCckgsR0FBMUIsRUFBK0I7QUFDN0IsU0FBT3FILE1BQU0sSUFBSSxJQUFWLEdBQWlCdWxCLFNBQWpCLEdBQTZCdmxCLE1BQU0sQ0FBQ3JILEdBQUQsQ0FBMUM7QUFDRDs7ZUFFYytULFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNaZjtBQUNBLElBQUl2TCxnQkFBZ0IsR0FBRyxnQkFBdkI7QUFFQTs7QUFDQSxJQUFJQyxRQUFRLEdBQUcsa0JBQWY7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNKLE9BQVQsQ0FBaUJsSSxLQUFqQixFQUF3QnVJLE1BQXhCLEVBQWdDO0FBQzlCLE1BQUl6QyxJQUFJLFdBQVU5RixLQUFWLENBQVI7O0FBQ0F1SSxRQUFNLEdBQUdBLE1BQU0sSUFBSSxJQUFWLEdBQWlCRixnQkFBakIsR0FBb0NFLE1BQTdDO0FBRUEsU0FBTyxDQUFDLENBQUNBLE1BQUYsS0FDSnpDLElBQUksSUFBSSxRQUFSLElBQ0VBLElBQUksSUFBSSxRQUFSLElBQW9Cd0MsUUFBUSxDQUFDb25CLElBQVQsQ0FBYzF2QixLQUFkLENBRmxCLEtBR0FBLEtBQUssR0FBRyxDQUFDLENBQVQsSUFBY0EsS0FBSyxHQUFHLENBQVIsSUFBYSxDQUEzQixJQUFnQ0EsS0FBSyxHQUFHdUksTUFIL0M7QUFJRDs7ZUFFY0wsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QmY7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU0UsY0FBVCxDQUF3QnBJLEtBQXhCLEVBQStCbUksS0FBL0IsRUFBc0NqQixNQUF0QyxFQUE4QztBQUM1QyxNQUFJLENBQUMsdUJBQVNBLE1BQVQsQ0FBTCxFQUF1QjtBQUNyQixXQUFPLEtBQVA7QUFDRDs7QUFDRCxNQUFJcEIsSUFBSSxXQUFVcUMsS0FBVixDQUFSOztBQUNBLE1BQUlyQyxJQUFJLElBQUksUUFBUixHQUNLLDBCQUFZb0IsTUFBWixLQUF1QixzQkFBUWlCLEtBQVIsRUFBZWpCLE1BQU0sQ0FBQ3FCLE1BQXRCLENBRDVCLEdBRUt6QyxJQUFJLElBQUksUUFBUixJQUFvQnFDLEtBQUssSUFBSWpCLE1BRnRDLEVBR007QUFDSixXQUFPLGlCQUFHQSxNQUFNLENBQUNpQixLQUFELENBQVQsRUFBa0JuSSxLQUFsQixDQUFQO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7O2VBRWNvSSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCZjs7OztBQUVBO0FBQ0EsSUFBSW1NLFVBQVUsR0FBSSxZQUFXO0FBQzNCLE1BQUlDLEdBQUcsR0FBRyxTQUFTd1csSUFBVCxDQUFjdlcsdUJBQWNBLG9CQUFXaFYsSUFBekIsSUFBaUNnVixvQkFBV2hWLElBQVgsQ0FBZ0JzckQsUUFBakQsSUFBNkQsRUFBM0UsQ0FBVjtBQUNBLFNBQU92MkMsR0FBRyxHQUFJLG1CQUFtQkEsR0FBdkIsR0FBOEIsRUFBeEM7QUFDRCxDQUhpQixFQUFsQjtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTTCxRQUFULENBQWtCL00sSUFBbEIsRUFBd0I7QUFDdEIsU0FBTyxDQUFDLENBQUNtTixVQUFGLElBQWlCQSxVQUFVLElBQUluTixJQUF0QztBQUNEOztlQUVjK00sUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQmY7QUFDQSxJQUFJM0wsV0FBVyxHQUFHeEosTUFBTSxDQUFDcXJCLFNBQXpCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUzNnQixXQUFULENBQXFCMUosS0FBckIsRUFBNEI7QUFDMUIsTUFBSXdKLElBQUksR0FBR3hKLEtBQUssSUFBSUEsS0FBSyxDQUFDRyxXQUExQjtBQUFBLE1BQ0lzSixLQUFLLEdBQUksT0FBT0QsSUFBUCxJQUFlLFVBQWYsSUFBNkJBLElBQUksQ0FBQzZnQixTQUFuQyxJQUFpRDdoQixXQUQ3RDtBQUdBLFNBQU94SSxLQUFLLEtBQUt5SixLQUFqQjtBQUNEOztlQUVjQyxXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pCZjs7OztBQUVBO0FBQ0EsSUFBSTZPLFVBQVUsR0FBRyxzQkFBUXZaLE1BQU0sQ0FBQ1MsSUFBZixFQUFxQlQsTUFBckIsQ0FBakI7ZUFFZXVaLFU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU04sWUFBVCxDQUFzQi9RLE1BQXRCLEVBQThCO0FBQzVCLE1BQUlpQyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxNQUFJakMsTUFBTSxJQUFJLElBQWQsRUFBb0I7QUFDbEIsU0FBSyxJQUFJckgsR0FBVCxJQUFnQmIsTUFBTSxDQUFDa0ksTUFBRCxDQUF0QixFQUFnQztBQUM5QmlDLFlBQU0sQ0FBQ3V0QyxJQUFQLENBQVk3MkMsR0FBWjtBQUNEO0FBQ0Y7O0FBQ0QsU0FBT3NKLE1BQVA7QUFDRDs7ZUFFYzhPLFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJmOzs7Ozs7QUFFQTtBQUNBLElBQUluQyxXQUFXLEdBQUcsOEJBQU9DLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE9BQTlCLElBQXlDLENBQUNBLE9BQU8sQ0FBQ2tqQyxRQUFsRCxJQUE4RGxqQyxPQUFoRjtBQUVBOztBQUNBLElBQUlDLFVBQVUsR0FBR0YsV0FBVyxJQUFJLDhCQUFPM1MsTUFBUCxNQUFpQixRQUFoQyxJQUE0Q0EsTUFBNUMsSUFBc0QsQ0FBQ0EsTUFBTSxDQUFDODFDLFFBQTlELElBQTBFOTFDLE1BQTNGO0FBRUE7O0FBQ0EsSUFBSThTLGFBQWEsR0FBR0QsVUFBVSxJQUFJQSxVQUFVLENBQUNELE9BQVgsS0FBdUJELFdBQXpEO0FBRUE7O0FBQ0EsSUFBSWlDLFdBQVcsR0FBRzlCLGFBQWEsSUFBSTlQLG9CQUFXNmtELE9BQTlDO0FBRUE7O0FBQ0EsSUFBSTEwQyxRQUFRLEdBQUksWUFBVztBQUN6QixNQUFJO0FBQ0Y7QUFDQSxRQUFJMEIsS0FBSyxHQUFHaEMsVUFBVSxJQUFJQSxVQUFVLENBQUNySSxPQUF6QixJQUFvQ3FJLFVBQVUsQ0FBQ3JJLE9BQVgsQ0FBbUIsTUFBbkIsRUFBMkJxSyxLQUEzRTs7QUFFQSxRQUFJQSxLQUFKLEVBQVc7QUFDVCxhQUFPQSxLQUFQO0FBQ0QsS0FOQyxDQVFGOzs7QUFDQSxXQUFPRCxXQUFXLElBQUlBLFdBQVcsQ0FBQ2t6QyxPQUEzQixJQUFzQ2x6QyxXQUFXLENBQUNrekMsT0FBWixDQUFvQixNQUFwQixDQUE3QztBQUNELEdBVkQsQ0FVRSxPQUFPMzlDLENBQVAsRUFBVSxDQUFFO0FBQ2YsQ0FaZSxFQUFoQjs7ZUFjZWdKLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCZjtBQUNBLElBQUk5TixXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FBekI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUloVyxvQkFBb0IsR0FBRzdMLFdBQVcsQ0FBQzhCLFFBQXZDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUzFGLGNBQVQsQ0FBd0I1RSxLQUF4QixFQUErQjtBQUM3QixTQUFPcVUsb0JBQW9CLENBQUNzVixJQUFyQixDQUEwQjNwQixLQUExQixDQUFQO0FBQ0Q7O2VBRWM0RSxjOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU29GLE9BQVQsQ0FBaUI1QyxJQUFqQixFQUF1QjJDLFNBQXZCLEVBQWtDO0FBQ2hDLFNBQU8sVUFBU21oRCxHQUFULEVBQWM7QUFDbkIsV0FBTzlqRCxJQUFJLENBQUMyQyxTQUFTLENBQUNtaEQsR0FBRCxDQUFWLENBQVg7QUFDRCxHQUZEO0FBR0Q7O2VBRWNsaEQsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNkZjs7OztBQUVBO0FBQ0EsSUFBSTRLLFNBQVMsR0FBRzlOLElBQUksQ0FBQytJLEdBQXJCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVMvSCxRQUFULENBQWtCVixJQUFsQixFQUF3QnlOLEtBQXhCLEVBQStCOUssU0FBL0IsRUFBMEM7QUFDeEM4SyxPQUFLLEdBQUdELFNBQVMsQ0FBQ0MsS0FBSyxLQUFLNFgsU0FBVixHQUF1QnJsQixJQUFJLENBQUNtQixNQUFMLEdBQWMsQ0FBckMsR0FBMENzTSxLQUEzQyxFQUFrRCxDQUFsRCxDQUFqQjtBQUNBLFNBQU8sWUFBVztBQUNoQixRQUFJbFUsSUFBSSxHQUFHOFUsU0FBWDtBQUFBLFFBQ0l0TixLQUFLLEdBQUcsQ0FBQyxDQURiO0FBQUEsUUFFSUksTUFBTSxHQUFHcU0sU0FBUyxDQUFDalUsSUFBSSxDQUFDNEgsTUFBTCxHQUFjc00sS0FBZixFQUFzQixDQUF0QixDQUZ0QjtBQUFBLFFBR0k1SyxLQUFLLEdBQUc1RSxLQUFLLENBQUNrRCxNQUFELENBSGpCOztBQUtBLFdBQU8sRUFBRUosS0FBRixHQUFVSSxNQUFqQixFQUF5QjtBQUN2QjBCLFdBQUssQ0FBQzlCLEtBQUQsQ0FBTCxHQUFleEgsSUFBSSxDQUFDa1UsS0FBSyxHQUFHMU0sS0FBVCxDQUFuQjtBQUNEOztBQUNEQSxTQUFLLEdBQUcsQ0FBQyxDQUFUO0FBQ0EsUUFBSTJNLFNBQVMsR0FBR3pQLEtBQUssQ0FBQ3dQLEtBQUssR0FBRyxDQUFULENBQXJCOztBQUNBLFdBQU8sRUFBRTFNLEtBQUYsR0FBVTBNLEtBQWpCLEVBQXdCO0FBQ3RCQyxlQUFTLENBQUMzTSxLQUFELENBQVQsR0FBbUJ4SCxJQUFJLENBQUN3SCxLQUFELENBQXZCO0FBQ0Q7O0FBQ0QyTSxhQUFTLENBQUNELEtBQUQsQ0FBVCxHQUFtQjlLLFNBQVMsQ0FBQ0UsS0FBRCxDQUE1QjtBQUNBLFdBQU8sb0JBQU03QyxJQUFOLEVBQVksSUFBWixFQUFrQjBOLFNBQWxCLENBQVA7QUFDRCxHQWhCRDtBQWlCRDs7ZUFFY2hOLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNmO0FBQ0EsSUFBSTBRLFFBQVEsR0FBRyxrQkFBZjtlQUVlQSxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hmO0FBQ0EsSUFBSUMsVUFBVSxHQUFHLGlCQUFqQjtlQUVlQSxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hmO0FBQ0EsSUFBSXJPLGFBQWEsR0FBRyxrQkFBcEI7ZUFFZUEsYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIZjs7Ozs7O0FBRUE7QUFDQSxJQUFJbkUsUUFBUSxHQUFHLFFBQU9DLElBQVAseUNBQU9BLElBQVAsTUFBZSxRQUFmLElBQTJCQSxJQUEzQixJQUFtQ0EsSUFBSSxDQUFDbEgsTUFBTCxLQUFnQkEsTUFBbkQsSUFBNkRrSCxJQUE1RTtBQUVBOztBQUNBLElBQUlGLElBQUksR0FBR0csdUJBQWNGLFFBQWQsSUFBMEJHLFFBQVEsQ0FBQyxhQUFELENBQVIsRUFBckM7ZUFFZUosSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSZjs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJNkIsV0FBVyxHQUFHLHVCQUFTbU4sd0JBQVQsQ0FBbEI7ZUFFZW5OLFc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYmY7QUFDQSxJQUFJcU4sU0FBUyxHQUFHLEdBQWhCO0FBQUEsSUFDSUMsUUFBUSxHQUFHLEVBRGY7QUFHQTs7QUFDQSxJQUFJQyxTQUFTLEdBQUd0SixJQUFJLENBQUNnK0IsR0FBckI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUy8wQixRQUFULENBQWtCM04sSUFBbEIsRUFBd0I7QUFDdEIsTUFBSWlPLEtBQUssR0FBRyxDQUFaO0FBQUEsTUFDSUMsVUFBVSxHQUFHLENBRGpCO0FBR0EsU0FBTyxZQUFXO0FBQ2hCLFFBQUlDLEtBQUssR0FBR0gsU0FBUyxFQUFyQjtBQUFBLFFBQ0lJLFNBQVMsR0FBR0wsUUFBUSxJQUFJSSxLQUFLLEdBQUdELFVBQVosQ0FEeEI7QUFHQUEsY0FBVSxHQUFHQyxLQUFiOztBQUNBLFFBQUlDLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtBQUNqQixVQUFJLEVBQUVILEtBQUYsSUFBV0gsU0FBZixFQUEwQjtBQUN4QixlQUFPTyxTQUFTLENBQUMsQ0FBRCxDQUFoQjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0xKLFdBQUssR0FBRyxDQUFSO0FBQ0Q7O0FBQ0QsV0FBT2pPLElBQUksQ0FBQ2EsS0FBTCxDQUFXd2tCLFNBQVgsRUFBc0JoWCxTQUF0QixDQUFQO0FBQ0QsR0FiRDtBQWNEOztlQUVjVixROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDZjtBQUNBLElBQUlmLFNBQVMsR0FBRzVOLFFBQVEsQ0FBQ2lrQixTQUF6QjtBQUVBOztBQUNBLElBQUlwVyxZQUFZLEdBQUdELFNBQVMsQ0FBQzFKLFFBQTdCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUzhKLFFBQVQsQ0FBa0JoTixJQUFsQixFQUF3QjtBQUN0QixNQUFJQSxJQUFJLElBQUksSUFBWixFQUFrQjtBQUNoQixRQUFJO0FBQ0YsYUFBTzZNLFlBQVksQ0FBQzBWLElBQWIsQ0FBa0J2aUIsSUFBbEIsQ0FBUDtBQUNELEtBRkQsQ0FFRSxPQUFPa0csQ0FBUCxFQUFVLENBQUU7O0FBQ2QsUUFBSTtBQUNGLGFBQVFsRyxJQUFJLEdBQUcsRUFBZjtBQUNELEtBRkQsQ0FFRSxPQUFPa0csQ0FBUCxFQUFVLENBQUU7QUFDZjs7QUFDRCxTQUFPLEVBQVA7QUFDRDs7ZUFFYzhHLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUluQyxZQUFZLEdBQUcsNkJBQWUsVUFBUy9LLE1BQVQsRUFBaUJzTCxNQUFqQixFQUF5QjI0QyxRQUF6QixFQUFtQzEzQyxVQUFuQyxFQUErQztBQUMvRSwyQkFBV2pCLE1BQVgsRUFBbUIscUJBQU9BLE1BQVAsQ0FBbkIsRUFBbUN0TCxNQUFuQyxFQUEyQ3VNLFVBQTNDO0FBQ0QsQ0FGa0IsQ0FBbkI7ZUFJZXhCLFk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJa0IsT0FBTyxHQUFHLHVCQUFTLFVBQVMvTCxJQUFULEVBQWV6RyxJQUFmLEVBQXFCO0FBQzFDLE1BQUk7QUFDRixXQUFPLG9CQUFNeUcsSUFBTixFQUFZcWxCLFNBQVosRUFBdUI5ckIsSUFBdkIsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPMk0sQ0FBUCxFQUFVO0FBQ1YsV0FBTyxzQkFBUUEsQ0FBUixJQUFhQSxDQUFiLEdBQWlCLElBQUkrb0IsS0FBSixDQUFVL29CLENBQVYsQ0FBeEI7QUFDRDtBQUNGLENBTmEsQ0FBZDtlQVFlNkYsTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOEIsUUFBVCxDQUFrQmpWLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU8sWUFBVztBQUNoQixXQUFPQSxLQUFQO0FBQ0QsR0FGRDtBQUdEOztlQUVjaVYsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMzTyxFQUFULENBQVl0RyxLQUFaLEVBQW1CcUcsS0FBbkIsRUFBMEI7QUFDeEIsU0FBT3JHLEtBQUssS0FBS3FHLEtBQVYsSUFBb0JyRyxLQUFLLEtBQUtBLEtBQVYsSUFBbUJxRyxLQUFLLEtBQUtBLEtBQXhEO0FBQ0Q7O2VBRWNDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENmOztBQUNBOzs7O0FBRUE7QUFDQSxJQUFJcVMsZUFBZSxHQUFHLFVBQXRCO0FBQUEsSUFDSUMsa0JBQWtCLEdBQUdsRyxNQUFNLENBQUNpRyxlQUFlLENBQUNuRyxNQUFqQixDQUQvQjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVNrRyxNQUFULENBQWdCMUcsTUFBaEIsRUFBd0I7QUFDdEJBLFFBQU0sR0FBRyx1QkFBU0EsTUFBVCxDQUFUO0FBQ0EsU0FBUUEsTUFBTSxJQUFJNEcsa0JBQWtCLENBQUM4VyxJQUFuQixDQUF3QjFkLE1BQXhCLENBQVgsR0FDSEEsTUFBTSxDQUFDd2YsT0FBUCxDQUFlN1ksZUFBZixFQUFnQ0UsdUJBQWhDLENBREcsR0FFSDdHLE1BRko7QUFHRDs7ZUFFYzBHLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzNRLFFBQVQsQ0FBa0IvSCxLQUFsQixFQUF5QjtBQUN2QixTQUFPQSxLQUFQO0FBQ0Q7O2VBRWMrSCxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BCZjs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSVMsV0FBVyxHQUFHeEosTUFBTSxDQUFDcXJCLFNBQXpCO0FBRUE7O0FBQ0EsSUFBSTVoQixjQUFjLEdBQUdELFdBQVcsQ0FBQ0MsY0FBakM7QUFFQTs7QUFDQSxJQUFJa04sb0JBQW9CLEdBQUduTixXQUFXLENBQUNtTixvQkFBdkM7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSTlNLFdBQVcsR0FBRyw4QkFBZ0IsWUFBVztBQUFFLFNBQU80TSxTQUFQO0FBQW1CLENBQWhDLEVBQWhCLElBQXNERyx3QkFBdEQsR0FBd0UsVUFBUzVWLEtBQVQsRUFBZ0I7QUFDeEcsU0FBTywyQkFBYUEsS0FBYixLQUF1QnlJLGNBQWMsQ0FBQ2toQixJQUFmLENBQW9CM3BCLEtBQXBCLEVBQTJCLFFBQTNCLENBQXZCLElBQ0wsQ0FBQzJWLG9CQUFvQixDQUFDZ1UsSUFBckIsQ0FBMEIzcEIsS0FBMUIsRUFBaUMsUUFBakMsQ0FESDtBQUVELENBSEQ7ZUFLZTZJLFc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJRixPQUFPLEdBQUd0RCxLQUFLLENBQUNzRCxPQUFwQjtlQUVlQSxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCZjs7QUFDQTs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2xDLFdBQVQsQ0FBcUJ6RyxLQUFyQixFQUE0QjtBQUMxQixTQUFPQSxLQUFLLElBQUksSUFBVCxJQUFpQix1QkFBU0EsS0FBSyxDQUFDdUksTUFBZixDQUFqQixJQUEyQyxDQUFDLHlCQUFXdkksS0FBWCxDQUFuRDtBQUNEOztlQUVjeUcsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ2Y7O0FBQ0E7Ozs7OztBQUVBO0FBQ0EsSUFBSXFQLFdBQVcsR0FBRyw4QkFBT0MsT0FBUCxNQUFrQixRQUFsQixJQUE4QkEsT0FBOUIsSUFBeUMsQ0FBQ0EsT0FBTyxDQUFDa2pDLFFBQWxELElBQThEbGpDLE9BQWhGO0FBRUE7O0FBQ0EsSUFBSUMsVUFBVSxHQUFHRixXQUFXLElBQUksOEJBQU8zUyxNQUFQLE1BQWlCLFFBQWhDLElBQTRDQSxNQUE1QyxJQUFzRCxDQUFDQSxNQUFNLENBQUM4MUMsUUFBOUQsSUFBMEU5MUMsTUFBM0Y7QUFFQTs7QUFDQSxJQUFJOFMsYUFBYSxHQUFHRCxVQUFVLElBQUlBLFVBQVUsQ0FBQ0QsT0FBWCxLQUF1QkQsV0FBekQ7QUFFQTs7QUFDQSxJQUFJSSxNQUFNLEdBQUdELGFBQWEsR0FBR2pRLGNBQUtrUSxNQUFSLEdBQWlCdVcsU0FBM0M7QUFFQTs7QUFDQSxJQUFJdFcsY0FBYyxHQUFHRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ25OLFFBQVYsR0FBcUIwakIsU0FBaEQ7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUkxakIsUUFBUSxHQUFHb04sY0FBYyxJQUFJQyxrQkFBakM7ZUFFZXJOLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDZjs7QUFDQTs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSVksU0FBUyxHQUFHLHVCQUFoQjtBQUFBLElBQ0lDLFFBQVEsR0FBRyxnQkFEZjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTRSxPQUFULENBQWlCOUosS0FBakIsRUFBd0I7QUFDdEIsTUFBSSxDQUFDLDJCQUFhQSxLQUFiLENBQUwsRUFBMEI7QUFDeEIsV0FBTyxLQUFQO0FBQ0Q7O0FBQ0QsTUFBSTBILEdBQUcsR0FBRyx5QkFBVzFILEtBQVgsQ0FBVjtBQUNBLFNBQU8wSCxHQUFHLElBQUlrQyxRQUFQLElBQW1CbEMsR0FBRyxJQUFJaUMsU0FBMUIsSUFDSixPQUFPM0osS0FBSyxDQUFDNnNCLE9BQWIsSUFBd0IsUUFBeEIsSUFBb0MsT0FBTzdzQixLQUFLLENBQUNtQixJQUFiLElBQXFCLFFBQXpELElBQXFFLENBQUMsNEJBQWNuQixLQUFkLENBRHpFO0FBRUQ7O2VBRWM4SixPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25DZjs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSXhDLFFBQVEsR0FBRyx3QkFBZjtBQUFBLElBQ0lDLE9BQU8sR0FBRyxtQkFEZDtBQUFBLElBRUlDLE1BQU0sR0FBRyw0QkFGYjtBQUFBLElBR0lDLFFBQVEsR0FBRyxnQkFIZjtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU2pCLFVBQVQsQ0FBb0J4RyxLQUFwQixFQUEyQjtBQUN6QixNQUFJLENBQUMsdUJBQVNBLEtBQVQsQ0FBTCxFQUFzQjtBQUNwQixXQUFPLEtBQVA7QUFDRCxHQUh3QixDQUl6QjtBQUNBOzs7QUFDQSxNQUFJMEgsR0FBRyxHQUFHLHlCQUFXMUgsS0FBWCxDQUFWO0FBQ0EsU0FBTzBILEdBQUcsSUFBSUgsT0FBUCxJQUFrQkcsR0FBRyxJQUFJRixNQUF6QixJQUFtQ0UsR0FBRyxJQUFJSixRQUExQyxJQUFzREksR0FBRyxJQUFJRCxRQUFwRTtBQUNEOztlQUVjakIsVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ2Y7QUFDQSxJQUFJNkIsZ0JBQWdCLEdBQUcsZ0JBQXZCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTOUIsUUFBVCxDQUFrQnZHLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU8sT0FBT0EsS0FBUCxJQUFnQixRQUFoQixJQUNMQSxLQUFLLEdBQUcsQ0FBQyxDQURKLElBQ1NBLEtBQUssR0FBRyxDQUFSLElBQWEsQ0FEdEIsSUFDMkJBLEtBQUssSUFBSXFJLGdCQUQzQztBQUVEOztlQUVjOUIsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNSLFFBQVQsQ0FBa0IvRixLQUFsQixFQUF5QjtBQUN2QixNQUFJOEYsSUFBSSxXQUFVOUYsS0FBVixDQUFSOztBQUNBLFNBQU9BLEtBQUssSUFBSSxJQUFULEtBQWtCOEYsSUFBSSxJQUFJLFFBQVIsSUFBb0JBLElBQUksSUFBSSxVQUE5QyxDQUFQO0FBQ0Q7O2VBRWNDLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU2pCLFlBQVQsQ0FBc0I5RSxLQUF0QixFQUE2QjtBQUMzQixTQUFPQSxLQUFLLElBQUksSUFBVCxJQUFpQixRQUFPQSxLQUFQLEtBQWdCLFFBQXhDO0FBQ0Q7O2VBRWM4RSxZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCZjs7QUFDQTs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSWdTLFNBQVMsR0FBRyxpQkFBaEI7QUFFQTs7QUFDQSxJQUFJOUMsU0FBUyxHQUFHNU4sUUFBUSxDQUFDaWtCLFNBQXpCO0FBQUEsSUFDSTdoQixXQUFXLEdBQUd4SixNQUFNLENBQUNxckIsU0FEekI7QUFHQTs7QUFDQSxJQUFJcFcsWUFBWSxHQUFHRCxTQUFTLENBQUMxSixRQUE3QjtBQUVBOztBQUNBLElBQUk3QixjQUFjLEdBQUdELFdBQVcsQ0FBQ0MsY0FBakM7QUFFQTs7QUFDQSxJQUFJMFAsZ0JBQWdCLEdBQUdsRSxZQUFZLENBQUMwVixJQUFiLENBQWtCM3FCLE1BQWxCLENBQXZCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBUzZLLGFBQVQsQ0FBdUI3SixLQUF2QixFQUE4QjtBQUM1QixNQUFJLENBQUMsMkJBQWFBLEtBQWIsQ0FBRCxJQUF3Qix5QkFBV0EsS0FBWCxLQUFxQjhXLFNBQWpELEVBQTREO0FBQzFELFdBQU8sS0FBUDtBQUNEOztBQUNELE1BQUlyTixLQUFLLEdBQUcsMkJBQWF6SixLQUFiLENBQVo7O0FBQ0EsTUFBSXlKLEtBQUssS0FBSyxJQUFkLEVBQW9CO0FBQ2xCLFdBQU8sSUFBUDtBQUNEOztBQUNELE1BQUlELElBQUksR0FBR2YsY0FBYyxDQUFDa2hCLElBQWYsQ0FBb0JsZ0IsS0FBcEIsRUFBMkIsYUFBM0IsS0FBNkNBLEtBQUssQ0FBQ3RKLFdBQTlEO0FBQ0EsU0FBTyxPQUFPcUosSUFBUCxJQUFlLFVBQWYsSUFBNkJBLElBQUksWUFBWUEsSUFBN0MsSUFDTHlLLFlBQVksQ0FBQzBWLElBQWIsQ0FBa0JuZ0IsSUFBbEIsS0FBMkIyTyxnQkFEN0I7QUFFRDs7ZUFFY3RPLGE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0RmOztBQUNBOzs7Ozs7QUFFQTtBQUNBLElBQUl1UCxTQUFTLEdBQUcsaUJBQWhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTRCxRQUFULENBQWtCblosS0FBbEIsRUFBeUI7QUFDdkIsU0FBTyxRQUFPQSxLQUFQLEtBQWdCLFFBQWhCLElBQ0osMkJBQWFBLEtBQWIsS0FBdUIseUJBQVdBLEtBQVgsS0FBcUJvWixTQUQvQztBQUVEOztlQUVjRCxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVCZjs7QUFDQTs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSTlDLGdCQUFnQixHQUFHQyxxQkFBWUEsa0JBQVNyTixZQUE1QztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsWUFBWSxHQUFHb04sZ0JBQWdCLEdBQUcsd0JBQVVBLGdCQUFWLENBQUgsR0FBaUNHLHlCQUFwRTtlQUVldk4sWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQmY7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVN4SixJQUFULENBQWN5SCxNQUFkLEVBQXNCO0FBQ3BCLFNBQU8sMEJBQVlBLE1BQVosSUFBc0IsNEJBQWNBLE1BQWQsQ0FBdEIsR0FBOEMsdUJBQVNBLE1BQVQsQ0FBckQ7QUFDRDs7ZUFFY3pILEk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENmOztBQUNBOztBQUNBOzs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM2VCxNQUFULENBQWdCcE0sTUFBaEIsRUFBd0I7QUFDdEIsU0FBTywwQkFBWUEsTUFBWixJQUFzQiw0QkFBY0EsTUFBZCxFQUFzQixJQUF0QixDQUF0QixHQUFvRCx5QkFBV0EsTUFBWCxDQUEzRDtBQUNEOztlQUVjb00sTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOEMsU0FBVCxHQUFxQjtBQUNuQixTQUFPLEtBQVA7QUFDRDs7ZUFFY0EsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQmY7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTtBQUNBLElBQUk3RSxvQkFBb0IsR0FBRyxnQkFBM0I7QUFBQSxJQUNJQyxtQkFBbUIsR0FBRyxvQkFEMUI7QUFBQSxJQUVJQyxxQkFBcUIsR0FBRywrQkFGNUI7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxZQUFZLEdBQUcsaUNBQW5CO0FBRUE7O0FBQ0EsSUFBSUMsU0FBUyxHQUFHLE1BQWhCO0FBRUE7O0FBQ0EsSUFBSUMsaUJBQWlCLEdBQUcsd0JBQXhCO0FBRUE7O0FBQ0EsSUFBSXBKLFdBQVcsR0FBR3hKLE1BQU0sQ0FBQ3FyQixTQUF6QjtBQUVBOztBQUNBLElBQUk1aEIsY0FBYyxHQUFHRCxXQUFXLENBQUNDLGNBQWpDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTNkksUUFBVCxDQUFrQlUsTUFBbEIsRUFBMEJwRSxPQUExQixFQUFtQ21FLEtBQW5DLEVBQTBDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQUlGLFFBQVEsR0FBR0MsMEJBQWlCSyxPQUFqQixDQUF5Qjg3QixDQUF6QixDQUEyQm44QixnQkFBM0IsSUFBK0NBLHlCQUE5RDs7QUFFQSxNQUFJQyxLQUFLLElBQUksNkJBQWVDLE1BQWYsRUFBdUJwRSxPQUF2QixFQUFnQ21FLEtBQWhDLENBQWIsRUFBcUQ7QUFDbkRuRSxXQUFPLEdBQUc2ZSxTQUFWO0FBQ0Q7O0FBQ0R6YSxRQUFNLEdBQUcsdUJBQVNBLE1BQVQsQ0FBVDtBQUNBcEUsU0FBTyxHQUFHLDJCQUFhLEVBQWIsRUFBaUJBLE9BQWpCLEVBQTBCaUUsUUFBMUIsRUFBb0NLLCtCQUFwQyxDQUFWO0FBRUEsTUFBSUMsT0FBTyxHQUFHLDJCQUFhLEVBQWIsRUFBaUJ2RSxPQUFPLENBQUN1RSxPQUF6QixFQUFrQ04sUUFBUSxDQUFDTSxPQUEzQyxFQUFvREQsK0JBQXBELENBQWQ7QUFBQSxNQUNJRSxXQUFXLEdBQUcsbUJBQUtELE9BQUwsQ0FEbEI7QUFBQSxNQUVJRSxhQUFhLEdBQUcseUJBQVdGLE9BQVgsRUFBb0JDLFdBQXBCLENBRnBCO0FBSUEsTUFBSVUsVUFBSjtBQUFBLE1BQ0lDLFlBREo7QUFBQSxNQUVJNUssS0FBSyxHQUFHLENBRlo7QUFBQSxNQUdJb0ssV0FBVyxHQUFHM0UsT0FBTyxDQUFDMkUsV0FBUixJQUF1QlosU0FIekM7QUFBQSxNQUlJYSxNQUFNLEdBQUcsVUFKYixDQWhCd0MsQ0FzQnhDOztBQUNBLE1BQUlDLFlBQVksR0FBR0MsTUFBTSxDQUN2QixDQUFDOUUsT0FBTyxDQUFDOEssTUFBUixJQUFrQi9HLFNBQW5CLEVBQThCYSxNQUE5QixHQUF1QyxHQUF2QyxHQUNBRCxXQUFXLENBQUNDLE1BRFosR0FDcUIsR0FEckIsR0FFQSxDQUFDRCxXQUFXLEtBQUtuSSxzQkFBaEIsR0FBZ0NzSCxZQUFoQyxHQUErQ0MsU0FBaEQsRUFBMkRhLE1BRjNELEdBRW9FLEdBRnBFLEdBR0EsQ0FBQzVFLE9BQU8sQ0FBQ3c5QyxRQUFSLElBQW9CejVDLFNBQXJCLEVBQWdDYSxNQUhoQyxHQUd5QyxJQUpsQixFQUt2QixHQUx1QixDQUF6QixDQXZCd0MsQ0E4QnhDO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUlHLFNBQVMsR0FBR2xLLGNBQWMsQ0FBQ2toQixJQUFmLENBQW9CL2IsT0FBcEIsRUFBNkIsV0FBN0IsSUFDWCxtQkFDQSxDQUFDQSxPQUFPLENBQUMrRSxTQUFSLEdBQW9CLEVBQXJCLEVBQXlCNmUsT0FBekIsQ0FBaUMsU0FBakMsRUFBNEMsR0FBNUMsQ0FEQSxHQUVBLElBSFcsR0FJWixFQUpKO0FBTUF4ZixRQUFNLENBQUN3ZixPQUFQLENBQWUvZSxZQUFmLEVBQTZCLFVBQVNRLEtBQVQsRUFBZ0JvNEMsV0FBaEIsRUFBNkJ6NEMsZ0JBQTdCLEVBQStDMDRDLGVBQS9DLEVBQWdFQyxhQUFoRSxFQUErRXY0QyxNQUEvRSxFQUF1RjtBQUNsSEosb0JBQWdCLEtBQUtBLGdCQUFnQixHQUFHMDRDLGVBQXhCLENBQWhCLENBRGtILENBR2xIOztBQUNBOTRDLFVBQU0sSUFBSVIsTUFBTSxDQUFDMmtCLEtBQVAsQ0FBYXh1QixLQUFiLEVBQW9CNkssTUFBcEIsRUFBNEJ3ZSxPQUE1QixDQUFvQzVmLGlCQUFwQyxFQUF1RGlCLHlCQUF2RCxDQUFWLENBSmtILENBTWxIOztBQUNBLFFBQUl3NEMsV0FBSixFQUFpQjtBQUNmdjRDLGdCQUFVLEdBQUcsSUFBYjtBQUNBTixZQUFNLElBQUksY0FBYzY0QyxXQUFkLEdBQTRCLFFBQXRDO0FBQ0Q7O0FBQ0QsUUFBSUUsYUFBSixFQUFtQjtBQUNqQng0QyxrQkFBWSxHQUFHLElBQWY7QUFDQVAsWUFBTSxJQUFJLFNBQVMrNEMsYUFBVCxHQUF5QixhQUFuQztBQUNEOztBQUNELFFBQUkzNEMsZ0JBQUosRUFBc0I7QUFDcEJKLFlBQU0sSUFBSSxtQkFBbUJJLGdCQUFuQixHQUFzQyw2QkFBaEQ7QUFDRDs7QUFDRHpLLFNBQUssR0FBRzZLLE1BQU0sR0FBR0MsS0FBSyxDQUFDMUssTUFBdkIsQ0FsQmtILENBb0JsSDtBQUNBOztBQUNBLFdBQU8wSyxLQUFQO0FBQ0QsR0F2QkQ7QUF5QkFULFFBQU0sSUFBSSxNQUFWLENBakV3QyxDQW1FeEM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsTUFBSVUsUUFBUSxHQUFHekssY0FBYyxDQUFDa2hCLElBQWYsQ0FBb0IvYixPQUFwQixFQUE2QixVQUE3QixLQUE0Q0EsT0FBTyxDQUFDc0YsUUFBbkU7O0FBQ0EsTUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYlYsVUFBTSxHQUFHLG1CQUFtQkEsTUFBbkIsR0FBNEIsT0FBckM7QUFDRCxHQTFFdUMsQ0EyRXhDOzs7QUFDQUEsUUFBTSxHQUFHLENBQUNPLFlBQVksR0FBR1AsTUFBTSxDQUFDZ2YsT0FBUCxDQUFlamdCLG9CQUFmLEVBQXFDLEVBQXJDLENBQUgsR0FBOENpQixNQUEzRCxFQUNOZ2YsT0FETSxDQUNFaGdCLG1CQURGLEVBQ3VCLElBRHZCLEVBRU5nZ0IsT0FGTSxDQUVFL2YscUJBRkYsRUFFeUIsS0FGekIsQ0FBVCxDQTVFd0MsQ0FnRnhDOztBQUNBZSxRQUFNLEdBQUcsZUFBZVUsUUFBUSxJQUFJLEtBQTNCLElBQW9DLE9BQXBDLElBQ05BLFFBQVEsR0FDTCxFQURLLEdBRUwsc0JBSEcsSUFLUCxtQkFMTyxJQU1OSixVQUFVLEdBQ04sa0JBRE0sR0FFTixFQVJFLEtBVU5DLFlBQVksR0FDVCxvQ0FDQSx1REFGUyxHQUdULEtBYkcsSUFlUFAsTUFmTyxHQWdCUCxlQWhCRjtBQWtCQSxNQUFJckosTUFBTSxHQUFHLHNCQUFRLFlBQVc7QUFDOUIsV0FBTy9DLFFBQVEsQ0FBQ2dNLFdBQUQsRUFBY08sU0FBUyxHQUFHLFNBQVosR0FBd0JILE1BQXRDLENBQVIsQ0FDSnZLLEtBREksQ0FDRXdrQixTQURGLEVBQ2FwYSxhQURiLENBQVA7QUFFRCxHQUhZLENBQWIsQ0FuR3dDLENBd0d4QztBQUNBOztBQUNBbEosUUFBTSxDQUFDcUosTUFBUCxHQUFnQkEsTUFBaEI7O0FBQ0EsTUFBSSxzQkFBUXJKLE1BQVIsQ0FBSixFQUFxQjtBQUNuQixVQUFNQSxNQUFOO0FBQ0Q7O0FBQ0QsU0FBT0EsTUFBUDtBQUNEOztlQUVjbUksUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1UGY7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJUSxnQkFBZ0IsR0FBRztBQUVyQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxZQUFVMEcsaUJBUlc7O0FBVXJCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGNBQVlDLG1CQWhCUzs7QUFrQnJCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGlCQUFlck8sc0JBeEJNOztBQTBCckI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsY0FBWSxFQWhDUzs7QUFrQ3JCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLGFBQVc7QUFFVDtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSSxTQUFLO0FBQUUsZ0JBQVVzTztBQUFaO0FBUkk7QUF4Q1UsQ0FBdkI7ZUFvRGU1RyxnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRWY7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTeEgsUUFBVCxDQUFrQnRLLEtBQWxCLEVBQXlCO0FBQ3ZCLFNBQU9BLEtBQUssSUFBSSxJQUFULEdBQWdCLEVBQWhCLEdBQXFCLDJCQUFhQSxLQUFiLENBQTVCO0FBQ0Q7O2VBRWNzSyxROzs7Ozs7Ozs7Ozs7QUMzQmYsdUNBQXVDLDRCQUE0QixlQUFlLGtCQUFrQix1QkFBdUIsdUJBQXVCLGVBQWUsNEJBQTRCLDRCQUE0QixtQkFBbUIsY0FBYyxvQkFBb0Isc0JBQXNCLHVCQUF1Qix1QkFBdUIscUJBQXFCLG1DQUFtQyxtQ0FBbUMsbUNBQW1DLG1DQUFtQyxxQkFBcUIsMEhBQTBILDBIQUEwSCxHQUFHLHlEQUF5RCxlQUFlLHNCQUFzQix3QkFBd0IsR0FBRyw0QkFBNEIsMEJBQTBCLG1CQUFtQixHQUFHLG9DQUFvQyx5RUFBeUUseUVBQXlFLEdBQUcsOEJBQThCLG1CQUFtQix1QkFBdUIsYUFBYSxHQUFHLDhCQUE4Qix1QkFBdUIsMEJBQTBCLEdBQUcsbUNBQW1DLGlCQUFpQixtQkFBbUIsR0FBRyxzSEFBc0gsd0NBQXdDLHdDQUF3QyxHQUFHLHNIQUFzSCwwREFBMEQsMERBQTBELEdBQUcsNEZBQTRGLHFCQUFxQixrQ0FBa0MsaUNBQWlDLEdBQUcsK0NBQStDLG1CQUFtQixHQUFHLCtDQUErQyxpQkFBaUIsa0NBQWtDLEdBQUcsMERBQTBELGlCQUFpQixHQUFHLDBEQUEwRCx1QkFBdUIsbUJBQW1CLHlCQUF5Qiw4QkFBOEIsZ0JBQWdCLGNBQWMsYUFBYSxlQUFlLEdBQUcsNkpBQTZKLGVBQWUsZ0JBQWdCLEdBQUcsa0ZBQWtGLGNBQWMsZUFBZSxHQUFHLDhCQUE4QixzQkFBc0IsbUJBQW1CLEdBQUcsNkJBQTZCLHNCQUFzQixtQkFBbUIsR0FBRyw0RUFBNEUsaUJBQWlCLEdBQUcsdUNBQXVDLGlDQUFpQyxHQUFHLHNDQUFzQyw4QkFBOEIsR0FBRyxrRkFBa0YsY0FBYyxHQUFHLDBDQUEwQyw4QkFBOEIsR0FBRyx5Q0FBeUMsMkJBQTJCLEdBQUcsNkJBQTZCLGVBQWUsR0FBRyxzQkFBc0IsdUJBQXVCLDBCQUEwQixHQUFHLHFCQUFxQix5QkFBeUIsMEJBQTBCLHlCQUF5QixrQkFBa0IsR0FBRyxzQ0FBc0MsNEJBQTRCLDJCQUEyQiwwQkFBMEIsaUJBQWlCLG1CQUFtQix1QkFBdUIsdUJBQXVCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QixxQkFBcUIsd0JBQXdCLG9CQUFvQixvQkFBb0Isb0JBQW9CLEdBQUcscUZBQXFGLDBCQUEwQixvQkFBb0IsdUJBQXVCLFdBQVcsaUJBQWlCLGtCQUFrQixlQUFlLDJCQUEyQiwwQkFBMEIsR0FBRywySEFBMkgsa0JBQWtCLEdBQUcseUZBQXlGLHVCQUF1QixHQUFHLCtIQUErSCwwREFBMEQsK0NBQStDLDZMQUE2TCwyREFBMkQsK0NBQStDLCtKQUErSixtQkFBbUIsR0FBRyx5R0FBeUcsa0JBQWtCLEdBQUcsNkZBQTZGLGdCQUFnQixpQkFBaUIsR0FBRyx1R0FBdUcsa0NBQWtDLDBCQUEwQixrQkFBa0IsR0FBRyxvQkFBb0IsdUJBQXVCLGlCQUFpQixHQUFHLGtEQUFrRCwwQkFBMEIsR0FBRywwQkFBMEIsZ0JBQWdCLEdBQUcscUNBQXFDLGtCQUFrQixHQUFHLHlHQUF5RyxjQUFjLDZCQUE2QixHQUFHLHlCQUF5Qix1QkFBdUIsYUFBYSxnQkFBZ0IseUJBQXlCLGdCQUFnQixxQkFBcUIsZUFBZSxvQkFBb0IsMENBQTBDLG1DQUFtQyxtQ0FBbUMsR0FBRywrQkFBK0IsZ0NBQWdDLEdBQUcsZ0NBQWdDLGdDQUFnQyxHQUFHLCtCQUErQixtQkFBbUIsa0JBQWtCLHVCQUF1QixHQUFHLGlDQUFpQyxXQUFXLHFCQUFxQixHQUFHLHVDQUF1Qyx1Q0FBdUMsd0NBQXdDLGdEQUFnRCxhQUFhLEdBQUcsbUNBQW1DLGFBQWEsR0FBRyx5Q0FBeUMsdUNBQXVDLHdDQUF3Qyw2Q0FBNkMsYUFBYSxHQUFHLDZCQUE2QixtQkFBbUIsaUJBQWlCLEdBQUcsa0NBQWtDLDBCQUEwQixHQUFHLDBCQUEwQixpQ0FBaUMsR0FBRywrQkFBK0IsZUFBZSxHQUFHLDRCQUE0QixvQkFBb0IseUJBQXlCLHFCQUFxQixtQkFBbUIsdUJBQXVCLGVBQWUsZ0JBQWdCLDBCQUEwQixtQkFBbUIsaUJBQWlCLDBCQUEwQix1QkFBdUIsa0RBQWtELGtEQUFrRCxHQUFHLDJDQUEyQyx5QkFBeUIscUJBQXFCLG1CQUFtQiwwQkFBMEIsdUJBQXVCLGVBQWUsR0FBRyxpREFBaUQsaUNBQWlDLEdBQUcsNkNBQTZDLGVBQWUsa0JBQWtCLDBCQUEwQixHQUFHLGdFQUFnRSx5Q0FBeUMsR0FBRyxrRUFBa0Usc0NBQXNDLEdBQUcsMkNBQTJDLDRCQUE0QixtQ0FBbUMsbUNBQW1DLG1CQUFtQixpQkFBaUIseUJBQXlCLGNBQWMsMEJBQTBCLHVCQUF1Qix5QkFBeUIscUJBQXFCLHlCQUF5QixpQkFBaUIsY0FBYyxxQkFBcUIsNEJBQTRCLGtDQUFrQywrQkFBK0IsMEJBQTBCLEdBQUcsaURBQWlELGVBQWUsR0FBRywrR0FBK0csb0JBQW9CLDJCQUEyQiw0QkFBNEIseUJBQXlCLEdBQUcsNERBQTRELHlCQUF5Qiw0QkFBNEIsaUJBQWlCLHFCQUFxQiwyQkFBMkIsbUJBQW1CLG9CQUFvQix1QkFBdUIseUJBQXlCLHFCQUFxQixpQkFBaUIseUJBQXlCLHVCQUF1QixrQkFBa0IseUJBQXlCLHVCQUF1Qiw0QkFBNEIsbUNBQW1DLGlDQUFpQyw4QkFBOEIsZ0JBQWdCLEdBQUcsb0lBQW9JLGtCQUFrQixHQUFHLGtFQUFrRSxpQ0FBaUMsR0FBRywyRkFBMkYsa0NBQWtDLGtCQUFrQixlQUFlLEdBQUcsdUJBQXVCLDRCQUE0Qix1QkFBdUIscUJBQXFCLGdCQUFnQix5QkFBeUIsMEJBQTBCLHlCQUF5QixrQkFBa0IsOEJBQThCLGdDQUFnQywrQkFBK0IsZ0NBQWdDLGlCQUFpQixHQUFHLG1EQUFtRCx5QkFBeUIsMEJBQTBCLHlCQUF5QixrQkFBa0Isd0JBQXdCLG9CQUFvQixvQkFBb0Isb0JBQW9CLEdBQUcsMEJBQTBCLG9CQUFvQixtQkFBbUIsNEJBQTRCLDRCQUE0QixtQkFBbUIsY0FBYyx1QkFBdUIsbUJBQW1CLHdCQUF3QixvQkFBb0Isb0JBQW9CLG9CQUFvQix3QkFBd0IsR0FBRyxvQ0FBb0MsdUJBQXVCLEdBQUcsbUJBQW1CLHVCQUF1QixxQkFBcUIseUJBQXlCLDBCQUEwQix5QkFBeUIsa0JBQWtCLDZCQUE2QixvQ0FBb0MsOEJBQThCLG9DQUFvQyxxQkFBcUIsR0FBRyx5QkFBeUIsZUFBZSxHQUFHLGlCQUFpQixlQUFlLGVBQWUscUJBQXFCLHFCQUFxQix5QkFBeUIseUJBQXlCLG1DQUFtQyxtQ0FBbUMsMEJBQTBCLHlCQUF5Qix5QkFBeUIsMEJBQTBCLGtCQUFrQiw0QkFBNEIsNEJBQTRCLHdCQUF3QiwyQkFBMkIsMENBQTBDLDBDQUEwQyxrREFBa0Qsa0RBQWtELGVBQWUsR0FBRyxpQ0FBaUMseUNBQXlDLHlDQUF5QyxHQUFHLGtCQUFrQixxQkFBcUIsa0NBQWtDLHlCQUF5QixtQ0FBbUMsbUNBQW1DLG1CQUFtQixvQkFBb0IscUJBQXFCLHVCQUF1QixvQ0FBb0MsNkNBQTZDLG9DQUFvQyxvQkFBb0IsaUJBQWlCLHNCQUFzQixjQUFjLDBCQUEwQix1QkFBdUIsNkJBQTZCLG9DQUFvQyw4QkFBOEIsb0NBQW9DLHVCQUF1QixHQUFHLDJaQUEyWixvQkFBb0IsZUFBZSx3QkFBd0IsMEJBQTBCLEdBQUcsd0JBQXdCLDBCQUEwQixHQUFHLDJEQUEyRCwwQkFBMEIsd0JBQXdCLGdCQUFnQixHQUFHLDJtQkFBMm1CLHdCQUF3Qiw2QkFBNkIsNkJBQTZCLGdCQUFnQiwwQkFBMEIsR0FBRyxrSEFBa0gsaUNBQWlDLEdBQUcsNEdBQTRHLGlDQUFpQyxHQUFHLHdOQUF3TiwwQ0FBMEMsMENBQTBDLEdBQUcsNklBQTZJLHdCQUF3QixHQUFHLDBCQUEwQixxQkFBcUIsMERBQTBELDBEQUEwRCxHQUFHLHlQQUF5UCw4QkFBOEIsNEJBQTRCLDhCQUE4QixvQkFBb0IsR0FBRywrRUFBK0Usd0JBQXdCLDhCQUE4QixHQUFHLGdDQUFnQyxxQkFBcUIsMERBQTBELDBEQUEwRCxHQUFHLHlCQUF5Qix1QkFBdUIsR0FBRyw2QkFBNkIsb0JBQW9CLEdBQUcsMEJBQTBCLGdCQUFnQixHQUFHLDJDQUEyQyxvQkFBb0Isd0NBQXdDLHdDQUF3QyxHQUFHLDZDQUE2QyxnQkFBZ0IsZ0JBQWdCLHNCQUFzQixHQUFHLCtGQUErRixtQkFBbUIsZ0JBQWdCLG9CQUFvQiw4QkFBOEIsNEJBQTRCLG9CQUFvQixpQkFBaUIsR0FBRyw2QkFBNkIsbUJBQW1CLHlCQUF5QiwwQkFBMEIseUJBQXlCLGtCQUFrQixtQ0FBbUMsbUNBQW1DLHFCQUFxQixHQUFHLHlCQUF5QiwwQkFBMEIsZUFBZSxtQ0FBbUMsbUNBQW1DLEdBQUcsbUJBQW1CLHVCQUF1QixlQUFlLG1CQUFtQixjQUFjLHNCQUFzQixxQkFBcUIsbUNBQW1DLG1DQUFtQyxxQkFBcUIseUJBQXlCLDBCQUEwQix5QkFBeUIsa0JBQWtCLEdBQUcseUJBQXlCLGtCQUFrQixtQkFBbUIsZ0JBQWdCLEdBQUcsb0NBQW9DLHdCQUF3QixvQkFBb0Isb0JBQW9CLG9CQUFvQixlQUFlLGlCQUFpQixnQkFBZ0IsR0FBRyx1REFBdUQsaUNBQWlDLEdBQUcseURBQXlELDhCQUE4QixHQUFHLCtDQUErQyxlQUFlLEdBQUcsNkNBQTZDLGVBQWUsR0FBRyx5QkFBeUIsNEJBQTRCLDZCQUE2Qiw2QkFBNkIsY0FBYyxxQkFBcUIsdUJBQXVCLGNBQWMsZUFBZSxvQkFBb0IseUJBQXlCLG1CQUFtQixvQkFBb0IsdUJBQXVCLG1DQUFtQyxtQ0FBbUMsa0NBQWtDLCtCQUErQiwwQkFBMEIsR0FBRyx3Q0FBd0Msc0JBQXNCLEdBQUcsbUZBQW1GLHFCQUFxQixHQUFHLCtCQUErQixlQUFlLGNBQWMsR0FBRyxnRkFBZ0Ysb0JBQW9CLGdCQUFnQix5QkFBeUIsbUJBQW1CLHNCQUFzQixjQUFjLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4QiwrQkFBK0Isb0NBQW9DLCtCQUErQixHQUFHLG9DQUFvQyxlQUFlLGVBQWUsb0JBQW9CLHVCQUF1QixxQkFBcUIsR0FBRywrSUFBK0kscUJBQXFCLEdBQUcsOEJBQThCLG9CQUFvQixHQUFHLG1DQUFtQyxVQUFVLGlCQUFpQixrREFBa0Qsa0RBQWtELEtBQUssUUFBUSxpQkFBaUIsOENBQThDLDhDQUE4QyxLQUFLLEdBQUcsMkJBQTJCLFVBQVUsaUJBQWlCLGtEQUFrRCxrREFBa0QsS0FBSyxRQUFRLGlCQUFpQiw4Q0FBOEMsOENBQThDLEtBQUssR0FBRyxHOzs7Ozs7Ozs7OztBQ0F2Mm1CLDBYQUEwWCx3QkFBd0IsNEJBQTRCLDZCQUE2Qix3Q0FBd0MsMEJBQTBCLHNCQUFzQixzQkFBc0IsS0FBSyxnSUFBZ0kseUJBQXlCLCtCQUErQixnQ0FBZ0Msc0NBQXNDLDBCQUEwQixzQkFBc0Isc0JBQXNCLEtBQUssd0ZBQXdGLDBCQUEwQixLQUFLLDBHQUEwRyxrQkFBa0IsbUJBQW1CLEtBQUssd0RBQXdELCtCQUErQixnQ0FBZ0Msc0NBQXNDLEtBQUssdURBQXVELDhCQUE4QiwrQkFBK0IscUNBQXFDLEtBQUssMERBQTBELHFDQUFxQyxxQ0FBcUMsMENBQTBDLDBDQUEwQyxLQUFLLDJEQUEyRCwyQkFBMkIsMkJBQTJCLG9CQUFvQiwrQkFBK0IsZ0NBQWdDLHNDQUFzQyxLQUFLLDBEQUEwRCxvQ0FBb0MsS0FBSyxzSEFBc0gscUNBQXFDLG9DQUFvQyxrQ0FBa0Msa0NBQWtDLEtBQUsscUJBQXFCLHlCQUF5Qix1QkFBdUIsMkJBQTJCLHFDQUFxQyw2QkFBNkIsMkJBQTJCLG9CQUFvQix3Q0FBd0MsZ0NBQWdDLEtBQUssMkJBQTJCLDhCQUE4QixzREFBc0Qsc0RBQXNELEtBQUssMEJBQTBCLGdDQUFnQywwQ0FBMEMsMENBQTBDLG1CQUFtQixLQUFLLEs7Ozs7Ozs7Ozs7O0FDQXYzRixvREFBb0Qsd0JBQXdCLHFGQUFxRix5QkFBeUIsbURBQW1ELHFCQUFxQixvQkFBb0IsS0FBSyx5S0FBeUsseURBQXlELEtBQUssMkhBQTJILDREQUE0RCxLQUFLLHVCQUF1Qix5REFBeUQsb0JBQW9CLHFDQUFxQyxxQ0FBcUMscUZBQXFGLG9CQUFvQix5QkFBeUIsZ0NBQWdDLGlDQUFpQyxxQkFBcUIsMERBQTBELDBEQUEwRCxLQUFLLDRCQUE0Qiw0REFBNEQsb0VBQW9FLEtBQUsseUNBQXlDLHVCQUF1Qix1QkFBdUIsd0JBQXdCLEtBQUssOENBQThDLHNEQUFzRCxLQUFLLHdDQUF3QyxvQkFBb0Isc0JBQXNCLEtBQUssOENBQThDLDJFQUEyRSxLQUFLLGlEQUFpRCw4R0FBOEcsS0FBSyw4QkFBOEIsdUJBQXVCLEtBQUssbUNBQW1DLGlEQUFpRCxpREFBaUQsS0FBSyxxQ0FBcUMsaURBQWlELGlEQUFpRCxLQUFLLEs7Ozs7Ozs7Ozs7O0FDQXB3RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyx1REFBUTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7O0FBRUEsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZCxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7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Q0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxzR0FBbUQ7O0FBRXhFOztBQUVBLEdBQUcsS0FBVSxFQUFFLEUiLCJmaWxlIjoiYmJqLWdyaWQtd2lkZ2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiIC8qXHJcbiAgKiBodHRwczovL2dpdGh1Yi5jb20va3JhYWRlbi9hdXRvY29tcGxldGVcclxuICAqIENvcHlyaWdodCAoYykgMjAxNiBEZW55cyBLcmFzbm9zaGNob2tcclxuICAqIE1JVCBMaWNlbnNlXHJcbiAgKi9cclxuXHJcbmV4cG9ydCBjb25zdCBlbnVtIEV2ZW50VHJpZ2dlciB7XHJcbiAgICBLZXlib2FyZCA9IDAsXHJcbiAgICBGb2N1cyA9IDFcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVJdGVtIHtcclxuICAgIGxhYmVsPzogc3RyaW5nO1xyXG4gICAgZ3JvdXA/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlU2V0dGluZ3M8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+IHtcclxuICAgIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgcmVuZGVyPzogKGl0ZW06IFQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcclxuICAgIHJlbmRlckdyb3VwPzogKG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xyXG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xyXG4gICAgbWluTGVuZ3RoPzogbnVtYmVyO1xyXG4gICAgZW1wdHlNc2c/OiBzdHJpbmc7XHJcbiAgICBvblNlbGVjdDogKGl0ZW06IFQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IGF1dG9jb21wbGV0ZSBvbiBmb2N1cyBldmVudC4gRm9jdXMgZXZlbnQgd2lsbCBpZ25vcmUgdGhlIGBtaW5MZW5ndGhgIHByb3BlcnR5IGFuZCB3aWxsIGFsd2F5cyBjYWxsIGBmZXRjaGAuXHJcbiAgICAgKi9cclxuICAgIHNob3dPbkZvY3VzPzogYm9vbGVhbjtcclxuICAgIGZldGNoOiAodGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogVFtdIHwgZmFsc2UpID0+IHZvaWQsIHRyaWdnZXI6IEV2ZW50VHJpZ2dlcikgPT4gdm9pZDtcclxuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsYmFjayBmb3IgYWRkaXRpb25hbCBhdXRvY29tcGxldGUgY3VzdG9taXphdGlvblxyXG4gICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCAtIGlucHV0IGJveCBhc3NvY2lhdGVkIHdpdGggYXV0b2NvbXBsZXRlXHJcbiAgICAgKiBAcGFyYW0ge0NsaWVudFJlY3QgfCBET01SZWN0fSBpbnB1dFJlY3QgLSBzaXplIG9mIHRoZSBpbnB1dCBib3ggYW5kIGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciAtIGNvbnRhaW5lciB3aXRoIHN1Z2dlc3Rpb25zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gbWF4IGhlaWdodCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGF1dG9jb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBjdXN0b21pemU/OiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50cyBhdXRvbWF0aWMgZm9ybSBzdWJtaXQgd2hlbiBFTlRFUiBpcyBwcmVzc2VkXHJcbiAgICAgKi9cclxuICAgIHByZXZlbnRTdWJtaXQ/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZVJlc3VsdCB7XHJcbiAgICBkZXN0cm95OiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBlbnVtIEtleXMge1xyXG4gICAgRW50ZXIgPSAxMyxcclxuICAgIEVzYyA9IDI3LFxyXG4gICAgVXAgPSAzOCxcclxuICAgIERvd24gPSA0MCxcclxuICAgIExlZnQgPSAzNyxcclxuICAgIFJpZ2h0ID0gMzksXHJcbiAgICBTaGlmdCA9IDE2LFxyXG4gICAgQ3RybCA9IDE3LFxyXG4gICAgQWx0ID0gMTgsXHJcbiAgICBDYXBzTG9jayA9IDIwLFxyXG4gICAgV2luZG93c0tleSA9IDkxLFxyXG4gICAgVGFiID0gOSxcclxuICAgIEYxID0gMTEyLFxyXG4gICAgRjEyID0gMTIzXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9jb21wbGV0ZTxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4oc2V0dGluZ3M6IEF1dG9jb21wbGV0ZVNldHRpbmdzPFQ+KTogQXV0b2NvbXBsZXRlUmVzdWx0IHtcclxuXHJcbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxyXG4gICAgY29uc3QgZG9jID0gZG9jdW1lbnQ7XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XHJcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xyXG4gICAgY29uc3QgZGVib3VuY2VXYWl0TXMgPSBzZXR0aW5ncy5kZWJvdW5jZVdhaXRNcyB8fCAwO1xyXG4gICAgY29uc3QgcHJldmVudFN1Ym1pdCA9IHNldHRpbmdzLnByZXZlbnRTdWJtaXQgfHwgZmFsc2U7XHJcbiAgICBcclxuICAgIC8vICdrZXl1cCcgZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgb24gTW9iaWxlIEZpcmVmb3gsIHNvIHdlIGhhdmUgdG8gdXNlICdpbnB1dCcgZXZlbnQgaW5zdGVhZFxyXG4gICAgY29uc3Qga2V5VXBFdmVudE5hbWUgPSBtb2JpbGVGaXJlZm94ID8gXCJpbnB1dFwiIDogXCJrZXl1cFwiO1xyXG4gICAgXHJcbiAgICBsZXQgaXRlbXM6IFRbXSA9IFtdO1xyXG4gICAgbGV0IGlucHV0VmFsdWUgPSBcIlwiO1xyXG4gICAgbGV0IG1pbkxlbiA9IDI7XHJcbiAgICBjb25zdCBzaG93T25Gb2N1cyA9IHNldHRpbmdzLnNob3dPbkZvY3VzO1xyXG4gICAgbGV0IHNlbGVjdGVkOiBUIHwgdW5kZWZpbmVkO1xyXG4gICAgbGV0IGtleXByZXNzQ291bnRlciA9IDA7XHJcbiAgICBsZXQgZGVib3VuY2VUaW1lciA6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoc2V0dGluZ3MubWluTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtaW5MZW4gPSBzZXR0aW5ncy5taW5MZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IHVuZGVmaW5lZFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IHNldHRpbmdzLmlucHV0O1xyXG5cclxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImF1dG9jb21wbGV0ZSBcIiArIChzZXR0aW5ncy5jbGFzc05hbWUgfHwgXCJcIik7XHJcblxyXG4gICAgLy8gSU9TIGltcGxlbWVudGF0aW9uIGZvciBmaXhlZCBwb3NpdGlvbmluZyBoYXMgbWFueSBidWdzLCBzbyB3ZSB3aWxsIHVzZSBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xyXG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRhY2ggdGhlIGNvbnRhaW5lciBmcm9tIERPTVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZXRhY2goKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGU7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBkZWJvdW5jaW5nIHRpbWVyIGlmIGFzc2lnbmVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsZWFyRGVib3VuY2VUaW1lcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZGVib3VuY2VUaW1lcikge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaCB0aGUgY29udGFpbmVyIHRvIERPTVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhdHRhY2goKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGNvbnRhaW5lciBmb3IgYXV0b2NvbXBsZXRlIGlzIGRpc3BsYXllZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb250YWluZXJEaXNwbGF5ZWQoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuICEhY29udGFpbmVyLnBhcmVudE5vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBhdXRvY29tcGxldGUgc3RhdGUgYW5kIGhpZGUgY29udGFpbmVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNsZWFyKCk6IHZvaWQge1xyXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIHVwZGF0ZSBjYWxsIGlmIHRoZXJlIGFyZSBwZW5kaW5nIEFKQVggcmVxdWVzdHNcclxuICAgICAgICBrZXlwcmVzc0NvdW50ZXIrKztcclxuICAgICAgICBcclxuICAgICAgICBpdGVtcyA9IFtdO1xyXG4gICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xyXG4gICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGRldGFjaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGF1dG9jb21wbGV0ZSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xyXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGggKyBcInB4XCI7XHJcblxyXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgIGxldCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0IHwgdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBjYWxjKCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb2NFbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudFRvcCA9IGRvY0VsLmNsaWVudFRvcCB8fCBkb2MuYm9keS5jbGllbnRUb3AgfHwgMDtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50TGVmdCA9IGRvY0VsLmNsaWVudExlZnQgfHwgZG9jLmJvZHkuY2xpZW50TGVmdCB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWwuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbExlZnQ7XHJcblxyXG4gICAgICAgICAgICBpbnB1dFJlY3QgPSBpbnB1dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gaW5wdXRSZWN0LnRvcCArIGlucHV0Lm9mZnNldEhlaWdodCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlucHV0UmVjdC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XHJcbiAgICBcclxuICAgICAgICAgICAgY29udGFpbmVyU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcclxuICAgIFxyXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSAoaW5wdXRSZWN0LnRvcCArIGlucHV0Lm9mZnNldEhlaWdodCk7XHJcbiAgICBcclxuICAgICAgICAgICAgaWYgKG1heEhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmJvdHRvbSA9IFwiXCI7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGUgY2FsYyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgdHdpY2UsIG90aGVyd2lzZSB0aGUgY2FsY3VsYXRpb24gbWF5IGJlIHdyb25nIG9uIHJlc2l6ZSBldmVudCAoY2hyb21lIGJyb3dzZXIpXHJcbiAgICAgICAgY2FsYygpO1xyXG4gICAgICAgIGNhbGMoKTtcclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1c3RvbWl6ZSAmJiBpbnB1dFJlY3QpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9taXplKGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWRyYXcgdGhlIGF1dG9jb21wbGV0ZSBkaXYgZWxlbWVudCB3aXRoIHN1Z2dlc3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBkZWxldGUgYWxsIGNoaWxkcmVuIGZyb20gYXV0b2NvbXBsZXRlIERPTSBjb250YWluZXJcclxuICAgICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXHJcbiAgICAgICAgbGV0IHJlbmRlciA9IGZ1bmN0aW9uKGl0ZW06IFQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVtRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICBpdGVtRWxlbWVudC50ZXh0Q29udGVudCA9IGl0ZW0ubGFiZWwgfHwgXCJcIjtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlcikge1xyXG4gICAgICAgICAgICByZW5kZXIgPSBzZXR0aW5ncy5yZW5kZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmdW5jdGlvbiB0byByZW5kZXIgYXV0b2NvbXBsZXRlIGdyb3Vwc1xyXG4gICAgICAgIGxldCByZW5kZXJHcm91cCA9IGZ1bmN0aW9uKGdyb3VwTmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcclxuICAgICAgICAgICAgY29uc3QgZ3JvdXBEaXYgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cE5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cERpdjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJHcm91cCkge1xyXG4gICAgICAgICAgICByZW5kZXJHcm91cCA9IHNldHRpbmdzLnJlbmRlckdyb3VwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGxldCBwcmV2R3JvdXAgPSBcIiM5PyRcIjtcclxuXHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtOiBUKTogdm9pZCB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmdyb3VwICYmIGl0ZW0uZ3JvdXAgIT09IHByZXZHcm91cCkge1xyXG4gICAgICAgICAgICAgICAgcHJldkdyb3VwID0gaXRlbS5ncm91cDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gcmVuZGVyR3JvdXAoaXRlbS5ncm91cCwgaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBEaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChncm91cERpdik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAoZGl2KSB7XHJcbiAgICAgICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3QoaXRlbSwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSArPSBcIiBzZWxlY3RlZFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5TXNnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgICAgICAgICAgICAgZW1wdHkuY2xhc3NOYW1lID0gXCJlbXB0eVwiO1xyXG4gICAgICAgICAgICAgICAgZW1wdHkudGV4dENvbnRlbnQgPSBzZXR0aW5ncy5lbXB0eU1zZztcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhdHRhY2goKTtcclxuICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICB1cGRhdGVTY3JvbGwoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1cGRhdGVJZkRpc3BsYXllZCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoY29udGFpbmVyRGlzcGxheWVkKCkpIHtcclxuICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2l6ZUV2ZW50SGFuZGxlcigpOiB2b2lkIHtcclxuICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNjcm9sbEV2ZW50SGFuZGxlcihlOiBFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXl1cEV2ZW50SGFuZGxlcihldjogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XHJcblxyXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFtLZXlzLlVwLCBLZXlzLkVudGVyLCBLZXlzLkVzYywgS2V5cy5SaWdodCwgS2V5cy5MZWZ0LCBLZXlzLlNoaWZ0LCBLZXlzLkN0cmwsIEtleXMuQWx0LCBLZXlzLkNhcHNMb2NrLCBLZXlzLldpbmRvd3NLZXksIEtleXMuVGFiXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpZ25vcmUpIHtcclxuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoa2V5Q29kZSA+PSBLZXlzLkYxICYmIGtleUNvZGUgPD0gS2V5cy5GMTIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlIGRvd24ga2V5IGlzIHVzZWQgdG8gb3BlbiBhdXRvY29tcGxldGVcclxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Eb3duICYmIGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXJ0RmV0Y2goRXZlbnRUcmlnZ2VyLktleWJvYXJkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJzZWxlY3RlZFwiKTtcclxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzWzBdIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgcHJldmlvdXMuY2xhc3NOYW1lLmluZGV4T2YoXCJncm91cFwiKSAhPT0gLTEgJiYgIXByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckJvdHRvbSA9IGNvbnRhaW5lci5zY3JvbGxUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdEJvdHRvbSA+IGNvbnRhaW5lckJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSBwcmV2aW91cyBpdGVtIGluIHN1Z2dlc3Rpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHNlbGVjdFByZXYoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID4gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaSAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIG5leHQgaXRlbSBpbiBzdWdnZXN0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBzZWxlY3ROZXh0KCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xyXG4gICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zWzBdO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKGl0ZW1zLmxlbmd0aCAtIDEpOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnRIYW5kbGVyKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LndoaWNoIHx8IGV2LmtleUNvZGUgfHwgMDtcclxuXHJcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5Eb3duIHx8IGtleUNvZGUgPT09IEtleXMuRXNjKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcklzRGlzcGxheWVkID0gY29udGFpbmVyRGlzcGxheWVkKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCB8fCBpdGVtcy5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAga2V5Q29kZSA9PT0gS2V5cy5VcFxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZWN0UHJldigpXHJcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3ROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcklzRGlzcGxheWVkKSB7XHJcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChzZWxlY3RlZCwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIGlmIChwcmV2ZW50U3VibWl0KSB7XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZvY3VzRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmIChzaG93T25Gb2N1cykge1xyXG4gICAgICAgICAgICBzdGFydEZldGNoKEV2ZW50VHJpZ2dlci5Gb2N1cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJ0RmV0Y2godHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSB7XHJcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUga2V5cyB3ZXJlIHByZXNzZWQsIGJlZm9yZSB3ZSBnZXQgdXBkYXRlIGZyb20gc2VydmVyLFxyXG4gICAgICAgIC8vIHRoaXMgbWF5IGNhdXNlIHJlZHJhd2luZyBvdXIgYXV0b2NvbXBsZXRlIG11bHRpcGxlIHRpbWVzIGFmdGVyIHRoZSBsYXN0IGtleSBwcmVzcy5cclxuICAgICAgICAvLyB0byBhdm9pZCB0aGlzLCB0aGUgbnVtYmVyIG9mIHRpbWVzIGtleWJvYXJkIHdhcyBwcmVzc2VkIHdpbGwgYmVcclxuICAgICAgICAvLyBzYXZlZCBhbmQgY2hlY2tlZCBiZWZvcmUgcmVkcmF3IG91ciBhdXRvY29tcGxldGUgYm94LlxyXG4gICAgICAgIGNvbnN0IHNhdmVkS2V5cHJlc3NDb3VudGVyID0gKytrZXlwcmVzc0NvdW50ZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlO1xyXG4gICAgICAgIGlmICh2YWwubGVuZ3RoID49IG1pbkxlbiB8fCB0cmlnZ2VyID09PSBFdmVudFRyaWdnZXIuRm9jdXMpIHtcclxuICAgICAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XHJcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpOiB2b2lkIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmZldGNoKHZhbCwgZnVuY3Rpb24oZWxlbWVudHM6IFRbXSB8IGZhbHNlKTogdm9pZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXByZXNzQ291bnRlciA9PT0gc2F2ZWRLZXlwcmVzc0NvdW50ZXIgJiYgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtcy5sZW5ndGggPiAwID8gaXRlbXNbMF0gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIEV2ZW50VHJpZ2dlci5LZXlib2FyZCk7XHJcbiAgICAgICAgICAgIH0sIHRyaWdnZXIgPT09IEV2ZW50VHJpZ2dlci5LZXlib2FyZCA/IGRlYm91bmNlV2FpdE1zIDogMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYmx1ckV2ZW50SGFuZGxlcigpOiB2b2lkIHtcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IGNsZWFyLCBiZWNhdXNlIHdoZW4gd2UgY2xpY2sgb24gYW4gaXRlbSwgYmx1ciB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgY2xpY2sgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIERPTVxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMjAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVzICMyNjogb24gbG9uZyBjbGlja3MgZm9jdXMgd2lsbCBiZSBsb3N0IGFuZCBvblNlbGVjdCBtZXRob2Qgd2lsbCBub3QgYmUgY2FsbGVkXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGV2dDogRXZlbnQpIHtcclxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpeGVzICMzMDogYXV0b2NvbXBsZXRlIGNsb3NlcyB3aGVuIHNjcm9sbGJhciBpcyBjbGlja2VkIGluIElFXHJcbiAgICAgKiBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85MjEwMjY3LzEzMTcyMzQ5XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4gaW5wdXQuZm9jdXMoKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVtb3ZlIERPTSBlbGVtZW50cyBhbmQgY2xlYXIgZXZlbnQgaGFuZGxlcnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZm9jdXNFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd25FdmVudEhhbmRsZXIpO1xyXG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xyXG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUV2ZW50SGFuZGxlcik7XHJcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsRXZlbnRIYW5kbGVyLCB0cnVlKTtcclxuICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcclxuICAgICAgICBjbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldHVwIGV2ZW50IGhhbmRsZXJzXHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duRXZlbnRIYW5kbGVyKTtcclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckV2ZW50SGFuZGxlcik7XHJcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZm9jdXNFdmVudEhhbmRsZXIpO1xyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcclxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZXN0cm95XHJcbiAgICB9O1xyXG59XHJcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImJiai1tYXNrcy9zcmMvU3RyaW5nTWFza1wiKSwgcmVxdWlyZShcImJiai1tYXNrcy9zcmMvTnVtYmVyTWFza1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJiYmotbWFza3Mvc3JjL1N0cmluZ01hc2tcIiwgXCJiYmotbWFza3Mvc3JjL051bWJlck1hc2tcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiSW5wdXRNYXNraW5nXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrXCIpLCByZXF1aXJlKFwiYmJqLW1hc2tzL3NyYy9OdW1iZXJNYXNrXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJCYXNpc1wiXSA9IHJvb3RbXCJCYXNpc1wiXSB8fCB7fSwgcm9vdFtcIkJhc2lzXCJdW1wiSW5wdXRNYXNraW5nXCJdID0gZmFjdG9yeShyb290W1wiQkJqXCJdW1wiTWFza3NcIl1bXCJTdHJpbmdNYXNrXCJdLCByb290W1wiQkJqXCJdW1wiTWFza3NcIl1bXCJOdW1iZXJNYXNrXCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDBiYWUwNTllMmI1ZmUyNmM1YjEwIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL0NvbXBvbmVudCdcblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tcG9uZW50L2luZGV4LmpzIiwiaW1wb3J0IHsgZGVjb3JhdGUsIGNyZWF0ZURlZmF1bHRTZXR0ZXIsXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMsIGdldE93bktleXMsIGJpbmQgfSBmcm9tICcuL3ByaXZhdGUvdXRpbHMnO1xuY29uc3QgeyBkZWZpbmVQcm9wZXJ0eSwgZ2V0UHJvdG90eXBlT2YgfSA9IE9iamVjdDtcblxubGV0IG1hcFN0b3JlO1xuXG5mdW5jdGlvbiBnZXRCb3VuZFN1cGVyKG9iaiwgZm4pIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVc2luZyBAYXV0b2JpbmQgb24gJHtmbi5uYW1lfSgpIHJlcXVpcmVzIFdlYWtNYXAgc3VwcG9ydCBkdWUgdG8gaXRzIHVzZSBvZiBzdXBlci4ke2ZuLm5hbWV9KClcbiAgICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamF5cGhlbHBzL2NvcmUtZGVjb3JhdG9ycy5qcy9pc3N1ZXMvMjBgXG4gICAgKTtcbiAgfVxuXG4gIGlmICghbWFwU3RvcmUpIHtcbiAgICAgbWFwU3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgaWYgKG1hcFN0b3JlLmhhcyhvYmopID09PSBmYWxzZSkge1xuICAgIG1hcFN0b3JlLnNldChvYmosIG5ldyBXZWFrTWFwKCkpO1xuICB9XG5cbiAgY29uc3Qgc3VwZXJTdG9yZSA9IG1hcFN0b3JlLmdldChvYmopO1xuXG4gIGlmIChzdXBlclN0b3JlLmhhcyhmbikgPT09IGZhbHNlKSB7XG4gICAgc3VwZXJTdG9yZS5zZXQoZm4sIGJpbmQoZm4sIG9iaikpO1xuICB9XG5cbiAgcmV0dXJuIHN1cGVyU3RvcmUuZ2V0KGZuKTtcbn1cblxuZnVuY3Rpb24gYXV0b2JpbmRDbGFzcyhrbGFzcykge1xuICBjb25zdCBkZXNjcyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoa2xhc3MucHJvdG90eXBlKTtcbiAgY29uc3Qga2V5cyA9IGdldE93bktleXMoZGVzY3MpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IGRlc2MgPSBkZXNjc1trZXldO1xuXG4gICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGVmaW5lUHJvcGVydHkoa2xhc3MucHJvdG90eXBlLCBrZXksIGF1dG9iaW5kTWV0aG9kKGtsYXNzLnByb3RvdHlwZSwga2V5LCBkZXNjKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXV0b2JpbmRNZXRob2QodGFyZ2V0LCBrZXksIHsgdmFsdWU6IGZuLCBjb25maWd1cmFibGUsIGVudW1lcmFibGUgfSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBAYXV0b2JpbmQgY2FuIG9ubHkgYmUgdXNlZCBvbiBmdW5jdGlvbnMsIG5vdDogJHtmbn1gKTtcbiAgfVxuXG4gIGNvbnN0IHsgY29uc3RydWN0b3IgfSA9IHRhcmdldDtcblxuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZSxcbiAgICBlbnVtZXJhYmxlLFxuXG4gICAgZ2V0KCkge1xuICAgICAgLy8gQ2xhc3MucHJvdG90eXBlLmtleSBsb29rdXBcbiAgICAgIC8vIFNvbWVvbmUgYWNjZXNzZXMgdGhlIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBwcm90b3R5cGUgb24gd2hpY2ggaXQgaXNcbiAgICAgIC8vIGFjdHVhbGx5IGRlZmluZWQgb24sIGkuZS4gQ2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgIGlmICh0aGlzID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuXG4gICAgICAvLyBDbGFzcy5wcm90b3R5cGUua2V5IGxvb2t1cFxuICAgICAgLy8gU29tZW9uZSBhY2Nlc3NlcyB0aGUgcHJvcGVydHkgZGlyZWN0bHkgb24gYSBwcm90b3R5cGUgYnV0IGl0IHdhcyBmb3VuZFxuICAgICAgLy8gdXAgdGhlIGNoYWluLCBub3QgZGVmaW5lZCBkaXJlY3RseSBvbiBpdFxuICAgICAgLy8gaS5lLiBDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KSA9PSBmYWxzZSAmJiBrZXkgaW4gQ2xhc3MucHJvdG90eXBlXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gY29uc3RydWN0b3IgJiYgZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IgPT09IGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b2JvdW5kIG1ldGhvZCBjYWxsaW5nIHN1cGVyLnNhbWVNZXRob2QoKSB3aGljaCBpcyBhbHNvIGF1dG9ib3VuZCBhbmQgc28gb24uXG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gY29uc3RydWN0b3IgJiYga2V5IGluIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBnZXRCb3VuZFN1cGVyKHRoaXMsIGZuKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYm91bmRGbiA9IGJpbmQoZm4sIHRoaXMpO1xuXG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gTk9UIGVudW1lcmFibGUgd2hlbiBpdCdzIGEgYm91bmQgbWV0aG9kXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogYm91bmRGblxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBib3VuZEZuO1xuICAgIH0sXG4gICAgc2V0OiBjcmVhdGVEZWZhdWx0U2V0dGVyKGtleSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKGFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGF1dG9iaW5kQ2xhc3MoLi4uYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGF1dG9iaW5kTWV0aG9kKC4uLmFyZ3MpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9iaW5kKC4uLmFyZ3MpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoYW5kbGUoYXJndW1lbnRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYW5kbGUoYXJncyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL2F1dG9iaW5kLmpzIiwiaW1wb3J0IHsgZGVjb3JhdGUgfSBmcm9tICcuL3ByaXZhdGUvdXRpbHMnO1xuXG5jb25zdCBHRU5FUklDX0ZVTkNUSU9OX0VSUk9SID0gJ3tjaGlsZH0gZG9lcyBub3QgcHJvcGVybHkgb3ZlcnJpZGUge3BhcmVudH0nO1xuY29uc3QgRlVOQ1RJT05fUkVHRVhQID0gL15mdW5jdGlvbiAoW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bXyRhLXpBLVowLTlcXHhBMC1cXHVGRkZGXSopPyhcXChbXlxcKV0qXFwpKVtcXHNcXFNdKyQvO1xuXG5jbGFzcyBTeW50YXhFcnJvclJlcG9ydGVyIHtcbiAgcGFyZW50S2xhc3M7XG4gIGNoaWxkS2xhc3M7XG4gIHBhcmVudERlc2NyaXB0b3I7XG4gIGNoaWxkRGVzY3JpcHRvcjtcbiAgXG4gIGdldCBrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGREZXNjcmlwdG9yLmtleTsgIFxuICB9XG4gIFxuICBnZXQgcGFyZW50Tm90YXRpb24oKSB7XG4gICAgcmV0dXJuIGAke3RoaXMucGFyZW50S2xhc3MuY29uc3RydWN0b3IubmFtZX0jJHt0aGlzLnBhcmVudFByb3BlcnR5U2lnbmF0dXJlfWA7XG4gIH1cblxuICBnZXQgY2hpbGROb3RhdGlvbigpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jaGlsZEtsYXNzLmNvbnN0cnVjdG9yLm5hbWV9IyR7dGhpcy5jaGlsZFByb3BlcnR5U2lnbmF0dXJlfWA7XG4gIH1cbiAgXG4gIGdldCBwYXJlbnRUb3BpYygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VG9waWModGhpcy5wYXJlbnREZXNjcmlwdG9yKTtcbiAgfVxuICBcbiAgZ2V0IGNoaWxkVG9waWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFRvcGljKHRoaXMuY2hpbGREZXNjcmlwdG9yKTtcbiAgfVxuICBcbiAgX2dldFRvcGljKGRlc2NyaXB0b3IpIHtcbiAgICBpZiAoZGVzY3JpcHRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDsgIFxuICAgIH1cbiAgICBcbiAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCdnZXQnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldDtcbiAgICB9XG4gICAgXG4gICAgaWYgKCdzZXQnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLnNldDtcbiAgICB9XG4gIH1cbiAgXG4gIGdldCBwYXJlbnRQcm9wZXJ0eVNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdFRvcGljU2lnbmF0dXJlKHRoaXMucGFyZW50VG9waWMpOyBcbiAgfVxuICBcbiAgZ2V0IGNoaWxkUHJvcGVydHlTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dHJhY3RUb3BpY1NpZ25hdHVyZSh0aGlzLmNoaWxkVG9waWMpOyBcbiAgfVxuICBcbiAgX2V4dHJhY3RUb3BpY1NpZ25hdHVyZSh0b3BpYykge1xuICAgIHN3aXRjaCAodHlwZW9mIHRvcGljKSB7XG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHJldHVybiB0aGlzLl9leHRyYWN0RnVuY3Rpb25TaWduYXR1cmUodG9waWMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5O1xuICAgIH1cbiAgfVxuICBcbiAgX2V4dHJhY3RGdW5jdGlvblNpZ25hdHVyZShmbikge1xuICAgIHJldHVybiBmblxuICAgICAgLnRvU3RyaW5nKClcbiAgICAgIC5yZXBsYWNlKFxuICAgICAgICBGVU5DVElPTl9SRUdFWFAsXG4gICAgICAgIChtYXRjaCwgbmFtZSA9IHRoaXMua2V5LCBwYXJhbXMpID0+IG5hbWUgKyBwYXJhbXNcbiAgICAgICk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwYXJlbnRLbGFzcywgY2hpbGRLbGFzcywgcGFyZW50RGVzY3JpcHRvciwgY2hpbGREZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5wYXJlbnRLbGFzcyA9IHBhcmVudEtsYXNzO1xuICAgIHRoaXMuY2hpbGRLbGFzcyA9IGNoaWxkS2xhc3M7XG4gICAgdGhpcy5wYXJlbnREZXNjcmlwdG9yID0gcGFyZW50RGVzY3JpcHRvcjtcbiAgICB0aGlzLmNoaWxkRGVzY3JpcHRvciA9IGNoaWxkRGVzY3JpcHRvcjtcbiAgfVxuICBcbiAgYXNzZXJ0KGNvbmRpdGlvbiwgbXNnID0gJycpIHtcbiAgICBpZiAoY29uZGl0aW9uICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLmVycm9yKEdFTkVSSUNfRlVOQ1RJT05fRVJST1IgKyBtc2cpO1xuICAgIH1cbiAgfVxuICBcbiAgZXJyb3IobXNnKSB7XG4gICAgbXNnID0gbXNnXG4gICAgICAvLyBSZXBsYWNlIGxhemlseSwgYmVjYXVzZSB0aGV5IGFjdHVhbGx5IG1pZ2h0IG5vdFxuICAgICAgLy8gYmUgYXZhaWxhYmxlIGluIGFsbCBjYXNlc1xuICAgICAgLnJlcGxhY2UoJ3twYXJlbnR9JywgbSA9PiB0aGlzLnBhcmVudE5vdGF0aW9uKVxuICAgICAgLnJlcGxhY2UoJ3tjaGlsZH0nLCBtID0+IHRoaXMuY2hpbGROb3RhdGlvbik7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKG1zZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvclR5cGUoZGVzY3JpcHRvcikge1xuICBpZiAoZGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgIHJldHVybiAnZGF0YSc7XG4gIH1cblxuICBpZiAoZGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSgnZ2V0JykgfHwgZGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSgnc2V0JykpIHtcbiAgICByZXR1cm4gJ2FjY2Vzc29yJztcbiAgfVxuXG4gIC8vIElmIG5vbmUgb2YgdGhlbSBleGlzdCwgYnJvd3NlcnMgdHJlYXQgaXQgYXNcbiAgLy8gYSBkYXRhIGRlc2NyaXB0b3Igd2l0aCBhIHZhbHVlIG9mIGB1bmRlZmluZWRgXG4gIHJldHVybiAnZGF0YSc7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25TaWduYXR1cmVzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKSB7XG4gIHJlcG9ydGVyLmFzc2VydChwYXJlbnQubGVuZ3RoID09PSBjaGlsZC5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBjaGVja0RhdGFEZXNjcmlwdG9ycyhwYXJlbnQsIGNoaWxkLCByZXBvcnRlcikge1xuICBjb25zdCBwYXJlbnRWYWx1ZVR5cGUgPSB0eXBlb2YgcGFyZW50LnZhbHVlO1xuICBjb25zdCBjaGlsZFZhbHVlVHlwZSA9IHR5cGVvZiBjaGlsZC52YWx1ZTtcbiAgXG4gIGlmIChwYXJlbnRWYWx1ZVR5cGUgPT09ICd1bmRlZmluZWQnICYmIGNoaWxkVmFsdWVUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNsYXNzIHByb3BlcnRpZXMgY2FuIGJlIGFueSBleHByZXNzaW9uLCB3aGljaCBpc24ndCByYW4gdW50aWwgdGhlXG4gICAgLy8gdGhlIGluc3RhbmNlIGlzIGNyZWF0ZWQsIHNvIHdlIGNhbid0IHJlbGlhYmx5IGdldCB0eXBlIGluZm9ybWF0aW9uXG4gICAgLy8gZm9yIHRoZW0geWV0IChwZXIgc3BlYykuIFBlcmhhcHMgd2hlbiBCYWJlbCBpbmNsdWRlcyBmbG93LXR5cGUgaW5mb1xuICAgIC8vIGluIHJ1bnRpbWU/IFRyaWVkIHJlZ2V4IHNvbHV0aW9ucywgYnV0IHN1cGVyIGhhY2t5IGFuZCBvbmx5IGZlYXNpYmxlXG4gICAgLy8gb24gcHJpbWl0aXZlcywgd2hpY2ggaXMgY29uZnVzaW5nIGZvciB1c2FnZS4uLlxuICAgIHJlcG9ydGVyLmVycm9yKGBkZXNjcmlwdG9yIHZhbHVlcyBhcmUgYm90aCB1bmRlZmluZWQuIChjbGFzcyBwcm9wZXJ0aWVzIGFyZSBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQpJ2ApO1xuICB9XG4gIFxuICBpZiAocGFyZW50VmFsdWVUeXBlICE9PSBjaGlsZFZhbHVlVHlwZSkge1xuICAgIGNvbnN0IGlzRnVuY3Rpb25PdmVyVW5kZWZpbmVkID0gKGNoaWxkVmFsdWVUeXBlID09PSAnZnVuY3Rpb24nICYmIHBhcmVudFZhbHVlVHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgICAvLyBFdmVuIHRob3VnaCB3ZSBkb24ndCBzdXBwb3J0IGNsYXNzIHByb3BlcnRpZXMsIHRoaXNcbiAgICAvLyB3aWxsIHN0aWxsIGhhbmRsZSBtb3JlIHRoYW4ganVzdCBmdW5jdGlvbnMsIGp1c3QgaW4gY2FzZS5cbiAgICAvLyBTaGFkb3dpbmcgYW4gdW5kZWZpbmVkIHZhbHVlIGlzIGFuIGVycm9yIGlmIHRoZSBpbmhlcml0ZWRcbiAgICAvLyB2YWx1ZSB3YXMgdW5kZWZpbmVkICh1c3VhbGx5IGEgY2xhc3MgcHJvcGVydHksIG5vdCBhIG1ldGhvZClcbiAgICBpZiAoaXNGdW5jdGlvbk92ZXJVbmRlZmluZWQgfHwgcGFyZW50VmFsdWVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcG9ydGVyLmVycm9yKGB2YWx1ZSB0eXBlcyBkbyBub3QgbWF0Y2guIHtwYXJlbnR9IGlzIFwiJHtwYXJlbnRWYWx1ZVR5cGV9XCIsIHtjaGlsZH0gaXMgXCIke2NoaWxkVmFsdWVUeXBlfVwiYCk7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTd2l0Y2gsIGluIHByZXBhcmF0aW9uIGZvciBzdXBwb3J0aW5nIG1vcmUgdHlwZXNcbiAgc3dpdGNoIChjaGlsZFZhbHVlVHlwZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNoZWNrRnVuY3Rpb25TaWduYXR1cmVzKHBhcmVudC52YWx1ZSwgY2hpbGQudmFsdWUsIHJlcG9ydGVyKTtcbiAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgZGVmYXVsdDpcbiAgICAgIHJlcG9ydGVyLmVycm9yKGBVbmV4cGVjdGVkIGVycm9yLiBQbGVhc2UgZmlsZSBhIGJ1ZyB3aXRoOiB7cGFyZW50fSBpcyBcIiR7cGFyZW50VmFsdWVUeXBlfVwiLCB7Y2hpbGR9IGlzIFwiJHtjaGlsZFZhbHVlVHlwZX1cImApO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tBY2Nlc3NvckRlc2NyaXB0b3JzKHBhcmVudCwgY2hpbGQsIHJlcG9ydGVyKSB7XG4gIGNvbnN0IHBhcmVudEhhc0dldHRlciA9IHR5cGVvZiBwYXJlbnQuZ2V0ID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBjaGlsZEhhc0dldHRlciA9IHR5cGVvZiBjaGlsZC5nZXQgPT09ICdmdW5jdGlvbic7XG4gIGNvbnN0IHBhcmVudEhhc1NldHRlciA9IHR5cGVvZiBwYXJlbnQuc2V0ID09PSAnZnVuY3Rpb24nO1xuICBjb25zdCBjaGlsZEhhc1NldHRlciA9IHR5cGVvZiBjaGlsZC5zZXQgPT09ICdmdW5jdGlvbic7XG4gIFxuICBpZiAocGFyZW50SGFzR2V0dGVyIHx8IGNoaWxkSGFzR2V0dGVyKSB7XG4gICAgaWYgKCFwYXJlbnRIYXNHZXR0ZXIgJiYgcGFyZW50SGFzU2V0dGVyKSB7XG4gICAgICByZXBvcnRlci5lcnJvcihge3BhcmVudH0gaXMgc2V0dGVyIGJ1dCB7Y2hpbGR9IGlzIGdldHRlcmApO1xuICAgIH1cbiAgICBcbiAgICBpZiAoIWNoaWxkSGFzR2V0dGVyICYmIGNoaWxkSGFzU2V0dGVyKSB7XG4gICAgICByZXBvcnRlci5lcnJvcihge3BhcmVudH0gaXMgZ2V0dGVyIGJ1dCB7Y2hpbGR9IGlzIHNldHRlcmApO1xuICAgIH1cbiAgICBcbiAgICBjaGVja0Z1bmN0aW9uU2lnbmF0dXJlcyhwYXJlbnQuZ2V0LCBjaGlsZC5nZXQsIHJlcG9ydGVyKTtcbiAgfVxuICBcbiAgaWYgKHBhcmVudEhhc1NldHRlciB8fCBjaGlsZEhhc1NldHRlcikge1xuICAgIGlmICghcGFyZW50SGFzU2V0dGVyICYmIHBhcmVudEhhc0dldHRlcikge1xuICAgICAgcmVwb3J0ZXIuZXJyb3IoYHtwYXJlbnR9IGlzIGdldHRlciBidXQge2NoaWxkfSBpcyBzZXR0ZXJgKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjaGlsZEhhc1NldHRlciAmJiBjaGlsZEhhc0dldHRlcikge1xuICAgICAgcmVwb3J0ZXIuZXJyb3IoYHtwYXJlbnR9IGlzIHNldHRlciBidXQge2NoaWxkfSBpcyBnZXR0ZXJgKTtcbiAgICB9XG4gICAgXG4gICAgY2hlY2tGdW5jdGlvblNpZ25hdHVyZXMocGFyZW50LnNldCwgY2hpbGQuc2V0LCByZXBvcnRlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tEZXNjcmlwdG9ycyhwYXJlbnQsIGNoaWxkLCByZXBvcnRlcikge1xuICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0RGVzY3JpcHRvclR5cGUocGFyZW50KTtcbiAgY29uc3QgY2hpbGRUeXBlID0gZ2V0RGVzY3JpcHRvclR5cGUoY2hpbGQpO1xuXG4gIGlmIChwYXJlbnRUeXBlICE9PSBjaGlsZFR5cGUpIHtcbiAgICByZXBvcnRlci5lcnJvcihgZGVzY3JpcHRvciB0eXBlcyBkbyBub3QgbWF0Y2guIHtwYXJlbnR9IGlzIFwiJHtwYXJlbnRUeXBlfVwiLCB7Y2hpbGR9IGlzIFwiJHtjaGlsZFR5cGV9XCJgKTtcbiAgfVxuXG4gIHN3aXRjaCAoY2hpbGRUeXBlKSB7XG4gICAgY2FzZSAnZGF0YSc6XG4gICAgICBjaGVja0RhdGFEZXNjcmlwdG9ycyhwYXJlbnQsIGNoaWxkLCByZXBvcnRlcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FjY2Vzc29yJzpcbiAgICAgIGNoZWNrQWNjZXNzb3JEZXNjcmlwdG9ycyhwYXJlbnQsIGNoaWxkLCByZXBvcnRlcik7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5jb25zdCBzdWdnZXN0aW9uVHJhbnNmb3JtcyA9IFtcbiAga2V5ID0+IGtleS50b0xvd2VyQ2FzZSgpLFxuICBrZXkgPT4ga2V5LnRvVXBwZXJDYXNlKCksXG4gIGtleSA9PiBrZXkgKyAncycsXG4gIGtleSA9PiBrZXkuc2xpY2UoMCwgLTEpLFxuICBrZXkgPT4ga2V5LnNsaWNlKDEsIGtleS5sZW5ndGgpLFxuXTtcblxuZnVuY3Rpb24gZmluZFBvc3NpYmxlQWx0ZXJuYXRpdmVzKHN1cGVyS2xhc3MsIGtleSkge1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHN1Z2dlc3Rpb25UcmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGZuID0gc3VnZ2VzdGlvblRyYW5zZm9ybXNbaV07XG4gICAgY29uc3Qgc3VnZ2VzdGlvbiA9IGZuKGtleSk7XG5cbiAgICBpZiAoc3VnZ2VzdGlvbiBpbiBzdXBlcktsYXNzKSB7XG4gICAgICByZXR1cm4gc3VnZ2VzdGlvbjtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVEZXNjcmlwdG9yKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGRlc2NyaXB0b3Iua2V5ID0ga2V5O1xuICBjb25zdCBzdXBlcktsYXNzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gIGNvbnN0IHN1cGVyRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3VwZXJLbGFzcywga2V5KTtcbiAgY29uc3QgcmVwb3J0ZXIgPSBuZXcgU3ludGF4RXJyb3JSZXBvcnRlcihzdXBlcktsYXNzLCB0YXJnZXQsIHN1cGVyRGVzY3JpcHRvciwgZGVzY3JpcHRvcik7XG4gIFxuICBpZiAoc3VwZXJEZXNjcmlwdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzdWdnZXN0ZWRLZXkgPSBmaW5kUG9zc2libGVBbHRlcm5hdGl2ZXMoc3VwZXJLbGFzcywga2V5KTtcbiAgICBjb25zdCBzdWdnZXN0aW9uID0gc3VnZ2VzdGVkS2V5ID8gYFxcblxcbiAgRGlkIHlvdSBtZWFuIFwiJHtzdWdnZXN0ZWRLZXl9XCI/YCA6ICcnO1xuICAgIHJlcG9ydGVyLmVycm9yKGBObyBkZXNjcmlwdG9yIG1hdGNoaW5nIHtjaGlsZH0gd2FzIGZvdW5kIG9uIHRoZSBwcm90b3R5cGUgY2hhaW4uJHtzdWdnZXN0aW9ufWApO1xuICB9XG4gIFxuICBjaGVja0Rlc2NyaXB0b3JzKHN1cGVyRGVzY3JpcHRvciwgZGVzY3JpcHRvciwgcmVwb3J0ZXIpO1xuICBcbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG92ZXJyaWRlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGRlY29yYXRlKGhhbmRsZURlc2NyaXB0b3IsIGFyZ3MpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtZGVjb3JhdG9ycy9zcmMvb3ZlcnJpZGUuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xufTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvICsgXCIgXCIgKyBvcHRpb25zLmluc2VydEF0LmJlZm9yZSk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCJpbXBvcnQgbGF6eUluaXRpYWxpemUgZnJvbSAnLi4vbGF6eS1pbml0aWFsaXplJztcblxuY29uc3QgeyBkZWZpbmVQcm9wZXJ0eSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfSA9IE9iamVjdDtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVzY3JpcHRvcihkZXNjKSB7XG4gIGlmICghZGVzYyB8fCAhZGVzYy5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGtleXMgPSBbJ3ZhbHVlJywgJ2luaXRpYWxpemVyJywgJ2dldCcsICdzZXQnXTtcblxuICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGRlc2MuaGFzT3duUHJvcGVydHkoa2V5c1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29yYXRlKGhhbmRsZURlc2NyaXB0b3IsIGVudHJ5QXJncykge1xuICBpZiAoaXNEZXNjcmlwdG9yKGVudHJ5QXJnc1tlbnRyeUFyZ3MubGVuZ3RoIC0gMV0pKSB7XG4gICAgcmV0dXJuIGhhbmRsZURlc2NyaXB0b3IoLi4uZW50cnlBcmdzLCBbXSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBoYW5kbGVEZXNjcmlwdG9yKC4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksIGVudHJ5QXJncyk7XG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBNZXRhIHtcbiAgQGxhenlJbml0aWFsaXplXG4gIGRlYm91bmNlVGltZW91dElkcyA9IHt9O1xuXG4gIEBsYXp5SW5pdGlhbGl6ZVxuICB0aHJvdHRsZVRpbWVvdXRJZHMgPSB7fTtcblxuICBAbGF6eUluaXRpYWxpemVcbiAgdGhyb3R0bGVQcmV2aW91c1RpbWVzdGFtcHMgPSB7fTtcblxuICBAbGF6eUluaXRpYWxpemVcbiAgdGhyb3R0bGVUcmFpbGluZ0FyZ3MgPSBudWxsO1xuXG4gIEBsYXp5SW5pdGlhbGl6ZVxuICBwcm9maWxlTGFzdFJhbiA9IG51bGw7XG59XG5cbmNvbnN0IE1FVEFfS0VZID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpXG4gID8gU3ltYm9sKCdfX2NvcmVfZGVjb3JhdG9yc19fJylcbiAgOiAnX19jb3JlX2RlY29yYXRvcnNfXyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXRhRm9yKG9iaikge1xuICBpZiAob2JqLmhhc093blByb3BlcnR5KE1FVEFfS0VZKSA9PT0gZmFsc2UpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmosIE1FVEFfS0VZLCB7XG4gICAgICAvLyBEZWZhdWx0czogTk9UIGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSwgb3Igd3JpdGFibGVcbiAgICAgIHZhbHVlOiBuZXcgTWV0YSgpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb2JqW01FVEFfS0VZXTtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE93bktleXMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbiAgICA/IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KVxuICAgICAgICAgIC5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpO1xuICAgICAgfVxuICAgIDogZ2V0T3duUHJvcGVydHlOYW1lcztcblxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgY29uc3QgZGVzY3MgPSB7fTtcblxuICBnZXRPd25LZXlzKG9iaikuZm9yRWFjaChcbiAgICBrZXkgPT4gKGRlc2NzW2tleV0gPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpKVxuICApO1xuXG4gIHJldHVybiBkZXNjcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTZXR0ZXIoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIC8vIElTIGVudW1lcmFibGUgd2hlbiByZWFzc2lnbmVkIGJ5IHRoZSBvdXRzaWRlIHdvcmRcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbmV3VmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmQoZm4sIGNvbnRleHQpIHtcbiAgaWYgKGZuLmJpbmQpIHtcbiAgICByZXR1cm4gZm4uYmluZChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gX19hdXRvYmluZF9fKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgd2FybiA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ29iamVjdCcgfHwgIWNvbnNvbGUgfHwgdHlwZW9mIGNvbnNvbGUud2FybiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoKSA9PiB7fTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmluZChjb25zb2xlLndhcm4sIGNvbnNvbGUpO1xuICB9XG59KSgpO1xuXG5jb25zdCBzZWVuRGVwcmVjYXRpb25zID0ge307XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxEZXByZWNhdGlvbihtc2cpIHtcbiAgaWYgKHNlZW5EZXByZWNhdGlvbnNbbXNnXSAhPT0gdHJ1ZSkge1xuICAgIHNlZW5EZXByZWNhdGlvbnNbbXNnXSA9IHRydWU7XG4gICAgd2FybignREVQUkVDQVRJT046ICcgKyBtc2cpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1kZWNvcmF0b3JzL3NyYy9wcml2YXRlL3V0aWxzLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2VxLmpzIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9fbGliL3RvSW50ZWdlci9pbmRleC5qcyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVpcmVkQXJncyhyZXF1aXJlZCwgYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPCByZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVxdWlyZWQgKyAnIGFyZ3VtZW50JyArIChyZXF1aXJlZCA+IDEgPyAncycgOiAnJykgKyAnIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJncy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQm9vbGVhblN3aXRjaCBmcm9tICcuL0Jvb2xlYW5Td2l0Y2gnXG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5Td2l0Y2hcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuU3dpdGNoL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IFRlbXBsYXRlUmVuZGVyZXIgZnJvbSAnLi9UZW1wbGF0ZVJlbmRlcmVyJ1xuXG5leHBvcnQgZGVmYXVsdCBUZW1wbGF0ZVJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGVtcGxhdGVSZW5kZXJlci9pbmRleC5qcyIsImltcG9ydCBkZWZpbmVQcm9wZXJ0eSBmcm9tICcuL19kZWZpbmVQcm9wZXJ0eS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VBc3NpZ25WYWx1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsImltcG9ydCBnZXROYXRpdmUgZnJvbSAnLi9fZ2V0TmF0aXZlLmpzJztcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmluZVByb3BlcnR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZGVmaW5lUHJvcGVydHkuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19mcmVlR2xvYmFsLmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsImltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcbmltcG9ydCBvdmVyUmVzdCBmcm9tICcuL19vdmVyUmVzdC5qcyc7XG5pbXBvcnQgc2V0VG9TdHJpbmcgZnJvbSAnLi9fc2V0VG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJlc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmVzdC5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlkZW50aXR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pZGVudGl0eS5qcyIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcHBseS5qcyIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSXRlcmF0ZWVDYWxsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJdGVyYXRlZUNhbGwuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcyIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xyXG5cdGlmKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBkb21FeGNUYWcgPSAnW29iamVjdCBET01FeGNlcHRpb25dJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAqIGBTeW50YXhFcnJvcmAsIGBUeXBlRXJyb3JgLCBvciBgVVJJRXJyb3JgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Vycm9yKEVycm9yKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBlcnJvclRhZyB8fCB0YWcgPT0gZG9tRXhjVGFnIHx8XG4gICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRXJyb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRXJyb3IuanMiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlSW50ZXJwb2xhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUludGVycG9sYXRlLmpzIiwiaW1wb3J0IGJhc2VUb1N0cmluZyBmcm9tICcuL19iYXNlVG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b1N0cmluZy5qcyIsImltcG9ydCB7IGRlY29yYXRlIH0gZnJvbSAnLi9wcml2YXRlL3V0aWxzJztcblxuZnVuY3Rpb24gaGFuZGxlRGVzY3JpcHRvcih0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICBkZXNjcmlwdG9yLndyaXRhYmxlID0gZmFsc2U7XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkb25seSguLi5hcmdzKSB7XG4gIHJldHVybiBkZWNvcmF0ZShoYW5kbGVEZXNjcmlwdG9yLCBhcmdzKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL3JlYWRvbmx5LmpzIiwiaW1wb3J0IHR6UGFyc2VUaW1lem9uZSBmcm9tICcuLi9fbGliL3R6UGFyc2VUaW1lem9uZSdcbmltcG9ydCBzdWJNaWxsaXNlY29uZHMgZnJvbSAnZGF0ZS1mbnMvZXNtL3N1Yk1pbGxpc2Vjb25kcydcbmltcG9ydCB0b0RhdGUgZnJvbSAnLi4vdG9EYXRlJ1xuXG4vKipcbiAqIEBuYW1lIHV0Y1RvWm9uZWRUaW1lXG4gKiBAY2F0ZWdvcnkgVGltZSBab25lIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IEdldCBhIGRhdGUvdGltZSByZXByZXNlbnRpbmcgbG9jYWwgdGltZSBpbiBhIGdpdmVuIHRpbWUgem9uZSBmcm9tIHRoZSBVVEMgZGF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJucyBhIGRhdGUgaW5zdGFuY2Ugd2l0aCB2YWx1ZXMgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCB0aW1lIGluIHRoZSB0aW1lIHpvbmVcbiAqIHNwZWNpZmllZCBvZiB0aGUgVVRDIHRpbWUgZnJvbSB0aGUgZGF0ZSBwcm92aWRlZC4gSW4gb3RoZXIgd29yZHMsIHdoZW4gdGhlIG5ldyBkYXRlXG4gKiBpcyBmb3JtYXR0ZWQgaXQgd2lsbCBzaG93IHRoZSBlcXVpdmFsZW50IGhvdXJzIGluIHRoZSB0YXJnZXQgdGltZSB6b25lIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBjdXJyZW50IHN5c3RlbSB0aW1lIHpvbmUuXG4gKlxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB3aXRoIHRoZSByZWxldmFudCBVVEMgdGltZVxuICogQHBhcmFtIHtTdHJpbmd9IHRpbWVab25lIC0gdGhlIHRpbWUgem9uZSB0byBnZXQgbG9jYWwgdGltZSBmb3IsIGNhbiBiZSBhbiBvZmZzZXQgb3IgSUFOQSB0aW1lIHpvbmVcbiAqIEBwYXJhbSB7T3B0aW9uc1dpdGhUWn0gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHBhc3NlZCB0byBgdG9EYXRlYC4gU2VlIFt0b0RhdGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvdG9EYXRlfVxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBlcXVpdmFsZW50IHRpbWUgaW4gdGhlIHRpbWUgem9uZVxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSW4gSnVuZSAxMGFtIFVUQyBpcyA2YW0gaW4gTmV3IFlvcmsgKC0wNDowMClcbiAqIGNvbnN0IHJlc3VsdCA9IHV0Y1RvWm9uZWRUaW1lKCcyMDE0LTA2LTI1VDEwOjAwOjAwLjAwMFonLCAnQW1lcmljYS9OZXdfWW9yaycpXG4gKiAvLz0+IEp1biAyNSAyMDE0IDA2OjAwOjAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHV0Y1RvWm9uZWRUaW1lKGRpcnR5RGF0ZSwgdGltZVpvbmUsIG9wdGlvbnMpIHtcbiAgdmFyIGRhdGUgPSB0b0RhdGUoZGlydHlEYXRlLCBvcHRpb25zKVxuXG4gIC8vIFRoaXMgZGF0ZSBoYXMgdGhlIFVUQyB0aW1lIHZhbHVlcyBvZiB0aGUgaW5wdXQgZGF0ZSBhdCB0aGUgc3lzdGVtIHRpbWUgem9uZVxuICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKFxuICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBkYXRlLmdldFVUQ01vbnRoKCksXG4gICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgIGRhdGUuZ2V0VVRDTWludXRlcygpLFxuICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKClcbiAgKVxuICAvLyBXZSBqdXN0IG5lZWQgdG8gYXBwbHkgdGhlIG9mZnNldCBpbmRpY2F0ZWQgYnkgdGhlIHRpbWUgem9uZSB0byB0aGlzIGxvY2FsaXplZCBkYXRlXG4gIHZhciBvZmZzZXRNaWxsaXNlY29uZHMgPSB0elBhcnNlVGltZXpvbmUodGltZVpvbmUsIHV0Y0RhdGUpXG5cbiAgcmV0dXJuIG9mZnNldE1pbGxpc2Vjb25kc1xuICAgID8gc3ViTWlsbGlzZWNvbmRzKHV0Y0RhdGUsIG9mZnNldE1pbGxpc2Vjb25kcylcbiAgICA6IHV0Y0RhdGVcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vdXRjVG9ab25lZFRpbWUvaW5kZXguanMiLCJpbXBvcnQgdHpUb2tlbml6ZURhdGUgZnJvbSAnLi4vdHpUb2tlbml6ZURhdGUvaW5kZXguanMnXG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiA9IDM2MDAwMDBcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDBcblxudmFyIHBhdHRlcm5zID0ge1xuICB0aW1lem9uZTogLyhbWistXS4qKSQvLFxuICB0aW1lem9uZVo6IC9eKFopJC8sXG4gIHRpbWV6b25lSEg6IC9eKFsrLV0pKFxcZHsyfSkkLyxcbiAgdGltZXpvbmVISE1NOiAvXihbKy1dKShcXGR7Mn0pOj8oXFxkezJ9KSQvLFxuICB0aW1lem9uZUlBTkE6IC8oVVRDfCg/OlthLXpBLVpdK1xcL1thLXpBLVpfXSsoPzpcXC9bYS16QS1aX10rKT8pKSQvXG59XG5cbi8vIFBhcnNlIHZhcmlvdXMgdGltZSB6b25lIG9mZnNldCBmb3JtYXRzIHRvIGFuIG9mZnNldCBpbiBtaWxsaXNlY29uZHNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHR6UGFyc2VUaW1lem9uZSh0aW1lem9uZVN0cmluZywgZGF0ZSkge1xuICB2YXIgdG9rZW5cbiAgdmFyIGFic29sdXRlT2Zmc2V0XG5cbiAgLy8gWlxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lWi5leGVjKHRpbWV6b25lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgdmFyIGhvdXJzXG5cbiAgLy8gwrFoaFxuICB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lSEguZXhlYyh0aW1lem9uZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXG5cbiAgICBpZiAoIXZhbGlkYXRlVGltZXpvbmUoaG91cnMpKSB7XG4gICAgICByZXR1cm4gTmFOXG4gICAgfVxuXG4gICAgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSXG4gICAgcmV0dXJuIHRva2VuWzFdID09PSAnKycgPyAtYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldFxuICB9XG5cbiAgLy8gwrFoaDptbSBvciDCsWhobW1cbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZUhITU0uZXhlYyh0aW1lem9uZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXG4gICAgdmFyIG1pbnV0ZXMgPSBwYXJzZUludCh0b2tlblszXSwgMTApXG5cbiAgICBpZiAoIXZhbGlkYXRlVGltZXpvbmUoaG91cnMsIG1pbnV0ZXMpKSB7XG4gICAgICByZXR1cm4gTmFOXG4gICAgfVxuXG4gICAgYWJzb2x1dGVPZmZzZXQgPVxuICAgICAgaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFXG4gICAgcmV0dXJuIHRva2VuWzFdID09PSAnKycgPyAtYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldFxuICB9XG5cbiAgLy8gSUFOQSB0aW1lIHpvbmVcbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZUlBTkEuZXhlYyh0aW1lem9uZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgLy8gdmFyIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSB0elRva2VuaXplRGF0ZShkYXRlLCB0aW1lem9uZVN0cmluZylcbiAgICB2YXIgdG9rZW5zID0gdHpUb2tlbml6ZURhdGUoZGF0ZSwgdGltZXpvbmVTdHJpbmcpXG4gICAgdmFyIGFzVVRDID0gRGF0ZS5VVEMoXG4gICAgICB0b2tlbnNbMF0sXG4gICAgICB0b2tlbnNbMV0gLSAxLFxuICAgICAgdG9rZW5zWzJdLFxuICAgICAgdG9rZW5zWzNdLFxuICAgICAgdG9rZW5zWzRdLFxuICAgICAgdG9rZW5zWzVdXG4gICAgKVxuICAgIHZhciB0aW1lc3RhbXBXaXRoTXNaZXJvZWQgPSBkYXRlLmdldFRpbWUoKSAtIChkYXRlLmdldFRpbWUoKSAlIDEwMDApXG4gICAgcmV0dXJuIC0oYXNVVEMgLSB0aW1lc3RhbXBXaXRoTXNaZXJvZWQpXG4gIH1cblxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSB7XG4gIGlmIChtaW51dGVzICE9IG51bGwgJiYgKG1pbnV0ZXMgPCAwIHx8IG1pbnV0ZXMgPiA1OSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMtdHovZXNtL19saWIvdHpQYXJzZVRpbWV6b25lL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IHsgRXZlbnRzTWl4aW4sIHdpdGhFdmVudHNNaXhpbiB9IGZyb20gJy4vRXZlbnRzTWl4aW4nXG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50c01peGluXG5leHBvcnQgeyB3aXRoRXZlbnRzTWl4aW4gfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0V2ZW50c01peGluL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IERhdGVUaW1lSW5wdXQgZnJvbSAnLi9EYXRlVGltZUlucHV0J1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUlucHV0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRGF0ZVRpbWVJbnB1dC9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBCb29sZWFuRWRpdG9yIGZyb20gJy4vQm9vbGVhbkVkaXRvcidcbmltcG9ydCBCb29sZWFuUmVuZGVyZXIgZnJvbSAnLi9Cb29sZWFuUmVuZGVyZXInXG5pbXBvcnQgQm9vbGVhbkZpbHRlciBmcm9tICcuL0Jvb2xlYW5GaWx0ZXInXG5pbXBvcnQgTnVtYmVyRWRpdG9yIGZyb20gJy4vTnVtYmVyRWRpdG9yJ1xuaW1wb3J0IFRleHRFZGl0b3IgZnJvbSAnLi9UZXh0RWRpdG9yJ1xuaW1wb3J0IFRlbXBsYXRlUmVuZGVyZXIgZnJvbSAnLi9UZW1wbGF0ZVJlbmRlcmVyJ1xuaW1wb3J0IEltYWdlUmVuZGVyZXIgZnJvbSAnLi9JbWFnZVJlbmRlcmVyJ1xuaW1wb3J0IERhdGVUaW1lRmlsdGVyIGZyb20gJy4vRGF0ZVRpbWVGaWx0ZXInXG5pbXBvcnQgRGF0ZVRpbWVFZGl0b3IgZnJvbSAnLi9EYXRlVGltZUVkaXRvcidcblxuZXhwb3J0IHtcbiAgQm9vbGVhbkVkaXRvcixcbiAgQm9vbGVhblJlbmRlcmVyLFxuICBCb29sZWFuRmlsdGVyLFxuICBOdW1iZXJFZGl0b3IsXG4gIFRleHRFZGl0b3IsXG4gIFRlbXBsYXRlUmVuZGVyZXIsXG4gIEltYWdlUmVuZGVyZXIsXG4gIERhdGVUaW1lRmlsdGVyLFxuICBEYXRlVGltZUVkaXRvcixcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBCb29sZWFuRWRpdG9yIGZyb20gJy4vQm9vbGVhbkVkaXRvcidcblxuZXhwb3J0IGRlZmF1bHQgQm9vbGVhbkVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5FZGl0b3IvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCBCb29sZWFuU3dpdGNoIGZyb20gJy4uL0Jvb2xlYW5Td2l0Y2gnXG5cbi8qKlxuICogQm9vbGVhbnMgRWRpdG9yXG4gKlxuICogSGFuZGxlIGJvb2xlYW4gdmFsdWVzIEVkaXRpbmdcbiAqXG4gKiAjIyBPcHRpb25zXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKipib29sZWFuVXNlZFRydWVWYWx1ZSoqICAgfCB1bmRlZmluZWQgICAgfCB0aGUgdmFsdWUgdG8gcmV0dXJuIHdoZW4gdGhlIGVkaXRvciBjaGFuZ2VzIHRoZSBjdXJyZW50IGNlbGwgdmFsdWUgdG8gdHJ1ZS4gaW4gY2FzZSBpdCBpcyB1bmRlZmluZWQgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGl0ZW0gaW4gKipib29sZWFuVHJ1ZVZhbHVlW10qKlxuICogfCAqKmJvb2xlYW5Vc2VkRmFsc2VWYWx1ZSoqICAgfCB1bmRlZmluZWQgICAgfCB0aGUgdmFsdWUgdG8gcmV0dXJuIHdoZW4gdGhlIGVkaXRvciBjaGFuZ2VzIHRoZSBjdXJyZW50IGNlbGwgdmFsdWUgdG8gZmFsc2UuIGluIGNhc2UgaXQgaXMgdW5kZWZpbmVkIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpdGVtIGluICoqYm9vbGVhbkZhbHNlVmFsdWVbXSoqXG4gKiB8ICoqYm9vbGVhblRydWVWYWx1ZVtdKiogICAgICAgfCB0cnVlKGJvb2wpICBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgdHJ1ZWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfCAqKmJvb2xlYW5GYWxzZVZhbHVlW10qKiAgICAgIHwgZmFsc2UoYm9vbCkgXHR8IFRoZSBvcHRpb25zIGRlc2NyaWJlcyB3aGF0IGlzIGNvbnNpZGVyZWQgYGZhbHNlYFxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIEJvb2xlYW5FZGl0b3IgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBpbml0KHBhcmFtcykge1xuICAgIGlmIChwYXJhbXMua2V5UHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gQm9vbGVhbihwYXJhbXMua2V5UHJlc3MpXG4gICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IEJvb2xlYW4ocGFyYW1zLmNoYXJQcmVzcylcbiAgICB9XG5cbiAgICB0aGlzLl90cnVlVmFsdWUgPSBbXS5jb25jYXQoXG4gICAgICB0aGlzLmdldE9wdGlvbignYm9vbGVhblRydWVWYWx1ZScsIHBhcmFtcywgW3RydWVdKVxuICAgIClcblxuICAgIHRoaXMuX2ZhbHNlVmFsdWUgPSBbXS5jb25jYXQoXG4gICAgICB0aGlzLmdldE9wdGlvbignYm9vbGVhbkZhbHNlVmFsdWUnLCBwYXJhbXMsIFtmYWxzZV0pXG4gICAgKVxuXG4gICAgdGhpcy5fcmV0dXJuVHJ1ZVZhbHVlID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAnYm9vbGVhblVzZWRUcnVlVmFsdWUnLFxuICAgICAgcGFyYW1zLFxuICAgICAgdGhpcy5fdHJ1ZVZhbHVlWzBdXG4gICAgKVxuICAgIHRoaXMuX3JldHVybkZhbHNlVmFsdWUgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICdib29sZWFuVXNlZEZhbHNlVmFsdWUnLFxuICAgICAgcGFyYW1zLFxuICAgICAgdGhpcy5fZmFsc2VWYWx1ZVswXVxuICAgIClcblxuICAgIHRoaXMuX3RydWVWYWx1ZSA9IHRoaXMuX3RydWVWYWx1ZS5tYXAoeCA9PiBTdHJpbmcoeCkpXG4gICAgdGhpcy5fZmFsc2VWYWx1ZSA9IHRoaXMuX2ZhbHNlVmFsdWUubWFwKHggPT4gU3RyaW5nKHgpKVxuXG4gICAgdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0XG4gICAgaWYgKHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICBsZXQga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9XG4gICAgICAgIHBhcmFtcy5rZXlQcmVzcyA9PSAzMiB8fCBwYXJhbXMua2V5UHJlc3MgPT0gNDYgLy8gc3BhY2UgLy8gZGVsZXRlXG5cbiAgICAgIGlmIChrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmNoYXJQcmVzcyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHBhcmFtcy5jaGFyUHJlc3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSB0aGlzLl9jb252ZXJ0VmFsdWUoXG4gICAgICB0aGlzLl92YWx1ZSxcbiAgICAgIHRoaXMuX3RydWVWYWx1ZSxcbiAgICAgIHRoaXMuX2ZhbHNlVmFsdWVcbiAgICApXG5cbiAgICB0aGlzLl9zd2l0Y2hlciA9IG5ldyBCb29sZWFuU3dpdGNoKHRoaXMuX3ZhbHVlLCBzd2l0Y2hlciA9PiB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2NvbnZlcnRWYWx1ZShcbiAgICAgICAgc3dpdGNoZXIuaXNDaGVja2VkKCksXG4gICAgICAgIHRoaXMuX3RydWVWYWx1ZSxcbiAgICAgICAgdGhpcy5fZmFsc2VWYWx1ZVxuICAgICAgKVxuICAgIH0pXG4gICAgdGhpcy5fc3dpdGNoZXIuaW5pdChwYXJhbXMpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBnZXRHdWkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXRjaGVyLmdldEd1aSgpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3N3aXRjaGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgR1VJIGlzIGF0dGFjaGVkIHRvIERPTS5cbiAgICogTWFrZSBzdXJlIHRoZSBjb250YWluZXIgaXMgYWx3YXlzIGZvY3VzZWQgYW5kIGxpc3RlbmluZyB0byBrZXkgY2hhbmdlc1xuICAgKi9cbiAgYWZ0ZXJHdWlBdHRhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuZm9jdXNJbigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZmluYWwgdmFsdWUgdG8gdGhlIGdyaWQsIHRoZSByZXN1bHQgb2YgdGhlIGVkaXRpbmdcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZSA/IHRoaXMuX3JldHVyblRydWVWYWx1ZSA6IHRoaXMuX3JldHVybkZhbHNlVmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBvbmNlIGFmdGVyIGluaXRpYWxpemVkIGFuZCByZXR1cm5zIGZhbHNlIHNvIHRoZSBlZGl0b3IgYXBwZWFycyBpbiB0aGUgY2VsbFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBhbHdheXMgZmFsc2VcbiAgICoqL1xuICBpc1BvcHVwKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGRvaW5nIGZ1bGwgcm93IGVkaXQsIHRoZW4gZ2V0cyBjYWxsZWQgd2hlbiB0YWJiaW5nIGludG8gdGhlIGNlbGwuXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBmb2N1c0luKCkge1xuICAgIHRoaXMuX3N3aXRjaGVyLnNldERpc2FibGVkKGZhbHNlKVxuICAgIHRoaXMuX3N3aXRjaGVyLmZvY3VzKClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGRvaW5nIGZ1bGwgcm93IGVkaXQsIHRoZW4gZ2V0cyBjYWxsZWQgd2hlbiB0YWJiaW5nIG91dCBvZiB0aGUgY2VsbC5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGZvY3VzT3V0KCkge1xuICAgIHRoaXMuX3N3aXRjaGVyLnNldERpc2FibGVkKHRydWUpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZhbHVlIHRoZSBjdXJyZW50IGNlbGwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB0cnVlVmFsdWUgdHJ1ZSB2YWx1ZSBhbGlhc1xuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGZhbHNlVmFsdWUgZmFsc2UgdmFsdWUgYWxpYXNcbiAgICovXG4gIF9jb252ZXJ0VmFsdWUodmFsdWUsIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlQXNTdHJpbmcgPSBTdHJpbmcodmFsdWUpXG5cbiAgICByZXR1cm4gdHJ1ZVZhbHVlLmluZGV4T2YodmFsdWVBc1N0cmluZykgPiAtMVxuICAgICAgPyB0cnVlXG4gICAgICA6IGZhbHNlVmFsdWUuaW5kZXhPZih2YWx1ZUFzU3RyaW5nKSA+IC0xXG4gICAgICA/IGZhbHNlXG4gICAgICA6IHZhbHVlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQm9vbGVhbkVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5FZGl0b3IvQm9vbGVhbkVkaXRvci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGNvbXBvbmVudCBjbGFzc1xuICpcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIGFic3RyYWN0IGNsYXNzIHdoaWNoIGFsbCBjb21wb25lbnRzIHNob3VsZCB1c2VcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBDb21wb25lbnQge1xuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCBodG1sIGVsZW1lbnRcbiAgICpcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2d1aSA9IG51bGxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICpcbiAgICogQHJldHVybiB2b2lkXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgaW5pdChwYXJhbXMpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCB0aGUgW2luaXRdIG1ldGhvZGBcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudCBvZiB0aGUgY29tcG9uZW50LCB0aGlzIGlzIHdoYXQgdGhlIGdyaWQgcHV0cyBpbnRvIHRoZSBjZWxsXG4gICAqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgZ2V0R3VpKCkge1xuICAgIHJldHVybiB0aGlzLl9ndWlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLiBJZiB5b3VyIGN1c3RvbSBjb21wb25lbnQgbmVlZHMgdG8gZG9cbiAgICogYW55IHJlc291cmNlIGNsZWFuaW5nIHVwLCBkbyBpdCBoZXJlLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBwYXNzXG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgcmVxdWlyZWQgb3B0aW9uIHZhbHVlXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0cnkgdG8gZmluZCB0aGUgcGFzc2VkIG9wdGlvbidzIHZhbHVlIGluIHRoZSBmb2xsb3dpbmcgb3JkZXJcbiAgICpcbiAgICogIDEuIHBhcmFtc1xuICAgKiAgMi4gU2VhcmNoIGBwYXJhbXMuY29sRGVmYFxuICAgKiAgMy4gU2VhcmNoIGBwYXJhbXMuY29udGV4dC5BR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnW0NPTFVNTl9JRF1gIG9yIGBwYXJhbXMuY29udGV4dC5tZXRhW0NPTFVNTl9JRF1gXG4gICAqICA0LiBTZWFyY2ggYHBhcmFtcy5jb250ZXh0LkFHcmlkQ29tcG9uZW50c01ldGFDb25maWdgIG9yIGBwYXJhbXMuY29udGV4dC5tZXRhYFxuICAgKiAgNS4gU2VhcmNoIGBwYXJhbXMuY29udGV4dGBcbiAgICogIDYuIElmIG5vbmUgZm91bmQgcmV0dXJuIHRoZSBmYWxsYmFja1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgb3B0aW9uXG4gICAqIEBwYXJhbSB7cGFyYW1zfSBwYXJhbXMgYW4gb2JqZWN0IHVzZWQgdG8gc2VhcmNoIGZvciB0aGUgb3B0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmYWxsYmFjayBhIHZhbHVlIHRvIHJldHVybiBpbiBjYXNlIHRoZSBvcHRpb24gY2FuIG5vdCBiZSBmb3VuZFxuICAgKi9cbiAgZ2V0T3B0aW9uKG5hbWUsIHBhcmFtcywgZmFsbGJhY2sgPSBudWxsKSB7XG4gICAgbGV0IG9wdGlvblxuXG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgcGFyYW1zW25hbWVdICE9PSBudWxsKSB7XG4gICAgICBvcHRpb24gPSBwYXJhbXNbbmFtZV1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdHJ5IHRvIGZldGNoIGZyb20gdGhlIGNvbHVtbiBkZWYgZmlyc3RcbiAgICAgIGlmIChcbiAgICAgICAgcGFyYW1zLmhhc093blByb3BlcnR5KCdjb2xEZWYnKSAmJlxuICAgICAgICBwYXJhbXMuY29sRGVmLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgIHBhcmFtcy5jb2xEZWZbbmFtZV0gIT09IG51bGxcbiAgICAgICkge1xuICAgICAgICBvcHRpb24gPSBwYXJhbXMuY29sRGVmW25hbWVdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0cnkgdG8gZmV0Y2ggZnJvbSBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnfG1ldGEgaW4gdGhlIGNvbnRleHRcbiAgICAgICAgbGV0IEFHcmlkQ29tcG9uZW50c01ldGFDb25maWcgPSBudWxsXG4gICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoJ2NvbnRleHQnKSkge1xuICAgICAgICAgIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWcgPVxuICAgICAgICAgICAgcGFyYW1zLmNvbnRleHQuQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZyB8fCBwYXJhbXMuY29udGV4dC5tZXRhXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZyAmJlxuICAgICAgICAgIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWcuaGFzT3duUHJvcGVydHkocGFyYW1zLmNvbHVtbi5jb2xJZCkgJiZcbiAgICAgICAgICBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnW3BhcmFtcy5jb2x1bW4uY29sSWRdLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZ1twYXJhbXMuY29sdW1uLmNvbElkXVtuYW1lXSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb24gPSBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnW3BhcmFtcy5jb2x1bW4uY29sSWRdW25hbWVdXG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgQUdyaWRDb21wb25lbnRzTWV0YUNvbmZpZyAmJlxuICAgICAgICAgIEFHcmlkQ29tcG9uZW50c01ldGFDb25maWcuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICBBR3JpZENvbXBvbmVudHNNZXRhQ29uZmlnW25hbWVdICE9PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbiA9IEFHcmlkQ29tcG9uZW50c01ldGFDb25maWdbbmFtZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0cnkgdG8gZmV0Y2ggZnJvbSB0aGUgY29udGV4dCBvYmplY3QgaXRzZWxmXG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHBhcmFtcy5jb250ZXh0XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29udGV4dCAmJlxuICAgICAgICAgICAgY29udGV4dC5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICAgICAgY29udGV4dFtuYW1lXSAhPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgb3B0aW9uID0gY29udGV4dFtuYW1lXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0cnkgdG8gY2hlY2sgcGFyYW1zIGl0c2VsZiBvciBmYWxsYmFjayB0byBkZWZhdWx0XG4gICAgICAgICAgICBvcHRpb24gPSBmYWxsYmFja1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0eXBlb2Ygb3B0aW9uICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbiA6IGZhbGxiYWNrXG4gIH1cblxuICAvKipcbiAgICogR2V0IFdpbmRvdyBJbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge3BhcmFtc30gcGFyYW1zIGFuIG9iamVjdCB1c2VkIHRvIHNlYXJjaCBmb3IgdGhlIHdpbmRvdyBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtXaW5kb3d9XG4gICAqL1xuICBnZXRXaW4ocGFyYW1zKSB7XG4gICAgY29uc3Qgd2luID0gdGhpcy5nZXRPcHRpb24oJ3dpbmRvdycsIHBhcmFtcykgfHwgd2luZG93IHx8IG51bGxcblxuICAgIGlmICghd2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3aW5kb3cnKVxuICAgIH1cblxuICAgIHJldHVybiB3aW5cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZG9jdW1lbnQgSW5zdGFuY2VcbiAgICpcbiAgICogQHBhcmFtIHtwYXJhbXN9IHBhcmFtcyBhbiBvYmplY3QgdXNlZCB0byBzZWFyY2ggZm9yIHRoZSBkb2N1bWVudCBpbnN0YW5jZVxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MRG9jdW1lbnR9XG4gICAqL1xuICBnZXREb2MocGFyYW1zKSB7XG4gICAgY29uc3QgZG9jID0gdGhpcy5nZXRPcHRpb24oJ2RvY3VtZW50JywgcGFyYW1zKSB8fCBkb2N1bWVudCB8fCBudWxsXG5cbiAgICBpZiAoIWRvYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgZG9jdW1lbnQnKVxuICAgIH1cblxuICAgIHJldHVybiBkb2NcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21wb25lbnQvQ29tcG9uZW50LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlIH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuLi9Db21wb25lbnQnXG5pbXBvcnQgJy4vc3R5bGUuc2NzcydcblxuLyoqXG4gKiBCb29sZWFuIFJlbmRlcmVyXG4gKlxuICogU2ltcGxlIHRvZ2dsZSBzd2l0Y2ggdG8gaGFuZGxlIGJvb2xlYW4gdmFsdWVzXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgQm9vbGVhblN3aXRjaCBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IEJvb2xlYW5Td2l0Y2ggQ29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luaXRpYWxWYWx1ZSA9IGZhbHNlXSB0aGUgZGVmYXVsdCBzdGF0ZSAsIGNoZWNrZWQgb3IgdW5jaGVja2VkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtsaXN0ZW5lciA9IG51bGxdIGEgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN0YXRlIGlzIGNoYW5nZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSA9IGZhbHNlLCBsaXN0ZW5lciA9IG51bGwpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5zZXRDaGVja2VkKGluaXRpYWxWYWx1ZSlcbiAgICB0aGlzLnNldExpc3RlbmVyKGxpc3RlbmVyKVxuICAgIHRoaXMuc2V0RGlzYWJsZWQoZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgaW5pdChwYXJhbXMpIHtcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpXG4gICAgdGhpcy5fb25LZXlkb3duID0gdGhpcy5fb25LZXlkb3duLmJpbmQodGhpcylcblxuICAgIHRoaXMuX2d1aSA9IHRoaXMuZ2V0RG9jKHBhcmFtcykuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ2Jvb2xTd2l0Y2hfX3dyYXBwZXInXG4gICAgdGhpcy5fZ3VpLnRhYkluZGV4ID0gLTFcblxuICAgIHRoaXMucmVuZGVyKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHN3aXRjaCBzbGlkZXIgYW5kIGhpZGRlbiBpbnB1dC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBkb2MgPSB0aGlzLmdldERvYyh0aGlzLl9wYXJhbXMpXG5cbiAgICBjb25zdCBib29sU3dpdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBib29sU3dpdGNoLmNsYXNzTmFtZSA9ICdib29sU3dpdGNoJ1xuXG4gICAgLy8gaW5wdXRcbiAgICB0aGlzLl9pbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgdGhpcy5faW5wdXQuaWQgPSBgZWwtJHtNYXRoLnJhbmRvbSgpfWBcbiAgICB0aGlzLl9pbnB1dC5uYW1lID0gJ2NoZWNrYm94J1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTmFtZSA9ICdib29sU3dpdGNoX19jaGVja2JveCdcbiAgICB0aGlzLl9pbnB1dC50eXBlID0gJ2NoZWNrYm94J1xuICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZCgpXG4gICAgdGhpcy5faW5wdXQuZGlzYWJsZWQgPSB0aGlzLmlzRGlzYWJsZWQoKVxuICAgIHRoaXMuX2lucHV0LnRhYkluZGV4ID0gJzAnXG5cbiAgICAvLyBsYWJlbFxuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKVxuICAgIGxhYmVsLmNsYXNzTmFtZSA9ICdib29sU3dpdGNoX19sYWJlbCdcbiAgICBsYWJlbC5mb3IgPSB0aGlzLl9pbnB1dC5pZFxuICAgIGxhYmVsLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJib29sU3dpdGNoX19pbm5lclwiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiYm9vbFN3aXRjaF9fc3dpdGNoXCI+PC9zcGFuPlxuICAgIGBcblxuICAgIC8vIGF0dGFjaGUgaW5wdXQgYW5kIHNsaWRlciB0byBjb21wb25lbnRcbiAgICBib29sU3dpdGNoLmFwcGVuZENoaWxkKHRoaXMuX2lucHV0KVxuICAgIGJvb2xTd2l0Y2guYXBwZW5kQ2hpbGQobGFiZWwpXG5cbiAgICBib29sU3dpdGNoLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaylcbiAgICB0aGlzLl9ndWkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93bilcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChib29sU3dpdGNoKVxuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgYm9vbFN3aXRjaCA9IHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCcuYm9vbFN3aXRjaCcpXG4gICAgYm9vbFN3aXRjaC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2spXG4gICAgdGhpcy5fZ3VpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleWRvd24pXG4gIH1cblxuICAvKipcbiAgICogRm9jdXMgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5fZ3VpLmZvY3VzKClcbiAgICB0aGlzLl9pbnB1dC5mb2N1cygpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbGlzdGVuZXIgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHN3aXRjaCBzdGF0ZSBpcyBjaGFuZ2VkXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAqL1xuICBzZXRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xpc3RlbmVyID0gbGlzdGVuZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3RlbmVyIGluc3RhbmNlICwgaWZcbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb258bnVsbH1cbiAgICovXG4gIGdldExpc3RlbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9saXN0ZW5lclxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjaGVja2VkXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdmFsdWUgdHJ1ZSB0byBjaGVjayAsIGZhbHNlIHRvIHVuY2hlY2tcbiAgICovXG4gIHNldENoZWNrZWQodmFsdWUpIHtcbiAgICB0aGlzLl9jaGVja2VkID0gdmFsdWVcbiAgICBpZiAodGhpcy5faW5wdXQpIHtcbiAgICAgIHRoaXMuX2lucHV0LmNoZWNrZWQgPSB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgaWYgc3dpdGNoIGlzIGNoZWNrZWRcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gIHRydWUgd2hlbiBjaGVja2VkICwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBpc0NoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIGNvbXBvbmVudCBzdGF0ZVxuICAgKi9cbiAgdG9nZ2xlKCkge1xuICAgIHRoaXMuc2V0Q2hlY2tlZCghdGhpcy5pc0NoZWNrZWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgZGlzYWJsZWRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSB2YWx1ZSB0cnVlIHRvIGRpc2FibGVkICwgZmFsc2UgdG8gZW5hYmxlXG4gICAqL1xuICBzZXREaXNhYmxlZCh2YWx1ZSkge1xuICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWVcbiAgICBpZiAodGhpcy5faW5wdXQpIHtcbiAgICAgIHRoaXMuX2lucHV0LmRpc2FibGVkID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN3aXRjaCBpcyBkaXNhYmxlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gZGlzYWJsZWQgLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkXG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY2xpY2sgbGlzdGVuZXIgb2YgdGhlIHN3aXRjaC4gSXQgd2lsbCB0b2dnbGUgdGhlIHN0YXRlIGFuZCBmaXJlIGFueSByZWdpc3RlcmVkIGxpc3RlbmVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGV2ZW50IG9iamVjdFxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIF9vbkNsaWNrKGUpIHtcbiAgICBpZiAodGhpcy5fZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMudG9nZ2xlKClcblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcikge1xuICAgICAgdGhpcy5fbGlzdGVuZXIodGhpcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQga2V5IGxpc3RlbmVyIG9mIHRoZSBzd2l0Y2guIEl0IHdpbGwgdG9nZ2xlIHRoZSBzdGF0ZSB1c2luZyBrZXlib2FyZCBrZXlzIChsZWZ0ICwgcmlnaHQgLCBzcGFjZSlcbiAgICogYW5kIGZpcmUgYW55IHJlZ2lzdGVyZWQgbGlzdGVuZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZSAgdGhlIGV2ZW50IG9iamVjdFxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uS2V5ZG93bihlKSB7XG4gICAgaWYgKHRoaXMuX2Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBlLndoaWNoIHx8IGUua2V5Q29kZVxuXG4gICAgLy8gc3BhY2VcbiAgICBpZiAoa2V5ID09IDMyKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpXG4gICAgICBpZiAodGhpcy5fbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIodGhpcylcbiAgICAgIH1cbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgLy8gcmlnaHRcbiAgICBlbHNlIGlmIChrZXkgPT0gMzkpIHtcbiAgICAgIHRoaXMuc2V0Q2hlY2tlZCh0cnVlKVxuICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyKHRoaXMpXG4gICAgICB9XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgfVxuICAgIC8vIGxlZnRcbiAgICBlbHNlIGlmIChrZXkgPT0gMzcpIHtcbiAgICAgIHRoaXMuc2V0Q2hlY2tlZChmYWxzZSlcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcih0aGlzKVxuICAgICAgfVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuU3dpdGNoXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhblN3aXRjaC9Cb29sZWFuU3dpdGNoLmpzIiwiaW1wb3J0IHsgZGVjb3JhdGUsIGNyZWF0ZURlZmF1bHRTZXR0ZXIgfSBmcm9tICcuL3ByaXZhdGUvdXRpbHMnO1xuY29uc3QgeyBkZWZpbmVQcm9wZXJ0eSB9ID0gT2JqZWN0O1xuXG5mdW5jdGlvbiBoYW5kbGVEZXNjcmlwdG9yKHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGNvbnN0IHsgY29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBpbml0aWFsaXplciwgdmFsdWUgfSA9IGRlc2NyaXB0b3I7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlLFxuICAgIGVudW1lcmFibGUsXG5cbiAgICBnZXQoKSB7XG4gICAgICAvLyBUaGlzIGhhcHBlbnMgaWYgc29tZW9uZSBhY2Nlc3NlcyB0aGVcbiAgICAgIC8vIHByb3BlcnR5IGRpcmVjdGx5IG9uIHRoZSBwcm90b3R5cGVcbiAgICAgIGlmICh0aGlzID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXQgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyLmNhbGwodGhpcykgOiB2YWx1ZTtcblxuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgZW51bWVyYWJsZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiByZXRcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBzZXQ6IGNyZWF0ZURlZmF1bHRTZXR0ZXIoa2V5KVxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZSguLi5hcmdzKSB7XG4gIHJldHVybiBkZWNvcmF0ZShoYW5kbGVEZXNjcmlwdG9yLCBhcmdzKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWRlY29yYXRvcnMvc3JjL2xhenktaW5pdGlhbGl6ZS5qcyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuU3dpdGNoL3N0eWxlLnNjc3MiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hZy1jZWxsLWlubGluZS1lZGl0aW5nIC5ib29sU3dpdGNoX193cmFwcGVye21hcmdpbjphdXRvIDExcHh9LmJvb2xTd2l0Y2hfX3dyYXBwZXJ7ZGlzcGxheTpmbGV4O3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YWxpZ24taXRlbXM6Y2VudGVyO291dGxpbmU6bm9uZTtwYWRkaW5nLWxlZnQ6NnB4O292ZXJmbG93OmhpZGRlbjstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lfS5ib29sU3dpdGNoe3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjU1cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZX0uYm9vbFN3aXRjaF9fY2hlY2tib3h7ZGlzcGxheTpub25lfS5ib29sU3dpdGNoX19sYWJlbHtkaXNwbGF5OmJsb2NrO292ZXJmbG93OmhpZGRlbjtjdXJzb3I6cG9pbnRlcjtib3JkZXI6MnB4IHNvbGlkIHZhcigtLWFnLWlucHV0LWJvcmRlci1jb2xvciwgdmFyKC0tYWctYm9yZGVyLWNvbG9yLCAjYmFiZmM3KSk7Ym9yZGVyLXJhZGl1czoyMHB4fS5ib29sU3dpdGNoX19pbm5lcntkaXNwbGF5OmJsb2NrO3dpZHRoOjIwMCU7bWFyZ2luLWxlZnQ6LTEwMCU7dHJhbnNpdGlvbjptYXJnaW4gMC4zcyBlYXNlLWluIDBzfS5ib29sU3dpdGNoX19pbm5lcjpiZWZvcmUsLmJvb2xTd2l0Y2hfX2lubmVyOmFmdGVye2Rpc3BsYXk6YmxvY2s7ZmxvYXQ6bGVmdDt3aWR0aDo1MCU7aGVpZ2h0OjE1cHg7cGFkZGluZzowO2xpbmUtaGVpZ2h0OjE1cHg7Zm9udC1zaXplOjE0cHg7Y29sb3I6d2hpdGU7Zm9udC1mYW1pbHk6J1NlZ29lIFVJIFN5bWJvbCcsIFRyZWJ1Y2hldCwgQXJpYWwsIHNhbnMtc2VyaWY7Zm9udC13ZWlnaHQ6Ym9sZDtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmJvb2xTd2l0Y2hfX2lubmVyOmJlZm9yZXtjb250ZW50OidcXFxcMjcxNCc7cGFkZGluZy1sZWZ0OjEwcHg7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1hZy1jaGVja2JveC1jaGVja2VkLWNvbG9yLCB2YXIoLS1hZy1hbHBpbmUtYWN0aXZlLWNvbG9yLCAjMjE5NmYzKSk7Y29sb3I6I2ZmZmZmZn0uYm9vbFN3aXRjaF9faW5uZXI6YWZ0ZXJ7Y29udGVudDonXFxcXDI3MTgnO3BhZGRpbmctcmlnaHQ6MTBweDtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWFnLWJhY2tncm91bmQtY29sb3IpO2NvbG9yOnZhcigtLWFnLWlucHV0LWJvcmRlci1jb2xvciwgdmFyKC0tYWctYm9yZGVyLWNvbG9yLCAjYmFiZmM3KSk7dGV4dC1hbGlnbjpyaWdodH0uYm9vbFN3aXRjaF9fc3dpdGNoe2Rpc3BsYXk6YmxvY2s7d2lkdGg6MThweDttYXJnaW46MXB4O2JhY2tncm91bmQ6I2ZmZmZmZjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDozNXB4O2JvcmRlcjoycHggc29saWQgdmFyKC0tYWctaW5wdXQtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNiYWJmYzcpKTtib3JkZXItcmFkaXVzOjIwcHg7dHJhbnNpdGlvbjphbGwgMC4zcyBlYXNlLWluIDBzfS5ib29sU3dpdGNoX19jaGVja2JveDpjaGVja2VkKy5ib29sU3dpdGNoX19sYWJlbCAuYm9vbFN3aXRjaF9faW5uZXJ7bWFyZ2luLWxlZnQ6MH0uYm9vbFN3aXRjaF9fY2hlY2tib3g6Y2hlY2tlZCsuYm9vbFN3aXRjaF9fbGFiZWwgLmJvb2xTd2l0Y2hfX3N3aXRjaHtyaWdodDowcHh9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9Cb29sZWFuU3dpdGNoL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBCb29sZWFuUmVuZGVyZXIgZnJvbSAnLi9Cb29sZWFuUmVuZGVyZXInXG5cbmV4cG9ydCBkZWZhdWx0IEJvb2xlYW5SZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5SZW5kZXJlci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IEJvb2xlYW5Td2l0Y2ggZnJvbSAnLi4vQm9vbGVhblN3aXRjaCdcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG5cbi8qKlxuICogQm9vbGVhbnMgUmVuZGVyZXJcbiAqXG4gKiBIYW5kbGUgYm9vbGVhbiB2YWx1ZXMgUmVuZGVyaW5nXG4gKlxuICogIyMgT3B0aW9uc1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqYm9vbGVhblRydWVSZW5kZXJWYWx1ZSoqICBcdHwgc3dpdGNoICAgICAgXHR8IFRoZSBvcHRpb24gY29udHJvbHMgaG93IHRvIHJlbmRlciBgdHJ1ZWAgdmFsdWVzLiA8YnI+ICoqc3dpdGNoKiogaXMgYSBzcGVjaWFsIHZhbHVlIHVzZWQgdG8gcmVuZGVyIHRydWUgdmFsdWVzIGFzIGEgc3dpdGNoIGNvbXBvbmVudCAgXHR8XG4gKiB8ICoqYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUqKiBcdHwgc3dpdGNoICAgICAgXHR8IFRoZSBvcHRpb24gY29udHJvbHMgaG93IHRvIHJlbmRlciBgZmFsc2VgIHZhbHVlcy4gPGJyPiAqKnN3aXRjaCoqIGlzIGEgc3BlY2lhbCB2YWx1ZSB1c2VkIHRvIHJlbmRlciB0cnVlIHZhbHVlcyBhcyBhIHN3aXRjaCBjb21wb25lbnQgXHR8XG4gKiB8ICoqYm9vbGVhblRydWVWYWx1ZVtdKiogICAgICAgfCB0cnVlKGJvb2wpICBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgdHJ1ZWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfCAqKmJvb2xlYW5GYWxzZVZhbHVlW10qKiAgICAgIHwgZmFsc2UoYm9vbCkgXHR8IFRoZSBvcHRpb25zIGRlc2NyaWJlcyB3aGF0IGlzIGNvbnNpZGVyZWQgYGZhbHNlYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBCb29sZWFuUmVuZGVyZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBCb29sZWFuUmVuZGVyZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKClcblxuICAgIC8vIHdpbGwgdGhpcyBhZmZlY3QgQkJqIGJ1aSA/XG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICdib29sUmVuZGVyZXInXG4gICAgdGhpcy5fZ3VpLnN0eWxlLmZvbnRGYW1pbHkgPVxuICAgICAgJ1wiU2Vnb2UgVUkgU3ltYm9sXCIsVHJlYnVjaGV0LCBBcmlhbCwgc2Fucy1zZXJpZidcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGluaXQocGFyYW1zKSB7XG4gICAgdGhpcy5yZWZyZXNoKHBhcmFtcywgdHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIGdldEd1aSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3VpXG4gIH1cblxuICAvKipcbiAgICogIEBpbmhlcml0RG9jXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9zd2l0Y2hlcikge1xuICAgICAgdGhpcy5fc3dpdGNoZXIuZGVzdHJveSgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2ggdGhlIGNlbGxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBjZWxsIHJlbmRlcmVyIHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCB0cnVlIHdoZW4gdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGluIGBpbml0YCBwaGFzZSAsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSByZWZyZXNoIHN1Y2NlZWRlZCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICByZWZyZXNoKHBhcmFtcywgaXNJbml0KSB7XG4gICAgbGV0IHZhbHVlID0gcGFyYW1zLnZhbHVlRm9ybWF0dGVkID8gcGFyYW1zLnZhbHVlRm9ybWF0dGVkIDogcGFyYW1zLnZhbHVlXG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICAgICAgY29uc3QgYm9vbGVhblRydWVSZW5kZXJWYWx1ZSA9IFN0cmluZyhcbiAgICAgICAgdGhpcy5nZXRPcHRpb24oJ2Jvb2xlYW5UcnVlUmVuZGVyVmFsdWUnLCBwYXJhbXMsICdzd2l0Y2gnKVxuICAgICAgKVxuICAgICAgY29uc3QgYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWUgPSBTdHJpbmcoXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uKCdib29sZWFuRmFsc2VSZW5kZXJWYWx1ZScsIHBhcmFtcywgJ3N3aXRjaCcpXG4gICAgICApXG4gICAgICBjb25zdCBib29sZWFuVHJ1ZVZhbHVlID0gW11cbiAgICAgICAgLmNvbmNhdCh0aGlzLmdldE9wdGlvbignYm9vbGVhblRydWVWYWx1ZScsIHBhcmFtcywgW3RydWVdKSlcbiAgICAgICAgLm1hcCh4ID0+IFN0cmluZyh4KSlcbiAgICAgIGNvbnN0IGJvb2xlYW5GYWxzZVZhbHVlID0gW11cbiAgICAgICAgLmNvbmNhdCh0aGlzLmdldE9wdGlvbignYm9vbGVhbkZhbHNlVmFsdWUnLCBwYXJhbXMsIFtmYWxzZV0pKVxuICAgICAgICAubWFwKHggPT4gU3RyaW5nKHgpKVxuXG4gICAgICAvLyBoYW5kbGUgdHJ1ZSB2YWx1ZXNcbiAgICAgIGlmIChib29sZWFuVHJ1ZVZhbHVlLmluZGV4T2YodmFsdWUpID4gLTEpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFib29sZWFuVHJ1ZVJlbmRlclZhbHVlLmxlbmd0aCB8fFxuICAgICAgICAgIGJvb2xlYW5UcnVlUmVuZGVyVmFsdWUgPT09ICdzd2l0Y2gnXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN3aXRjaGVyID0gdGhpcy5fZ2V0U3dpdGNoZXIocGFyYW1zKVxuICAgICAgICAgIHN3aXRjaGVyLnNldENoZWNrZWQodHJ1ZSlcbiAgICAgICAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gJydcbiAgICAgICAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQoc3dpdGNoZXIuZ2V0R3VpKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9IGJvb2xlYW5UcnVlUmVuZGVyVmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIGZhbHNlIHZhbHVlc1xuICAgICAgZWxzZSBpZiAoYm9vbGVhbkZhbHNlVmFsdWUuaW5kZXhPZih2YWx1ZSkgPiAtMSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWJvb2xlYW5GYWxzZVJlbmRlclZhbHVlLmxlbmd0aCB8fFxuICAgICAgICAgIGJvb2xlYW5GYWxzZVJlbmRlclZhbHVlID09PSAnc3dpdGNoJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBzd2l0Y2hlciA9IHRoaXMuX2dldFN3aXRjaGVyKHBhcmFtcylcbiAgICAgICAgICBzd2l0Y2hlci5zZXRDaGVja2VkKGZhbHNlKVxuICAgICAgICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSAnJ1xuICAgICAgICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChzd2l0Y2hlci5nZXRHdWkoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gYm9vbGVhbkZhbHNlUmVuZGVyVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3dpdGNoIGluc3RhbmNlIGlmIGF2YWlsYWJsZSAsIG9yIGNyZWF0ZSBpdCBvdGhlcndpc2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFuU3dpdGNofSBzd2l0Y2ggaW5zdGFuY2VcbiAgICovXG4gIF9nZXRTd2l0Y2hlcihwYXJhbXMpIHtcbiAgICBpZiAoIXRoaXMuX3N3aXRjaGVyKSB7XG4gICAgICB0aGlzLl9zd2l0Y2hlciA9IG5ldyBCb29sZWFuU3dpdGNoKClcbiAgICAgIHRoaXMuX3N3aXRjaGVyLnNldERpc2FibGVkKHRydWUpXG4gICAgICB0aGlzLl9zd2l0Y2hlci5pbml0KHBhcmFtcylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3dpdGNoZXJcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuUmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Cb29sZWFuUmVuZGVyZXIvQm9vbGVhblJlbmRlcmVyLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IEJvb2xlYW5GaWx0ZXIgZnJvbSAnLi9Cb29sZWFuRmlsdGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhbkZpbHRlci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCB7IGF1dG9iaW5kLCBvdmVycmlkZSB9IGZyb20gJ2NvcmUtZGVjb3JhdG9ycydcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0ICcuL3N0eWxlLnNjc3MnXG5cbmNvbnN0IHRvVGl0bGVDYXNlID0gcGhyYXNlID0+IHtcbiAgcmV0dXJuIHBocmFzZVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnNwbGl0KCcgJylcbiAgICAubWFwKHdvcmQgPT4gd29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSkpXG4gICAgLmpvaW4oJyAnKVxufVxuXG5jb25zdCBzdHJpcEhUTUwgPSBodG1sID0+IHtcbiAgY29uc3QgdG1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJylcbiAgdG1wLmlubmVySFRNTCA9IGh0bWxcbiAgcmV0dXJuIHRtcC50ZXh0Q29udGVudCB8fCB0bXAuaW5uZXJUZXh0IHx8ICcnXG59XG5cbi8qKlxuICogQm9vbGVhbnMgRmlsdGVyXG4gKlxuICogSGFuZGxlIGJvb2xlYW4gdmFsdWVzIEZpbHRlcmluZ1xuICpcbiAqICMjIE9wdGlvbnNcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKmJvb2xlYW5Vc2VkVHJ1ZVZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IHRoZSB2YWx1ZSB0byB1c2Ugd2hlbiB0aGUgZmlsdGVyIGRpc3BsYXlzIHRoZSB0cnVlIHN0YXRlIC4gaW4gY2FzZSBpdCBpcyB1bmRlZmluZWQgdGhlbiB3ZSB1c2UgdGhlIGZpcnN0IGl0ZW0gaW4gKipib29sZWFuVHJ1ZVZhbHVlW10qKlxuICogfCAqKmJvb2xlYW5Vc2VkRmFsc2VWYWx1ZSoqICAgfCB1bmRlZmluZWQgICAgfCB0aGUgdmFsdWUgdG8gdXNlIHdoZW4gdGhlIGZpbHRlciBkaXNwbGF5cyB0aGUgZmFsc2Ugc3RhdGUuIGluIGNhc2UgaXQgaXMgdW5kZWZpbmVkIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpdGVtIGluICoqYm9vbGVhbkZhbHNlVmFsdWVbXSoqXG4gKiB8ICoqYm9vbGVhblRydWVWYWx1ZVtdKiogICAgICAgfCB0cnVlKGJvb2wpICBcdHwgVGhlIG9wdGlvbnMgZGVzY3JpYmVzIHdoYXQgaXMgY29uc2lkZXJlZCBgdHJ1ZWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfCAqKmJvb2xlYW5GYWxzZVZhbHVlW10qKiAgICAgIHwgZmFsc2UoYm9vbCkgXHR8IFRoZSBvcHRpb25zIGRlc2NyaWJlcyB3aGF0IGlzIGNvbnNpZGVyZWQgYGZhbHNlYFxuICogfCAqKmNsZWFyQnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYSBDbGVhciBidXR0b24uIFRoZSBDbGVhciBidXR0b24gd2lsbCBjbGVhciB0aGUgKGZvcm0pIGRldGFpbHMgb2YgdGhlIGZpbHRlciB3aXRob3V0IHJlbW92aW5nIGFueSBhY3RpdmUgZmlsdGVycyBvbiB0aGUgY29sdW1uLlxuICogfCAqKmFwcGx5QnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYW4gQXBwbHkgYnV0dG9uLiBJZiB0aGUgQXBwbHkgYnV0dG9uIGlzIHByZXNlbnQsIHRoZW4gdGhlIGZpbHRlciBpcyBvbmx5IGFwcGxpZWQgYWZ0ZXIgdGhlIHVzZXIgaGl0cyB0aGUgQXBwbHkgYnV0dG9uLlxuICogfCAqKnJlc2V0QnV0dG9uKiogICB8IGZhbHNlICAgIHwgIFNldCB0byB0cnVlIHRvIGhhdmUgdGhlIGZpbHRlciB1c2UgYSBSZXNldCBidXR0b24uIFRoZSBSZXNldCBidXR0b24gd2lsbCBjbGVhciB0aGUgZGV0YWlscyBvZiB0aGUgZmlsdGVyIGFuZCBhbnkgYWN0aXZlIGZpbHRlcnMgb24gdGhhdCBjb2x1bW4uXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY2xhc3MgQm9vbGVhbkZpbHRlciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBUcnVlICwgZmFsc2UgdHJhbnNsYXRpb25cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9ib29sZWFuRmlsdGVyVHJhbnNsYXRpb24gPSB7fVxuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBCb29sZWFuRmlsdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnYm9vbGVhbkZpbHRlciBhZy1maWx0ZXItYm9keS13cmFwcGVyJ1xuICAgIHRoaXMuX2d1aS50YWJJbmRleCA9ICcwJ1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgaW5pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2xhdGUgPSBwYXJhbXMuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5nZXRMb2NhbGVUZXh0RnVuYygpXG4gICAgY29uc3QgaXNDbGVhckZpbHRlciA9IHRoaXMuZ2V0T3B0aW9uKCdjbGVhckJ1dHRvbicsIHBhcmFtcywgZmFsc2UpXG4gICAgY29uc3QgaXNSZXNldEJ1dHRvbiA9IHRoaXMuZ2V0T3B0aW9uKCdyZXNldEJ1dHRvbicsIHBhcmFtcywgZmFsc2UpXG4gICAgY29uc3QgaXNBcHBseUJ1dHRvbiA9IHRoaXMuZ2V0T3B0aW9uKCdhcHBseUJ1dHRvbicsIHBhcmFtcywgZmFsc2UpXG5cbiAgICB0aGlzLl90cnVlVmFsdWUgPSBbXVxuICAgICAgLmNvbmNhdCh0aGlzLmdldE9wdGlvbignYm9vbGVhblRydWVWYWx1ZScsIHBhcmFtcywgW3RydWVdKSlcbiAgICAgIC5tYXAoeCA9PiBTdHJpbmcoeCkpXG5cbiAgICB0aGlzLl9mYWxzZVZhbHVlID0gW11cbiAgICAgIC5jb25jYXQodGhpcy5nZXRPcHRpb24oJ2Jvb2xlYW5GYWxzZVZhbHVlJywgcGFyYW1zLCBbZmFsc2VdKSlcbiAgICAgIC5tYXAoeCA9PiBTdHJpbmcoeCkpXG5cbiAgICB0aGlzLl91c2VkVHJ1ZVZhbHVlID0gU3RyaW5nKFxuICAgICAgdGhpcy5nZXRPcHRpb24oJ2Jvb2xlYW5Vc2VkVHJ1ZVZhbHVlJywgcGFyYW1zLCB0aGlzLl90cnVlVmFsdWVbMF0pXG4gICAgKVxuXG4gICAgdGhpcy5fdXNlZEZhbHNlVmFsdWUgPSBTdHJpbmcoXG4gICAgICB0aGlzLmdldE9wdGlvbignYm9vbGVhblVzZWRGYWxzZVZhbHVlJywgcGFyYW1zLCB0aGlzLl9mYWxzZVZhbHVlWzBdKVxuICAgIClcblxuICAgIHRoaXMuX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbiA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbicsXG4gICAgICBwYXJhbXMsXG4gICAgICB7XG4gICAgICAgIHRydWU6IHRyYW5zbGF0ZShcbiAgICAgICAgICAnYm9vbGVhblRydWUnLFxuICAgICAgICAgIHRvVGl0bGVDYXNlKFN0cmluZyh0aGlzLl91c2VkVHJ1ZVZhbHVlKSlcbiAgICAgICAgKSxcbiAgICAgICAgZmFsc2U6IHRyYW5zbGF0ZShcbiAgICAgICAgICAnYm9vbGVhbkZhbHNlJyxcbiAgICAgICAgICB0b1RpdGxlQ2FzZShTdHJpbmcodGhpcy5fdXNlZEZhbHNlVmFsdWUpKVxuICAgICAgICApLFxuICAgICAgICByZXNldDogdHJhbnNsYXRlKFxuICAgICAgICAgICdib29sZWFuUmVzZXQnLFxuICAgICAgICAgIHRyYW5zbGF0ZSgncmVzZXRGaWx0ZXInLCAnUmVzZXQgRmlsdGVyJylcbiAgICAgICAgKSxcbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcbiAgICB0aGlzLl9maWx0ZXJUZXh0ID0gbnVsbFxuXG4gICAgdGhpcy5fb25SYWRpb0NoYW5nZSA9IHRoaXMuX29uUmFkaW9DaGFuZ2UuYmluZCh0aGlzLCBpc0FwcGx5QnV0dG9uKVxuXG4gICAgLy8gY3JlYXRlIGJvZHlcbiAgICBjb25zdCBib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBib2R5LmNsYXNzTmFtZSA9ICdib29sZWFuRmlsdGVyX19ib2R5IGFnLWZpbHRlci1ib2R5J1xuICAgIGJvZHkuc3R5bGUucGFkZGluZyA9ICc1cHggMTVweCdcbiAgICBib2R5LmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgICAgPGRpdiBjbGFzcz1cImJvb2xlYW5GaWx0ZXJfX2JvZHlfX2xhYmVsc1wiPlxuXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImFnLWlucHV0LWZpZWxkLWxhYmVsIGFnLWxhYmVsIGFnLXJhZGlvLWJ1dHRvbi1sYWJlbFwiPiAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyLXRydWUgYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXJhZGlvLWJ1dHRvbi1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cInRydWUtaW5wdXQgYWctaW5wdXQtZmllbGQtaW5wdXQgYWctcmFkaW8tYnV0dG9uLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJvb2xlYW5cIiB2YWx1ZT1cInRydWVcIi8+ICAgICAgICAgICAgICBcbiAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgPHNwYW4+JHt0aGlzLl9ib29sZWFuRmlsdGVyVHJhbnNsYXRpb24udHJ1ZX08L3NwYW4+XG4gICAgICAgIDwvbGFiZWw+XG5cblxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJhZy1pbnB1dC1maWVsZC1sYWJlbCBhZy1sYWJlbCBhZy1yYWRpby1idXR0b24tbGFiZWxcIj4gICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWctd3JhcHBlci1mYWxzZSBhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctcmFkaW8tYnV0dG9uLWlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiZmFsc2UtaW5wdXQgYWctaW5wdXQtZmllbGQtaW5wdXQgYWctcmFkaW8tYnV0dG9uLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJvb2xlYW5cIiB2YWx1ZT1cImZhbHNlXCIvPiAgICAgICAgICAgICAgXG4gICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgIDxzcGFuPiR7dGhpcy5fYm9vbGVhbkZpbHRlclRyYW5zbGF0aW9uLmZhbHNlfTwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICBcbiAgICAgICAgICAke1xuICAgICAgICAgICAgIWlzUmVzZXRCdXR0b25cbiAgICAgICAgICAgICAgPyAvKiBodG1sICovIGBcbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiYWctaW5wdXQtZmllbGQtbGFiZWwgYWctbGFiZWwgYWctcmFkaW8tYnV0dG9uLWxhYmVsXCI+ICAgICAgIFxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFnLXdyYXBwZXItcmVzZXQgYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXJhZGlvLWJ1dHRvbi1pbnB1dC13cmFwcGVyIGFnLWNoZWNrZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwicmVzZXQtaW5wdXQgYWctaW5wdXQtZmllbGQtaW5wdXQgYWctcmFkaW8tYnV0dG9uLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cImJvb2xlYW5cIiB2YWx1ZT1cIlwiIGNoZWNrZWQvPiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgICAgICAgIDxzcGFuPiR7dGhpcy5fYm9vbGVhbkZpbHRlclRyYW5zbGF0aW9uLnJlc2V0fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9sYWJlbD4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgIH0gICAgICAgXG4gICAgICAgIDwvZGl2PlxuICAgIGBcblxuICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25SYWRpb0NoYW5nZSlcblxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZChib2R5KVxuXG4gICAgLy8gY3JlYXRlIGFwcGx5IGZpbHRlciBwYW5lbFxuICAgIGNvbnN0IGFwcGx5RmlsdGVyUGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGFwcGx5RmlsdGVyUGFuZWwuY2xhc3NOYW1lID0gYGJvb2xlYW5GaWx0ZXJfX2JvZHlfX2FwcGx5UGFuZWwgYWctZmlsdGVyLWFwcGx5LXBhbmVsIGFnLWhpZGRlbmBcbiAgICBhcHBseUZpbHRlclBhbmVsLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImFnLXN0YW5kYXJkLWJ1dHRvbiBhZy1maWx0ZXItYXBwbHktcGFuZWwtYnV0dG9uIGNsZWFyICR7IWlzQ2xlYXJGaWx0ZXIgJiZcbiAgICAgICAgJ2FnLWhpZGRlbid9XCIgdHlwZT1cImJ1dHRvblwiPiR7dHJhbnNsYXRlKFxuICAgICAgJ2NsZWFyRmlsdGVyJyxcbiAgICAgICdDbGVhciBGaWx0ZXInXG4gICAgKX08L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJhZy1zdGFuZGFyZC1idXR0b24gYWctZmlsdGVyLWFwcGx5LXBhbmVsLWJ1dHRvbiByZXNldCAkeyFpc1Jlc2V0QnV0dG9uICYmXG4gICAgICAgICdhZy1oaWRkZW4nfVwiIHR5cGU9XCJidXR0b25cIj4ke3RyYW5zbGF0ZShcbiAgICAgICdyZXNldEZpbHRlcicsXG4gICAgICAnUmVzZXQgRmlsdGVyJ1xuICAgICl9PC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYWctc3RhbmRhcmQtYnV0dG9uIGFnLWZpbHRlci1hcHBseS1wYW5lbC1idXR0b24gYXBwbHkgJHshaXNBcHBseUJ1dHRvbiAmJlxuICAgICAgICAnYWctaGlkZGVuJ31cIiB0eXBlPVwiYnV0dG9uXCI+JHt0cmFuc2xhdGUoXG4gICAgICAnYXBwbHlGaWx0ZXInLFxuICAgICAgJ0FwcGx5IEZpbHRlcidcbiAgICApfTwvYnV0dG9uPlxuICAgIGBcblxuICAgIGlmIChpc0NsZWFyRmlsdGVyIHx8IGlzUmVzZXRCdXR0b24gfHwgaXNBcHBseUJ1dHRvbikge1xuICAgICAgYXBwbHlGaWx0ZXJQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCdhZy1oaWRkZW4nKVxuICAgIH1cblxuICAgIGFwcGx5RmlsdGVyUGFuZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdjbGljaycsXG4gICAgICB0aGlzLl9BcHBseUZpbHRlclBhbmVsQnV0dG9uQ2xpY2tcbiAgICApXG5cbiAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQoYXBwbHlGaWx0ZXJQYW5lbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZ3VpXG4gICAgICAucXVlcnlTZWxlY3RvcignLmJvb2xlYW5GaWx0ZXJfX2JvZHlfX2xhYmVscycpXG4gICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25SYWRpb0NoYW5nZSlcblxuICAgIHRoaXMuX2d1aVxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5ib29sZWFuRmlsdGVyX19ib2R5X19hcHBseVBhbmVsJylcbiAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX0FwcGx5RmlsdGVyUGFuZWxCdXR0b25DbGljaylcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHNlbGVjdGVkIGZpbHRlciBtYXRjaGVzIHRoZSBwYXNzZWQgY2VsbCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHBhc3MsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgZG9lc0ZpbHRlclBhc3MocGFyYW1zKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIGNvbnN0IHZhbHVlID0gU3RyaW5nKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgdGhpcy5fcGFyYW1zLmhhc093blByb3BlcnR5KCdmaWx0ZXJWYWx1ZUdldHRlcicpXG4gICAgICAgID8gdGhpcy5fcGFyYW1zLmZpbHRlclZhbHVlR2V0dGVyKHBhcmFtcylcbiAgICAgICAgOiB0aGlzLl9wYXJhbXMudmFsdWVHZXR0ZXIocGFyYW1zKVxuICAgIClcblxuICAgIHJldHVybiB0aGlzLl9maWx0ZXJUZXh0ID09PSAndHJ1ZSdcbiAgICAgID8gdGhpcy5fdHJ1ZVZhbHVlLmluZGV4T2YodmFsdWUpID4gLTFcbiAgICAgIDogdGhpcy5fZmFsc2VWYWx1ZS5pbmRleE9mKHZhbHVlKSA+IC0xXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgY29tcG9uZW50IGlzIGFwcGx5aW5nIGFueSBmaWx0ZXIgb24gdGhlIGNvbHVtblxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiovXG4gIGlzRmlsdGVyQWN0aXZlKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9maWx0ZXJUZXh0ICE9PSBudWxsICYmXG4gICAgICB0aGlzLl9maWx0ZXJUZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHRoaXMuX2ZpbHRlclRleHQgIT09ICcnXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpbHRlciBzdGF0ZS4gSWYgZmlsdGVyIGlzIG5vdCBhY3RpdmUsIHRoZW4gc2hvdWxkIHJldHVybiBudWxsL3VuZGVmaW5lZC5cbiAgICogVGhlIGdyaWQgY2FsbHMgZ2V0TW9kZWwoKSBvbiBhbGwgYWN0aXZlIGZpbHRlcnMgd2hlbiBncmlkQXBpLmdldEZpbHRlck1vZGVsKCkgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIE9iamVjdCB8IG51bGwgdGhlIGZpbHRlciBzdGF0ZVxuICAgKi9cbiAgZ2V0TW9kZWwoKSB7XG4gICAgaWYgKCF0aGlzLmlzRmlsdGVyQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWwgPSB7IHZhbHVlOiB0aGlzLl9maWx0ZXJUZXh0LCBmaWx0ZXJUeXBlOiAnYm9vbGVhbicgfVxuICAgIHJldHVybiBtb2RlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBmaWx0ZXIgc3RhdGUuIENhbGxlZCBieSB0aGUgZ3JpZCBhZnRlciBncmlkQXBpLnNldEZpbHRlck1vZGVsKG1vZGVsKSBpcyBjYWxsZWQuXG4gICAqIFRoZSBncmlkIHdpbGwgcGFzcyB1bmRlZmluZWQvbnVsbCB0byBjbGVhciB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IG1vZGVsXG4gICAqL1xuICBzZXRNb2RlbChtb2RlbCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuICAgIHRoaXMuX2ZpbHRlclRleHQgPSBtb2RlbCAmJiBtb2RlbC5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSA/IG1vZGVsLnZhbHVlIDogJydcblxuICAgIGNvbnN0IGZpbHRlclRleHRBc1N0cmluZyA9IFN0cmluZyh0aGlzLl9maWx0ZXJUZXh0KVxuICAgIGNvbnN0IGJvZHkgPSB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmJvb2xlYW5GaWx0ZXJfX2JvZHknKVxuICAgIGJvZHkucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdJykuZm9yRWFjaChpID0+IHtcbiAgICAgIGlmIChpLnZhbHVlID09IGZpbHRlclRleHRBc1N0cmluZykge1xuICAgICAgICBpLmNoZWNrZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmaWx0ZXIgbW9kZWwgYXMgcGxhaW4gc3RyaW5nIHRvIGRpc3BsYXkgaW4gdGhlIGZsb2F0aW5nIGZpbHRlciBpbnB1dFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IG1vZGVsXG4gICAqL1xuICBnZXRNb2RlbEFzU3RyaW5nKG1vZGVsKSB7XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmlwSFRNTChcbiAgICAgIG1vZGVsLnZhbHVlID09PSAndHJ1ZSdcbiAgICAgICAgPyB0aGlzLl9ib29sZWFuRmlsdGVyVHJhbnNsYXRpb24udHJ1ZVxuICAgICAgICA6IHRoaXMuX2Jvb2xlYW5GaWx0ZXJUcmFuc2xhdGlvbi5mYWxzZVxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgZmlsdGVyIHN0YXRlXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBjb25zdCBib2R5ID0gdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5ib29sZWFuRmlsdGVyX19ib2R5JylcbiAgICBib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXScpLmZvckVhY2goaSA9PiB7XG4gICAgICBpLmNoZWNrZWQgPSBmYWxzZVxuICAgIH0pXG5cbiAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLXRydWUnKS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLWZhbHNlJykuY2xhc3NMaXN0LnJlbW92ZSgnYWctY2hlY2tlZCcpXG4gICAgdHJ5IHtcbiAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItcmVzZXQnKS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBwYXNzICovXG4gICAgfVxuXG4gICAgdGhpcy5fZmlsdGVyVGV4dCA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gc2VsZWN0aW9uIGNoYW5nZXMgaW4gdGhlIGZpbHRlciByYWRpbyBidXR0b25zIGFuZCB1cGRhdGUgdGhlIGN1cnJlbnQgZmlsdGVyIHRleHRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgX29uUmFkaW9DaGFuZ2UoaXNBcHBseUJ1dHRvbiwgZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG4gICAgdGhpcy5fZmlsdGVyVGV4dCA9IHRhcmdldC52YWx1ZVxuXG4gICAgY29uc3QgYm9keSA9IHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCcuYm9vbGVhbkZpbHRlcl9fYm9keScpXG5cbiAgICBpZiAoYm9keSkge1xuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3RydWUtaW5wdXQnKSkge1xuICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLXRydWUnKS5jbGFzc0xpc3QuYWRkKCdhZy1jaGVja2VkJylcbiAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1mYWxzZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItcmVzZXQnKS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIHBhc3MgKi9cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdmYWxzZS1pbnB1dCcpKSB7XG4gICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItdHJ1ZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLWZhbHNlJykuY2xhc3NMaXN0LmFkZCgnYWctY2hlY2tlZCcpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1yZXNldCcpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLyogcGFzcyAqL1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib2R5LnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLXRydWUnKS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICAgICAgYm9keS5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1mYWxzZScpLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItcmVzZXQnKS5jbGFzc0xpc3QuYWRkKCdhZy1jaGVja2VkJylcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8qIHBhc3MgKi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmYWxzZSA9PT0gaXNBcHBseUJ1dHRvbikge1xuICAgICAgdGhpcy5fcGFyYW1zLmZpbHRlckNoYW5nZWRDYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byB0aGUgYnV0dG9uIGNsaWNrcyBpbiB0aGUgYnV0dG9ucyBwYW5lbCBhbmQgYXBwbHkgdGhlIGNob3NlbiBhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9BcHBseUZpbHRlclBhbmVsQnV0dG9uQ2xpY2soZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0XG5cbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnQlVUVE9OJykge1xuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3Jlc2V0JykpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpXG4gICAgICAgIHRoaXMuX3BhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbGVhcicpKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcHBseScpKSB7XG4gICAgICAgIHRoaXMuX3BhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCb29sZWFuRmlsdGVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQm9vbGVhbkZpbHRlci9Cb29sZWFuRmlsdGVyLmpzIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0Jvb2xlYW5GaWx0ZXIvc3R5bGUuc2NzcyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmJvb2xlYW5GaWx0ZXJfX2JvZHlfX2xhYmVscyBsYWJlbHtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6NnB4fS5ib29sZWFuRmlsdGVyX19ib2R5X19sYWJlbHMgbGFiZWx7ZGlzcGxheTpibG9jaztwYWRkaW5nOjZweCAwfS5ib29sZWFuRmlsdGVyX19ib2R5X19sYWJlbHMgbGFiZWwgc3BhbntwYWRkaW5nLWxlZnQ6NnB4fVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvQm9vbGVhbkZpbHRlci9zdHlsZS5zY3NzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgTnVtYmVyRWRpdG9yIGZyb20gJy4vTnVtYmVyRWRpdG9yJ1xuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJFZGl0b3JcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9OdW1iZXJFZGl0b3IvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IGF1dG9iaW5kLCBvdmVycmlkZSB9IGZyb20gJ2NvcmUtZGVjb3JhdG9ycydcblxuaW1wb3J0ICcuL3N0eWxlLnNjc3MnXG5cbi8qKlxuICogTnVtYmVycyBFZGl0b3JcbiAqXG4gKiBIYW5kbGUgbnVtYmVyIHZhbHVlcyBFZGl0aW5nXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKipudW1iZXJNaW5WYWx1ZSoqICAgfCB1bmRlZmluZWQgICAgfCBtaW4gYWxsb3dlZCB2YWx1ZVxuICogfCAqKm51bWJlck1heFZhbHVlKiogICB8IHVuZGVmaW5lZCAgICB8IG1heCBhbGxvd2VkIHZhbHVlXG4gKiB8ICoqbnVtYmVyU3RlcFZhbHVlKiogICAgICAgfCB1bmRlZmluZWQgIFx0fCBudW1iZXIgb2Ygc3RlcCBieSBpbmNyZW1lbnQgb3IgZGVjcmVtZW50XG4gKiB8ICoqbnVtYmVyTWFzayoqICAgICAgIHwgdW5kZWZpbmVkICBcdHwgYSBiYmogbnVtYmVyIG1hc2sgdG8gdmFsaWRhdGUgdGhlIG51bWJlciBhZ2FpbnN0XG4gKiB8KipudW1iZXJHcm91cGluZ1NlcGFyYXRvcioqIHwgLCB8IGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBncm91cGluZyBzZXBhcmF0b3IuIFRoZSBvcHRpb25zIGlzIHVzZWQgb25seSB3aGVuICoqbnVtYmVyTWFzayoqIGlzIGRlZmluZWQgfFxuICogfCoqbnVtYmVyRGVjaW1hbFNlcGFyYXRvcioqIHwgLiB8IGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBkZWNpbWFsIHNlcGFyYXRvci4gVGhlIG9wdGlvbnMgaXMgdXNlZCBvbmx5IHdoZW4gKipudW1iZXJNYXNrKiogaXMgZGVmaW5lZCAgfFxuICogfCoqbnVtYmVyRm9yY2VUcmFpbGluZ1plcm9zKiogfCBmYWxzZSB8IEFmZmVjdHMgdGhlIG91dHB1dCBieSBzd2l0Y2hpbmcgdGhlIHdheSBhIG1hc2sgd2l0aCBcIiNcIiBjaGFyYWN0ZXJzIGluIHRoZSB0cmFpbGluZyBwb3NpdGlvbnMgaXMgZmlsbGVkLiBmb3IgZXhhbXBsZSwgdGhlIGZ1bmN0aW9uIE51bWJlck1hc2subWFzayguMTA6XCIjLiMjXCIpIHJldHVybnMgLjEwIGluc3RlYWQgb2YgLjEgLiBUaGUgb3B0aW9ucyBpcyB1c2VkIG9ubHkgd2hlbiAqKm51bWJlck1hc2sqKiBpcyBkZWZpbmVkfFxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIE51bWJlckVkaXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJNaW5WYWx1ZScsIHBhcmFtcylcbiAgICBjb25zdCBtYXggPSB0aGlzLmdldE9wdGlvbignbnVtYmVyTWF4VmFsdWUnLCBwYXJhbXMpXG4gICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJTdGVwVmFsdWUnLCBwYXJhbXMpXG4gICAgY29uc3QgbWFzayA9IHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJNYXNrJywgcGFyYW1zKVxuXG4gICAgbGV0IHN0YXJ0VmFsdWVcblxuICAgIHRoaXMuX2ZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHBhcmFtcy5jZWxsU3RhcnRlZEVkaXRcbiAgICBpZiAodGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICBsZXQga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9XG4gICAgICAgIHBhcmFtcy5rZXlQcmVzcyA9PSAzMiB8fCBwYXJhbXMua2V5UHJlc3MgPT0gNDYgLy8gc3BhY2UgLy8gZGVsZXRlXG5cbiAgICAgIGlmIChrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlKSB7XG4gICAgICAgIHN0YXJ0VmFsdWUgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XG4gICAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMuY2hhclByZXNzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydFZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgICAgIGlmIChwYXJhbXMua2V5UHJlc3MgIT0gMTEzKSB7XG4gICAgICAgICAgLy9GMlxuICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodEFsbE9uRm9jdXMgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy52YWx1ZVxuICAgIH1cblxuICAgIC8vIG1ha2UgcGFyYW1zIGl0IGFjY2Vzc2libGUgZnJvbSB0YWxsIG1ldGhvZHNcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcblxuICAgIC8vIGNyZWF0ZSB0aGUgaW5wdXQgd3JhcHBlclxuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ251bWJlckVkaXRvciBhZy1jZWxsLWVkaXQtd3JhcHBlcidcbiAgICB0aGlzLl9ndWkudGFiSW5kZXggPSAnMCdcbiAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgPGRpdiBjbGFzcz1cImFnLWNlbGwtZWRpdG9yIGFnLWxhYmVsZWQgYWctbGFiZWwtYWxpZ24tbGVmdCBhZy10ZXh0LWZpZWxkIGFnLWlucHV0LWZpZWxkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXRleHQtZmllbGQtaW5wdXQtd3JhcHBlclwiPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYFxuXG4gICAgLy8gY3JlYXRlIHRoZSBpbnB1dFxuICAgIHRoaXMuX2lucHV0R2VuZXJhdGVkSWQgPSBNYXRoLnJhbmRvbSgpXG4gICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAuc2xpY2UoMiwgMTApIC8vIGdlbmVyYXRlIHJhbmRvbSBpZFxuICAgIHRoaXMuX2lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKVxuICAgIHRoaXMuX2lucHV0LmNsYXNzTmFtZSA9ICdudW1iZXJFZGl0b3JfX2lucHV0IGFnLWNlbGwtZWRpdC1pbnB1dCdcbiAgICB0aGlzLl9pbnB1dC5pZCA9IGBlbC0ke3RoaXMuX2lucHV0R2VuZXJhdGVkSWR9YFxuICAgIHRoaXMuX2lucHV0LnR5cGUgPSBtYXNrID8gJ3RleHQnIDogJ251bWJlcidcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHN0YXJ0VmFsdWVcbiAgICB0aGlzLl9pbnB1dC50YWJJbmRleCA9IDBcblxuICAgIC8vIHBsYWNlIHRoZSBpbnB1dCBpbnNpZGUgdGhlIHdyYXBwZXJcbiAgICB0aGlzLl9ndWkucXVlcnlTZWxlY3RvcignLmFnLWlucHV0LXdyYXBwZXInKS5hcHBlbmRDaGlsZCh0aGlzLl9pbnB1dClcblxuICAgIGlmIChtaW4gIT09IG51bGwpIHtcbiAgICAgIG1hc2sgPyAodGhpcy5faW5wdXQuZGF0YXNldC5taW4gPSBtaW4pIDogKHRoaXMuX2lucHV0Lm1pbiA9IG1pbilcbiAgICB9XG5cbiAgICBpZiAobWF4ICE9PSBudWxsKSB7XG4gICAgICBtYXNrID8gKHRoaXMuX2lucHV0LmRhdGFzZXQubWF4ID0gbWF4KSA6ICh0aGlzLl9pbnB1dC5tYXggPSBtYXgpXG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgIT09IG51bGwpIHtcbiAgICAgIG1hc2sgPyAodGhpcy5faW5wdXQuZGF0YXNldC5zdGVwID0gc3RlcCkgOiAodGhpcy5faW5wdXQuc3RlcCA9IHN0ZXApXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSBtYXNrIHRoZW4gd2UgdXNlIHRoZSBgQmFzaXMuSW5wdXRNYXNraW5nLk51bWJlcklucHV0YFxuICAgIGlmIChtYXNrKSB7XG4gICAgICBjb25zdCBncm91cGluZ1NlcGFyYXRvciA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgICAnbnVtYmVyR3JvdXBpbmdTZXBhcmF0b3InLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJHcm91cFNlcCcsIHBhcmFtcylcbiAgICAgIClcbiAgICAgIGNvbnN0IGRlY2ltYWxTZXBhcmF0b3IgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICAgJ251bWJlckRlY2ltYWxTZXBhcmF0b3InLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uKCdudW1iZXJEZWNpbWFsU2VwJywgcGFyYW1zKVxuICAgICAgKVxuICAgICAgY29uc3QgZm9yY2VUcmFpbGluZ1plcm9zID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAgICdudW1iZXJGb3JjZVRyYWlsaW5nWmVyb3MnLFxuICAgICAgICBwYXJhbXNcbiAgICAgIClcblxuICAgICAgaWYgKGdyb3VwaW5nU2VwYXJhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LmRhdGFzZXQuZ3JvdXBpbmdTZXBhcmF0b3IgPSBncm91cGluZ1NlcGFyYXRvclxuICAgICAgfVxuXG4gICAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9pbnB1dC5kYXRhc2V0LmRlY2ltYWxTZXBhcmF0b3IgPSBkZWNpbWFsU2VwYXJhdG9yXG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZVRyYWlsaW5nWmVyb3MgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuZGF0YXNldC5mb3JjZVRyYWlsaW5nWmVyb3MgPSBmb3JjZVRyYWlsaW5nWmVyb3NcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5wdXQuZGF0YXNldC5tYXNrID0gbWFza1xuICAgICAgdGhpcy5fbnVtYmVySW5wdXQgPSBuZXcgQmFzaXMuSW5wdXRNYXNraW5nLk51bWJlcklucHV0KHtcbiAgICAgICAgZWxlbWVudHM6IFt0aGlzLl9pbnB1dF0sXG4gICAgICAgIC8vIGRvYzogdGhpcy5nZXREb2MocGFyYW1zKSxcbiAgICAgICAgb25VcGRhdGU6IHRoaXMuX29uTnVtYmVySW5wdXRVcGRhdGUsXG4gICAgICAgIG9uSW52YWxpZDogdGhpcy5fb25OdW1iZXJJbnB1dEludmFsaWQsXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25JbnB1dEtleURvd25VcClcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25JbnB1dEtleURvd25VcClcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKVxuICAgIH1cblxuICAgIHRoaXMuX2d1aS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25Db21wb25lbnRLZXlEb3duKVxuXG4gICAgLy8gdXBkYXRlIGBjdXJyZW50VmFsdWVgIHRoZSB2YWx1ZSB3aGljaCB0aGlzIGNvbXBvbmVudCBpcyBtYW5hZ2luZ1xuICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHN0YXJ0VmFsdWVcbiAgICB0aGlzLl9faXNNYXNrZWRfXyA9IG1hc2sgJiYgbWFzay5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5fX2lzTWFza2VkX18pIHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX251bWJlcklucHV0LmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMuX2d1aS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25Db21wb25lbnRLZXlEb3duKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgR1VJIGlzIGF0dGFjaGVkIHRvIERPTS5cbiAgICpcbiAgICogTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBhbHdheXMgZm9jdXNlZCB0byBsaXN0ZW4gdG8ga2V5IGNoYW5nZXNcbiAgICovXG4gIGFmdGVyR3VpQXR0YWNoZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9faXNNYXNrZWRfXykge1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbnB1dCh0aGlzLl9pbnB1dClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faGlnaGxpZ2h0QWxsT25Gb2N1cykge1xuICAgICAgdGhpcy5faW5wdXQuc2VsZWN0KClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2ZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xuICAgICAgICB0aGlzLmZvY3VzSW4oKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICBjb25zdCBjYXN0ZWQgPSBOdW1iZXIodGhpcy5fY3VycmVudFZhbHVlKVxuICAgIGNvbnN0IHJldFZhbHVlID0gaXNOYU4oY2FzdGVkKSA/IHRoaXMuX2N1cnJlbnRWYWx1ZSA6IGNhc3RlZFxuICAgIHJldHVybiB0aGlzLl9faXNNYXNrZWRfXyA/IHJldFZhbHVlIDogdGhpcy5fcGFyYW1zLnBhcnNlVmFsdWUocmV0VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogSWYgZG9pbmcgZnVsbCByb3cgZWRpdCwgdGhlbiBnZXRzIGNhbGxlZCB3aGVuIHRhYmJpbmcgaW50byB0aGUgY2VsbC5cbiAgICovXG4gIGZvY3VzSW4oKSB7XG4gICAgaWYgKCF0aGlzLl9faXNNYXNrZWRfXykge1xuICAgICAgdGhpcy5faW5wdXQuZm9jdXMoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnB1dC5jbGljaygpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgaW5pdGlhbGl6ZWQgYW5kIHJldHVybnMgZmFsc2Ugc28gdGhlIGVkaXRvciBhcHBlYXJzIGluIHRoZSBjZWxsXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGFsd2F5cyBmYWxzZVxuICAgKiovXG4gIGlzUG9wdXAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGBjdXJyZW50VmFsdWVgIHdoZW4gdGhlIGNoZWNrYm94IHZhbHVlIGlzIGNoYW5nZWRcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25DaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5fdmFsaWRhdGVJbnB1dChldmVudC50YXJnZXQpXG4gICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX2lucHV0LnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZSB3aGVuIHRoZSBOdW1iZXJJbnB1dCBjb21wb25lbnRzIGZpcmUgdGhlIHVwZGF0ZVxuICAgKiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IF9tYXNrZWQgIHRoZSBtYXNrZWQgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHVubWFza2VkICB0aGUgdW5tYXNrZWQgdmFsdWVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25OdW1iZXJJbnB1dFVwZGF0ZShfbWFza2VkLCB1bm1hc2tlZCkge1xuICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHVubWFza2VkXG4gICAgdGhpcy5mb2N1c0luKClcbiAgICAvLyB3ZSBwYXNzIHRoZSBsYXN0IGNhcHR1cmVkIGV2ZW50IGJhY2sgdG8gdGhlIGdyaWQgdG8gaGFuZGxlIGl0IGludGVybmFsbHlcbiAgICBpZiAodGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pIHtcbiAgICAgIHRoaXMuX3BhcmFtcy5vbktleURvd24odGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pXG4gICAgICB0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXyA9IG51bGxcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9uIGludmFsaWQgaW5wdXRzICwgdXBkYXRlIHRoZSBpbnB1dCB3aXRoIGEgY3VzdG9tIHZhbGlkaXR5IG1lc3NhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBlcnJvciB0aGUgZXJyb3IgbWVzc2FnZSByZXBvcnRlZCBieSBOdW1iZXJJbnB1dFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCBUaGUgaW5wdXQgZWxlbWVudCB1c2VkIGluc3RhbmNlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uTnVtYmVySW5wdXRJbnZhbGlkKGVycm9yLCBpbnB1dCkge1xuICAgIHRoaXMuZm9jdXNJbigpXG4gICAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGNlbGxcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9wYXJhbXMudmFsdWVcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KGVycm9yLm1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhcHR1cmUgYWxsIGtleWJvYXJkIGV2ZW50cyB0byBhbGxvdyB2YWx1ZSBwcm9jZXNzaW5nIGJ5IHRoZSBOdW1iZXJJbnB1dCBjb21wb25lbnRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uQ29tcG9uZW50S2V5RG93bihlKSB7XG4gICAgY29uc3Qga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID1cbiAgICAgIGtleSA9PT0gMzcgfHwgLy8gbGVmdFxuICAgICAga2V5ID09PSAzOCB8fCAvLyB1cFxuICAgICAga2V5ID09PSAzOSB8fCAvLyByaWdodFxuICAgICAga2V5ID09PSA0MCB8fCAvLyBkb3duXG4gICAgICBrZXkgPT09IDMzIHx8IC8vIHBhZ2UgdXBcbiAgICAgIGtleSA9PT0gMzQgfHwgLy8gcGFnZSBkb3duXG4gICAgICBrZXkgPT09IDM1IHx8IC8vIHBhZ2UgaG9tZVxuICAgICAga2V5ID09PSAzNiB8fCAvLyBwYWdlIGVuZFxuICAgICAga2V5ID09PSAxMyAvLyBlbnRlclxuXG4gICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIC8vIHNhdmUgdGhlIGxhc3QgY2FwdHVyZSBrZXkgc28gTnVtYmVySW5wdXQgY2FuIHBhc3MgaXQgYWdhaW4gdG8gdGhlIGdyaWQuXG4gICAgICB0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXyA9IGVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlzdGVuIHRvIGtleSBjaGFuZ2VzIGFuZCB2YWxpZGF0ZSB0aGUgaW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25JbnB1dEtleURvd25VcChldmVudCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KGV2ZW50LnRhcmdldClcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZVxuXG4gICAgaWYgKGtleSA9PSAzOCB8fCBrZXkgPT0gNDApIHtcbiAgICAgIC8vIHRvcCB8IGRvd25cbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX2lucHV0LnZhbHVlXG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIH0gZWxzZSBpZiAoa2V5ID09IDEzIHx8IGtleSA9PT0gOSkge1xuICAgICAgLy8gZW50ZXJcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX2lucHV0LnZhbHVlXG4gICAgfVxuXG4gICAgLy8gd2UgcGFzcyB0aGUgbGFzdCBjYXB0dXJlZCBldmVudCBiYWNrIHRvIHRoZSBncmlkIHRvIGhhbmRsZSBpdCBpbnRlcm5hbGx5XG4gICAgaWYgKHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fKSB7XG4gICAgICB0aGlzLl9wYXJhbXMub25LZXlEb3duKHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fKVxuICAgICAgdGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoZSBnaXZlbiBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgaW5wdXQgZWxlbWVudFxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gdmFsaWQgLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIF92YWxpZGF0ZUlucHV0KGlucHV0KSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IGlucHV0LmNoZWNrVmFsaWRpdHkoKVxuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdiYmotbWFzay1lcnJvcicpXG4gICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdiYmotbWFzay1zdWNjZXNzJylcbiAgICAgIC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSB0aGlzLl9wYXJhbXMudmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnYmJqLW1hc2stZXJyb3InKVxuICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgnYmJqLW1hc2stc3VjY2VzcycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlzVmFsaWRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJFZGl0b3JcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9OdW1iZXJFZGl0b3IvTnVtYmVyRWRpdG9yLmpzIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL051bWJlckVkaXRvci9zdHlsZS5zY3NzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIubnVtYmVyRWRpdG9ye292ZXJmbG93OmhpZGRlbn0ubnVtYmVyRWRpdG9yIC5udW1iZXJJbnB1dE1hc2tfX3dyYXB7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3V0bGluZTpub25lO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzowO21hcmdpbjowO2Rpc3BsYXk6ZmxleDtmbGV4OjEgMSBhdXRvO2FsaWduLWl0ZW1zOmNlbnRlcjtsaW5lLWhlaWdodDpub3JtYWw7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS5udW1iZXJFZGl0b3IgLmJiai1tYXNrLWVycm9ye2JveC1zaGFkb3c6MCAtMnB4IDAgI2U5MWU2MyBpbnNldH0ubnVtYmVyRWRpdG9yIC5iYmotbWFzay1zdWNjZXNze2JveC1zaGFkb3c6MCAtMnB4IDAgIzRjYWY1MCBpbnNldH0ubnVtYmVyRWRpdG9yX19pbnB1dHtwYWRkaW5nLWxlZnQ6NnB4O2JvcmRlcjp0aGluIHNvbGlkIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywxNTAsMjQzLDAuNCkpO2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6aW5oZXJpdH0uYWctdGhlbWUtYWxwaW5lIC5udW1iZXJFZGl0b3JfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0gLm51bWJlckVkaXRvcl9faW5wdXQsLmFnLXRoZW1lLW1hdGVyaWFsIC5udW1iZXJFZGl0b3JfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZil9LmFnLXRoZW1lLWFscGluZS1kYXJrIC5udW1iZXJFZGl0b3JfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0tZGFyayAubnVtYmVyRWRpdG9yX19pbnB1dHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICMyZDM0MzYpfVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zcmMvTnVtYmVyRWRpdG9yL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBUZXh0RWRpdG9yIGZyb20gJy4vVGV4dEVkaXRvcidcblxuZXhwb3J0IGRlZmF1bHQgVGV4dEVkaXRvclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1RleHRFZGl0b3IvaW5kZXguanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCB7IGF1dG9iaW5kLCBvdmVycmlkZSB9IGZyb20gJ2NvcmUtZGVjb3JhdG9ycydcblxuaW1wb3J0ICcuL3N0eWxlLnNjc3MnXG5cbi8qKlxuICogVGV4dCBFZGl0b3JcbiAqXG4gKiBIYW5kbGUgdGV4dCB2YWx1ZXMgRWRpdGluZ1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqdGV4dFBhdHRlcm4qKiAgIHwgdW5kZWZpbmVkICAgIHwgQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCB0aGUgaW5wdXQncyB2YWx1ZSBtdXN0IG1hdGNoIGluIG9yZGVyIGZvciB0aGUgdmFsdWUgdG8gcGFzcyBjb25zdHJhaW50IHZhbGlkYXRpb25cbiAqIHwgKip0ZXh0UmVxdWlyZWQqKiAgIHwgdW5kZWZpbmVkICAgIHwgQm9vbGVhbi4gQSB2YWx1ZSBpcyByZXF1aXJlZCB0byBjb25zaWRlciB0aGUgaW5wdXQgdmFsaWRcbiAqIHwgKip0ZXh0TWFzayoqICAgfCB1bmRlZmluZWQgICAgfCBBIGJiaiBzdHJpbmcgbWFzayB0byB2YWxpZGF0ZSB0aGUgdmFsdWVcbiAqIHwgKip0ZXh0VGl0bGUqKiAgIHwgbnVsbCAgICB8IFRoZSBpbnB1dCB0aXRsZSAsIHdoZW4gbnVsbCBhbmQgdGhlICoqdGV4dE1hc2sqKiBvcHRpb25zIGlzIGRlZmluZWQgLCB0aGVuIHdlIHVzZSB0aGUgbWFzayBhcyB0aXRsZSAsIHdoZW4gc2V0IHRvIGBkZWZhdWx0YCB3ZSB0aGUgYnJvd3NlcidzIGRlZmF1bHQgdGl0bGUgLCBvdGhlcndpc2UgdGhlIHZhbHVlIGRlZmluZWQgaW4gdGhpcyBvcHRpb25cbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBUZXh0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuZ2V0T3B0aW9uKCd0ZXh0UGF0dGVybicsIHBhcmFtcylcbiAgICBjb25zdCByZXF1aXJlZCA9IHRoaXMuZ2V0T3B0aW9uKCd0ZXh0UmVxdWlyZWQnLCBwYXJhbXMpXG4gICAgY29uc3QgbWFzayA9IHRoaXMuZ2V0T3B0aW9uKCd0ZXh0TWFzaycsIHBhcmFtcylcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuZ2V0T3B0aW9uKCd0ZXh0VGl0bGUnLCBwYXJhbXMpXG5cbiAgICBsZXQgc3RhcnRWYWx1ZVxuXG4gICAgdGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkID0gcGFyYW1zLmNlbGxTdGFydGVkRWRpdFxuICAgIGlmICh0aGlzLl9mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIGxldCBrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlID1cbiAgICAgICAgcGFyYW1zLmtleVByZXNzID09IDMyIHx8IHBhcmFtcy5rZXlQcmVzcyA9PSA0NiAvLyBzcGFjZSAvLyBkZWxldGVcblxuICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgc3RhcnRWYWx1ZSA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5jaGFyUHJlc3MpIHtcbiAgICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy5jaGFyUHJlc3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0VmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICAgICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPSAxMTMpIHtcbiAgICAgICAgICAvL0YyXG4gICAgICAgICAgdGhpcy5faGlnaGxpZ2h0QWxsT25Gb2N1cyA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zXG5cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAndGV4dEVkaXRvciBhZy1jZWxsLWVkaXQtd3JhcHBlcidcbiAgICB0aGlzLl9ndWkudGFiSW5kZXggPSAnMCdcbiAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXG4gICAgPGRpdiBjbGFzcz1cImFnLWNlbGwtZWRpdG9yIGFnLWxhYmVsZWQgYWctbGFiZWwtYWxpZ24tbGVmdCBhZy10ZXh0LWZpZWxkIGFnLWlucHV0LWZpZWxkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXRleHQtZmllbGQtaW5wdXQtd3JhcHBlclwiPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYFxuXG4gICAgLy8gaW5wdXRcbiAgICB0aGlzLl9pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICB0aGlzLl9pbnB1dC5jbGFzc05hbWUgPVxuICAgICAgJ3RleHRFZGl0b3JfX2lucHV0IGFnLWNlbGwtZWRpdC1pbnB1dCBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy10ZXh0LWZpZWxkLWlucHV0J1xuICAgIHRoaXMuX2lucHV0LmlkID0gYGVsLSR7TWF0aC5yYW5kb20oKVxuICAgICAgLnRvU3RyaW5nKDE2KVxuICAgICAgLnNsaWNlKDIsIDEwKX1gIC8vIGdlbmVyYXRlIHJhbmRvbSBpZFxuICAgIHRoaXMuX2lucHV0LnR5cGUgPSAndGV4dCdcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHN0YXJ0VmFsdWVcbiAgICB0aGlzLl9pbnB1dC50YWJJbmRleCA9IDBcblxuICAgIHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCcuYWctaW5wdXQtd3JhcHBlcicpLmFwcGVuZENoaWxkKHRoaXMuX2lucHV0KVxuXG4gICAgaWYgKHBhdHRlcm4gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZSgncGF0dGVybicsIHBhdHRlcm4pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJywgJ3JlcXVpcmVkJylcbiAgICB9XG5cbiAgICBpZiAodGl0bGUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aXRsZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnRpdGxlID0gdGl0bGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1hc2spIHtcbiAgICAgIHRoaXMuX2lucHV0LnRpdGxlID0gbWFza1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgbWFzayB0aGVuIHdlIHVzZSB0aGUgYEJhc2lzLklucHV0TWFza2luZy5UZXh0SW5wdXRgXG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHRoaXMuX2lucHV0LmRhdGFzZXQubWFzayA9IG1hc2tcbiAgICAgIHRoaXMuX3RleHRJbnB1dCA9IG5ldyBCYXNpcy5JbnB1dE1hc2tpbmcuVGV4dElucHV0KHtcbiAgICAgICAgZWxlbWVudHM6IFt0aGlzLl9pbnB1dF0sXG4gICAgICAgIGRvYzogdGhpcy5nZXREb2MocGFyYW1zKSxcbiAgICAgICAgb25VcGRhdGU6IHRoaXMuX29uVGV4dElucHV0VXBkYXRlLFxuICAgICAgICBvbkludmFsaWQ6IHRoaXMuX29uVGV4dElucHV0SW52YWxpZCxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSlcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKVxuICAgIH1cblxuICAgIHRoaXMuX2d1aS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25Db21wb25lbnRLZXlEb3duKVxuXG4gICAgLy8gdXBkYXRlIGBjdXJyZW50VmFsdWVgIHRoZSB2YWx1ZSB3aGljaCB0aGlzIGNvbXBvbmVudCBpcyBtYW5hZ2luZ1xuICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHN0YXJ0VmFsdWVcbiAgICB0aGlzLl9faXNNYXNrZWRfXyA9IG1hc2sgJiYgbWFzay5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiAgQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5fX2lzTWFza2VkX18pIHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbklucHV0S2V5RG93blVwKVxuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSlcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZXh0SW5wdXQuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbkNvbXBvbmVudEtleURvd24pXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBHVUkgaXMgYXR0YWNoZWQgdG8gRE9NLlxuICAgKlxuICAgKiBNYWtlIHN1cmUgY29udGFpbmVyIGlzIGFsd2F5cyBmb2N1c2VkIHRvIGxpc3RlbiB0byBrZXkgY2hhbmdlc1xuICAgKi9cbiAgYWZ0ZXJHdWlBdHRhY2hlZCgpIHtcbiAgICBpZiAoIXRoaXMuX19pc01hc2tlZF9fKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUlucHV0KHRoaXMuX2lucHV0KVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9oaWdobGlnaHRBbGxPbkZvY3VzKSB7XG4gICAgICB0aGlzLl9pbnB1dC5zZWxlY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICAgIHRoaXMuZm9jdXNJbigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBUaGUgY29tcG9uZW50IHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJhbXMucGFyc2VWYWx1ZSh0aGlzLl9jdXJyZW50VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogSWYgZG9pbmcgZnVsbCByb3cgZWRpdCwgdGhlbiBnZXRzIGNhbGxlZCB3aGVuIHRhYmJpbmcgaW50byB0aGUgY2VsbC5cbiAgICovXG4gIGZvY3VzSW4oKSB7XG4gICAgdGhpcy5faW5wdXQuZm9jdXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgaW5pdGlhbGl6ZWQgYW5kIHJldHVybnMgZmFsc2Ugc28gdGhlIGVkaXRvciBhcHBlYXJzIGluIHRoZSBjZWxsXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGFsd2F5cyBmYWxzZVxuICAgKiovXG4gIGlzUG9wdXAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIHdoZW4gdGhlIFRleHRJbnB1dCBjb21wb25lbnQgZmlyZXMgdGhlIHVwZGF0ZVxuICAgKiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IF9tYXNrZWQgIHRoZSBtYXNrZWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVubWFza2VkICB0aGUgdW5tYXNrZWQgdmFsdWVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25UZXh0SW5wdXRVcGRhdGUoX21hc2tlZCwgdW5tYXNrZWQsIGlucHV0KSB7XG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gdW5tYXNrZWRcbiAgICBpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSgnJylcbiAgICB0aGlzLmZvY3VzSW4oKVxuICAgIC8vIHdlIHBhc3MgdGhlIGxhc3QgY2FwdHVyZWQgZXZlbnQgYmFjayB0byB0aGUgZ3JpZCB0byBoYW5kbGUgaXQgaW50ZXJuYWxseVxuICAgIGlmICh0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXykge1xuICAgICAgdGhpcy5fcGFyYW1zLm9uS2V5RG93bih0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXylcbiAgICAgIHRoaXMuX19sYXN0Q29tcG9uZW50S2V5Ym9hcmRQcmVzc19fID0gbnVsbFxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT24gaW52YWxpZCBpbnB1dHMgLCB1cGRhdGUgdGhlIGlucHV0IHdpdGggYSBjdXN0b20gdmFsaWRpdHkgbWVzc2FnZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVycm9yIHRoZSBlcnJvciBtZXNzYWdlIHJlcG9ydGVkIGJ5IFRleHRJbnB1dFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dCBUaGUgaW5wdXQgZWxlbWVudCB1c2VkIGluc3RhbmNlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uVGV4dElucHV0SW52YWxpZChlcnJvciwgaW5wdXQpIHtcbiAgICB0aGlzLmZvY3VzSW4oKVxuICAgIC8vIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBjZWxsXG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5fcGFyYW1zLnZhbHVlXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlucHV0LnNldEN1c3RvbVZhbGlkaXR5KGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXB0dXJlIGFsbCBrZXlib2FyZCBldmVudHMgdG8gYWxsb3cgdmFsdWUgcHJvY2Vzc2luZyBieSB0aGUgTnVtYmVySW5wdXQgY29tcG9uZW50XG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkNvbXBvbmVudEtleURvd24oZSkge1xuICAgIGNvbnN0IGtleSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGNvbnN0IGlzTmF2aWdhdGlvbktleSA9XG4gICAgICBrZXkgPT09IDM3IHx8IC8vIGxlZnRcbiAgICAgIGtleSA9PT0gMzggfHwgLy8gdXBcbiAgICAgIGtleSA9PT0gMzkgfHwgLy8gcmlnaHRcbiAgICAgIGtleSA9PT0gNDAgfHwgLy8gZG93blxuICAgICAga2V5ID09PSAzMyB8fCAvLyBwYWdlIHVwXG4gICAgICBrZXkgPT09IDM0IHx8IC8vIHBhZ2UgZG93blxuICAgICAga2V5ID09PSAzNSB8fCAvLyBwYWdlIGhvbWVcbiAgICAgIGtleSA9PT0gMzYgfHwgLy8gcGFnZSBlbmRcbiAgICAgIGtleSA9PT0gMTMgLy8gZW50ZXJcblxuICAgIGlmIChpc05hdmlnYXRpb25LZXkpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAvLyBzYXZlIHRoZSBsYXN0IGNhcHR1cmUga2V5IHNvIE51bWJlcklucHV0IGNhbiBwYXNzIGl0IGFnYWluIHRvIHRoZSBncmlkLlxuICAgICAgdGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18gPSBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBrZXkgY2hhbmdlcyBhbmQgdmFsaWRhdGUgdGhlIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uSW5wdXRLZXlEb3duVXAoZXZlbnQpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5fdmFsaWRhdGVJbnB1dChldmVudC50YXJnZXQpXG5cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVcblxuICAgIGlmIChrZXkgPT0gMTMgfHwga2V5ID09PSA5KSB7XG4gICAgICAvLyBlbnRlclxuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5faW5wdXQudmFsdWVcbiAgICB9XG5cbiAgICAvLyB3ZSBwYXNzIHRoZSBsYXN0IGNhcHR1cmVkIGV2ZW50IGJhY2sgdG8gdGhlIGdyaWQgdG8gaGFuZGxlIGl0IGludGVybmFsbHlcbiAgICBpZiAodGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pIHtcbiAgICAgIHRoaXMuX3BhcmFtcy5vbktleURvd24odGhpcy5fX2xhc3RDb21wb25lbnRLZXlib2FyZFByZXNzX18pXG4gICAgICB0aGlzLl9fbGFzdENvbXBvbmVudEtleWJvYXJkUHJlc3NfXyA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGBjdXJyZW50VmFsdWVgIG9uIHRoZSBpbnB1dCB2YWx1ZSBpcyBjaGFuZ2VkIGFuZCBpdCBpcyB2YWxpZFxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkNoYW5nZShldmVudCkge1xuICAgIGNvbnN0IGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KGV2ZW50LnRhcmdldClcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgdGhpcy5fY3VycmVudFZhbHVlID0gdGhpcy5faW5wdXQudmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGdpdmVuIGlucHV0IGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCBpbnB1dCBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgX3ZhbGlkYXRlSW5wdXQoaW5wdXQpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gaW5wdXQuY2hlY2tWYWxpZGl0eSgpXG5cbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2Jiai1tYXNrLWVycm9yJylcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2Jiai1tYXNrLXN1Y2Nlc3MnKVxuICAgICAgLy8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHRoaXMuX3BhcmFtcy52YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKCdiYmotbWFzay1lcnJvcicpXG4gICAgICBpbnB1dC5jbGFzc0xpc3QuYWRkKCdiYmotbWFzay1zdWNjZXNzJylcbiAgICB9XG5cbiAgICByZXR1cm4gaXNWYWxpZFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRleHRFZGl0b3JcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZXh0RWRpdG9yL1RleHRFZGl0b3IuanMiLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmhlYWRcbiAgICAgICAgICAgICAgfTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLnNjc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGV4dEVkaXRvci9zdHlsZS5zY3NzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudGV4dEVkaXRvcntvdmVyZmxvdzpoaWRkZW59LnRleHRFZGl0b3IgLnRleHRJbnB1dE1hc2tfX3dyYXB7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3V0bGluZTpub25lO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzowO21hcmdpbjowO2Rpc3BsYXk6ZmxleDtmbGV4OjEgMSBhdXRvO2FsaWduLWl0ZW1zOmNlbnRlcjtsaW5lLWhlaWdodDpub3JtYWw7cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVufS50ZXh0RWRpdG9yIC5iYmotbWFzay1lcnJvcntib3gtc2hhZG93OjAgLTJweCAwICNlOTFlNjMgaW5zZXR9LnRleHRFZGl0b3IgLmJiai1tYXNrLXN1Y2Nlc3N7Ym94LXNoYWRvdzowIC0ycHggMCAjNGNhZjUwIGluc2V0fS50ZXh0RWRpdG9yX19pbnB1dHtwYWRkaW5nLWxlZnQ6NnB4O2JvcmRlcjp0aGluIHNvbGlkIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywxNTAsMjQzLDAuNCkpO2JvcmRlci1yYWRpdXM6M3B4O2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6aW5oZXJpdH0uYWctdGhlbWUtYWxwaW5lIC50ZXh0RWRpdG9yX19pbnB1dCwuYWctdGhlbWUtYmFsaGFtIC50ZXh0RWRpdG9yX19pbnB1dCwuYWctdGhlbWUtbWF0ZXJpYWwgLnRleHRFZGl0b3JfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZil9LmFnLXRoZW1lLWFscGluZS1kYXJrIC50ZXh0RWRpdG9yX19pbnB1dCwuYWctdGhlbWUtYmFsaGFtLWRhcmsgLnRleHRFZGl0b3JfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzJkMzQzNil9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9UZXh0RWRpdG9yL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0IHRlbXBsYXRlIGZyb20gJ2xvZGFzaC1lcy90ZW1wbGF0ZSdcblxuLyoqXG4gKiBOdW1iZXJzIEVkaXRvclxuICpcbiAqIEhhbmRsZSBudW1iZXIgdmFsdWVzIEVkaXRpbmdcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKnJlbmRlclRlbXBsYXRlKiogICB8IHVuZGVmaW5lZCAgICB8IGxvZGFzaCB0ZW1wbGF0ZVxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIFRlbXBsYXRlUmVuZGVyZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0IG5ldyBUZW1wbGF0ZVJlbmRlcmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyB3aWxsIHRoaXMgYWZmZWN0IEJCaiBidWkgP1xuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgdGhpcy5fZ3VpLmNsYXNzTmFtZSA9ICd0ZW1wbGF0ZVJlbmRlcmVyIGFnLWNlbGwtd3JhcHBlcidcbiAgICB0aGlzLl9ndWkuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICB0aGlzLl9ndWkuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgdGhpcy5fZ3VpLnN0eWxlLmxpbmVIZWlnaHQgPSAnbm9ybWFsJ1xuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgaW5pdChwYXJhbXMpIHtcbiAgICB0aGlzLnJlZnJlc2gocGFyYW1zLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqICBAaW5oZXJpdERvY1xuICAgKi9cbiAgZ2V0R3VpKCkge1xuICAgIHJldHVybiB0aGlzLl9ndWlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBjZWxsIGxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBjZWxsIHJlbmRlcmVyIHBhcmFtc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCB0cnVlIHdoZW4gdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGluIGBpbml0YCBwaGFzZSAsIGZhbHNlIG90aGVyd2lzZVxuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSByZWZyZXNoIHN1Y2NlZWRlZCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cbiAgICovXG4gIHJlZnJlc2gocGFyYW1zLCBpc0luaXQpIHtcbiAgICBpZiAoaXNJbml0KSB7XG4gICAgICB0aGlzLl9jb21waWxlZFRlbXBsYXRlID0gdGVtcGxhdGUoXG4gICAgICAgIHRoaXMuZ2V0T3B0aW9uKCdyZW5kZXJUZW1wbGF0ZScsIHBhcmFtcywgJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgbGV0IGNvbnRlbnRcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fY29tcGlsZWRUZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29udGVudCA9IHRoaXMuX2NvbXBpbGVkVGVtcGxhdGUoeyBwYXJhbXMgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA/IHBhcmFtcy52YWx1ZUZvcm1hdHRlZCA6IHBhcmFtcy52YWx1ZVxuICAgIH1cblxuICAgIHRoaXMuX2d1aS5pbm5lckhUTUwgPSBjb250ZW50XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRlbXBsYXRlUmVuZGVyZXJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9UZW1wbGF0ZVJlbmRlcmVyL1RlbXBsYXRlUmVuZGVyZXIuanMiLCJpbXBvcnQgYXNzaWduSW5XaXRoIGZyb20gJy4vYXNzaWduSW5XaXRoLmpzJztcbmltcG9ydCBhdHRlbXB0IGZyb20gJy4vYXR0ZW1wdC5qcyc7XG5pbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluIGZyb20gJy4vX2N1c3RvbURlZmF1bHRzQXNzaWduSW4uanMnO1xuaW1wb3J0IGVzY2FwZVN0cmluZ0NoYXIgZnJvbSAnLi9fZXNjYXBlU3RyaW5nQ2hhci5qcyc7XG5pbXBvcnQgaXNFcnJvciBmcm9tICcuL2lzRXJyb3IuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcbmltcG9ydCB0ZW1wbGF0ZVNldHRpbmdzIGZyb20gJy4vdGVtcGxhdGVTZXR0aW5ncy5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuICovXG52YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgcmVFbXB0eVN0cmluZ01pZGRsZSA9IC9cXGIoX19wIFxcKz0pICcnIFxcKy9nLFxuICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaFxuICogW0VTIHRlbXBsYXRlIGRlbGltaXRlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRlbXBsYXRlLWxpdGVyYWwtbGV4aWNhbC1jb21wb25lbnRzKS5cbiAqL1xudmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gKlxuICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J3RlbXBsYXRlU291cmNlc1tuXSddXG4gKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICpcbiAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICpcbiAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gKlxuICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gKlxuICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gKlxuICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAqIGNvbXBpbGVkKGRhdGEpO1xuICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAqXG4gKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAqIGNvbXBpbGVkLnNvdXJjZTtcbiAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAqIC8vICAgcmV0dXJuIF9fcDtcbiAqIC8vIH1cbiAqXG4gKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAqICAgdmFyIEpTVCA9IHtcXFxuICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gKiAgIH07XFxcbiAqICcpO1xuICovXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgdmFyIHNldHRpbmdzID0gdGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzLl8udGVtcGxhdGVTZXR0aW5ncyB8fCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gIHZhciBpc0VzY2FwaW5nLFxuICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgLCAnZycpO1xuXG4gIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAvLyB3aXRoIGxvb2t1cCAoaW4gY2FzZSBvZiBlLmcuIHByb3RvdHlwZSBwb2xsdXRpb24pLCBhbmQgc3RyaXAgbmV3bGluZXMgaWYgYW55LlxuICAvLyBBIG5ld2xpbmUgd291bGRuJ3QgYmUgYSB2YWxpZCBzb3VyY2VVUkwgYW55d2F5LCBhbmQgaXQnZCBlbmFibGUgY29kZSBpbmplY3Rpb24uXG4gIHZhciBzb3VyY2VVUkwgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgID8gKCcvLyMgc291cmNlVVJMPScgK1xuICAgICAgIChvcHRpb25zLnNvdXJjZVVSTCArICcnKS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnICcpICtcbiAgICAgICAnXFxuJylcbiAgICA6ICcnO1xuXG4gIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgIH1cbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAvLyBMaWtlIHdpdGggc291cmNlVVJMLCB3ZSB0YWtlIGNhcmUgdG8gbm90IGNoZWNrIHRoZSBvcHRpb24ncyBwcm90b3R5cGUsXG4gIC8vIGFzIHRoaXMgY29uZmlndXJhdGlvbiBpcyBhIGNvZGUgaW5qZWN0aW9uIHZlY3Rvci5cbiAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gIH1cbiAgLy8gQ2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzLlxuICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdUcmFpbGluZywgJyQxOycpO1xuXG4gIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAodmFyaWFibGVcbiAgICAgID8gJydcbiAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICApICtcbiAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgIChpc0VzY2FwaW5nXG4gICAgICAgPyAnLCBfX2UgPSBfLmVzY2FwZSdcbiAgICAgICA6ICcnXG4gICAgKSArXG4gICAgKGlzRXZhbHVhdGluZ1xuICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgOiAnO1xcbidcbiAgICApICtcbiAgICBzb3VyY2UgK1xuICAgICdyZXR1cm4gX19wXFxufSc7XG5cbiAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAuYXBwbHkodW5kZWZpbmVkLCBpbXBvcnRzVmFsdWVzKTtcbiAgfSk7XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gIC8vIHRoZSBgc291cmNlYCBwcm9wZXJ0eSBhcyBhIGNvbnZlbmllbmNlIGZvciBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMuXG4gIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICB0aHJvdyByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RlbXBsYXRlLmpzIiwiaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGtleXNJbiBmcm9tICcuL2tleXNJbi5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGFsaWFzIGV4dGVuZFdpdGhcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uYXNzaWduV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICogfVxuICpcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAqXG4gKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhc3NpZ25JbldpdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbkluV2l0aC5qcyIsImltcG9ydCBhc3NpZ25WYWx1ZSBmcm9tICcuL19hc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5T2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weU9iamVjdC5qcyIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NpZ25WYWx1ZS5qcyIsImltcG9ydCBiYXNlSXNOYXRpdmUgZnJvbSAnLi9fYmFzZUlzTmF0aXZlLmpzJztcbmltcG9ydCBnZXRWYWx1ZSBmcm9tICcuL19nZXRWYWx1ZS5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldE5hdGl2ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldE5hdGl2ZS5qcyIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzTmF0aXZlLmpzIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiaW1wb3J0IGNvcmVKc0RhdGEgZnJvbSAnLi9fY29yZUpzRGF0YS5qcyc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTWFza2VkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNNYXNrZWQuanMiLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcmVKc0RhdGEuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRvU291cmNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanMiLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRWYWx1ZS5qcyIsImltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVBc3NpZ25lcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NyZWF0ZUFzc2lnbmVyLmpzIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlclJlc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyUmVzdC5qcyIsImltcG9ydCBiYXNlU2V0VG9TdHJpbmcgZnJvbSAnLi9fYmFzZVNldFRvU3RyaW5nLmpzJztcbmltcG9ydCBzaG9ydE91dCBmcm9tICcuL19zaG9ydE91dC5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2V0VG9TdHJpbmcuanMiLCJpbXBvcnQgY29uc3RhbnQgZnJvbSAnLi9jb25zdGFudC5qcyc7XG5pbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gJy4vaWRlbnRpdHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldFRvU3RyaW5nLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9jb25zdGFudC5qcyIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hvcnRPdXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaG9ydE91dC5qcyIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXNJbi5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5c0luIGZyb20gJy4vX25hdGl2ZUtleXNJbi5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzSW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5c0luLmpzIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXNJbi5qcyIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGF0dGVtcHQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2F0dGVtcHQuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzUGxhaW5PYmplY3QuanMiLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFByb3RvdHlwZS5qcyIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbURlZmF1bHRzQXNzaWduSW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jdXN0b21EZWZhdWx0c0Fzc2lnbkluLmpzIiwiLyoqIFVzZWQgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgJ1xcXFwnOiAnXFxcXCcsXG4gIFwiJ1wiOiBcIidcIixcbiAgJ1xcbic6ICduJyxcbiAgJ1xccic6ICdyJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy50ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjaHIgVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIGVzY2FwZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmdDaGFyKGNocikge1xuICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1tjaHJdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVTdHJpbmdDaGFyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZXNjYXBlU3RyaW5nQ2hhci5qcyIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiaW1wb3J0IGVzY2FwZSBmcm9tICcuL2VzY2FwZS5qcyc7XG5pbXBvcnQgcmVFc2NhcGUgZnJvbSAnLi9fcmVFc2NhcGUuanMnO1xuaW1wb3J0IHJlRXZhbHVhdGUgZnJvbSAnLi9fcmVFdmFsdWF0ZS5qcyc7XG5pbXBvcnQgcmVJbnRlcnBvbGF0ZSBmcm9tICcuL19yZUludGVycG9sYXRlLmpzJztcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IGxvZGFzaCBhcmUgbGlrZSB0aG9zZSBpblxuICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gKiBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciB0ZW1wbGF0ZVNldHRpbmdzID0ge1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2VzY2FwZSc6IHJlRXNjYXBlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKi9cbiAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBpbmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdpbnRlcnBvbGF0ZSc6IHJlSW50ZXJwb2xhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgJ3ZhcmlhYmxlJzogJycsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gaW1wb3J0IHZhcmlhYmxlcyBpbnRvIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgJ2ltcG9ydHMnOiB7XG5cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG4gICAgJ18nOiB7ICdlc2NhcGUnOiBlc2NhcGUgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZVNldHRpbmdzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90ZW1wbGF0ZVNldHRpbmdzLmpzIiwiaW1wb3J0IGVzY2FwZUh0bWxDaGFyIGZyb20gJy4vX2VzY2FwZUh0bWxDaGFyLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggSFRNTCBlbnRpdGllcyBhbmQgSFRNTCBjaGFyYWN0ZXJzLiAqL1xudmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nLFxuICAgIHJlSGFzVW5lc2NhcGVkSHRtbCA9IFJlZ0V4cChyZVVuZXNjYXBlZEh0bWwuc291cmNlKTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAqXG4gKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICpcbiAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICogWFNTIHZlY3RvcnMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICA6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lc2NhcGUuanMiLCJpbXBvcnQgYmFzZVByb3BlcnR5T2YgZnJvbSAnLi9fYmFzZVByb3BlcnR5T2YuanMnO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xudmFyIGh0bWxFc2NhcGVzID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc8JzogJyZsdDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gIFwiJ1wiOiAnJiMzOTsnXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8uZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gKi9cbnZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlSHRtbENoYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19lc2NhcGVIdG1sQ2hhci5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUHJvcGVydHlPZi5qcyIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVG9TdHJpbmcuanMiLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFc2NhcGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUVzY2FwZS5qcyIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXZhbHVhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yZUV2YWx1YXRlLmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IEltYWdlUmVuZGVyZXIgZnJvbSAnLi9JbWFnZVJlbmRlcmVyJ1xuXG5leHBvcnQgZGVmYXVsdCBJbWFnZVJlbmRlcmVyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvSW1hZ2VSZW5kZXJlci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBUZW1wbGF0ZVJlbmRlcmVyIGZyb20gJy4uL1RlbXBsYXRlUmVuZGVyZXInXG5cbi8qKlxuICogTnVtYmVycyBFZGl0b3JcbiAqXG4gKiBIYW5kbGUgbnVtYmVyIHZhbHVlcyBFZGl0aW5nXG4gKlxuICogfCBOYW1lICAgICAgICAgICAgICAgICAgXHR8IERlZmF1bHQgICAgIFx0fCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXHR8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVx0fDotLS0tLS0tLS0tLS0tOnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwgKippbWFnZVJlbmRlcmVyV2lkdGgqKiAgIHwgMjhweCAgICB8IGltYWdlIHdpZHRoXG4gKiB8ICoqaW1hZ2VSZW5kZXJlckhlaWdodCoqICAgfCAyOHB4ICAgIHwgaW1hZ2UgaGVpZ2h0XG4gKiB8ICoqaW1hZ2VSZW5kZXJlckxpc3QqKiAgICAgICB8IHt9ICBcdHwgYSBsaXN0IG9mIHdoaWNoIG1hcHMgaW1hZ2VzIHdpdGggY2VsbCB2YWx1ZXMgYXMgSlNPTiBvciBwbGFpbiBKUyBvYmplY3RcbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9sb2Rhc2guY29tL2RvY3MvNC4xNy4xNSN0ZW1wbGF0ZVxuICovXG5jbGFzcyBJbWFnZVJlbmRlcmVyIGV4dGVuZHMgVGVtcGxhdGVSZW5kZXJlciB7XG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgcmVmcmVzaChwYXJhbXMsIGlzSW5pdCkge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgY29uc3QgaW1hZ2VXaWR0aCA9IHRoaXMuZ2V0T3B0aW9uKCdpbWFnZVJlbmRlcmVyV2lkdGgnLCBwYXJhbXMsICcyOHB4JylcbiAgICBjb25zdCBpbWFnZUhlaWdodCA9IHRoaXMuZ2V0T3B0aW9uKCdpbWFnZVJlbmRlcmVySGVpZ2h0JywgcGFyYW1zLCAnMjhweCcpXG4gICAgbGV0IGltYWdlTGlzdCA9IHRoaXMuZ2V0T3B0aW9uKCdpbWFnZVJlbmRlcmVyTGlzdCcsIHBhcmFtcylcblxuICAgIHRyeSB7XG4gICAgICBpbWFnZUxpc3QgPSBKU09OLnBhcnNlKGltYWdlTGlzdClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpbWFnZUxpc3QgPSBpbWFnZUxpc3QgfHwge31cbiAgICB9XG5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbiAgICBpZiAoaW1hZ2VMaXN0ICYmIGltYWdlTGlzdC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgIHBhcmFtcy5yZW5kZXJUZW1wbGF0ZSA9IC8qaHRtbCovIGBcbiAgICAgICAgPGltZyBcbiAgICAgICAgICBzcmM9XCIke2ltYWdlTGlzdFtwYXJhbXMudmFsdWVdfVwiIFxuICAgICAgICAgIHdpZHRoPVwiJHtpbWFnZVdpZHRofVwiXG4gICAgICAgICAgaGVpZ2h0PVwiJHtpbWFnZUhlaWdodH1cIiAgXG4gICAgICAgIC8+XG4gICAgICBgXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcy5yZW5kZXJUZW1wbGF0ZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnJlZnJlc2gocGFyYW1zLCBpc0luaXQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2VSZW5kZXJlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0ltYWdlUmVuZGVyZXIvSW1hZ2VSZW5kZXJlci5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCBEYXRlVGltZUZpbHRlciBmcm9tICcuL0RhdGVUaW1lRmlsdGVyJ1xuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lRmlsdGVyL2luZGV4LmpzIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzIGxpYi5cbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cbiAqXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG4gKi9cblxuaW1wb3J0IHsgYXV0b2JpbmQsIG92ZXJyaWRlLCByZWFkb25seSB9IGZyb20gJ2NvcmUtZGVjb3JhdG9ycydcbmltcG9ydCB1dGNUb1pvbmVkVGltZSBmcm9tICdkYXRlLWZucy10ei91dGNUb1pvbmVkVGltZSdcbmltcG9ydCB7IHdpdGhFdmVudHNNaXhpbiB9IGZyb20gJy4uL0V2ZW50c01peGluJ1xuaW1wb3J0IERhdGVUaW1lSW5wdXQgZnJvbSAnLi4vRGF0ZVRpbWVJbnB1dCdcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi4vQ29tcG9uZW50J1xuaW1wb3J0ICcuL3N0eWxlLnNjc3MnXG5cbmNvbnN0IFRPS0VOUyA9IHtcbiAgVE9LRU5fRVFVQUw6ICdlcXVhbHMnLFxuICBUT0tFTl9OT1RfRVFVQUw6ICdub3RFcXVhbCcsXG4gIFRPS0VOX0xFU1M6ICdsZXNzVGhhbicsXG4gIFRPS0VOX0dSRUFURVI6ICdncmVhdGVyVGhhbicsXG4gIFRPS0VOX1JBTkdFOiAnaW5SYW5nZScsXG4gIFRPS0VOX0FORDogJ0FORCcsXG4gIFRPS0VOX09SOiAnT1InLFxufVxuXG5Ad2l0aEV2ZW50c01peGluXG5jbGFzcyBDb25kaXRpb25QYW5lbCBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdGFudCB3aGljaCBkZXNjcmliZXMgdGhlIGV2ZW50IG5hbWUgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gdGhlIG9wdGlvblxuICAgKiBzdGF0ZSBpcyBjaGFuZ2VkXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBAcmVhZG9ubHlcbiAgc3RhdGljIE9OX0NPTkRJVElPTl9DSEFOR0VEID0gJ0NvbmRpdGlvblBhbmVsLk9OX0NPTkRJVElPTl9DSEFOR0VEJ1xuICAvKipcbiAgICogVGhlIG9wdGlvbiBzdGF0ZVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgQHJlYWRvbmx5XG4gIHN0YXRlID0ge1xuICAgIHR5cGU6IFRPS0VOUy5UT0tFTl9FUVVBTCxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgZmlsdGVyVG86IG51bGwsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0RhdGVUaW1lSW5wdXR9XG4gICAqL1xuICBfZmlsdGVyVGltZUlucHV0ID0gbmV3IERhdGVUaW1lSW5wdXQoKVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RGF0ZVRpbWVJbnB1dH1cbiAgICovXG4gIF9maWx0ZXJUb0RhdGVUaW1lSW5wdXQgPSBuZXcgRGF0ZVRpbWVJbnB1dCgpXG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGVuYWJsZWQgZmlsdGVyIHR5cGVzXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIF9maWx0ZXJPcHRpb25zID0gW11cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZW5hYmxlZCBmaWx0ZXIgdHlwZVxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgX2RlZmF1bHRPcHRpb24gPSAtMVxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHBhcmFtcy5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldExvY2FsZVRleHRGdW5jKClcblxuICAgIHRoaXMuX2ZpbHRlck9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbignZmlsdGVyT3B0aW9ucycsIHBhcmFtcywgW1xuICAgICAgVE9LRU5TLlRPS0VOX0VRVUFMLFxuICAgICAgVE9LRU5TLlRPS0VOX05PVF9FUVVBTCxcbiAgICAgIFRPS0VOUy5UT0tFTl9MRVNTLFxuICAgICAgVE9LRU5TLlRPS0VOX0dSRUFURVIsXG4gICAgICBUT0tFTlMuVE9LRU5fUkFOR0UsXG4gICAgXSlcblxuICAgIHRoaXMuX2RlZmF1bHRPcHRpb24gPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICdkZWZhdWx0T3B0aW9uJyxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHRoaXMuX2ZpbHRlck9wdGlvbnMuaW5kZXhPZihUT0tFTlMuVE9LRU5fRVFVQUwpID4gLTFcbiAgICAgICAgPyBUT0tFTlMuVE9LRU5fRVFVQUxcbiAgICAgICAgOiB0aGlzLl9maWx0ZXJPcHRpb25zWzBdXG4gICAgKVxuXG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdGhpcy5fZGVmYXVsdE9wdGlvblxuXG4gICAgY29uc3Qgb3B0aW9uc1RyYW5zbGF0aW9ucyA9IHtcbiAgICAgIFtUT0tFTlMuVE9LRU5fRVFVQUxdOiB0cmFuc2xhdGUoVE9LRU5TLlRPS0VOX0VRVUFMLCAnRXF1YWxzJyksXG4gICAgICBbVE9LRU5TLlRPS0VOX05PVF9FUVVBTF06IHRyYW5zbGF0ZShUT0tFTlMuVE9LRU5fRVFVQUwsICdOb3QgZXF1YWwnKSxcbiAgICAgIFtUT0tFTlMuVE9LRU5fTEVTU106IHRyYW5zbGF0ZShUT0tFTlMuVE9LRU5fTEVTUywgJ0xlc3MgdGhhbicpLFxuICAgICAgW1RPS0VOUy5UT0tFTl9HUkVBVEVSXTogdHJhbnNsYXRlKFRPS0VOUy5UT0tFTl9HUkVBVEVSLCAnR3JlYXRlciB0aGFuJyksXG4gICAgICBbVE9LRU5TLlRPS0VOX1JBTkdFXTogdHJhbnNsYXRlKFRPS0VOUy5UT0tFTl9SQU5HRSwgJ0luIHJhbmdlJyksXG4gICAgfVxuXG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ2RhdGVUaW1lRmlsdGVyIGFnLWZpbHRlci1ib2R5LXdyYXBwZXInXG4gICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgICAgPHNlbGVjdCBjbGFzcz1cImFnLWZpbHRlci1zZWxlY3QgZGF0ZVRpbWVGaWx0ZXJfX3NlbGVjdFwiICAke1xuICAgICAgICB0aGlzLl9maWx0ZXJPcHRpb25zLmxlbmd0aCA9PT0gMSA/ICdkaXNhYmxlZCcgOiAnJ1xuICAgICAgfT5cbiAgICAgICAgJHt0aGlzLl9maWx0ZXJPcHRpb25zLm1hcChcbiAgICAgICAgICBvcHRpb24gPT4gLyogaHRtbCAqLyBgXG4gICAgICAgICAgPG9wdGlvbiBcbiAgICAgICAgICAgIHZhbHVlPVwiJHtvcHRpb259XCIgXG4gICAgICAgICAgICAke29wdGlvbiA9PT0gdGhpcy5fZGVmYXVsdE9wdGlvbiA/ICdzZWxlY3RlZCcgOiAnJ31cbiAgICAgICAgICA+XG4gICAgICAgICAgICAgICR7b3B0aW9uc1RyYW5zbGF0aW9uc1tvcHRpb25dfVxuICAgICAgICAgIDwvb3B0aW9uPmBcbiAgICAgICAgKX1cbiAgICAgIDwvc2VsZWN0PlxuICAgICAgPGRpdiBjbGFzcz1cImFnLWZpbHRlci1ib2R5XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZy1maWx0ZXItZGF0ZS1mcm9tXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWctZmlsdGVyLWRhdGUtdG8gYWctaGlkZGVuXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYFxuXG4gICAgdGhpcy5fZmlsdGVyVGltZUlucHV0LmluaXQocGFyYW1zKVxuICAgIHRoaXMuX2ZpbHRlclRpbWVJbnB1dC5vbihEYXRlVGltZUlucHV0Lk9OX0RBVEVfQ0hBTkdFRCwgc2VsZWN0ZWREYXRlID0+IHtcbiAgICAgIHRoaXMuc3RhdGUuZmlsdGVyID0gc2VsZWN0ZWREYXRlXG4gICAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgICB9KVxuXG4gICAgdGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0LmluaXQocGFyYW1zKVxuICAgIHRoaXMuX2ZpbHRlclRvRGF0ZVRpbWVJbnB1dC5vbihcbiAgICAgIERhdGVUaW1lSW5wdXQuT05fREFURV9DSEFOR0VELFxuICAgICAgc2VsZWN0ZWREYXRlID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWx0ZXJUbyA9IHNlbGVjdGVkRGF0ZVxuICAgICAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9ndWlcbiAgICAgIC5xdWVyeVNlbGVjdG9yKCcuYWctZmlsdGVyLWRhdGUtZnJvbScpXG4gICAgICAuYXBwZW5kQ2hpbGQodGhpcy5fZmlsdGVyVGltZUlucHV0LmdldEd1aSgpKVxuICAgIHRoaXMuX2d1aVxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItZGF0ZS10bycpXG4gICAgICAuYXBwZW5kQ2hpbGQodGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0LmdldEd1aSgpKVxuXG4gICAgY29uc3Qgc2VsZWN0ID0gdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItc2VsZWN0JylcbiAgICBzZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25UeXBlQ2hhbmdlKVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vZmYoQ29uZGl0aW9uUGFuZWwuT05fQ09ORElUSU9OX0NIQU5HRUQpXG4gICAgdGhpcy5fZmlsdGVyVGltZUlucHV0LmRlc3Ryb3koKVxuICAgIHRoaXMuX2ZpbHRlclRvRGF0ZVRpbWVJbnB1dC5kZXN0cm95KClcbiAgICB0aGlzLl9ndWlcbiAgICAgIC5xdWVyeVNlbGVjdG9yKCcuYWctZmlsdGVyLXNlbGVjdCcpXG4gICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25UeXBlQ2hhbmdlKVxuICAgIHRoaXMucmVzZXQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZVxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5maWx0ZXIgPSBudWxsXG4gICAgdGhpcy5zdGF0ZS5maWx0ZXJUbyA9IG51bGxcbiAgICB0aGlzLl9maWx0ZXJUaW1lSW5wdXQucmVzZXQoKVxuICAgIHRoaXMuX2ZpbHRlclRvRGF0ZVRpbWVJbnB1dC5yZXNldCgpXG5cbiAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbmRpdGlvbiBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICovXG4gIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSB8fCB7fVxuICAgIHRoaXMuc3RhdGUuZmlsdGVyID0gc3RhdGUuZmlsdGVyIHx8IG51bGxcbiAgICB0aGlzLnN0YXRlLmZpbHRlclRvID0gc3RhdGUuZmlsdGVyVG8gfHwgbnVsbFxuICAgIHRoaXMuc3RhdGUudHlwZSA9IHN0YXRlLnR5cGUgfHwgdGhpcy5fZGVmYXVsdE9wdGlvblxuXG4gICAgY29uc3QgZ3VpID0gdGhpcy5fZ3VpXG4gICAgY29uc3QgZmlsdGVyT3B0aW9ucyA9IHRoaXMuX2ZpbHRlck9wdGlvbnNcbiAgICBjb25zdCBzZWxlY3RFbCA9IGd1aS5xdWVyeVNlbGVjdG9yKCcuYWctZmlsdGVyLXNlbGVjdCcpXG4gICAgY29uc3QgZmlsdGVySW5wdXQgPSB0aGlzLl9maWx0ZXJUaW1lSW5wdXRcbiAgICBjb25zdCBmaWx0ZXJUb0lucHV0ID0gdGhpcy5fZmlsdGVyVG9EYXRlVGltZUlucHV0XG5cbiAgICBzZWxlY3RFbC5zZWxlY3RlZEluZGV4ID0gZmlsdGVyT3B0aW9ucy5pbmRleE9mKHRoaXMuc3RhdGUudHlwZSlcbiAgICBmaWx0ZXJJbnB1dC5zZXREYXRlKHRoaXMuc3RhdGUuZmlsdGVyKVxuICAgIGZpbHRlclRvSW5wdXQuc2V0RGF0ZSh0aGlzLnN0YXRlLmZpbHRlclRvKVxuXG4gICAgLy8gd2UgZmlyZSBvbiBjaGFuZ2UgZXZlbnQgaW4gY2FzZSB0aGUgZmlsdGVyIG9wdGlvbnMgY29udGFpblxuICAgIC8vIG9uZSBvcHRpb24gd2hpY2ggaXMgaW4gUmFuZ2UgXCJpblJhbmdlXCJcbiAgICBpZiAoJ2NyZWF0ZUV2ZW50JyBpbiBkb2N1bWVudCkge1xuICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKVxuICAgICAgZXZ0LmluaXRFdmVudCgnY2hhbmdlJywgZmFsc2UsIHRydWUpXG4gICAgICBzZWxlY3RFbC5kaXNwYXRjaEV2ZW50KGV2dClcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0RWwuZmlyZUV2ZW50KCdvbmNoYW5nZScpXG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoQ29uZGl0aW9uUGFuZWwuT05fQ09ORElUSU9OX0NIQU5HRUQsIHRoaXMuc3RhdGUpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGF0ZSB3aXRoIHRoZSBzZWxlY3RlZCB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25UeXBlQ2hhbmdlKGUpIHtcbiAgICBjb25zdCBlbCA9IGUudGFyZ2V0XG4gICAgY29uc3QgZmlsdGVyRGF0ZVRvID0gdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1maWx0ZXItZGF0ZS10bycpXG5cbiAgICB0aGlzLnN0YXRlLnR5cGUgPSBlbC5vcHRpb25zW2VsLnNlbGVjdGVkSW5kZXhdLnZhbHVlXG5cbiAgICBpZiAodGhpcy5zdGF0ZS50eXBlID09PSBUT0tFTlMuVE9LRU5fUkFOR0UpIHtcbiAgICAgIGZpbHRlckRhdGVUby5jbGFzc0xpc3QucmVtb3ZlKCdhZy1oaWRkZW4nKVxuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXJEYXRlVG8uY2xhc3NMaXN0LmFkZCgnYWctaGlkZGVuJylcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxufVxuXG5Ad2l0aEV2ZW50c01peGluXG5jbGFzcyBKb2luQ29uZGl0aW9uUGFuZWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RhbnQgd2hpY2ggZGVzY3JpYmVzIHRoZSBldmVudCBuYW1lIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIHRoZSBqb2luXG4gICAqIHN0YXRlIGlzIGNoYW5nZWRcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIEByZWFkb25seVxuICBzdGF0aWMgT05fSk9JTl9DT05ESVRJT05fQ0hBTkdFRCA9XG4gICAgJ0pvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VEJ1xuICAvKipcbiAgICogVGhlIGpvaW4gc3RhdGVcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIEByZWFkb25seVxuICBzdGF0ZSA9IHtcbiAgICBjb25kaXRpb24xOiB7fSxcbiAgICBjb25kaXRpb24yOiB7fSxcbiAgICBvcGVyYXRvcjogVE9LRU5TLlRPS0VOX09SLFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPcHRpb259XG4gICAqL1xuICBfZmlyc3RDb25kaXRpb25QYW5lbCA9IG5ldyBDb25kaXRpb25QYW5lbCgpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtPcHRpb259XG4gICAqL1xuICBfc2Vjb25kQ29uZGl0aW9uUGFuZWwgPSBuZXcgQ29uZGl0aW9uUGFuZWwoKVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfb3BlcmF0b3JQYW5lbCA9IG51bGxcblxuICAvKipcbiAgICogUGFyYW1zIHJlY2VpdmVkIGFmdGVyIGluaXRcbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9wYXJhbXMgPSBudWxsXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGluaXQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gcGFyYW1zLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0TG9jYWxlVGV4dEZ1bmMoKVxuXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zXG5cbiAgICB0aGlzLl9maXJzdENvbmRpdGlvblBhbmVsLmluaXQocGFyYW1zKVxuICAgIHRoaXMuX2ZpcnN0Q29uZGl0aW9uUGFuZWwub24oXG4gICAgICBDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCxcbiAgICAgIHRoaXMuX29uRmlyc3RDb25kaXRpb25DaGFuZ2VkXG4gICAgKVxuXG4gICAgdGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwuaW5pdChwYXJhbXMpXG4gICAgdGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwub24oXG4gICAgICBDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCxcbiAgICAgIHRoaXMuX29uU2Vjb25kQ29uZGl0aW9uQ2hhbmdlZFxuICAgIClcbiAgICB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5nZXRHdWkoKS5jbGFzc0xpc3QuYWRkKCdhZy1oaWRkZW4nKVxuXG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9ndWkuY2xhc3NOYW1lID0gJ2FnLWZpbHRlci1ib2R5LXdyYXBwZXIgYWctc2ltcGxlLWZpbHRlci1ib2R5LXdyYXBwZXInXG4gICAgdGhpcy5fZ3VpLmFwcGVuZENoaWxkKHRoaXMuX2ZpcnN0Q29uZGl0aW9uUGFuZWwuZ2V0R3VpKCkpXG5cbiAgICAvL3ByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IGlkT25lID0gJ18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpLFxuICAgICAgICAgIGlkVHdvID0gJ18nICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpXG5cbiAgICB0aGlzLl9vcGVyYXRvclBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB0aGlzLl9vcGVyYXRvclBhbmVsLmNsYXNzTmFtZSA9ICdhZy1maWx0ZXItY29uZGl0aW9uIGFnLWhpZGRlbidcbiAgICB0aGlzLl9vcGVyYXRvclBhbmVsLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgIDxkaXYgY2xhc3M9XCJhZy1maWx0ZXItY29uZGl0aW9uLW9wZXJhdG9yIGFnLWZpbHRlci1jb25kaXRpb24tb3BlcmF0b3ItYW5kIGFnLWxhYmVsZWQgYWctbGFiZWwtYWxpZ24tcmlnaHQgYWctcmFkaW8tYnV0dG9uIGFnLWlucHV0LWZpZWxkXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImFnLWlucHV0LWZpZWxkLWxhYmVsIGFnLWxhYmVsIGFnLXJhZGlvLWJ1dHRvbi1sYWJlbFwiIGZvcj1cIiR7aWRPbmV9XCI+ICAgICAgIFxuICAgICAgICAgICR7dHJhbnNsYXRlKCdhbmRDb25kaXRpb24nLCAnQU5EJyl9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyLWFuZCBhZy13cmFwcGVyIGFnLWlucHV0LXdyYXBwZXIgYWctcmFkaW8tYnV0dG9uLWlucHV0LXdyYXBwZXIgYWctY2hlY2tlZFwiPlxuICAgICAgICAgIDxpbnB1dCBpZD1cIiR7aWRPbmV9XCIgY2xhc3M9XCJBTkQgYWctaW5wdXQtZmllbGQtaW5wdXQgYWctcmFkaW8tYnV0dG9uLWlucHV0XCIgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm9yQW5kUmFkaW9cIiB2YWx1ZT1cIiR7XG4gICAgICBUT0tFTlMuVE9LRU5fQU5EXG4gICAgfVwiLz4gICAgICAgICAgICAgIFxuICAgICAgICA8L2Rpdj4gXG4gICAgPC9kaXY+ICAgXG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImFnLWZpbHRlci1jb25kaXRpb24tb3BlcmF0b3IgYWctZmlsdGVyLWNvbmRpdGlvbi1vcGVyYXRvci1hbmQgYWctbGFiZWxlZCBhZy1sYWJlbC1hbGlnbi1yaWdodCBhZy1yYWRpby1idXR0b24gYWctaW5wdXQtZmllbGRcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwiYWctaW5wdXQtZmllbGQtbGFiZWwgYWctbGFiZWwgYWctcmFkaW8tYnV0dG9uLWxhYmVsXCIgZm9yPVwiJHtpZFR3b31cIj4gICAgICAgXG4gICAgICAgICAgJHt0cmFuc2xhdGUoJ29yQ29uZGl0aW9uJywgJ09SJyl9XG4gICAgICAgIDwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhZy13cmFwcGVyLW9yIGFnLXdyYXBwZXIgYWctaW5wdXQtd3JhcHBlciBhZy1yYWRpby1idXR0b24taW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgIDxpbnB1dCBpZD1cIiR7aWRUd299XCIgY2xhc3M9XCJPUiBhZy1pbnB1dC1maWVsZC1pbnB1dCBhZy1yYWRpby1idXR0b24taW5wdXRcIiB0eXBlPVwicmFkaW9cIiBuYW1lPVwib3JBbmRSYWRpb1wiIHZhbHVlPVwiJHtcbiAgICAgIFRPS0VOUy5UT0tFTl9PUlxuICAgIH1cIi8+ICAgICAgICAgICAgICBcbiAgICAgICAgPC9kaXY+ICAgICAgICAgXG4gICAgPC9kaXY+ICAgXG4gICAgYFxuICAgIHRoaXMuX2d1aS5hcHBlbmRDaGlsZCh0aGlzLl9vcGVyYXRvclBhbmVsKVxuICAgIHRoaXMuX29wZXJhdG9yUGFuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25PcGVyYXRvckNoYW5nZWQpXG5cbiAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQodGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwuZ2V0R3VpKCkpXG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX2ZpcnN0Q29uZGl0aW9uUGFuZWwuZGVzdHJveSgpXG4gICAgdGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwuZGVzdHJveSgpXG4gICAgdGhpcy5fb3BlcmF0b3JQYW5lbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbk9wZXJhdG9yQ2hhbmdlZClcbiAgICB0aGlzLm9mZihKb2luQ29uZGl0aW9uUGFuZWwuT05fSk9JTl9DT05ESVRJT05fQ0hBTkdFRClcbiAgICB0aGlzLnJlc2V0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3RhdGVcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX2ZpcnN0Q29uZGl0aW9uUGFuZWwucmVzZXQoKVxuICAgIHRoaXMuX3NlY29uZENvbmRpdGlvblBhbmVsLnJlc2V0KClcbiAgICB0aGlzLm5vdGlmeShDb25kaXRpb25QYW5lbC5PTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvbmRpdGlvbiBqb2luIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICAgKi9cbiAgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlIHx8IHt9XG4gICAgdGhpcy5zdGF0ZS5vcGVyYXRvciA9IHN0YXRlLm9wZXJhdG9yIHx8IFRPS0VOUy5UT0tFTl9PUlxuICAgIHRoaXMuc3RhdGUuY29uZGl0aW9uMSA9IHN0YXRlLmNvbmRpdGlvbjEgfHwgbnVsbFxuICAgIHRoaXMuc3RhdGUuY29uZGl0aW9uMiA9IHN0YXRlLmNvbmRpdGlvbjIgfHwgbnVsbFxuXG4gICAgdGhpcy5fZmlyc3RDb25kaXRpb25QYW5lbC5zZXRTdGF0ZSh0aGlzLnN0YXRlLmNvbmRpdGlvbjEpXG4gICAgdGhpcy5fc2Vjb25kQ29uZGl0aW9uUGFuZWwuc2V0U3RhdGUodGhpcy5zdGF0ZS5jb25kaXRpb24yKVxuICAgIHRoaXMuX29wZXJhdG9yUGFuZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlmIChpbnB1dC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5zdGF0ZS5vcGVyYXRvcikpIHtcbiAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLm5vdGlmeShKb2luQ29uZGl0aW9uUGFuZWwuT05fSk9JTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHNlbGVjdGVkIGNvbmRpdGlvbiB0byB0aGUgY29tcG9uZW50IHN0YXRlclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uT3BlcmF0b3JDaGFuZ2VkKGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldFxuXG4gICAgdGhpcy5zdGF0ZS5vcGVyYXRvciA9IHRhcmdldC52YWx1ZVxuXG4gICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ09SJykpIHtcbiAgICAgIHRoaXMuX29wZXJhdG9yUGFuZWxcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLW9yJylcbiAgICAgICAgLmNsYXNzTGlzdC5hZGQoJ2FnLWNoZWNrZWQnKVxuICAgICAgdGhpcy5fb3BlcmF0b3JQYW5lbFxuICAgICAgICAucXVlcnlTZWxlY3RvcignLmFnLXdyYXBwZXItYW5kJylcbiAgICAgICAgLmNsYXNzTGlzdC5yZW1vdmUoJ2FnLWNoZWNrZWQnKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vcGVyYXRvclBhbmVsXG4gICAgICAgIC5xdWVyeVNlbGVjdG9yKCcuYWctd3JhcHBlci1vcicpXG4gICAgICAgIC5jbGFzc0xpc3QucmVtb3ZlKCdhZy1jaGVja2VkJylcbiAgICAgIHRoaXMuX29wZXJhdG9yUGFuZWxcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoJy5hZy13cmFwcGVyLWFuZCcpXG4gICAgICAgIC5jbGFzc0xpc3QuYWRkKCdhZy1jaGVja2VkJylcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeShKb2luQ29uZGl0aW9uUGFuZWwuT05fSk9JTl9DT05ESVRJT05fQ0hBTkdFRCwgdGhpcy5zdGF0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgIHRoZSBvcHRpb24gc3RhdGVcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25GaXJzdENvbmRpdGlvbkNoYW5nZWQoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbmRpdGlvbjEgPSBzdGF0ZVxuXG4gICAgY29uc3Qgc3VwcHJlc3NBbmRPckNvbmRpdGlvbiA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ3N1cHByZXNzQW5kT3JDb25kaXRpb24nLFxuICAgICAgdGhpcy5fcGFyYW1zLFxuICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBpZiAoIXN1cHByZXNzQW5kT3JDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHsgZmlsdGVyLCBmaWx0ZXJUbywgdHlwZSB9ID0gdGhpcy5zdGF0ZS5jb25kaXRpb24xXG4gICAgICBjb25zdCBzZWNvbmRDb25kaXRpb25HdWkgPSB0aGlzLl9zZWNvbmRDb25kaXRpb25QYW5lbC5nZXRHdWkoKVxuICAgICAgY29uc3Qgb3BlcmF0b3JQYW5lbEd1aSA9IHRoaXMuX29wZXJhdG9yUGFuZWxcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9XG4gICAgICAgIHR5cGUgPT09IFRPS0VOUy5UT0tFTl9SQU5HRSA/ICFmaWx0ZXIgfHwgIWZpbHRlclRvIDogIWZpbHRlclxuXG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgIHNlY29uZENvbmRpdGlvbkd1aS5jbGFzc0xpc3QuYWRkKCdhZy1oaWRkZW4nKVxuICAgICAgICBvcGVyYXRvclBhbmVsR3VpLmNsYXNzTGlzdC5hZGQoJ2FnLWhpZGRlbicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWNvbmRDb25kaXRpb25HdWkuY2xhc3NMaXN0LnJlbW92ZSgnYWctaGlkZGVuJylcbiAgICAgICAgb3BlcmF0b3JQYW5lbEd1aS5jbGFzc0xpc3QucmVtb3ZlKCdhZy1oaWRkZW4nKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5KEpvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSAgdGhlIG9wdGlvbiBzdGF0ZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vblNlY29uZENvbmRpdGlvbkNoYW5nZWQoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbmRpdGlvbjIgPSBzdGF0ZVxuICAgIHRoaXMubm90aWZ5KEpvaW5Db25kaXRpb25QYW5lbC5PTl9KT0lOX0NPTkRJVElPTl9DSEFOR0VELCB0aGlzLnN0YXRlKVxuICB9XG59XG5cbi8qKlxuICogRGF0ZVRpbWUgRmlsdGVyXG4gKlxuICogIyMgT3B0aW9uc1xuICpcbiAqIHwgTmFtZSAgICAgICAgICAgICAgICAgIFx0fCBEZWZhdWx0ICAgICBcdHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFx0fFxuICogfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cdHw6LS0tLS0tLS0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVUaW1lKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSB0aW1lXG4gKiB8ICoqZGF0ZVRpbWVFbmFibGUyNEhSKiogICB8IGZhbHNlICAgIHwgZW5hYmxlIC8gZGlzYWJsZSB0aW1lIDI0IGZvcm1hdFxuICogfCAqKmRhdGVUaW1lRW5hYmxlU2Vjb25kcyoqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgc2Vjb25kcyBtYW5hZ2VtZW50XG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVDYWxlbmRhcioqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgQ2FsZW5kYXIuXG4gKiB8ICoqZGF0ZVRpbWVNYXNrKiogICB8IGZhbHNlICAgIHwgVGhlIG1hc2sgdXNlZCB0byBmb3JtYXQgdGhlIHNlbGVjdGVkIGRhdGVcbiAqIHwgKipkYXRlVGltZU1heCoqICAgfCB1bmRlZmluZWQgICAgfCAgTWF4IGFsbG93ZWQgZGF0ZVxuICogfCAqKmRhdGVUaW1lTWluKiogICB8IHVuZGVmaW5lZCAgICB8ICBNaW4gYWxsb3dlZCBkYXRlXG4gKiB8ICoqZGF0ZVRpbWVGb3JtYXR0ZXIqKiAgIHwgdW5kZWZpbmVkICAgIHwgIEEgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBmb3JtYXQgdGhlIGRhdGUgKEBzZWUgc3VwcG9ydGVkIHBhcmFtKVxuICogfCAqKmRhdGVUaW1lTG9jYWxlKiogICB8IFN5c3RlbSBkZWZhdWx0ICAgIHwgIEEgbG9jYWxlIHRvIHVzZSBmb3IgZGF0ZSBmb3JtYXR0aW5nXG4gKiB8ICoqZGF0ZVRpbWVEZWZhdWx0SG91cioqICAgfCAxMiAgICB8ICBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gKiB8ICoqZGF0ZVRpbWVEZWZhdWx0TWludXRlKiogICB8IDAgICAgfCAgSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gKiB8ICoqZGF0ZVRpbWVEaXNhYmxlTW9iaWxlKiogICB8IGZhbHNlICAgIHwgIFNldCBkaXNhYmxlTW9iaWxlIHRvIHRydWUgdG8gYWx3YXlzIHVzZSB0aGUgbm9uLW5hdGl2ZSBwaWNrZXIuXG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVXZWVrTnVtYmVyKiogICB8IHRydWUgICAgfCAgRW5hYmxlcyBkaXNwbGF5IG9mIHdlZWsgbnVtYmVycyBpbiBjYWxlbmRhci5cbiAqIHwgKipmaWx0ZXJPcHRpb25zKiogICB8IEVxdWFscywgR3JlYXRlciBUaGFuLCBMZXNzIFRoYW4sIE5vdCBFcXVhbHMsIEluIFJhbmdlLiAgICB8ICBXaGF0IEZpbHRlciBPcHRpb25zIHRvIHByZXNlbnQgdG8gdGhlIHVzZXIuXG4gKiB8ICoqZGVmYXVsdE9wdGlvbioqICAgfCBFcXVhbHMgICAgfCAgVGhlIGRlZmF1bHQgRmlsdGVyIE9wdGlvbnMgdG8gYmUgc2VsZWN0ZWQuXG4gKiB8ICoqc3VwcHJlc3NBbmRPckNvbmRpdGlvbioqICAgfCBmYWxzZSAgICB8ICBJZiB0cnVlLCB0aGUgZmlsdGVyIHdpbGwgb25seSBvZmZlciBDb25kaXRpb24gMS5cbiAqIHwgKippblJhbmdlSW5jbHVzaXZlKiogICB8IGZhbHNlICAgIHwgIElmIHRydWUgdGhlbiBkb2luZyAnaW5SYW5nZScgZmlsdGVyIG9wdGlvbiB3aWxsIGluY2x1ZGUgdmFsdWVzIGVxdWFsIHRvIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSByYW5nZS5cbiAqIHwgKipjbGVhckJ1dHRvbioqICAgfCBmYWxzZSAgICB8ICBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBmaWx0ZXIgdXNlIGEgQ2xlYXIgYnV0dG9uLiBUaGUgQ2xlYXIgYnV0dG9uIHdpbGwgY2xlYXIgdGhlIChmb3JtKSBkZXRhaWxzIG9mIHRoZSBmaWx0ZXIgd2l0aG91dCByZW1vdmluZyBhbnkgYWN0aXZlIGZpbHRlcnMgb24gdGhlIGNvbHVtbi5cbiAqIHwgKiphcHBseUJ1dHRvbioqICAgfCBmYWxzZSAgICB8ICBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBmaWx0ZXIgdXNlIGFuIEFwcGx5IGJ1dHRvbi4gSWYgdGhlIEFwcGx5IGJ1dHRvbiBpcyBwcmVzZW50LCB0aGVuIHRoZSBmaWx0ZXIgaXMgb25seSBhcHBsaWVkIGFmdGVyIHRoZSB1c2VyIGhpdHMgdGhlIEFwcGx5IGJ1dHRvbi5cbiAqIHwgKipyZXNldEJ1dHRvbioqICAgfCBmYWxzZSAgICB8ICBTZXQgdG8gdHJ1ZSB0byBoYXZlIHRoZSBmaWx0ZXIgdXNlIGEgUmVzZXQgYnV0dG9uLiBUaGUgUmVzZXQgYnV0dG9uIHdpbGwgY2xlYXIgdGhlIGRldGFpbHMgb2YgdGhlIGZpbHRlciBhbmQgYW55IGFjdGl2ZSBmaWx0ZXJzIG9uIHRoYXQgY29sdW1uLlxuICpcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XG4gKi9cbmNsYXNzIERhdGVUaW1lRmlsdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtKb2lufVxuICAgKi9cbiAgX0pvaW5Db25kaXRpb25QYW5lbCA9IG5ldyBKb2luQ29uZGl0aW9uUGFuZWwoKVxuXG4gIC8qKlxuICAgKiBKb2luIHBhbmVsIHN0YXRlXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBfc3RhdGUgPSB7fVxuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgcGFyYW1zXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBfcGFyYW1zID0ge31cblxuICAvKipcbiAgICogQW4gb2JqZWN0IG9mIGFsbCB0aGUgcmVxdWlyZWQgb3B0aW9ucyBjYWNoZWQgZm9yIGRvZXNGaWx0ZXJQYXNzIG1ldGhvZFxuICAgKi9cbiAgX2RvZXNGaWx0ZXJQYXNzT3B0aW9ucyA9IG51bGxcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIEBvdmVycmlkZVxuICBpbml0KHBhcmFtcykge1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IHBhcmFtcy5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldExvY2FsZVRleHRGdW5jKClcbiAgICBjb25zdCBpc0NsZWFyRmlsdGVyID0gdGhpcy5nZXRPcHRpb24oJ2NsZWFyQnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcbiAgICBjb25zdCBpc1Jlc2V0QnV0dG9uID0gdGhpcy5nZXRPcHRpb24oJ3Jlc2V0QnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcbiAgICBjb25zdCBpc0FwcGx5QnV0dG9uID0gdGhpcy5nZXRPcHRpb24oJ2FwcGx5QnV0dG9uJywgcGFyYW1zLCBmYWxzZSlcblxuICAgIHRoaXMuX2d1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cbiAgICB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwuaW5pdChwYXJhbXMpXG4gICAgdGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLm9uKFxuICAgICAgSm9pbkNvbmRpdGlvblBhbmVsLk9OX0pPSU5fQ09ORElUSU9OX0NIQU5HRUQsXG4gICAgICBzdGF0ZSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fX2Rpc2FibGVTdGF0ZUNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgICAgdGhpcy5fb25Kb2luQ29uZGl0aW9uUGFuZWxTdGF0ZUNoYW5nZWQoc3RhdGUsIGlzQXBwbHlCdXR0b24pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQodGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLmdldEd1aSgpKVxuXG4gICAgY29uc3QgYXBwbHlGaWx0ZXJQYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgYXBwbHlGaWx0ZXJQYW5lbC5jbGFzc05hbWUgPSBgYWctZmlsdGVyLWFwcGx5LXBhbmVsIGFnLWhpZGRlbmBcbiAgICBhcHBseUZpbHRlclBhbmVsLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImFnLXN0YW5kYXJkLWJ1dHRvbiBhZy1maWx0ZXItYXBwbHktcGFuZWwtYnV0dG9uIGNsZWFyICR7IWlzQ2xlYXJGaWx0ZXIgJiZcbiAgICAgICAgJ2FnLWhpZGRlbid9XCIgdHlwZT1cImJ1dHRvblwiPiR7dHJhbnNsYXRlKFxuICAgICAgJ2NsZWFyRmlsdGVyJyxcbiAgICAgICdDbGVhciBGaWx0ZXInXG4gICAgKX08L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJhZy1zdGFuZGFyZC1idXR0b24gYWctZmlsdGVyLWFwcGx5LXBhbmVsLWJ1dHRvbiByZXNldCAkeyFpc1Jlc2V0QnV0dG9uICYmXG4gICAgICAgICdhZy1oaWRkZW4nfVwiIHR5cGU9XCJidXR0b25cIj4ke3RyYW5zbGF0ZShcbiAgICAgICdyZXNldEZpbHRlcicsXG4gICAgICAnUmVzZXQgRmlsdGVyJ1xuICAgICl9PC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYWctc3RhbmRhcmQtYnV0dG9uIGFnLWZpbHRlci1hcHBseS1wYW5lbC1idXR0b24gYXBwbHkgJHshaXNBcHBseUJ1dHRvbiAmJlxuICAgICAgICAnYWctaGlkZGVuJ31cIiB0eXBlPVwiYnV0dG9uXCI+JHt0cmFuc2xhdGUoXG4gICAgICAnYXBwbHlGaWx0ZXInLFxuICAgICAgJ0FwcGx5IEZpbHRlcidcbiAgICApfTwvYnV0dG9uPlxuICAgIGBcblxuICAgIGlmIChpc0NsZWFyRmlsdGVyIHx8IGlzUmVzZXRCdXR0b24gfHwgaXNBcHBseUJ1dHRvbikge1xuICAgICAgYXBwbHlGaWx0ZXJQYW5lbC5jbGFzc0xpc3QucmVtb3ZlKCdhZy1oaWRkZW4nKVxuICAgIH1cblxuICAgIGFwcGx5RmlsdGVyUGFuZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdjbGljaycsXG4gICAgICB0aGlzLl9BcHBseUZpbHRlclBhbmVsQnV0dG9uQ2xpY2tcbiAgICApXG5cbiAgICB0aGlzLl9ndWkuYXBwZW5kQ2hpbGQoYXBwbHlGaWx0ZXJQYW5lbClcblxuICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLnN0YXRlXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zXG5cbiAgICB0aGlzLl9kb2VzRmlsdGVyUGFzc09wdGlvbnMgPSB7XG4gICAgICBlbmFibGVUaW1lOiB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVFbmFibGVUaW1lJywgdGhpcy5fcGFyYW1zLCB0cnVlKSxcbiAgICAgIGluUmFuZ2VJbmNsdXNpdmU6IHRoaXMuZ2V0T3B0aW9uKCdpblJhbmdlSW5jbHVzaXZlJywgdGhpcy5fcGFyYW1zLCBmYWxzZSksXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICB2YWx1ZUdldHRlcjogdGhpcy5fcGFyYW1zLmhhc093blByb3BlcnR5KCdmaWx0ZXJWYWx1ZUdldHRlcicpXG4gICAgICAgID8gdGhpcy5fcGFyYW1zLmZpbHRlclZhbHVlR2V0dGVyXG4gICAgICAgIDogdGhpcy5fcGFyYW1zLnZhbHVlR2V0dGVyLFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fSm9pbkNvbmRpdGlvblBhbmVsLmRlc3Ryb3koKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgc2VsZWN0ZWQgZmlsdGVyIG1hdGNoZXMgdGhlIHBhc3NlZCBjZWxsIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICAgKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIHdoZW4gcGFzcywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBkb2VzRmlsdGVyUGFzcyhwYXJhbXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2RvZXNGaWx0ZXJQYXNzT3B0aW9ucy52YWx1ZUdldHRlcihwYXJhbXMpXG4gICAgY29uc3QgeyBjb25kaXRpb24xLCBjb25kaXRpb24yLCBvcGVyYXRvciB9ID0gdGhpcy5fc3RhdGVcbiAgICBjb25zdCBkb2VzUGFzc0ZpcnN0Q29uZGl0aW9uID0gdGhpcy5fZG9lc1Bhc3NDb25kaXRpb24oY29uZGl0aW9uMSwgdmFsdWUpXG4gICAgY29uc3QgZG9lc1Bhc3NTZWNvbmRDb25kaXRpb24gPSB0aGlzLl9kb2VzUGFzc0NvbmRpdGlvbihjb25kaXRpb24yLCB2YWx1ZSlcblxuICAgIHJldHVybiBvcGVyYXRvciA9PT0gVE9LRU5TLlRPS0VOX09SXG4gICAgICA/IGRvZXNQYXNzRmlyc3RDb25kaXRpb24gfHwgZG9lc1Bhc3NTZWNvbmRDb25kaXRpb25cbiAgICAgIDogZG9lc1Bhc3NGaXJzdENvbmRpdGlvbiAmJiBkb2VzUGFzc1NlY29uZENvbmRpdGlvblxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBpcyBhcHBseWluZyBhbnkgZmlsdGVyIG9uIHRoZSBjb2x1bW5cbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICoqL1xuICBpc0ZpbHRlckFjdGl2ZSgpIHtcbiAgICBjb25zdCB7IGNvbmRpdGlvbjEgfSA9IHRoaXMuX3N0YXRlXG5cbiAgICBpZiAoY29uZGl0aW9uMSAmJiBjb25kaXRpb24xLmZpbHRlcikge1xuICAgICAgaWYgKGNvbmRpdGlvbjEuZmlsdGVyVG8gJiYgY29uZGl0aW9uMS50eXBlID09PSBUT0tFTlMuVE9LRU5fUkFOR0UpIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbjEuZmlsdGVyICE9PSBudWxsICYmIGNvbmRpdGlvbjEuZmlsdGVyVG8gIT09IG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbmRpdGlvbjEuZmlsdGVyICE9PSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsdGVyIHN0YXRlLiBJZiBmaWx0ZXIgaXMgbm90IGFjdGl2ZSwgdGhlbiBzaG91bGQgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICAgKiBUaGUgZ3JpZCBjYWxscyBnZXRNb2RlbCgpIG9uIGFsbCBhY3RpdmUgZmlsdGVycyB3aGVuIGdyaWRBcGkuZ2V0RmlsdGVyTW9kZWwoKSBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm4gT2JqZWN0IHwgbnVsbCB0aGUgZmlsdGVyIHN0YXRlXG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICBjb25zdCBjbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5fc3RhdGUpKVxuICAgIDtbY2xvbmUuY29uZGl0aW9uMSwgY2xvbmUuY29uZGl0aW9uMl0uZm9yRWFjaCgoY29uZGl0aW9uLCBpKSA9PiB7XG4gICAgICBpZiAoY29uZGl0aW9uLmZpbHRlcikge1xuICAgICAgICBjb25kaXRpb24uZmlsdGVyID0gdGhpcy5fc3RhdGVbYGNvbmRpdGlvbiR7aSArIDF9YF0uZmlsdGVyLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICAgIGlmIChjb25kaXRpb24uZmlsdGVyVG8pIHtcbiAgICAgICAgY29uZGl0aW9uLmZpbHRlclRvID0gdGhpcy5fc3RhdGVbXG4gICAgICAgICAgYGNvbmRpdGlvbiR7aSArIDF9YFxuICAgICAgICBdLmZpbHRlclRvLnRvSVNPU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY2xvbmUuZmlsdGVyVHlwZSA9ICdkYXRldGltZSdcbiAgICBjbG9uZS5jb25kaXRpb24xLmZpbHRlclR5cGUgPSAnZGF0ZXRpbWUnXG4gICAgY2xvbmUuY29uZGl0aW9uMi5maWx0ZXJUeXBlID0gJ2RhdGV0aW1lJ1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgIHJldHVybiBjbG9uZS5oYXNPd25Qcm9wZXJ0eSgnY29uZGl0aW9uMicpICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICBjbG9uZS5jb25kaXRpb24yLmhhc093blByb3BlcnR5KCdmaWx0ZXInKSAmJlxuICAgICAgY2xvbmUuY29uZGl0aW9uMi5maWx0ZXJcbiAgICAgID8gY2xvbmVcbiAgICAgIDogY2xvbmUuY29uZGl0aW9uMVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBmaWx0ZXIgc3RhdGUuIENhbGxlZCBieSB0aGUgZ3JpZCBhZnRlciBncmlkQXBpLnNldEZpbHRlck1vZGVsKG1vZGVsKSBpcyBjYWxsZWQuXG4gICAqIFRoZSBncmlkIHdpbGwgcGFzcyB1bmRlZmluZWQvbnVsbCB0byBjbGVhciB0aGUgZmlsdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bGx9IG1vZGVsXG4gICAqL1xuICBzZXRNb2RlbChtb2RlbCkge1xuICAgIGlmIChcbiAgICAgIG1vZGVsICYmXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAhbW9kZWwuaGFzT3duUHJvcGVydHkoJ2NvbmRpdGlvbjEnKSAmJlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgIW1vZGVsLmhhc093blByb3BlcnR5KCdjb25kaXRpb24yJylcbiAgICApIHtcbiAgICAgIG1vZGVsID0ge1xuICAgICAgICBjb25kaXRpb24xOiBtb2RlbCxcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fX2Rpc2FibGVTdGF0ZUNoYW5nZUxpc3RlbmVyID0gdHJ1ZVxuICAgIHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5zZXRTdGF0ZShtb2RlbClcbiAgICB0aGlzLl9fZGlzYWJsZVN0YXRlQ2hhbmdlTGlzdGVuZXIgPSBmYWxzZVxuXG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwuc3RhdGVcbiAgICA7W3RoaXMuX3N0YXRlLmNvbmRpdGlvbjEsIHRoaXMuX3N0YXRlLmNvbmRpdGlvbjJdLmZvckVhY2goY29uZGl0aW9uID0+IHtcbiAgICAgIGlmIChjb25kaXRpb24uZmlsdGVyKSB7XG4gICAgICAgIGNvbmRpdGlvbi5maWx0ZXIgPSBuZXcgRGF0ZShjb25kaXRpb24uZmlsdGVyKVxuICAgICAgfVxuICAgICAgaWYgKGNvbmRpdGlvbi5maWx0ZXJUbykge1xuICAgICAgICBjb25kaXRpb24uZmlsdGVyVG8gPSBuZXcgRGF0ZShjb25kaXRpb24uZmlsdGVyVG8pXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbHRlciBtb2RlbCBhcyBwbGFpbiBzdHJpbmcgdG8gZGlzcGxheSBpbiB0aGUgZmxvYXRpbmcgZmlsdGVyIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgbnVsbH0gbW9kZWxcbiAgICovXG4gIGdldE1vZGVsQXNTdHJpbmcobW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBjb25zdCBkYXRlVGltZU1hc2sgPSB0aGlzLmdldE9wdGlvbihcbiAgICAgICdkYXRlVGltZU1hc2snLFxuICAgICAgdGhpcy5fcGFyYW1zLFxuICAgICAgLy8gQHRvZG8gRmluZCBhIGJldHRlciB3YXkgZm9yIHRoaXNcbiAgICAgIHRoaXMuX0pvaW5Db25kaXRpb25QYW5lbC5fZmlyc3RDb25kaXRpb25QYW5lbC5fZmlsdGVyVGltZUlucHV0LnBpY2tlclxuICAgICAgICAuY29uZmlnWydkYXRlRm9ybWF0J11cbiAgICApXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5nZXRPcHRpb24oXG4gICAgICAnZGF0ZVRpbWVMb2NhbGUnLFxuICAgICAgdGhpcy5fcGFyYW1zLFxuICAgICAgSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZSB8fCAnZW4tVVMnXG4gICAgKVxuXG4gICAgY29uc3QgeyBjb25kaXRpb24xLCBjb25kaXRpb24yLCBvcGVyYXRvciB9ID0gSlNPTi5wYXJzZShcbiAgICAgIEpTT04uc3RyaW5naWZ5KG1vZGVsKVxuICAgIClcblxuICAgIDtbY29uZGl0aW9uMSwgY29uZGl0aW9uMl0uZm9yRWFjaChjb25kaXRpb24gPT4ge1xuICAgICAgaWYgKGNvbmRpdGlvbi5maWx0ZXIpIHtcbiAgICAgICAgY29uZGl0aW9uLmZpbHRlciA9IEJCai5NYXNrcy5EYXRlTWFzay5tYXNrKFxuICAgICAgICAgIGNvbmRpdGlvbi5maWx0ZXIsXG4gICAgICAgICAgZGF0ZVRpbWVNYXNrLFxuICAgICAgICAgIGxvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25kaXRpb24uZmlsdGVyVG8pIHtcbiAgICAgICAgY29uZGl0aW9uLmZpbHRlclRvID0gQkJqLk1hc2tzLkRhdGVNYXNrLm1hc2soXG4gICAgICAgICAgY29uZGl0aW9uLmZpbHRlclRvLFxuICAgICAgICAgIGRhdGVUaW1lTWFzayxcbiAgICAgICAgICBsb2NhbGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBmaXJzdENvbmRpdGlvbkFzU3RyaW5nID0gYCR7Y29uZGl0aW9uMS5maWx0ZXIgfHwgJyd9ICR7XG4gICAgICBjb25kaXRpb24xLmZpbHRlclRvID8gJ+KGkiAnICsgY29uZGl0aW9uMS5maWx0ZXJUbyA6ICcnXG4gICAgfWBcbiAgICBjb25zdCBzZWNvbmRDb25kaXRpb25Bc1N0cmluZyA9IGAke2NvbmRpdGlvbjIuZmlsdGVyIHx8ICcnfSAke1xuICAgICAgY29uZGl0aW9uMi5maWx0ZXJUbyA/ICfihpIgJyArIGNvbmRpdGlvbjIuZmlsdGVyVG8gOiAnJ1xuICAgIH1gXG4gICAgY29uc3Qgb3BlcmF0b3JBc1N0cmluZyA9IGAke2NvbmRpdGlvbjIuZmlsdGVyICYmIG9wZXJhdG9yID8gb3BlcmF0b3IgOiAnJ31gXG5cbiAgICByZXR1cm4gYCR7Zmlyc3RDb25kaXRpb25Bc1N0cmluZ30gJHtvcGVyYXRvckFzU3RyaW5nfSAke3NlY29uZENvbmRpdGlvbkFzU3RyaW5nfWAudHJpbSgpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIHBhc3NlcyB0aGUgZmlsdGVyIGRlZmluZWQgaW4gdGhlIHBhc3NlZCBDb25kaXRpb25QYW5lbCdzIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25kaXRpb24gY29uZGl0aW9uIHBhbmVsIHN0YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBjZWxsIHZhbHVlXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBwYXNzLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIF9kb2VzUGFzc0NvbmRpdGlvbihjb25kaXRpb24sIHZhbHVlKSB7XG4gICAgaWYgKCFjb25kaXRpb24uZmlsdGVyIHx8ICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgeyBmaWx0ZXIsIGZpbHRlclRvLCB0eXBlIH0gPSBjb25kaXRpb25cbiAgICBjb25zdCB0aW1lem9uZSA9IEJCai5NYXNrcy5VdGlscy5EYXRlcy5nZXRUaW1lem9uZU9yT2Zmc2V0KClcbiAgICBjb25zdCBpblJhbmdlSW5jbHVzaXZlID0gdGhpcy5fZG9lc0ZpbHRlclBhc3NPcHRpb25zLmluUmFuZ2VJbmNsdXNpdmVcbiAgICBjb25zdCBlbmFibGVUaW1lID0gdGhpcy5fZG9lc0ZpbHRlclBhc3NPcHRpb25zLmVuYWJsZVRpbWVcbiAgICBsZXQgcGFzc2VkID0gZmFsc2VcblxuICAgIGlmIChCQmouTWFza3MuVXRpbHMuRGF0ZXMuSVNfVElNRV9SRUdFWC50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9IEJCai5NYXNrcy5VdGlscy5EYXRlcy5maXhTaG9ydElTTyh2YWx1ZSlcbiAgICAgIDtbZmlsdGVyLCBmaWx0ZXJUb10uZm9yRWFjaChkYXRlID0+IHtcbiAgICAgICAgaWYgKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcigxOTcwKVxuICAgICAgICAgIGRhdGUuc2V0TW9udGgoMClcbiAgICAgICAgICBkYXRlLnNldERhdGUoMSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKEJCai5NYXNrcy5VdGlscy5EYXRlcy5JU19EQVRFX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IEJCai5NYXNrcy5VdGlscy5EYXRlcy5maXhTaG9ydElTTyh2YWx1ZSlcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRoZSBkYXRldGltZSBmcm9tIHV0YyB0byBsb2NhbGVcbiAgICB2YWx1ZSA9IHV0Y1RvWm9uZWRUaW1lKHZhbHVlLCB0aW1lem9uZSlcbiAgICAvLyBmaXJzdERhdGUgPSBmaXJzdERhdGUgPyB6b25lZFRpbWVUb1V0YyhmaXJzdERhdGUgLCB0aW1lem9uZSkgOiBmaXJzdERhdGVcbiAgICAvLyBzZWNvbmREYXRlID0gc2Vjb25kRGF0ZSA/IHpvbmVkVGltZVRvVXRjKHNlY29uZERhdGUgLCB0aW1lem9uZSkgOiBzZWNvbmREYXRlXG5cbiAgICBpZiAoIWVuYWJsZVRpbWUpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgdGltZSBwb3J0aW9uIGZyb20gdGhlIGRhdGVcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1zZW1pXG4gICAgICA7W3ZhbHVlLCBmaWx0ZXIsIGZpbHRlclRvXS5mb3JFYWNoKGRhdGUgPT4ge1xuICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICBkYXRlLnNldEhvdXJzKDApXG4gICAgICAgICAgZGF0ZS5zZXRNaW51dGVzKDApXG4gICAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKDApXG4gICAgICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoMClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gVE9LRU5TLlRPS0VOX0VRVUFMKSB7XG4gICAgICBwYXNzZWQgPSBmaWx0ZXIgPiB2YWx1ZSA9PT0gZmFsc2UgJiYgZmlsdGVyIDwgdmFsdWUgPT0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRPS0VOUy5UT0tFTl9OT1RfRVFVQUwpIHtcbiAgICAgIHBhc3NlZCA9ICEoZmlsdGVyID4gdmFsdWUgPT09IGZhbHNlICYmIGZpbHRlciA8IHZhbHVlID09IGZhbHNlKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVE9LRU5TLlRPS0VOX0dSRUFURVIpIHtcbiAgICAgIHBhc3NlZCA9IGZpbHRlciA8IHZhbHVlXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUT0tFTlMuVE9LRU5fTEVTUykge1xuICAgICAgcGFzc2VkID0gZmlsdGVyID4gdmFsdWVcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRPS0VOUy5UT0tFTl9SQU5HRSAmJiBmaWx0ZXJUbykge1xuICAgICAgaWYgKGluUmFuZ2VJbmNsdXNpdmUpIHtcbiAgICAgICAgcGFzc2VkID1cbiAgICAgICAgICAoKGZpbHRlciA8IHZhbHVlIHx8XG4gICAgICAgICAgICAoZmlsdGVyID4gdmFsdWUgPT09IGZhbHNlICYmIGZpbHRlciA8IHZhbHVlID09IGZhbHNlKSkgJiZcbiAgICAgICAgICAgIGZpbHRlclRvID4gdmFsdWUpIHx8XG4gICAgICAgICAgKGZpbHRlclRvID4gdmFsdWUgPT09IGZhbHNlICYmIGZpbHRlclRvIDwgdmFsdWUgPT0gZmFsc2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXNzZWQgPSBmaWx0ZXIgPCB2YWx1ZSAmJiBmaWx0ZXJUbyA+IHZhbHVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhc3NlZFxuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgdG8gY2xpY2sgYnV0dG9uIGV2ZW50IG9uIHRoZSBmaWx0ZXIgcGFuZWwgYW5kIGV4ZWN1dGUgdGhlXG4gICAqIHJpZ2h0IGFjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX0FwcGx5RmlsdGVyUGFuZWxCdXR0b25DbGljayhlKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXRcblxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdCVVRUT04nKSB7XG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygncmVzZXQnKSkge1xuICAgICAgICB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwucmVzZXQoKVxuICAgICAgICB0aGlzLl9wYXJhbXMuZmlsdGVyQ2hhbmdlZENhbGxiYWNrKClcbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnY2xlYXInKSkge1xuICAgICAgICB0aGlzLl9Kb2luQ29uZGl0aW9uUGFuZWwucmVzZXQoKVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdhcHBseScpKSB7XG4gICAgICAgIHRoaXMuX3BhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZpbHRlciBzdGF0ZSBhbmQgQXBwbHkgdGhlIGZpbHRlciBkZXBlbmRpbmcgb25cbiAgICogd2hldGhlciB0aGUgYGlzQXBwbHlCdXR0b25BY3RpdmVgIGlzIHRydWUgb3IgZmFsc2VcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBcHBseUJ1dHRvbkFjdGl2ZVxuICAgKi9cbiAgQGF1dG9iaW5kXG4gIF9vbkpvaW5Db25kaXRpb25QYW5lbFN0YXRlQ2hhbmdlZChzdGF0ZSwgaXNBcHBseUJ1dHRvbkFjdGl2ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gc3RhdGVcbiAgICBpZiAoZmFsc2UgPT09IGlzQXBwbHlCdXR0b25BY3RpdmUpIHtcbiAgICAgIHRoaXMuX3BhcmFtcy5maWx0ZXJDaGFuZ2VkQ2FsbGJhY2soKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEYXRlVGltZUZpbHRlclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lRmlsdGVyL0RhdGVUaW1lRmlsdGVyLmpzIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRzXSB0b2tlbnMgb2YgdGhlIHByb3ZpZGVkXG4gKiBgZGF0ZWAgYXMgaXQgd2lsbCBiZSByZW5kZXJlZCBpbiB0aGUgYHRpbWVab25lYC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdHpUb2tlbml6ZURhdGUoZGF0ZSwgdGltZVpvbmUpIHtcbiAgdmFyIGR0ZiA9IGdldERhdGVUaW1lRm9ybWF0KHRpbWVab25lKVxuICByZXR1cm4gZHRmLmZvcm1hdFRvUGFydHMgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpIDogaGFja3lPZmZzZXQoZHRmLCBkYXRlKVxufVxuXG52YXIgdHlwZVRvUG9zID0ge1xuICB5ZWFyOiAwLFxuICBtb250aDogMSxcbiAgZGF5OiAyLFxuICBob3VyOiAzLFxuICBtaW51dGU6IDQsXG4gIHNlY29uZDogNVxufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgdmFyIGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gIHZhciBmaWxsZWQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwb3MgPSB0eXBlVG9Qb3NbZm9ybWF0dGVkW2ldLnR5cGVdXG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQoZm9ybWF0dGVkW2ldLnZhbHVlLCAxMClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZpbGxlZFxufVxuXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcbiAgdmFyIGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXQoZGF0ZSkucmVwbGFjZSgvXFx1MjAwRS9nLCAnJylcbiAgdmFyIHBhcnNlZCA9IC8oXFxkKylcXC8oXFxkKylcXC8oXFxkKyksPyAoXFxkKyk6KFxcZCspOihcXGQrKS8uZXhlYyhmb3JtYXR0ZWQpXG4gIC8vIHZhciBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWRcbiAgLy8gcmV0dXJuIFtmWWVhciwgZk1vbnRoLCBmRGF5LCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF1cbiAgcmV0dXJuIFtwYXJzZWRbM10sIHBhcnNlZFsxXSwgcGFyc2VkWzJdLCBwYXJzZWRbNF0sIHBhcnNlZFs1XSwgcGFyc2VkWzZdXVxufVxuXG4vLyBHZXQgYSBjYWNoZWQgSW50bC5EYXRlVGltZUZvcm1hdCBpbnN0YW5jZSBmb3IgdGhlIElBTkEgYHRpbWVab25lYC4gVGhpcyBjYW4gYmUgdXNlZFxuLy8gdG8gZ2V0IGRldGVybWluaXN0aWMgbG9jYWwgZGF0ZS90aW1lIG91dHB1dCBhY2NvcmRpbmcgdG8gdGhlIGBlbi1VU2AgbG9jYWxlIHdoaWNoXG4vLyBjYW4gYmUgdXNlZCB0byBleHRyYWN0IGxvY2FsIHRpbWUgcGFydHMgYXMgbmVjZXNzYXJ5LlxudmFyIGR0ZkNhY2hlID0ge31cbmZ1bmN0aW9uIGdldERhdGVUaW1lRm9ybWF0KHRpbWVab25lKSB7XG4gIGlmICghZHRmQ2FjaGVbdGltZVpvbmVdKSB7XG4gICAgLy8gTmV3IGJyb3dzZXJzIHVzZSBgaG91ckN5Y2xlYCwgSUUgYW5kIENocm9tZSA8NzMgZG9lcyBub3Qgc3VwcG9ydCBpdCBhbmQgdXNlcyBgaG91cjEyYFxuICAgIHZhciB0ZXN0RGF0ZUZvcm1hdHRlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgICAgeWVhcjogJ251bWVyaWMnLFxuICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcbiAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xuICAgIH0pLmZvcm1hdChuZXcgRGF0ZSgnMjAxNC0wNi0yNVQwNDowMDowMC4xMjNaJykpXG4gICAgdmFyIGhvdXJDeWNsZVN1cHBvcnRlZCA9XG4gICAgICB0ZXN0RGF0ZUZvcm1hdHRlZCA9PT0gJzA2LzI1LzIwMTQsIDAwOjAwOjAwJyB8fFxuICAgICAgdGVzdERhdGVGb3JtYXR0ZWQgPT09ICfigI4wNuKAji/igI4yNeKAji/igI4yMDE04oCOIOKAjjAw4oCOOuKAjjAw4oCOOuKAjjAwJ1xuXG4gICAgZHRmQ2FjaGVbdGltZVpvbmVdID0gaG91ckN5Y2xlU3VwcG9ydGVkXG4gICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHtcbiAgICAgICAgICBob3VyMTI6IGZhbHNlLFxuICAgICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcbiAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXG4gICAgICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBkYXk6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBob3VyOiAnMi1kaWdpdCcsXG4gICAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgICAgICAgc2Vjb25kOiAnMi1kaWdpdCdcbiAgICAgICAgfSlcbiAgICAgIDogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoJ2VuLVVTJywge1xuICAgICAgICAgIGhvdXJDeWNsZTogJ2gyMycsXG4gICAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxuICAgICAgICAgIHllYXI6ICdudW1lcmljJyxcbiAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxuICAgICAgICAgIGRheTogJzItZGlnaXQnLFxuICAgICAgICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xuICAgICAgICB9KVxuICB9XG4gIHJldHVybiBkdGZDYWNoZVt0aW1lWm9uZV1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9kYXRlLWZucy10ei9lc20vX2xpYi90elRva2VuaXplRGF0ZS9pbmRleC5qcyIsImltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanMnO1xuaW1wb3J0IGFkZE1pbGxpc2Vjb25kcyBmcm9tICcuLi9hZGRNaWxsaXNlY29uZHMvaW5kZXguanMnO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tICcuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qcyc7XG4vKipcbiAqIEBuYW1lIHN1Yk1pbGxpc2Vjb25kc1xuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3VidHJhY3QgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZyb20gdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogIyMjIHYyLjAuMCBicmVha2luZyBjaGFuZ2VzOlxuICpcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIHN1YnRyYWN0ZWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3VidHJhY3QgNzUwIG1pbGxpc2Vjb25kcyBmcm9tIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiB2YXIgcmVzdWx0ID0gc3ViTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MjkuMjUwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ViTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuICByZXR1cm4gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgLWFtb3VudCk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdWJNaWxsaXNlY29uZHMvaW5kZXguanMiLCJpbXBvcnQgdG9JbnRlZ2VyIGZyb20gJy4uL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzJztcbmltcG9ydCB0b0RhdGUgZnJvbSAnLi4vdG9EYXRlL2luZGV4LmpzJztcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSAnLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMnO1xuLyoqXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcbiAqIEBjYXRlZ29yeSBNaWxsaXNlY29uZCBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBZGQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XG4gKlxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBiZSBjaGFuZ2VkXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgYWRkZWQuIFBvc2l0aXZlIGRlY2ltYWxzIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5mbG9vcmAsIGRlY2ltYWxzIGxlc3MgdGhhbiB6ZXJvIHdpbGwgYmUgcm91bmRlZCB1c2luZyBgTWF0aC5jZWlsYC5cbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgbWlsbGlzZWNvbmRzIGFkZGVkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFkZCA3NTAgbWlsbGlzZWNvbmRzIHRvIDEwIEp1bHkgMjAxNCAxMjo0NTozMC4wMDA6XG4gKiB2YXIgcmVzdWx0ID0gYWRkTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxuICogLy89PiBUaHUgSnVsIDEwIDIwMTQgMTI6NDU6MzAuNzUwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSwgZGlydHlBbW91bnQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciB0aW1lc3RhbXAgPSB0b0RhdGUoZGlydHlEYXRlKS5nZXRUaW1lKCk7XG4gIHZhciBhbW91bnQgPSB0b0ludGVnZXIoZGlydHlBbW91bnQpO1xuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgYW1vdW50KTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2FkZE1pbGxpc2Vjb25kcy9pbmRleC5qcyIsImltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSAnLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanMnO1xuLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCB0aGUgdGltZXN0YW1wIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50KSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgYXJnU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KTsgLy8gQ2xvbmUgdGhlIGRhdGVcblxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgYXJnU3RyID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAvLyBQcmV2ZW50IHRoZSBkYXRlIHRvIGxvc2UgdGhlIG1pbGxpc2Vjb25kcyB3aGVuIHBhc3NlZCB0byBuZXcgRGF0ZSgpIGluIElFMTBcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGlmICgodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IFN0cmluZ10nKSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXCJTdGFydGluZyB3aXRoIHYyLjAuMC1iZXRhLjEgZGF0ZS1mbnMgZG9lc24ndCBhY2NlcHQgc3RyaW5ncyBhcyBkYXRlIGFyZ3VtZW50cy4gUGxlYXNlIHVzZSBgcGFyc2VJU09gIHRvIHBhcnNlIHN0cmluZ3MuIFNlZTogaHR0cHM6Ly9naXQuaW8vZmp1bGVcIik7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qcyIsImltcG9ydCB0b0ludGVnZXIgZnJvbSAnZGF0ZS1mbnMvZXNtL19saWIvdG9JbnRlZ2VyL2luZGV4LmpzJ1xuaW1wb3J0IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMgZnJvbSAnZGF0ZS1mbnMvZXNtL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy9pbmRleC5qcydcbmltcG9ydCB0elBhcnNlVGltZXpvbmUgZnJvbSAnLi4vX2xpYi90elBhcnNlVGltZXpvbmUnXG5cbnZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiA9IDM2MDAwMDBcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDBcbnZhciBERUZBVUxUX0FERElUSU9OQUxfRElHSVRTID0gMlxuXG52YXIgcGF0dGVybnMgPSB7XG4gIGRhdGVUaW1lRGVsaW1ldGVyOiAvW1QgXS8sXG4gIHBsYWluVGltZTogLzovLFxuICB0aW1lWm9uZURlbGltZXRlcjogL1taIF0vaSxcblxuICAvLyB5ZWFyIHRva2Vuc1xuICBZWTogL14oXFxkezJ9KSQvLFxuICBZWVk6IFtcbiAgICAvXihbKy1dXFxkezJ9KSQvLCAvLyAwIGFkZGl0aW9uYWwgZGlnaXRzXG4gICAgL14oWystXVxcZHszfSkkLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs0fSkkLyAvLyAyIGFkZGl0aW9uYWwgZGlnaXRzXG4gIF0sXG4gIFlZWVk6IC9eKFxcZHs0fSkvLFxuICBZWVlZWTogW1xuICAgIC9eKFsrLV1cXGR7NH0pLywgLy8gMCBhZGRpdGlvbmFsIGRpZ2l0c1xuICAgIC9eKFsrLV1cXGR7NX0pLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XG4gICAgL14oWystXVxcZHs2fSkvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcbiAgXSxcblxuICAvLyBkYXRlIHRva2Vuc1xuICBNTTogL14tKFxcZHsyfSkkLyxcbiAgREREOiAvXi0/KFxcZHszfSkkLyxcbiAgTU1ERDogL14tPyhcXGR7Mn0pLT8oXFxkezJ9KSQvLFxuICBXd3c6IC9eLT9XKFxcZHsyfSkkLyxcbiAgV3d3RDogL14tP1coXFxkezJ9KS0/KFxcZHsxfSkkLyxcblxuICBISDogL14oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXG4gIEhITU06IC9eKFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkLyxcbiAgSEhNTVNTOiAvXihcXGR7Mn0pOj8oXFxkezJ9KTo/KFxcZHsyfShbLixdXFxkKik/KSQvLFxuXG4gIC8vIHRpbWV6b25lIHRva2VucyAodG8gaWRlbnRpZnkgdGhlIHByZXNlbmNlIG9mIGEgdHopXG4gIHRpbWV6b25lOiAvKFtaKy1dLip8IFVUQ3woPzpbYS16QS1aXStcXC9bYS16QS1aX10rKD86XFwvW2EtekEtWl9dKyk/KSkkL1xufVxuXG4vKipcbiAqIEBuYW1lIHRvRGF0ZVxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXG4gKiBAc3VtbWFyeSBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBJZiBhbiBhcmd1bWVudCBpcyBhIHN0cmluZywgdGhlIGZ1bmN0aW9uIHRyaWVzIHRvIHBhcnNlIGl0LlxuICogRnVuY3Rpb24gYWNjZXB0cyBjb21wbGV0ZSBJU08gODYwMSBmb3JtYXRzIGFzIHdlbGwgYXMgcGFydGlhbCBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJU08gODYwMTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxuICogSWYgdGhlIGZ1bmN0aW9uIGNhbm5vdCBwYXJzZSB0aGUgc3RyaW5nIG9yIHRoZSB2YWx1ZXMgYXJlIGludmFsaWQsIGl0IHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxuICpcbiAqICoqTm90ZSoqOiAqYWxsKiBEYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYW55ICpkYXRlLWZucyogZnVuY3Rpb24gaXMgcHJvY2Vzc2VkIGJ5IGB0b0RhdGVgLlxuICogQWxsICpkYXRlLWZucyogZnVuY3Rpb25zIHdpbGwgdGhyb3cgYFJhbmdlRXJyb3JgIGlmIGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIGlzIG5vdCAwLCAxLCAyIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHBhcmFtIHtPcHRpb25zV2l0aFRafSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1lWm9uZT0nJ10gLSB1c2VkIHRvIHNwZWNpZnkgdGhlIElBTkEgdGltZSB6b25lIG9mZnNldCBvZiBhIGRhdGUgU3RyaW5nLlxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIG11c3QgYmUgMCwgMSBvciAyXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcyMDE0LTAyLTExVDExOjMwOjMwJyB0byBkYXRlOlxuICogdmFyIHJlc3VsdCA9IHRvRGF0ZSgnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxuICogLy8gaWYgdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXQgaXMgMTpcbiAqIHZhciByZXN1bHQgPSB0b0RhdGUoJyswMjAxNDEwMScsIHthZGRpdGlvbmFsRGlnaXRzOiAxfSlcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCwgZGlydHlPcHRpb25zKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnXG4gICAgKVxuICB9XG5cbiAgaWYgKGFyZ3VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gZGlydHlPcHRpb25zIHx8IHt9XG5cbiAgdmFyIGFkZGl0aW9uYWxEaWdpdHMgPVxuICAgIG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cyA9PSBudWxsXG4gICAgICA/IERFRkFVTFRfQURESVRJT05BTF9ESUdJVFNcbiAgICAgIDogdG9JbnRlZ2VyKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cylcbiAgaWYgKFxuICAgIGFkZGl0aW9uYWxEaWdpdHMgIT09IDIgJiZcbiAgICBhZGRpdGlvbmFsRGlnaXRzICE9PSAxICYmXG4gICAgYWRkaXRpb25hbERpZ2l0cyAhPT0gMFxuICApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYWRkaXRpb25hbERpZ2l0cyBtdXN0IGJlIDAsIDEgb3IgMicpXG4gIH1cblxuICAvLyBDbG9uZSB0aGUgZGF0ZVxuICBpZiAoXG4gICAgYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IERhdGVdJylcbiAgKSB7XG4gICAgLy8gUHJldmVudCB0aGUgZGF0ZSB0byBsb3NlIHRoZSBtaWxsaXNlY29uZHMgd2hlbiBwYXNzZWQgdG8gbmV3IERhdGUoKSBpbiBJRTEwXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50LmdldFRpbWUoKSlcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8XG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KVxuICB9IGVsc2UgaWYgKFxuICAgICEoXG4gICAgICB0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBTdHJpbmddJ1xuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIHZhciBkYXRlU3RyaW5ncyA9IHNwbGl0RGF0ZVN0cmluZyhhcmd1bWVudClcblxuICB2YXIgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpXG4gIHZhciB5ZWFyID0gcGFyc2VZZWFyUmVzdWx0LnllYXJcbiAgdmFyIHJlc3REYXRlU3RyaW5nID0gcGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nXG5cbiAgdmFyIGRhdGUgPSBwYXJzZURhdGUocmVzdERhdGVTdHJpbmcsIHllYXIpXG5cbiAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxuXG4gIGlmIChkYXRlKSB7XG4gICAgdmFyIHRpbWVzdGFtcCA9IGRhdGUuZ2V0VGltZSgpXG4gICAgdmFyIHRpbWUgPSAwXG4gICAgdmFyIG9mZnNldFxuXG4gICAgaWYgKGRhdGVTdHJpbmdzLnRpbWUpIHtcbiAgICAgIHRpbWUgPSBwYXJzZVRpbWUoZGF0ZVN0cmluZ3MudGltZSlcblxuICAgICAgaWYgKGlzTmFOKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGVTdHJpbmdzLnRpbWV6b25lIHx8IG9wdGlvbnMudGltZVpvbmUpIHtcbiAgICAgIG9mZnNldCA9IHR6UGFyc2VUaW1lem9uZShcbiAgICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgfHwgb3B0aW9ucy50aW1lWm9uZSxcbiAgICAgICAgbmV3IERhdGUodGltZXN0YW1wICsgdGltZSlcbiAgICAgIClcbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgICB9XG4gICAgICBvZmZzZXQgPSB0elBhcnNlVGltZXpvbmUoXG4gICAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lIHx8IG9wdGlvbnMudGltZVpvbmUsXG4gICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXG4gICAgICApXG4gICAgICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgb2Zmc2V0IGFjY3VyYXRlIHRvIGhvdXIgaW4gdGltZXpvbmVzIHRoYXQgY2hhbmdlIG9mZnNldFxuICAgICAgb2Zmc2V0ID0gZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcyhuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKSlcbiAgICAgIG9mZnNldCA9IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHMoXG4gICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdERhdGVTdHJpbmcoZGF0ZVN0cmluZykge1xuICB2YXIgZGF0ZVN0cmluZ3MgPSB7fVxuICB2YXIgYXJyYXkgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLmRhdGVUaW1lRGVsaW1ldGVyKVxuICB2YXIgdGltZVN0cmluZ1xuXG4gIGlmIChwYXR0ZXJucy5wbGFpblRpbWUudGVzdChhcnJheVswXSkpIHtcbiAgICBkYXRlU3RyaW5ncy5kYXRlID0gbnVsbFxuICAgIHRpbWVTdHJpbmcgPSBhcnJheVswXVxuICB9IGVsc2Uge1xuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBhcnJheVswXVxuICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXVxuICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gYXJyYXlbMl1cbiAgICBpZiAocGF0dGVybnMudGltZVpvbmVEZWxpbWV0ZXIudGVzdChkYXRlU3RyaW5ncy5kYXRlKSkge1xuICAgICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMudGltZVpvbmVEZWxpbWV0ZXIpWzBdXG4gICAgICB0aW1lU3RyaW5nID0gZGF0ZVN0cmluZy5zdWJzdHIoZGF0ZVN0cmluZ3MuZGF0ZS5sZW5ndGgsIGRhdGVTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aW1lU3RyaW5nKSB7XG4gICAgdmFyIHRva2VuID0gcGF0dGVybnMudGltZXpvbmUuZXhlYyh0aW1lU3RyaW5nKVxuICAgIGlmICh0b2tlbikge1xuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmcucmVwbGFjZSh0b2tlblsxXSwgJycpXG4gICAgICBkYXRlU3RyaW5ncy50aW1lem9uZSA9IHRva2VuWzFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGVTdHJpbmdzXG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkYXRlU3RyaW5nLCBhZGRpdGlvbmFsRGlnaXRzKSB7XG4gIHZhciBwYXR0ZXJuWVlZID0gcGF0dGVybnMuWVlZW2FkZGl0aW9uYWxEaWdpdHNdXG4gIHZhciBwYXR0ZXJuWVlZWVkgPSBwYXR0ZXJucy5ZWVlZWVthZGRpdGlvbmFsRGlnaXRzXVxuXG4gIHZhciB0b2tlblxuXG4gIC8vIFlZWVkgb3IgwrFZWVlZWVxuICB0b2tlbiA9IHBhdHRlcm5zLllZWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZWVkuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB2YXIgeWVhclN0cmluZyA9IHRva2VuWzFdXG4gICAgcmV0dXJuIHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHllYXJTdHJpbmcsIDEwKSxcbiAgICAgIHJlc3REYXRlU3RyaW5nOiBkYXRlU3RyaW5nLnNsaWNlKHllYXJTdHJpbmcubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFlZIG9yIMKxWVlZXG4gIHRva2VuID0gcGF0dGVybnMuWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZLmV4ZWMoZGF0ZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgdmFyIGNlbnR1cnlTdHJpbmcgPSB0b2tlblsxXVxuICAgIHJldHVybiB7XG4gICAgICB5ZWFyOiBwYXJzZUludChjZW50dXJ5U3RyaW5nLCAxMCkgKiAxMDAsXG4gICAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZShjZW50dXJ5U3RyaW5nLmxlbmd0aClcbiAgICB9XG4gIH1cblxuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICByZXR1cm4ge1xuICAgIHllYXI6IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZywgeWVhcikge1xuICAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuICBpZiAoeWVhciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YXIgdG9rZW5cbiAgdmFyIGRhdGVcbiAgdmFyIG1vbnRoXG4gIHZhciB3ZWVrXG5cbiAgLy8gWVlZWVxuICBpZiAoZGF0ZVN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICBkYXRlID0gbmV3IERhdGUoMClcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktTU1cbiAgdG9rZW4gPSBwYXR0ZXJucy5NTS5leGVjKGRhdGVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxuICAgIG1vbnRoID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcblxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoKVxuICAgIHJldHVybiBkYXRlXG4gIH1cblxuICAvLyBZWVlZLURERCBvciBZWVlZREREXG4gIHRva2VuID0gcGF0dGVybnMuRERELmV4ZWMoZGF0ZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXG4gICAgdmFyIGRheU9mWWVhciA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcblxuICAgIGlmICghdmFsaWRhdGVEYXlPZlllYXJEYXRlKHllYXIsIGRheU9mWWVhcikpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXG4gICAgfVxuXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCAwLCBkYXlPZlllYXIpXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIHl5eXktTU0tZGQgb3IgWVlZWU1NRERcbiAgdG9rZW4gPSBwYXR0ZXJucy5NTURELmV4ZWMoZGF0ZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxuICAgIHZhciBkYXkgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXG5cbiAgICBpZiAoIXZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXkpXG4gICAgcmV0dXJuIGRhdGVcbiAgfVxuXG4gIC8vIFlZWVktV3d3IG9yIFlZWVlXd3dcbiAgdG9rZW4gPSBwYXR0ZXJucy5Xd3cuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcblxuICAgIGlmICghdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5T2ZJU09XZWVrWWVhcih5ZWFyLCB3ZWVrKVxuICB9XG5cbiAgLy8gWVlZWS1Xd3ctRCBvciBZWVlZV3d3RFxuICB0b2tlbiA9IHBhdHRlcm5zLld3d0QuZXhlYyhkYXRlU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICB3ZWVrID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKSAtIDFcbiAgICB2YXIgZGF5T2ZXZWVrID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKSAtIDFcblxuICAgIGlmICghdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrLCBkYXlPZldlZWspKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxuICAgIH1cblxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWssIGRheU9mV2VlaylcbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBkYXRlXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0aW1lU3RyaW5nKSB7XG4gIHZhciB0b2tlblxuICB2YXIgaG91cnNcbiAgdmFyIG1pbnV0ZXNcblxuICAvLyBoaFxuICB0b2tlbiA9IHBhdHRlcm5zLkhILmV4ZWModGltZVN0cmluZylcbiAgaWYgKHRva2VuKSB7XG4gICAgaG91cnMgPSBwYXJzZUZsb2F0KHRva2VuWzFdLnJlcGxhY2UoJywnLCAnLicpKVxuXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMpKSB7XG4gICAgICByZXR1cm4gTmFOXG4gICAgfVxuXG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSXG4gIH1cblxuICAvLyBoaDptbSBvciBoaG1tXG4gIHRva2VuID0gcGF0dGVybnMuSEhNTS5leGVjKHRpbWVTdHJpbmcpXG4gIGlmICh0b2tlbikge1xuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKVxuICAgIG1pbnV0ZXMgPSBwYXJzZUZsb2F0KHRva2VuWzJdLnJlcGxhY2UoJywnLCAnLicpKVxuXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMpKSB7XG4gICAgICByZXR1cm4gTmFOXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSICsgbWludXRlcyAqIE1JTExJU0VDT05EU19JTl9NSU5VVEVcbiAgICApXG4gIH1cblxuICAvLyBoaDptbTpzcyBvciBoaG1tc3NcbiAgdG9rZW4gPSBwYXR0ZXJucy5ISE1NU1MuZXhlYyh0aW1lU3RyaW5nKVxuICBpZiAodG9rZW4pIHtcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcbiAgICBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKVxuICAgIHZhciBzZWNvbmRzID0gcGFyc2VGbG9hdCh0b2tlblszXS5yZXBsYWNlKCcsJywgJy4nKSlcblxuICAgIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKSkge1xuICAgICAgcmV0dXJuIE5hTlxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXG4gICAgICBtaW51dGVzICogTUlMTElTRUNPTkRTX0lOX01JTlVURSArXG4gICAgICBzZWNvbmRzICogMTAwMFxuICAgIClcbiAgfVxuXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB0aW1lXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIGRheU9mSVNPV2Vla1llYXIoaXNvV2Vla1llYXIsIHdlZWssIGRheSkge1xuICB3ZWVrID0gd2VlayB8fCAwXG4gIGRheSA9IGRheSB8fCAwXG4gIHZhciBkYXRlID0gbmV3IERhdGUoMClcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29XZWVrWWVhciwgMCwgNClcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgN1xuICB2YXIgZGlmZiA9IHdlZWsgKiA3ICsgZGF5ICsgMSAtIGZvdXJ0aE9mSmFudWFyeURheVxuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKVxuICByZXR1cm4gZGF0ZVxufVxuXG4vLyBWYWxpZGF0aW9uIGZ1bmN0aW9uc1xuXG52YXIgREFZU19JTl9NT05USCA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxudmFyIERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXJJbmRleCh5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8ICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgaWYgKG1vbnRoIDwgMCB8fCBtb250aCA+IDExKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGF0ZSAhPSBudWxsKSB7XG4gICAgaWYgKGRhdGUgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKVxuICAgIGlmIChpc0xlYXBZZWFyICYmIGRhdGUgPiBEQVlTX0lOX01PTlRIX0xFQVBfWUVBUlttb250aF0pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIWlzTGVhcFllYXIgJiYgZGF0ZSA+IERBWVNfSU5fTU9OVEhbbW9udGhdKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSB7XG4gIGlmIChkYXlPZlllYXIgPCAxKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKVxuICBpZiAoaXNMZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjYpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoIWlzTGVhcFllYXIgJiYgZGF5T2ZZZWFyID4gMzY1KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWssIGRheSkge1xuICBpZiAod2VlayA8IDAgfHwgd2VlayA+IDUyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAoZGF5ICE9IG51bGwgJiYgKGRheSA8IDAgfHwgZGF5ID4gNikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICBpZiAoaG91cnMgIT0gbnVsbCAmJiAoaG91cnMgPCAwIHx8IGhvdXJzID49IDI1KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1pbnV0ZXMgIT0gbnVsbCAmJiAobWludXRlcyA8IDAgfHwgbWludXRlcyA+PSA2MCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGlmIChzZWNvbmRzICE9IG51bGwgJiYgKHNlY29uZHMgPCAwIHx8IHNlY29uZHMgPj0gNjApKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zLXR6L2VzbS90b0RhdGUvaW5kZXguanMiLCJ2YXIgTUlMTElTRUNPTkRTX0lOX01JTlVURSA9IDYwMDAwO1xuXG5mdW5jdGlvbiBnZXREYXRlTWlsbGlzZWNvbmRzUGFydChkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFRpbWUoKSAlIE1JTExJU0VDT05EU19JTl9NSU5VVEU7XG59XG4vKipcbiAqIEdvb2dsZSBDaHJvbWUgYXMgb2YgNjcuMC4zMzk2Ljg3IGludHJvZHVjZWQgdGltZXpvbmVzIHdpdGggb2Zmc2V0IHRoYXQgaW5jbHVkZXMgc2Vjb25kcy5cbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXG4gKiAoZS5nLiBmb3IgJ0V1cm9wZS9QcmFndWUnIHRpbWV6b25lIHRoZSBvZmZzZXQgaXMgR01UKzAwOjU3OjQ0IGJlZm9yZSAxIE9jdG9iZXIgMTg5MVxuICogYW5kIEdNVCswMTowMDowMCBhZnRlciB0aGF0IGRhdGUpXG4gKlxuICogRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIHRoZSBvZmZzZXQgaW4gbWludXRlcyBhbmQgd291bGQgcmV0dXJuIDU3IGZvciB0aGUgZXhhbXBsZSBhYm92ZSxcbiAqIHdoaWNoIHdvdWxkIGxlYWQgdG8gaW5jb3JyZWN0IGNhbGN1bGF0aW9ucy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHRpbWV6b25lIG9mZnNldCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0YWtlcyBzZWNvbmRzIGluIGFjY291bnQuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRpcnR5RGF0ZS5nZXRUaW1lKCkpO1xuICB2YXIgYmFzZVRpbWV6b25lT2Zmc2V0ID0gTWF0aC5jZWlsKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcbiAgdmFyIGhhc05lZ2F0aXZlVVRDT2Zmc2V0ID0gYmFzZVRpbWV6b25lT2Zmc2V0ID4gMDtcbiAgdmFyIG1pbGxpc2Vjb25kc1BhcnRPZlRpbWV6b25lT2Zmc2V0ID0gaGFzTmVnYXRpdmVVVENPZmZzZXQgPyAoTUlMTElTRUNPTkRTX0lOX01JTlVURSArIGdldERhdGVNaWxsaXNlY29uZHNQYXJ0KGRhdGUpKSAlIE1JTExJU0VDT05EU19JTl9NSU5VVEUgOiBnZXREYXRlTWlsbGlzZWNvbmRzUGFydChkYXRlKTtcbiAgcmV0dXJuIGJhc2VUaW1lem9uZU9mZnNldCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUgKyBtaWxsaXNlY29uZHNQYXJ0T2ZUaW1lem9uZU9mZnNldDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kcy9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuXG4vKipcbiAqIEV2ZW50cyBNaXhpblxuICpcbiAqIEFsbG93IGNsYXNzZXMgdG8gaGF2ZSB0aGVpciBvd24gZXZlbnRzIG1hbmFnZXJcbiAqXG4gKiBAcGFyYW0ge0NsYXNzfSBzdXBlckNsYXNzXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuY29uc3QgRXZlbnRzTWl4aW4gPSBzdXBlckNsYXNzID0+XG4gIGNsYXNzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHJlZ2lzdGVycyBoYW5kbGVyc1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBfX2hhbmRsZXJzID0ge31cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9faGFuZGxlcnNbbmFtZV0gPSB0aGlzLl9faGFuZGxlcnNbbmFtZV0gfHwgW11cbiAgICAgIHRoaXMuX19oYW5kbGVyc1tuYW1lXS5wdXNoKGhhbmRsZXIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAgICAgKlxuICAgICAqICoqTm90ZSA6KiogaWYgaGFuZGxlciBpcyBub3QgcHJvdmlkZWQgdGhlbiBhbGwgcmVnaXN0ZXJlZCBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQgd2lsbCBiZSByZW1vdmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBoYW5kbGVyIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb2ZmKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX19oYW5kbGVyc1tuYW1lXSA9IHRoaXMuX19oYW5kbGVyc1tuYW1lXSB8fCBbXVxuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9faGFuZGxlcnNbbmFtZV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVnaXN0ZXJlZEhhbmRsZXIgaW4gdGhpcy5fX2hhbmRsZXJzKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fX2hhbmRsZXJzLmhhc093blByb3BlcnR5KHJlZ2lzdGVyZWRIYW5kbGVyKSAmJlxuICAgICAgICAgICAgdGhpcy5fX2hhbmRsZXJzW3JlZ2lzdGVyZWRIYW5kbGVyXSA9PT0gaGFuZGxlclxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX19oYW5kbGVyc1tuYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBoYW5kbGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBwYXlsb2FkXG4gICAgICovXG4gICAgbm90aWZ5KG5hbWUsIHBheWxvYWQpIHtcbiAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fX2hhbmRsZXJzW25hbWVdIHx8IFtdXG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgICAgICBoYW5kbGVyKHBheWxvYWQpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4vKipcbiAqIEFuIGV2ZW50cyBtaXhpbiBkZWNvcmF0b3JcbiAqXG4gKiBAcGFyYW0ge0NsYXNzfSBzdXBlckNsYXNzXG4gKlxuICogQHNlZSB7RXZlbnRzTWl4aW59XG4gKi9cbmZ1bmN0aW9uIHdpdGhFdmVudHNNaXhpbihzdXBlckNsYXNzKSB7XG4gIHJldHVybiBFdmVudHNNaXhpbihzdXBlckNsYXNzKVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudHNNaXhpblxuZXhwb3J0IHsgRXZlbnRzTWl4aW4sIHdpdGhFdmVudHNNaXhpbiB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvRXZlbnRzTWl4aW4vRXZlbnRzTWl4aW4uanMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgeyBhdXRvYmluZCwgb3ZlcnJpZGUsIHJlYWRvbmx5IH0gZnJvbSAnY29yZS1kZWNvcmF0b3JzJ1xuaW1wb3J0IHsgd2l0aEV2ZW50c01peGluIH0gZnJvbSAnLi4vRXZlbnRzTWl4aW4nXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcbmltcG9ydCAnLi9zdHlsZS5zY3NzJ1xuXG4vKipcbiAqIERhdGVUaW1lSW5wdXRcbiAqXG4gKiBTaW1wbGUgRGF0ZVRpbWVJbnB1dCBjb21wb25lbnQgd2hpY2ggaW50ZWdyYXRlcyB0aGUgZmxhdHBpY2tyXG4gKlxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cbiAqL1xuQHdpdGhFdmVudHNNaXhpblxuY2xhc3MgRGF0ZVRpbWVJbnB1dCBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdGFudCB3aGljaCBkZXNjcmliZXMgdGhlIGV2ZW50IG5hbWUgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYSBkYXRlXG4gICAqIGlzIHNlbGVjdGVkIHVzaW5nIHRoZSBkYXRlIHBpY2tlclxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgQHJlYWRvbmx5XG4gIHN0YXRpYyBPTl9EQVRFX0NIQU5HRUQgPSAnRGF0ZVRpbWVJbnB1dC5PTl9EQVRFX0NIQU5HRUQnXG5cbiAgLyoqXG4gICAqIFRoZSBkYXRlIHBpY2tlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAdHlwZSB7RmxhdHBpY2tyRm59XG4gICAqL1xuICBwaWNrZXIgPSBudWxsXG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IHNlbGVjdGVkIGRhdGVcbiAgICpcbiAgICogQHR5cGUge0RhdGV8bnVsbH1cbiAgICovXG4gIHNlbGVjdGVkRGF0ZSA9IG51bGxcblxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCByZWNlaXZlZCBwYXJhbXMgd2hlbiBpbml0IGlzIGNhbGxlZFxuICAgKnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIF9wYXJhbXMgPSB7fVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgbmV3IERhdGVUaW1lSW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0VkaXRvciB3aGVuIHRydWUgLCB0aGUgaW5wdXQgd2lsbCBzdHlsZWQgdG8gZml0IGFzIGEgY2VsbCBlZGl0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzRWRpdG9yID0gZmFsc2UpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLl9ndWkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnYWctY2VsbC1lZGl0LXdyYXBwZXInXG4gICAgdGhpcy5fZ3VpLmlubmVySFRNTCA9IC8qIGh0bWwgKi8gYFxuICAgIDxkaXYgY2xhc3M9XCJhZy1jZWxsLWVkaXRvciBhZy1sYWJlbGVkIGFnLWxhYmVsLWFsaWduLWxlZnQgYWctdGV4dC1maWVsZCBhZy1pbnB1dC1maWVsZFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImRhdGV0aW1lX19pbnB1dCAke1xuICAgICAgICBpc0VkaXRvciA/ICdkYXRldGltZV9faW5wdXQtLWVkaXRvciAnIDogJydcbiAgICAgIH0gYWctd3JhcHBlciBhZy1pbnB1dC13cmFwcGVyIGFnLXRleHQtZmllbGQtaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImRhdGV0aW1lX19pbnB1dF9faW5wdXQgJHtcbiAgICAgICAgICAgIGlzRWRpdG9yID8gJ2FnLWNlbGwtZWRpdC1pbnB1dCAnIDogJydcbiAgICAgICAgICB9IGFnLWlucHV0LWZpZWxkLWlucHV0IGFnLXRleHQtZmllbGQtaW5wdXRcIiB0eXBlPVwidGV4dFwiIGRhdGEtaW5wdXQ+XG4gICAgICAgICAgPGEgY2xhc3M9XCJkYXRldGltZV9faW5wdXRfX2NsZWFyXCIgZGF0YS1jbGVhcj5cbiAgICAgICAgICAgIDxpIGNsYXNzPVwiZGF0ZXRpbWVfX2lucHV0X19jbGVhcl9faWNvbiBhZy1pY29uIGFnLWljb24tY3Jvc3NcIj48L2k+XG4gICAgICAgICAgPC9hPiAgICBcbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIGBcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBpbml0KHBhcmFtcykge1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtc1xuICAgIGNvbnN0IGVuYWJsZVRpbWUgPSB0aGlzLmdldE9wdGlvbignZGF0ZVRpbWVFbmFibGVUaW1lJywgcGFyYW1zLCB0cnVlKVxuICAgIGNvbnN0IHRpbWVfMjRociA9IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZUVuYWJsZTI0SFInLCBwYXJhbXMsIHRydWUpXG4gICAgY29uc3QgZW5hYmxlU2Vjb25kcyA9IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZUVuYWJsZVNlY29uZHMnLCBwYXJhbXMsIGZhbHNlKVxuICAgIGNvbnN0IG5vQ2FsZW5kYXIgPSAhdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRW5hYmxlQ2FsZW5kYXInLCBwYXJhbXMsIHRydWUpXG5cbiAgICBsZXQgZGF0ZUZvcm1hdCA9IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZU1hc2snLCBwYXJhbXMpXG5cbiAgICAvLyB0cnkgdG8gZ2VuZXJhdGUgYSBkZWZhdWx0IGRhdGUgZm9ybWF0IGJhc2VkIG9uIHRoZSBvcHRpb25zXG4gICAgaWYgKCFkYXRlRm9ybWF0KSB7XG4gICAgICBkYXRlRm9ybWF0ID0gbm9DYWxlbmRhciA/ICcnIDogJyVZLyVNei8lRHonXG4gICAgICBpZiAoZW5hYmxlVGltZSkge1xuICAgICAgICBkYXRlRm9ybWF0ICs9IHRpbWVfMjRociA/ICcgJUh6OiVteicgOiAnICVoejolbXonXG5cbiAgICAgICAgaWYgKGVuYWJsZVNlY29uZHMpIHtcbiAgICAgICAgICBkYXRlRm9ybWF0ICs9ICc6JXN6J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0ZUZvcm1hdCA9IGRhdGVGb3JtYXQudHJpbSgpXG5cbiAgICAvLyBpbml0IHRoZSBkYXRlIHBpY2tlclxuICAgIHRoaXMucGlja2VyID0gZmxhdHBpY2tyKHRoaXMuX2d1aSwge1xuICAgICAgd3JhcDogdHJ1ZSxcbiAgICAgIC8vIGFsbG93IGVudGVyaW5nIHRoZSBkYXRlIG1hbnVhbGx5IHJlcXVpcmVzIGRhdGUgcGFyc2luZyBmcm9tIHN0cmluZ1xuICAgICAgLy8gdGhpcyBpcyBhIHRvdWdoIHRoaW5nIGFuZCByZXF1aXJlcyBsaWJzIGxpa2UgbW9tZW50XG4gICAgICBhbGxvd0lucHV0OiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiB0aGlzLl9vbkRhdGVDaGFuZ2VkLFxuICAgICAgZm9ybWF0RGF0ZTogdGhpcy5mb3JtYXREYXRlLFxuICAgICAgbWF4RGF0ZTogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lTWF4JywgcGFyYW1zLCBudWxsKSxcbiAgICAgIG1pbkRhdGU6IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZU1pbicsIHBhcmFtcywgbnVsbCksXG4gICAgICBkZWZhdWx0SG91cjogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRGVmYXVsdEhvdXInLCBwYXJhbXMsIDEyKSxcbiAgICAgIGRlZmF1bHRNaW51dGU6IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZURlZmF1bHRNaW51dGUnLCBwYXJhbXMsIDApLFxuICAgICAgZGlzYWJsZU1vYmlsZTogdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRGlzYWJsZU1vYmlsZScsIHBhcmFtcywgZmFsc2UpLFxuICAgICAgd2Vla051bWJlcnM6IHRoaXMuZ2V0T3B0aW9uKCdkYXRlVGltZUVuYWJsZVdlZWtOdW1iZXInLCBwYXJhbXMsIGZhbHNlKSxcbiAgICAgIGxvY2FsZTogdGhpcy5fZ2V0UGlja2VyTG9jYWxlKCksXG4gICAgICBub0NhbGVuZGFyLFxuICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgIGVuYWJsZVRpbWUsXG4gICAgICBlbmFibGVTZWNvbmRzLFxuICAgICAgdGltZV8yNGhyLFxuICAgIH0pXG5cbiAgICAvLyBmb3JjZSBkaWFsb2cgb3ZlcmZsb3dcbiAgICB0aGlzLnBpY2tlci5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhZy1jdXN0b20tY29tcG9uZW50LXBvcHVwJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgQG92ZXJyaWRlXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5waWNrZXIuZGVzdHJveSgpXG4gICAgdGhpcy5vZmYoRGF0ZVRpbWVJbnB1dC5PTl9EQVRFX0NIQU5HRUQpXG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBwaWNrZXIgZGF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0RhdGV8U3RyaW5nfSB2YWx1ZSB0aGUgZGF0ZSB2YWx1ZSB0byBzZXRcbiAgICovXG4gIHNldERhdGUodmFsdWUpIHtcbiAgICB0aGlzLnBpY2tlci5zZXREYXRlKHZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW4gUGlja2VyXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMucGlja2VyLm9wZW4oKVxuICAgIHRoaXMuX2d1aS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLmZvY3VzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSBwaWNrZXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucGlja2VyLmNsb3NlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgcGlja2VyXG4gICAqL1xuICByZXNldCgpIHtcbiAgICAvKiogdGhpcyBjaGVjayBiZWNhdXNlIHRoZSB0ZXN0cyBmYWlsIGhlcmUgZm9yIHNvbWUgcmVhc29ucyAgKi9cbiAgICBpZiAodGhpcy5waWNrZXIuY29uZmlnKSB7XG4gICAgICB0aGlzLnBpY2tlci5jbGVhcigpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgZGF0ZSB1c2luZyBgQkJqLk1hc2tzLlR5cGVzLmRhdGVgXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIGRhdGUgYXMgYSBzdHJpbmdcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBCQmogZGF0ZSBmb3JtYXRcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgZGF0ZSBhcyBzdHJpbmdcbiAgICovXG4gIEBhdXRvYmluZFxuICBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdCkge1xuICAgIGNvbnN0IGRhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5nZXRPcHRpb24oJ2RhdGVUaW1lRm9ybWF0dGVyJywgdGhpcy5fcGFyYW1zKVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuZ2V0T3B0aW9uKFxuICAgICAgJ2RhdGVUaW1lTG9jYWxlJyxcbiAgICAgIHRoaXMuX3BhcmFtcyxcbiAgICAgIEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUgfHwgJ2VuLVVTJ1xuICAgIClcblxuICAgIGlmIChkYXRlVGltZUZvcm1hdHRlcikge1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBkYXRlVGltZUZvcm1hdHRlclxuICAgICAgbGV0IGV4cHJlc3Npb24gPSBkYXRlVGltZUZvcm1hdHRlclxuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICBpZiAoIShleHByZXNzaW9uLmluZGV4T2YoJ3JldHVybicpID49IDApKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uID0gJ3JldHVybiAnICsgZXhwcmVzc2lvbiArICc7J1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXG4gICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAnZm9ybWF0JyxcbiAgICAgICAgICAgICdsb2NhbGUnLFxuICAgICAgICAgICAgJ0RhdGVNYXNrJyxcbiAgICAgICAgICAgIGV4cHJlc3Npb25cbiAgICAgICAgICApKGRhdGUsIGZvcm1hdCwgbG9jYWxlLCBCQmouTWFza3MuRGF0ZU1hc2spXG5cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIHJldHVybiBkYXRlVGltZUZvcm1hdHRlcihkYXRlLCBmb3JtYXQsIGxvY2FsZSwgQkJqLk1hc2tzLkRhdGVNYXNrKVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIGRhdGVUaW1lRm9ybWF0dGVyIGRlZmluZWQgZm9yIGNvbHVtbiBcIiR7dGhpcy5fcGFyYW1zLmNvbERlZi5maWVsZH1cIi4gVGhlIGZvcm1hdHRlciBzaG91bGQgYmUgYW4gZXhwcmVzc2lvbiBvciBwbGFpbiBmdW5jdGlvbmBcbiAgICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZm9ybWF0IHx8IChmb3JtYXQgJiYgZm9ybWF0LmluZGV4T2YoJyUnKSA8IDApKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gQkJqLk1hc2tzLkRhdGVNYXNrLm1hc2soZGF0ZSwgZm9ybWF0LCBsb2NhbGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBkYXRlIHBpY2tlciBjaGFuZ2VzIGFuZCB1cGRhdGUgdGhlIHNlbGVjdGVkIGRhdGVcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWREYXRlcyAgYXJyYXkgb2Ygc2VsZWN0ZWQgZGF0ZXNcbiAgICovXG4gIEBhdXRvYmluZFxuICBfb25EYXRlQ2hhbmdlZChzZWxlY3RlZERhdGVzKSB7XG4gICAgdGhpcy5zZWxlY3RlZERhdGUgPSBzZWxlY3RlZERhdGVzWzBdIHx8IG51bGxcbiAgICB0aGlzLm5vdGlmeShEYXRlVGltZUlucHV0Lk9OX0RBVEVfQ0hBTkdFRCwgdGhpcy5zZWxlY3RlZERhdGUpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHBpY2tlciBnbG9iYWwgbG9jYWxpemF0aW9uIHdoaWNoIHdpbGwgd29yayB3aXRoIGFueSBsb2NhbGVcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmxhdHBpY2tyL2ZsYXRwaWNrci9ibG9iL21hc3Rlci9zcmMvbDEwbi9kZWZhdWx0LnRzXG4gICAqL1xuICBfZ2V0UGlja2VyTG9jYWxlKCkge1xuICAgIGNvbnN0IGxvY2FsZSA9IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGUgfHwgJ2VuLVVTJ1xuXG4gICAgY29uc3Qgd2Vla0RheXNTaG9ydCA9IFtdXG4gICAgY29uc3Qgd2Vla0RheXNMb25nID0gW11cblxuICAgIGZvciAobGV0IGRheSA9IDQ7IGRheSA8IDExOyBkYXkrKykge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKDE5NzAsIDEgLSAxLCBkYXkpXG5cbiAgICAgIHdlZWtEYXlzU2hvcnQucHVzaChcbiAgICAgICAgZGF0ZVxuICAgICAgICAgIC50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHtcbiAgICAgICAgICAgIHdlZWtkYXk6ICdzaG9ydCcsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc3BsaXQoJywnKVswXSAvLyB0aGUgZGF0ZS10aW1lLWZvcm1hdC10aW1lem9uZSBwb2x5ZmlsbCBhdHRhY2ggdGhlIGRhdGUgYWxzb1xuICAgICAgKVxuXG4gICAgICB3ZWVrRGF5c0xvbmcucHVzaChcbiAgICAgICAgZGF0ZVxuICAgICAgICAgIC50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHtcbiAgICAgICAgICAgIHdlZWtkYXk6ICdsb25nJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zcGxpdCgnLCcpWzBdIC8vIHRoZSBkYXRlLXRpbWUtZm9ybWF0LXRpbWV6b25lIHBvbHlmaWxsIGF0dGFjaCB0aGUgZGF0ZSBhbHNvXG4gICAgICApXG4gICAgfVxuXG4gICAgY29uc3QgbW9udGhzU2hvcnQgPSBbXVxuICAgIGNvbnN0IG1vbnRoc0xvbmcgPSBbXVxuXG4gICAgZm9yIChsZXQgbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoMTk3MCwgbW9udGgsIDQpXG5cbiAgICAgIG1vbnRoc1Nob3J0LnB1c2goXG4gICAgICAgIGRhdGUudG9Mb2NhbGVTdHJpbmcobG9jYWxlLCB7XG4gICAgICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICAgIH0pXG4gICAgICApXG5cbiAgICAgIG1vbnRoc0xvbmcucHVzaChcbiAgICAgICAgZGF0ZS50b0xvY2FsZVN0cmluZyhsb2NhbGUsIHtcbiAgICAgICAgICBtb250aDogJ2xvbmcnLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3ZWVrZGF5czoge1xuICAgICAgICBzaG9ydGhhbmQ6IHdlZWtEYXlzU2hvcnQsXG4gICAgICAgIGxvbmdoYW5kOiB3ZWVrRGF5c0xvbmcsXG4gICAgICB9LFxuICAgICAgbW9udGhzOiB7XG4gICAgICAgIHNob3J0aGFuZDogbW9udGhzU2hvcnQsXG4gICAgICAgIGxvbmdoYW5kOiBtb250aHNMb25nLFxuICAgICAgfSxcbiAgICAgIGRheXNJbk1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgICBmaXJzdERheU9mV2VlazogQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmdldFdlZWtTdGFydEJ5TG9jYWxlKGxvY2FsZSksXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIG9yZGluYWw6IG51bWJlciA9PiAnJyxcbiAgICAgIHJhbmdlU2VwYXJhdG9yOiAnICAnLFxuICAgICAgd2Vla0FiYnJldmlhdGlvbjogJycsXG4gICAgICBzY3JvbGxUaXRsZTogJycsXG4gICAgICB0b2dnbGVUaXRsZTogJycsXG4gICAgICBhbVBNOiBbJ0FNJywgJ1BNJ10sXG4gICAgICB5ZWFyQXJpYUxhYmVsOiAnJyxcbiAgICAgIGhvdXJBcmlhTGFiZWw6ICcnLFxuICAgICAgbWludXRlQXJpYUxhYmVsOiAnJyxcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVRpbWVJbnB1dFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL0RhdGVUaW1lSW5wdXQvRGF0ZVRpbWVJbnB1dC5qcyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EYXRlVGltZUlucHV0L3N0eWxlLnNjc3MiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kYXRldGltZV9faW5wdXR7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO292ZXJmbG93OmhpZGRlbjtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWFnLWlucHV0LWJvcmRlci1jb2xvciwgdmFyKC0tYWctYm9yZGVyLWNvbG9yLCAjYmFiZmM3KSk7Ym9yZGVyLXJhZGl1czozcHh9LmRhdGV0aW1lX19pbnB1dDpmb2N1cywuZGF0ZXRpbWVfX2lucHV0OmFjdGl2ZSwuZGF0ZXRpbWVfX2lucHV0OmhvdmVye2JvcmRlci1jb2xvcjp2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHJnYmEoMzMsMTUwLDI0MywwLjQpKX0uZGF0ZXRpbWVfX2lucHV0X19pbnB1dHtmbGV4OjE7cGFkZGluZzo2cHg7Ym9yZGVyOm5vbmU7b3V0bGluZTpub25lO2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6aW5oZXJpdH0uYWctdGhlbWUtYWxwaW5lIC5kYXRldGltZV9faW5wdXRfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0gLmRhdGV0aW1lX19pbnB1dF9faW5wdXQsLmFnLXRoZW1lLW1hdGVyaWFsIC5kYXRldGltZV9faW5wdXRfX2lucHV0e2JhY2tncm91bmQtY29sb3I6dmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZil9LmFnLXRoZW1lLWFscGluZS1kYXJrIC5kYXRldGltZV9faW5wdXRfX2lucHV0LC5hZy10aGVtZS1iYWxoYW0tZGFyayAuZGF0ZXRpbWVfX2lucHV0X19pbnB1dHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICMyZDM0MzYpfS5kYXRldGltZV9faW5wdXRfX2NsZWFye21hcmdpbi1sZWZ0OjFweDttYXJnaW4tdG9wOjFweDtwYWRkaW5nOjZweDt0ZXh0LWFsaWduOmNlbnRlcjtib3JkZXI6bm9uZTtvdXRsaW5lOm5vbmU7Y3Vyc29yOnBvaW50ZXI7Y29sb3I6aW5oZXJpdH0uZGF0ZXRpbWVfX2lucHV0LS1lZGl0b3J7Ym9yZGVyLWNvbG9yOnZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywxNTAsMjQzLDAuNCkpfS5kYXRldGltZV9faW5wdXQtLWVkaXRvciAuZGF0ZXRpbWVfX2lucHV0X19pbnB1dHtwYWRkaW5nOjA7cGFkZGluZy1sZWZ0OjZweH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL0RhdGVUaW1lSW5wdXQvc3R5bGUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5zY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EYXRlVGltZUZpbHRlci9zdHlsZS5zY3NzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZGF0ZVRpbWVGaWx0ZXIgc2VsZWN0e21hcmdpbi1ib3R0b206OXB4O3BhZGRpbmc6NnB4O2JvcmRlci1yYWRpdXM6M3B4O2JvcmRlcjoxcHggc29saWQgdmFyKC0tYWctaW5wdXQtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1ib3JkZXItY29sb3IsICNiYWJmYzcpKTtjb2xvcjppbmhlcml0fS5kYXRlVGltZUZpbHRlciBzZWxlY3Q6Zm9jdXMsLmRhdGVUaW1lRmlsdGVyIHNlbGVjdDphY3RpdmV7Ym9yZGVyLWNvbG9yOnZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywxNTAsMjQzLDAuNCkpfS5kYXRlVGltZUZpbHRlciBzZWxlY3Qgb3B0aW9ue3RleHQtaW5kZW50OjZweH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3JjL0RhdGVUaW1lRmlsdGVyL3N0eWxlLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSAyIDMiLCIvKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtYWdncmlkLWNvbXBvbmVudHMgbGliLlxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxuICpcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cbiAqL1xuXG5pbXBvcnQgRGF0ZVRpbWVFZGl0b3IgZnJvbSAnLi9EYXRlVGltZUVkaXRvcidcblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVRpbWVFZGl0b3JcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EYXRlVGltZUVkaXRvci9pbmRleC5qcyIsIi8qXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1hZ2dyaWQtY29tcG9uZW50cyBsaWIuXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XG4gKlxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuICovXG5cbmltcG9ydCB7IGF1dG9iaW5kLCBvdmVycmlkZSB9IGZyb20gJ2NvcmUtZGVjb3JhdG9ycydcbmltcG9ydCB1dGNUb1pvbmVkVGltZSBmcm9tICdkYXRlLWZucy10ei91dGNUb1pvbmVkVGltZSdcbmltcG9ydCBEYXRlVGltZUlucHV0IGZyb20gJy4uL0RhdGVUaW1lSW5wdXQnXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJy4uL0NvbXBvbmVudCdcblxuLyoqXG4gKiBEYXRlVGltZUlucHV0XG4gKlxuICogU2ltcGxlIERhdGVUaW1lSW5wdXQgY29tcG9uZW50IHdoaWNoIGludGVncmF0ZXMgdGhlIGZsYXRwaWNrclxuICpcbiAqICMjIE9wdGlvbnNcbiAqXG4gKiB8IE5hbWUgICAgICAgICAgICAgICAgICBcdHwgRGVmYXVsdCAgICAgXHR8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcdHxcbiAqIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHR8Oi0tLS0tLS0tLS0tLS06fC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCAqKmRhdGVUaW1lRW5hYmxlVGltZSoqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgdGltZVxuICogfCAqKmRhdGVUaW1lRW5hYmxlMjRIUioqICAgfCBmYWxzZSAgICB8IGVuYWJsZSAvIGRpc2FibGUgdGltZSAyNCBmb3JtYXRcbiAqIHwgKipkYXRlVGltZUVuYWJsZVNlY29uZHMqKiAgIHwgZmFsc2UgICAgfCBlbmFibGUgLyBkaXNhYmxlIHNlY29uZHMgbWFuYWdlbWVudFxuICogfCAqKmRhdGVUaW1lRW5hYmxlQ2FsZW5kYXIqKiAgIHwgZmFsc2UgICAgfCBlbmFibGUgLyBkaXNhYmxlIENhbGVuZGFyLlxuICogfCAqKmRhdGVUaW1lTWFzayoqICAgfCBmYWxzZSAgICB8IFRoZSBtYXNrIHVzZWQgdG8gZm9ybWF0IHRoZSBzZWxlY3RlZCBkYXRlXG4gKiB8ICoqZGF0ZVRpbWVNYXgqKiAgIHwgdW5kZWZpbmVkICAgIHwgIE1heCBhbGxvd2VkIGRhdGVcbiAqIHwgKipkYXRlVGltZU1pbioqICAgfCB1bmRlZmluZWQgICAgfCAgTWluIGFsbG93ZWQgZGF0ZVxuICogfCAqKmRhdGVUaW1lRm9ybWF0dGVyKiogICB8IGZhbHNlICAgIHwgIEEgZnVuY3Rpb24gb3IgZXhwcmVzc2lvbiB0byBmb3JtYXQgdGhlIGRhdGUgKEBzZWUgc3VwcG9ydGVkIHBhcmFtKVxuICogfCAqKmRhdGVUaW1lTG9jYWxlKiogICB8IFN5c3RlbSBkZWZhdWx0ICAgIHwgIEEgbG9jYWxlIHRvIHVzZSBmb3IgZGF0ZSBmb3JtYXR0aW5nXG4gKiB8ICoqZGF0ZVRpbWVEZWZhdWx0SG91cioqICAgfCAxMiAgICB8ICBJbml0aWFsIHZhbHVlIG9mIHRoZSBob3VyIGVsZW1lbnQuXG4gKiB8ICoqZGF0ZVRpbWVEZWZhdWx0TWludXRlKiogICB8IDAgICAgfCAgSW5pdGlhbCB2YWx1ZSBvZiB0aGUgbWludXRlIGVsZW1lbnQuXG4gKiB8ICoqZGF0ZVRpbWVEaXNhYmxlTW9iaWxlKiogICB8IGZhbHNlICAgIHwgIFNldCBkaXNhYmxlTW9iaWxlIHRvIHRydWUgdG8gYWx3YXlzIHVzZSB0aGUgbm9uLW5hdGl2ZSBwaWNrZXIuXG4gKiB8ICoqZGF0ZVRpbWVFbmFibGVXZWVrTnVtYmVyKiogICB8IHRydWUgICAgfCAgRW5hYmxlcyBkaXNwbGF5IG9mIHdlZWsgbnVtYmVycyBpbiBjYWxlbmRhci5cbiAqXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxuICovXG5jbGFzcyBEYXRlVGltZUVkaXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBAdHlwZSB7RGF0ZVRpbWVJbnB1dH1cbiAgICovXG4gIF9pbnB1dCA9IG5ldyBEYXRlVGltZUlucHV0KHRydWUpXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBfdmFsdWUgPSBudWxsXG5cbiAgLyoqXG4gICAqIFBhcmFtcyByZWNlaXZlZCBpbiBpbml0XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBfcGFyYW1zID0gbnVsbFxuXG4gIC8qKlxuICAgKiBUYWtlcyBpbmNvbXBsZXRlIGlzbyBzdHJpbmcgYW5kIHJldHVybiBhIGNvbXBsZXRlIG9uZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0ZSBpbmNvbXBsZXRlIGlzbyBzdHJpbmdcbiAgICpcbiAgICogQHJldHVybiB7U3RyaW5nfSBjb21wbGV0ZSBpc28gc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgZml4U2hvcnRJU08odmFsdWUpIHtcbiAgICByZXR1cm4gQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmZpeFNob3J0SVNPKHZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgaW5pdChwYXJhbXMpIHtcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXNcbiAgICB0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHBhcmFtcy5jZWxsU3RhcnRlZEVkaXRcbiAgICBpZiAodGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgIGxldCBrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlID1cbiAgICAgICAgcGFyYW1zLmtleVByZXNzID09IDMyIHx8IHBhcmFtcy5rZXlQcmVzcyA9PSA0NiAvLyBzcGFjZSAvLyBkZWxldGVcblxuICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gcGFyYW1zLmNoYXJQcmVzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBwYXJhbXMudmFsdWVcbiAgICAgICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPSAxMTMpIHtcbiAgICAgICAgICAvL0YyXG4gICAgICAgICAgdGhpcy5oaWdobGlnaHRBbGxPbkZvY3VzID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gcGFyYW1zLnZhbHVlXG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSBEYXRlVGltZUVkaXRvci5maXhTaG9ydElTTyh0aGlzLl92YWx1ZSlcbiAgICB0aGlzLl9pbnB1dC5pbml0KHBhcmFtcylcbiAgICB0aGlzLl9pbnB1dC5vbihEYXRlVGltZUlucHV0Lk9OX0RBVEVfQ0hBTkdFRCwgdGhpcy5fb25EYXRlQ2hhbmdlKVxuXG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl9pbnB1dC5zZXREYXRlKFxuICAgICAgICB1dGNUb1pvbmVkVGltZSh0aGlzLl92YWx1ZSwgQkJqLk1hc2tzLlV0aWxzLkRhdGVzLmdldFRpbWV6b25lT3JPZmZzZXQoKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9ndWkgPSB0aGlzLl9pbnB1dC5nZXRHdWkoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBAb3ZlcnJpZGVcbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9pbnB1dC5kZXN0cm95KClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCBvbmNlIGFmdGVyIEdVSSBpcyBhdHRhY2hlZCB0byBET00uXG4gICAqIE1ha2Ugc3VyZSB0aGUgY29udGFpbmVyIGlzIGFsd2F5cyBmb2N1c2VkIGFuZCBsaXN0ZW5pbmcgdG8ga2V5IGNoYW5nZXNcbiAgICovXG4gIGFmdGVyR3VpQXR0YWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkKSB7XG4gICAgICB0aGlzLmZvY3VzSW4oKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZpbmFsIHZhbHVlIHRvIHRoZSBncmlkLCB0aGUgcmVzdWx0IG9mIHRoZSBlZGl0aW5nXG4gICAqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1zLnBhcnNlVmFsdWUodGhpcy5fdmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjYWxsZWQgb25jZSBhZnRlciBpbml0aWFsaXplZCBhbmQgcmV0dXJucyBmYWxzZSBzbyB0aGUgZWRpdG9yIGFwcGVhcnMgaW4gdGhlIGNlbGxcbiAgICpcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYWx3YXlzIGZhbHNlXG4gICAqKi9cbiAgaXNQb3B1cCgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBkb2luZyBmdWxsIHJvdyBlZGl0LCB0aGVuIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyBpbnRvIHRoZSBjZWxsLlxuICAgKi9cbiAgZm9jdXNJbigpIHtcbiAgICB0aGlzLl9pbnB1dC5vcGVuKClcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBkb2luZyBmdWxsIHJvdyBlZGl0LCB0aGVuIGdldHMgY2FsbGVkIHdoZW4gdGFiYmluZyBvdXQgb2YgdGhlIGNlbGwuXG4gICAqL1xuICBmb2N1c091dCgpIHtcbiAgICB0aGlzLl9pbnB1dC5jbG9zZSgpXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBlZGl0b3IgdmFsdWUgd2l0aCBzZWxlY3RlZCBkYXRlIGZyb20gdGhlIGlucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlXG4gICAqL1xuICBAYXV0b2JpbmRcbiAgX29uRGF0ZUNoYW5nZShkYXRlKSB7XG4gICAgdGhpcy5fdmFsdWUgPSBkYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGUudG9JU09TdHJpbmcoKSA6ICcnXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVRpbWVFZGl0b3JcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9EYXRlVGltZUVkaXRvci9EYXRlVGltZUVkaXRvci5qcyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGZkN2Y2MDQyMTkyZTEyMzJjZjY1IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwiYmJqLW1hc2tzL3NyYy9TdHJpbmdNYXNrXCIsXCJjb21tb25qczJcIjpcImJiai1tYXNrcy9zcmMvU3RyaW5nTWFza1wiLFwiYW1kXCI6XCJiYmotbWFza3Mvc3JjL1N0cmluZ01hc2tcIixcInJvb3RcIjpbXCJCQmpcIixcIk1hc2tzXCIsXCJTdHJpbmdNYXNrXCJdfVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWlucHV0LW1hc2tpbmcgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSAnLi9UZXh0SW5wdXQnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBUZXh0SW5wdXRcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL1RleHRJbnB1dC9pbmRleC5qcyIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWlucHV0LW1hc2tpbmcgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBTdHJpbmdNYXNrIGZyb20gJ2Jiai1tYXNrcy9zcmMvU3RyaW5nTWFzaydcclxuaW1wb3J0IHtcclxuICBtYXNrSWZOb3RNYXNrZWQsXHJcbiAgdW5tYXNrLFxyXG4gIGZpbmRDYXJldFBvc2l0aW9uLFxyXG4gIGdlbmVyYXRlUGF0dGVybkZyb21NYXNrLFxyXG59IGZyb20gJy4vdG9vbHMuanMnXHJcblxyXG4vKipcclxuICogVGhlIGBUZXh0SW5wdXRgIHdpbGwgd3JhcCB0ZXh0IGlucHV0cyBhbmQgYXBwbHkgdGhlIGdpdmVuIFtiYmogc3RyaW5nIG1hc2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9CYXNpc0h1Yi9iYmotbWFza3Mjc3RyaW5nLW1hc2tzKVxyXG4gKlxyXG4gKiAqKk9wdGlvbnMqKlxyXG4gKlxyXG4gKiBfT3B0aW9ucyBjYW4gYmUgcGFzc2VkIHZpYSBkYXRhIGF0dHJpYnV0ZXMgLiBGb3IgZGF0YSBhdHRyaWJ1dGVzLCBhcHBlbmQgdGhlIG9wdGlvbiBuYW1lIHRvIGRhdGEtLCBhcyBpbiBkYXRhLW1hc2tfXHJcbiAqXHJcbiAqIHwgT3B0aW9uICAgIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8LS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBtYXNrIHwgICAgICAgICB8IFRoZSBiYmogc3RyaW5nIG1hc2sgQHNlZSBbQkJqIFN0cmluZyBNYXNrc10oaHR0cHM6Ly9naXRodWIuY29tL0Jhc2lzSHViL2Jiai1tYXNrcyNzdHJpbmctbWFza3MpIHxcclxuICpcclxuICogIDxicj5cclxuICpcclxuICogKipFeGFtcGxlIDoqKlxyXG4gKiBgYGBodG1sXHJcbiAqICA8aW5wdXQgY2xhc3M9XCJiYmotdGV4dC1tYXNrZWRcIiBuYW1lPVwidGVzdFwiIGlkPVwidGVzdFwiIHZhbHVlPVwiZWQyM1wiIGRhdGEtbWFzaz1cIkFBLTAwXCI+XHJcbiAqXHJcbiAqICA8c2NyaXB0PlxyXG4gKiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKGUpIHtcclxuICogICAgICBuZXcgQmFzaXMuSW5wdXRNYXNraW5nLlRleHRJbnB1dCh7XHJcbiAqICAgICAgICAgb25VcGRhdGU6IChtYXNrZWRWYWx1ZSAsIHJhd1ZhbHVlICwgaW5wdXQpID0+IHtcclxuICogICAgICAgICAgICAvLyBkbyBzb21ldGhpbmdcclxuICogICAgICAgICB9LFxyXG4gKiAgICAgICAgIG9uSW52YWxpZDogKGVyciAsIGlucHV0KSA9PiB7XHJcbiAqICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nXHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgIH0pXHJcbiAqICAgIH0pXHJcbiAqICA8L3NjcmlwdD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG5jbGFzcyBUZXh0SW5wdXQge1xyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBuZXcgVGV4dElucHV0XHJcbiAgICpcclxuICAgKiBAcGFyYW0gez9PYmplY3R9IG9wdGlvbnMgLSBUaGUgaW5wdXQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ30gW29wdGlvbnMuZWxlbWVudHM9XCIuYmJqLXRleHQtbWFza2VkXCJdIC0gVGhlIGNsYXNzIG5hbWUgb3IgdGhlIG5vZGUgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtIVE1MRG9jdW1lbnR9IFtvcHRpb25zLmRvY3VtZW50PWRvY3VtZW50XSAtIERvY3VtZW50IGluc3RhbmNlIHRvIHVzZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jc3NDbGFzc0Vycm9yPVwiYmJqLW1hc2stZXJyb3JcIl0gLSBBIGNzcyBjbGFzcyB0byBhdHRhY2ggdG8gdGhlIGlucHV0IHdoZW4gaXQgaXMgaW52YWxpZFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3M9XCJiYmotbWFzay1zdWNjZXNzXCJdIC0gQSBjc3MgY2xhc3MgdG8gYXR0YWNoIHRvIHRoZSBpbnB1dCB3aGVuIGl0IGlzIHZhbGlkIGFmdGVyIHRoZSB1c2VyIGludGVyYWN0aW9uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25VcGRhdGU9bnVsbF0gLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiB0aGUgbmV3IG1hc2tlZCB2YWx1ZSBpcyBzZXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkludmFsaWQ9bnVsbF0gLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiB0aGUgaW5wdXQgb3IgdGhlIG1hc2sgaXMgaW52YWxpZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAuLi57XHJcbiAgICAgICAgZWxlbWVudHM6ICcuYmJqLXRleHQtbWFza2VkJyxcclxuICAgICAgICBkb2M6IGRvY3VtZW50LFxyXG4gICAgICAgIGNzc0NsYXNzRXJyb3I6ICdiYmotbWFzay1lcnJvcicsXHJcbiAgICAgICAgY3NzQ2xhc3NTdWNjZXNzOiAnYmJqLW1hc2stc3VjY2VzcycsXHJcbiAgICAgICAgb25VcGRhdGU6IG51bGwsXHJcbiAgICAgICAgb25JbnZhbGlkOiBudWxsLFxyXG4gICAgICB9LFxyXG4gICAgICAuLi5vcHRpb25zLFxyXG4gICAgfVxyXG4gICAgdGhpcy5fb25LZXlzdHJva2UgPSB0aGlzLl9vbktleXN0cm9rZS5iaW5kKHRoaXMpXHJcbiAgICB0aGlzLl9vbkZvY3VzID0gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpXHJcbiAgICB0aGlzLnJlZnJlc2goKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGFuZCB3cmFwIHRoZSBpbnB1dCBlbGVtZW50cyBmb3IgbWFza2luZyBpbiBjYXNlXHJcbiAgICogdGhleSBhcmUgbm90IHdyYXBwZWQgeWV0XHJcbiAgICovXHJcbiAgcmVmcmVzaCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnRzID1cclxuICAgICAgdHlwZW9mIHRoaXMub3B0aW9ucy5lbGVtZW50cyA9PT0gJ3N0cmluZydcclxuICAgICAgICA/IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvckFsbCh0aGlzLm9wdGlvbnMuZWxlbWVudHMpXHJcbiAgICAgICAgOiB0aGlzLm9wdGlvbnMuZWxlbWVudHNcclxuICAgIGxldCBpbnB1dCwgcGFyZW50Q2xhc3NcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlucHV0ID0gZWxlbWVudHNbaV1cclxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCkge1xyXG4gICAgICAgIHBhcmVudENsYXNzID0gaW5wdXQucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2NsYXNzJylcclxuXHJcbiAgICAgICAgaWYgKCFpbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJykpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgYEJCak1hc2tpbmc6IElucHV0IGhhcyBubyBJRC4gV2l0aG91dCBhbiBJRCB0aGUgaW5wdXQgY2Fubm90IGJlIG1hc2tlZGAsXHJcbiAgICAgICAgICAgIGlucHV0XHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgaW5pdGlhbGl6ZSB0aGUgaW5wdXQncyB3cmFwIHR3aWNlXHJcbiAgICAgICAgY29uc3QgaXNXcmFwcGVkID1cclxuICAgICAgICAgIHBhcmVudENsYXNzICYmIHBhcmVudENsYXNzLmluZGV4T2YoJ3RleHRJbnB1dE1hc2tfX3dyYXAnKSA+IC0xXHJcbiAgICAgICAgdGhpcy5fd3JhcChpbnB1dCwgaXNXcmFwcGVkKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBCQmpNYXNraW5nOiBJbnZhbGlkIGlucHV0IGVsZW1lbnQuIFRoZSBlbGVtZW50IHdpbGwgYmUgaWdub3JlZGAsXHJcbiAgICAgICAgICBpbnB1dFxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW53cmFwIHRoZSBpbnB1dCBlbGVtZW50cyBhbmQgcmVtb3ZlIGF0dGFjaGVkIGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9XHJcbiAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmVsZW1lbnRzKVxyXG4gICAgICAgIDogdGhpcy5vcHRpb25zLmVsZW1lbnRzXHJcblxyXG4gICAgbGV0IGlucHV0LCBwYXJlbnQsIHBhcmVudENsYXNzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpbnB1dCA9IGVsZW1lbnRzW2ldXHJcbiAgICAgIHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGVcclxuICAgICAgcGFyZW50Q2xhc3MgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpXHJcblxyXG4gICAgICBpZiAocGFyZW50Q2xhc3MgJiYgcGFyZW50Q2xhc3MuaW5kZXhPZigndGV4dElucHV0TWFza19fd3JhcCcpID4gLTEpIHtcclxuICAgICAgICB0aGlzLl91bndyYXAocGFyZW50KVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgdGhlIHRleHQgbWFza2luZyBpbnB1dCB3cmFwcGVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0IHRoZSBpbnB1dCBlbGVtZW50XHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1dyYXBwZWQgd2hlbiB0cnVlIHRoZSBpbnB1dCBpcyBhbHJlYWR5IHdyYXBwZWQgYW5kIHdlIG5lZWQgdG8gYWRkIHdoYXQgaXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nIG9ubHlcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtIVE1MU3BhbkVsZW1lbnR9IHRoZSB3cmFwIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfd3JhcChpbnB1dCwgaXNXcmFwcGVkKSB7XHJcbiAgICBjb25zdCBpbnB1dElkID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpLFxyXG4gICAgICBpbnB1dE5hbWUgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSxcclxuICAgICAgbWFzayA9IGlucHV0LmRhdGFzZXQubWFzayB8fCAnJyxcclxuICAgICAgb3JpZ2luYWxQYXR0ZXJuID0gaW5wdXQucGF0dGVybixcclxuICAgICAgZGVmYXVsdFBhdHRlcm4gPSBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzayhtYXNrKSxcclxuICAgICAgcGF0dGVybiA9IG9yaWdpbmFsUGF0dGVybiB8fCBkZWZhdWx0UGF0dGVyblxyXG5cclxuICAgIGxldCB3cmFwID0gbnVsbCxcclxuICAgICAgdW5tYXNrSW5wdXQgPSBudWxsXHJcblxyXG4gICAgaWYgKCFpc1dyYXBwZWQpIHtcclxuICAgICAgd3JhcCA9IHRoaXMub3B0aW9ucy5kb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpXHJcbiAgICAgIHVubWFza0lucHV0ID0gdGhpcy5vcHRpb25zLmRvYy5jcmVhdGVFbGVtZW50KCdpbnB1dCcpIC8vIGhpZGRlbiBpbnB1dCB3aXRoIHRoZSB1bm1hc2tlZCB2YWx1ZXMgZm9yIGZvcm1zXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cmFwID0gaW5wdXQucGFyZW50Tm9kZVxyXG4gICAgICB1bm1hc2tJbnB1dCA9IHdyYXAucXVlcnlTZWxlY3RvcignLnRleHRJbnB1dE1hc2tfX3VubWFza2VkSW5wdXQnKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbmZpZ3VyZSB0aGUgYWN0dWFsIGlucHV0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgaW5wdXQudmFsdWUgPSBtYXNrSWZOb3RNYXNrZWQoaW5wdXQudmFsdWUsIG1hc2spXHJcbiAgICBpbnB1dC5wYXR0ZXJuID0gcGF0dGVyblxyXG4gICAgaW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dElucHV0TWFza19fdGV4dElucHV0JylcclxuICAgIGlucHV0LmRhdGFzZXQubWFzayA9IG1hc2tcclxuICAgIGlucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCA9IHVubWFzayhpbnB1dC52YWx1ZSwgbWFzaylcclxuICAgIGlmIChvcmlnaW5hbFBhdHRlcm4gJiYgb3JpZ2luYWxQYXR0ZXJuICE9PSBkZWZhdWx0UGF0dGVybikge1xyXG4gICAgICBpbnB1dC5kYXRhc2V0LmlzQ3VzdG9tUGF0dGVybiA9IHRydWVcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzV3JhcHBlZCkge1xyXG4gICAgICBpZiAoIShpbnB1dC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHwgaW5wdXQuaGFzQXR0cmlidXRlKCdkaXNhYmxlJykpKSB7XHJcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbktleXN0cm9rZSlcclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX29uS2V5c3Ryb2tlKVxyXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgdGhpcy5fb25LZXlzdHJva2UpXHJcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX29uRm9jdXMpXHJcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkZvY3VzKVxyXG4gICAgICB9XHJcbiAgICAgIGlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXAsIGlucHV0KSAvLyBtb3ZlIHRoZSBpbnB1dCBvdXRzaWRlIHRoZSB3cmFwcGVyXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuX3ZhbGlkYXRlSW5wdXQoaW5wdXQpKSB7XHJcbiAgICAgIHRoaXMuX19maXJlT25VcGRhdGUoaW5wdXQudmFsdWUsIGlucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCwgaW5wdXQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uZmlndXJlIHRoZSB1bm1hc2tlZCBpbnB1dFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdW5tYXNrSW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJylcclxuICAgIHVubWFza0lucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdoaWRkZW4nKVxyXG4gICAgdW5tYXNrSW5wdXQuY2xhc3NMaXN0LmFkZCgndGV4dElucHV0TWFza19fdW5tYXNrZWRJbnB1dCcpXHJcbiAgICB1bm1hc2tJbnB1dC52YWx1ZSA9IGlucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZFxyXG4gICAgaWYgKGlucHV0SWQpIHVubWFza0lucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBgJHtpbnB1dElkfS11bm1hc2tlZGApXHJcbiAgICBpZiAoaW5wdXROYW1lKSB1bm1hc2tJbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBgJHtpbnB1dE5hbWV9LXVubWFza2VkYClcclxuXHJcbiAgICBpZiAoIWlzV3JhcHBlZCkge1xyXG4gICAgICAvLyBjb25maWd1cmUgdGhlIHdyYXBwZXJcclxuICAgICAgd3JhcC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3RleHRJbnB1dE1hc2tfX3dyYXAnKVxyXG4gICAgICB3cmFwLmFwcGVuZENoaWxkKHVubWFza0lucHV0KVxyXG4gICAgICB3cmFwLmFwcGVuZENoaWxkKGlucHV0KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB3cmFwXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIG1hc2tlZCBpbnB1dCBhbmQgcmVtb3ZlIHRoZSB2YWx1ZSBjaGFuZ2VkIGxpc3RlbmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxTcGFuRWxlbWVudH0gdGV4dElucHV0IHRoZSB3cmFwcGVyIHNwYW4gaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfdW53cmFwKHRleHRJbnB1dCkge1xyXG4gICAgdGV4dElucHV0LnJlbW92ZUNoaWxkKFxyXG4gICAgICB0ZXh0SW5wdXQucXVlcnlTZWxlY3RvcignLnRleHRJbnB1dE1hc2tfX3VubWFza2VkSW5wdXQnKVxyXG4gICAgKVxyXG5cclxuICAgIGNvbnN0IGlucHV0ID0gdGV4dElucHV0LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0SW5wdXRNYXNrX190ZXh0SW5wdXQnKVxyXG4gICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9vbktleXN0cm9rZSlcclxuICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5fb25LZXlzdHJva2UpXHJcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuX29uS2V5c3Ryb2tlKVxyXG4gICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuX29uRm9jdXMpXHJcbiAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uRm9jdXMpXHJcbiAgICBkZWxldGUgaW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkXHJcbiAgICBpZiAoIWlucHV0LmRhdGFzZXQuaXNDdXN0b21QYXR0ZXJuKSB7XHJcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgncGF0dGVybicpXHJcbiAgICAgIGRlbGV0ZSBpbnB1dC5kYXRhc2V0LmlzQ3VzdG9tUGF0dGVyblxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcblxyXG4gICAgdGV4dElucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGlucHV0LCB0ZXh0SW5wdXQpXHJcbiAgICB0ZXh0SW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0SW5wdXQpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gZXZlcnkga2V5c3Ryb2tlIG9uIHRoZSBpbnB1dCBhbmQgdXBkYXRlIHRoZSBtYXNrZWQgYW5kIHRoZSB1bm1hc2tlZCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF9vbktleXN0cm9rZShlKSB7XHJcbiAgICBpZiAoZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkgfHwgZS5hbHRLZXkgfHwgZS5tZXRhS2V5KSByZXR1cm5cclxuICAgIGlmKGUua2V5Q29kZSAhPT0gMTMpIGUucHJldmVudERlZmF1bHQoKVxyXG4gICAgXHJcbiAgICBjb25zdCBpbnB1dCA9IGUudGFyZ2V0LFxyXG4gICAgICBtYXNrID0gaW5wdXQuZGF0YXNldC5tYXNrIHx8IHRoaXMub3B0aW9ucy5tYXNrLFxyXG4gICAgICBldmVudFR5cGUgPSBlLnR5cGVcclxuXHJcbiAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgaW5wdXQuc2V0Q3VzdG9tVmFsaWRpdHkoJycpO1xyXG5cclxuICAgIGxldCB2YWx1ZSA9IGlucHV0LnZhbHVlLFxyXG4gICAgICBrZXlDb2RlID0gZS5rZXlDb2RlLFxyXG4gICAgICBrZXlDb250ZW50ID0gZS5rZXkgfHwgZS5jb2RlLnJlcGxhY2UoL1teMC05XS9nLCAnJyksXHJcbiAgICAgIGtleSA9IGtleUNvbnRlbnQgPyAoa2V5Q29udGVudC5sZW5ndGggPiAxID8gJycgOiBrZXlDb250ZW50KSA6ICcnLFxyXG4gICAgICBpbnNlcnRQb3NpdGlvbiA9IGZpbmRDYXJldFBvc2l0aW9uKHZhbHVlLCBtYXNrKSxcclxuICAgICAgbmV3VmFsdWUsXHJcbiAgICAgIHVubWFza2VkVmFsdWUsXHJcbiAgICAgIG1hc2tFcnJvciA9IGZhbHNlXHJcblxyXG4gICAgc3dpdGNoIChldmVudFR5cGUpIHtcclxuICAgICAgY2FzZSAncGFzdGUnOlxyXG4gICAgICAgIG5ld1ZhbHVlID0gbWFza0lmTm90TWFza2VkKFxyXG4gICAgICAgICAgKGUuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YSgnVGV4dCcpLFxyXG4gICAgICAgICAgbWFza1xyXG4gICAgICAgIClcclxuICAgICAgICBicmVha1xyXG4gICAgICBjYXNlICdrZXl1cCc6XHJcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGNhc2UgJ2tleXByZXNzJzpcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGlucHV0LnNlbGVjdGlvblN0YXJ0XHJcbiAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBpbnNlcnRQb3NpdGlvbikgaW5zZXJ0UG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydFxyXG5cclxuICAgICAgICBuZXdWYWx1ZSA9XHJcbiAgICAgICAgICB2YWx1ZS5zdWJzdHIoMCwgaW5zZXJ0UG9zaXRpb24pICsga2V5ICsgdmFsdWUuc3Vic3RyKGluc2VydFBvc2l0aW9uKVxyXG4gICAgICAgIGJyZWFrXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuXHJcbiAgICB1bm1hc2tlZFZhbHVlID0gdW5tYXNrKG5ld1ZhbHVlLCBtYXNrKVxyXG5cclxuICAgIGlmIChbMzUsIDM2LCAzNywgMzgsIDM5LCA0MF0uaW5kZXhPZihrZXlDb2RlKSA9PT0gLTEpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpbnB1dC52YWx1ZSA9IFN0cmluZ01hc2subWFzayh1bm1hc2tlZFZhbHVlLCBtYXNrLCBmYWxzZSlcclxuICAgICAgICBpZih0aGlzLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xyXG4gICAgICAgICAgaW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkID0gdW5tYXNrZWRWYWx1ZVxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmRvYy5xdWVyeVNlbGVjdG9yKFxyXG4gICAgICAgICAgICBgIyR7aW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpfS11bm1hc2tlZGBcclxuICAgICAgICAgICkudmFsdWUgPSB1bm1hc2tlZFZhbHVlXHJcbiAgICAgICAgICB0aGlzLl9fYXBwbHlDc3NDbGFzc1N0YXRlKGlucHV0LCAnc3VjY2VzcycpXHJcbiAgICAgICAgICB0aGlzLl9fZmlyZU9uVXBkYXRlKGlucHV0LnZhbHVlLCBpbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWQsIGlucHV0KVxyXG4gICAgICAgIH1cclxuICAgICAgICBtYXNrRXJyb3IgPSBmYWxzZVxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuX19hcHBseUNzc0NsYXNzU3RhdGUoaW5wdXQsICdlcnJvcicpXHJcbiAgICAgICAgdGhpcy5fX2ZpcmVPbkludmFsaWQoZXJyb3IsIGlucHV0KVxyXG4gICAgICAgIG1hc2tFcnJvciA9IHRydWVcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fdXBkYXRlQ2FyZXRQb3NpdGlvbihpbnB1dCwgbWFzaylcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1hc2tFcnJvcikgdGhpcy5fdmFsaWRhdGVJbnB1dChpbnB1dClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBmb2N1cyBldmVudHMgb24gdGhlIGlucHV0IGFuZCB1cGRhdGUgdGhlIGNhcmV0IHBvc2l0aW9uXHJcbiAgICogd2hlcmUgdGhlIG5leHQgY2hhciBzaG91bGQgYmUgaW5zZXJ0ZWQgYWNjb3JkaW5nIHRvIHRoZSBtYXNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGVcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfb25Gb2N1cyhlKSB7XHJcbiAgICBjb25zdCBpbnB1dCA9IGUudGFyZ2V0XHJcbiAgICBjb25zdCBtYXNrID0gaW5wdXQuZGF0YXNldC5tYXNrIHx8IHRoaXMub3B0aW9ucy5tYXNrXHJcbiAgICB0aGlzLl91cGRhdGVDYXJldFBvc2l0aW9uKGlucHV0LCBtYXNrKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBvbiB0aGUgaW5wdXQgYmFzZWQgb24gdGhlIGdpdmVuIG1hc2tcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayAgYmJqIHN0cmluZ1xyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF91cGRhdGVDYXJldFBvc2l0aW9uKGlucHV0LCBtYXNrKSB7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgY29uc3QgcG9zaXRpb24gPSBmaW5kQ2FyZXRQb3NpdGlvbihpbnB1dC52YWx1ZSwgbWFzaylcclxuICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zaXRpb24sIHBvc2l0aW9uKVxyXG4gICAgfSwgMClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgYGNoZWNrVmFsaWRpdHlgIG9uIHRoZSBpbnB1dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUlucHV0KGlucHV0KSB7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gaW5wdXQuY2hlY2tWYWxpZGl0eSgpXHJcblxyXG4gICAgaWYgKGlzVmFsaWQpIHtcclxuICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZShpbnB1dCwgJ3N1Y2Nlc3MnKVxyXG4gICAgICBpbnB1dC5zZXRDdXN0b21WYWxpZGl0eSgnJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19hcHBseUNzc0NsYXNzU3RhdGUoaW5wdXQsICdlcnJvcicpXHJcbiAgICAgIHRoaXMuX19maXJlT25JbnZhbGlkKGlucHV0LnZhbGlkYXRpb25NZXNzYWdlLCBpbnB1dClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNWYWxpZFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2ZpcmVPblVwZGF0ZSh2YWx1ZU1hc2tlZCwgdmFsdWVVbm1hc2tlZCwgaW5wdXQpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMub25VcGRhdGUpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKHZhbHVlTWFza2VkLCB2YWx1ZVVubWFza2VkLCBpbnB1dClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19maXJlT25JbnZhbGlkKGVycm9yLCBpbnB1dCkge1xyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkludmFsaWQpIHtcclxuICAgICAgdGhpcy5vcHRpb25zLm9uSW52YWxpZChlcnJvciwgaW5wdXQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fYXBwbHlDc3NDbGFzc1N0YXRlKGlucHV0LCBzdGF0ZSkge1xyXG4gICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSB8fCBpbnB1dC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykpIHtcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuICAgICAgaW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHN0YXRlID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3InKSB7XHJcbiAgICAgICAgaW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuICAgICAgICBpbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRJbnB1dFxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGV4dElucHV0L1RleHRJbnB1dC5qcyIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJhc2lzLWlucHV0LW1hc2tpbmcgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBTdHJpbmdNYXNrIGZyb20gJ2Jiai1tYXNrcy9zcmMvU3RyaW5nTWFzaydcclxuXHJcbmNvbnN0IFNVUFBPUlRFRF9NQVNLUyA9IFsnWCcsICdhJywgJ0EnLCAnMCcsICd6JywgJ1onLCAnVSddXHJcbi8qKlxyXG4gKiBXaGVuIHRydWUgLCB0aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIFVuaWNvZGUgUHJvcGVydHkgRXNjYXBlc1xyXG4gKiBvdGhlcndpc2UgaXQgaXMgZmFsc2UgXHJcbiAqIFxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcmVnZXhwLXVuaWNvZGUtcHJvcGVydHktZXNjYXBlc31cclxuICovXHJcbmxldCBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRCA9IGZhbHNlXHJcbnRyeSB7XHJcbiAgZXZhbCgnL1xcXFxwe0x9L3UnKVxyXG4gIElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEID0gdHJ1ZVxyXG59IGNhdGNoIChlcnIpIHtcclxuICBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRCA9IGZhbHNlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbWFza2VkIHdpdGggdGhlIGdpdmVuIG1hc2sgb3Igbm90XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBtYXNrZWQgb3IgdW5tYXNrZWQgdmFsdWVcclxuICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgIGEgYmJqIG1hc2tcclxuICpcclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSB3aGVuIHRoZSB2YWx1ZSBpcyBtYXNrZWQgd2l0aCBnaXZlbiBtYXNrICwgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5jb25zdCBpc01hc2tlZFZhbHVlID0gKHZhbHVlLCBtYXNrKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBpc01hc2tlZFZhbHVlLl9fQ0FDSEVfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGlzTWFza2VkVmFsdWUuX19DQUNIRV9fID0ge31cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7dmFsdWV9LSR7bWFza31gXHJcblxyXG4gIGlmICghaXNNYXNrZWRWYWx1ZS5fX0NBQ0hFX19bY2FjaGVLZXldKSB7XHJcbiAgICBjb25zdCB1bm1hc2tlZFZhbHVlID0gdW5tYXNrKHZhbHVlLCBtYXNrKVxyXG4gICAgaXNNYXNrZWRWYWx1ZS5fX0NBQ0hFX19bY2FjaGVLZXldID1cclxuICAgICAgdmFsdWUgPT09IFN0cmluZ01hc2subWFzayh1bm1hc2tlZFZhbHVlLCBtYXNrKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGlzTWFza2VkVmFsdWUuX19DQUNIRV9fW2NhY2hlS2V5XVxyXG59XHJcblxyXG4vKipcclxuICogTWFzayB0aGUgZ2l2ZW4gdmFsdWUgd2l0aCB0aGUgZ2l2ZW4gbWFzayBpbiBjYXNlIHRoZSB2YWx1ZSBpcyBub3QgYWxyZWFkeSBtYXNrZWQgd2l0aCB0aGVcclxuICogZ2l2ZW4gbWFza1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgbWFza2VkIG9yIHVubWFza2VkIHZhbHVlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrICBhIGJiaiBtYXNrXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gYSBtYXNrZWQgdmFsdWVcclxuICovXHJcbmNvbnN0IG1hc2tJZk5vdE1hc2tlZCA9ICh2YWx1ZSwgbWFzaykgPT4ge1xyXG4gIGlmICh0eXBlb2YgbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG1hc2tJZk5vdE1hc2tlZC5fX0NBQ0hFX18gPSB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHt2YWx1ZX0tJHttYXNrfWBcclxuXHJcbiAgaWYgKCFtYXNrSWZOb3RNYXNrZWQuX19DQUNIRV9fW2NhY2hlS2V5XSkge1xyXG4gICAgaWYgKGlzTWFza2VkVmFsdWUodmFsdWUsIG1hc2spKSB7XHJcbiAgICAgIG1hc2tJZk5vdE1hc2tlZC5fX0NBQ0hFX19bY2FjaGVLZXldID0gdmFsdWVcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfX1tjYWNoZUtleV0gPSBTdHJpbmdNYXNrLm1hc2soXHJcbiAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgIG1hc2ssXHJcbiAgICAgICAgICBmYWxzZVxyXG4gICAgICAgIClcclxuICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIG1hc2tJZk5vdE1hc2tlZC5fX0NBQ0hFX19bY2FjaGVLZXldID0gU3RyaW5nTWFzay5tYXNrKCcnLCBtYXNrKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWFza0lmTm90TWFza2VkLl9fQ0FDSEVfX1tjYWNoZUtleV1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmVnZXggcGF0dGVyIGJhc2VkIG9uIHRoZSBnaXZlIHRhc2tcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgIGJiaiBzdHJpbmcgbWFza1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJlZ2V4IGZvciB0aGUgZ2l2ZSBtYXNrXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzayA9IG1hc2sgPT4ge1xyXG4gIGlmICh0eXBlb2YgZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2suX19DQUNIRV9fID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2suX19DQUNIRV9fID0ge31cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhY2hlS2V5ID0gbWFza1xyXG5cclxuICBpZiAoIWdlbmVyYXRlUGF0dGVybkZyb21NYXNrLl9fQ0FDSEVfX1tjYWNoZUtleV0pIHtcclxuICAgIGNvbnN0IG1hc2tBc0FycnkgPSBtYXNrLnNwbGl0KCcnKVxyXG4gICAgbGV0IHJlZ2V4ID0gJydcclxuICAgIG1hc2tBc0FycnkuZm9yRWFjaChjID0+IHtcclxuICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgY2FzZSAnWCc6XHJcbiAgICAgICAgICByZWdleCArPSAnKFteIC1+XSknXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9tb3RoZXJlZmYuaW4vcmVnZXhwdSNpbnB1dD12YXIrcmVnZXgrJTNEKy8lNUNwJTdCTCU3RC91JTNCJnVuaWNvZGVQcm9wZXJ0eUVzY2FwZT0xXHJcbiAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTAwMzMvcmVndWxhci1leHByZXNzaW9uLXRvLW1hdGNoLW5vbi1hc2NpaS1jaGFyYWN0ZXJzI2Fuc3dlci00ODkwMjc2NVxyXG4gICAgICAgICAgcmVnZXggKz0gSVNfVU5JQ09ERV9QUk9QRVJUWV9TVVBQT1JURURcclxuICAgICAgICAgICAgPyAnXFxcXHB7TH0nXHJcbiAgICAgICAgICAgIDogJygoPzpbQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1RDAtXFx1MDVFQVxcdTA1RUYtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NkFcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTA5RkNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg2LVxcdTBFOEFcXHUwRThDLVxcdTBFQTNcXHUwRUE1XFx1MEVBNy1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkYxLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3OFxcdTE4ODAtXFx1MTg4NFxcdTE4ODctXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQzkwLVxcdTFDQkFcXHUxQ0JELVxcdTFDQkZcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjNcXHUxQ0Y1XFx1MUNGNlxcdTFDRkFcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE4M1xcdTIxODRcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1XFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM0JcXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJGXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkVGXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RTVcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QkZcXHVBN0MyLVxcdUE3QzZcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE4RkVcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY3XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYyRC1cXHVERjQwXFx1REY0Mi1cXHVERjQ5XFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzVcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXFx1REQwMC1cXHVERDIzXFx1REYwMC1cXHVERjFDXFx1REYyN1xcdURGMzAtXFx1REY0NVxcdURGRTAtXFx1REZGNl18XFx1RDgwNFtcXHVEQzAzLVxcdURDMzdcXHVEQzgzLVxcdURDQUZcXHVEQ0QwLVxcdURDRThcXHVERDAzLVxcdUREMjZcXHVERDQ0XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzAwLVxcdURDMzRcXHVEQzQ3LVxcdURDNEFcXHVEQzVGXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURFQjhcXHVERjAwLVxcdURGMUFdfFxcdUQ4MDZbXFx1REMwMC1cXHVEQzJCXFx1RENBMC1cXHVEQ0RGXFx1RENGRlxcdUREQTAtXFx1RERBN1xcdUREQUEtXFx1REREMFxcdURERTFcXHVEREUzXFx1REUwMFxcdURFMEItXFx1REUzMlxcdURFM0FcXHVERTUwXFx1REU1Qy1cXHVERTg5XFx1REU5RFxcdURFQzAtXFx1REVGOF18XFx1RDgwN1tcXHVEQzAwLVxcdURDMDhcXHVEQzBBLVxcdURDMkVcXHVEQzQwXFx1REM3Mi1cXHVEQzhGXFx1REQwMC1cXHVERDA2XFx1REQwOFxcdUREMDlcXHVERDBCLVxcdUREMzBcXHVERDQ2XFx1REQ2MC1cXHVERDY1XFx1REQ2N1xcdURENjhcXHVERDZBLVxcdUREODlcXHVERDk4XFx1REVFMC1cXHVERUYyXXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXFx1RDg3NC1cXHVEODc5XVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERUQwLVxcdURFRURcXHVERjAwLVxcdURGMkZcXHVERjQwLVxcdURGNDNcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REU0MC1cXHVERTdGXFx1REYwMC1cXHVERjRBXFx1REY1MFxcdURGOTMtXFx1REY5RlxcdURGRTBcXHVERkUxXFx1REZFM118XFx1RDgyMVtcXHVEQzAwLVxcdURGRjddfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDAtXFx1REQxRVxcdURENTAtXFx1REQ1MlxcdURENjQtXFx1REQ2N1xcdURENzAtXFx1REVGQl18XFx1RDgyRltcXHVEQzAwLVxcdURDNkFcXHVEQzcwLVxcdURDN0NcXHVEQzgwLVxcdURDODhcXHVEQzkwLVxcdURDOTldfFxcdUQ4MzVbXFx1REMwMC1cXHVEQzU0XFx1REM1Ni1cXHVEQzlDXFx1REM5RVxcdURDOUZcXHVEQ0EyXFx1RENBNVxcdURDQTZcXHVEQ0E5LVxcdURDQUNcXHVEQ0FFLVxcdURDQjlcXHVEQ0JCXFx1RENCRC1cXHVEQ0MzXFx1RENDNS1cXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REVBNVxcdURFQTgtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZDQl18XFx1RDgzOFtcXHVERDAwLVxcdUREMkNcXHVERDM3LVxcdUREM0RcXHVERDRFXFx1REVDMC1cXHVERUVCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M1xcdURENEJdfFxcdUQ4M0JbXFx1REUwMC1cXHVERTAzXFx1REUwNS1cXHVERTFGXFx1REUyMVxcdURFMjJcXHVERTI0XFx1REUyN1xcdURFMjktXFx1REUzMlxcdURFMzQtXFx1REUzN1xcdURFMzlcXHVERTNCXFx1REU0MlxcdURFNDdcXHVERTQ5XFx1REU0QlxcdURFNEQtXFx1REU0RlxcdURFNTFcXHVERTUyXFx1REU1NFxcdURFNTdcXHVERTU5XFx1REU1QlxcdURFNURcXHVERTVGXFx1REU2MVxcdURFNjJcXHVERTY0XFx1REU2Ny1cXHVERTZBXFx1REU2Qy1cXHVERTcyXFx1REU3NC1cXHVERTc3XFx1REU3OS1cXHVERTdDXFx1REU3RVxcdURFODAtXFx1REU4OVxcdURFOEItXFx1REU5QlxcdURFQTEtXFx1REVBM1xcdURFQTUtXFx1REVBOVxcdURFQUItXFx1REVCQl18XFx1RDg2OVtcXHVEQzAwLVxcdURFRDZcXHVERjAwLVxcdURGRkZdfFxcdUQ4NkRbXFx1REMwMC1cXHVERjM0XFx1REY0MC1cXHVERkZGXXxcXHVEODZFW1xcdURDMDAtXFx1REMxRFxcdURDMjAtXFx1REZGRl18XFx1RDg3M1tcXHVEQzAwLVxcdURFQTFcXHVERUIwLVxcdURGRkZdfFxcdUQ4N0FbXFx1REMwMC1cXHVERkUwXXxcXHVEODdFW1xcdURDMDAtXFx1REUxRF0pKSdcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICByZWdleCArPSAnKFswLTldKSdcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgICByZWdleCArPSBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRFxyXG4gICAgICAgICAgICA/ICcoWzAtOV18XFxcXHB7TH0pJ1xyXG4gICAgICAgICAgICA6ICcoWzAtOV18KD86W0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4Ni1cXHUwRThBXFx1MEU4Qy1cXHUwRUEzXFx1MEVBNVxcdTBFQTctXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUM5MC1cXHUxQ0JBXFx1MUNCRC1cXHUxQ0JGXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YzXFx1MUNGNVxcdTFDRjZcXHUxQ0ZBXFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRlxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFRlxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0M2XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2N1xcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMkQtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdUREMDAtXFx1REQyM1xcdURGMDAtXFx1REYxQ1xcdURGMjdcXHVERjMwLVxcdURGNDVcXHVERkUwLVxcdURGRjZdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ0NFxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1RlxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERUI4XFx1REYwMC1cXHVERjFBXXxcXHVEODA2W1xcdURDMDAtXFx1REMyQlxcdURDQTAtXFx1RENERlxcdURDRkZcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdURFRTAtXFx1REVGMl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OV1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU3RlxcdURGMDAtXFx1REY0QVxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMVxcdURGRTNdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkY3XXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDUwLVxcdURENTJcXHVERDY0LVxcdURENjdcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4MzhbXFx1REQwMC1cXHVERDJDXFx1REQzNy1cXHVERDNEXFx1REQ0RVxcdURFQzAtXFx1REVFQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNcXHVERDRCXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdKSknXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGNhc2UgJ1UnOlxyXG4gICAgICAgICAgcmVnZXggKz0gSVNfVU5JQ09ERV9QUk9QRVJUWV9TVVBQT1JURURcclxuICAgICAgICAgICAgPyAnKChbMC05XSl8KFxcXFxzKXwoWy4sLyMhJCVeJio7Ont9PS1fYH4oKV0pfChcXFxccHtMfSkpJ1xyXG4gICAgICAgICAgICA6ICcoKFswLTldKXwoXFxcXHMpfChbLiwvIyEkJV4mKjs6e309LV9gfigpXSl8KD86W0EtWmEtelxceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYwLVxcdTA1ODhcXHUwNUQwLVxcdTA1RUFcXHUwNUVGLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDg2MC1cXHUwODZBXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwOUZDXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEFGOVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNTgtXFx1MEM1QVxcdTBDNjBcXHUwQzYxXFx1MEM4MFxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1NC1cXHUwRDU2XFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4Ni1cXHUwRThBXFx1MEU4Qy1cXHUwRUEzXFx1MEVBNVxcdTBFQTctXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZGMS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUM5MC1cXHUxQ0JBXFx1MUNCRC1cXHUxQ0JGXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YzXFx1MUNGNVxcdTFDRjZcXHUxQ0ZBXFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRlxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZFRlxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0JGXFx1QTdDMi1cXHVBN0M2XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOEZFXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI2N1xcdUFCNzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURGMDAtXFx1REYxRlxcdURGMkQtXFx1REY0MFxcdURGNDItXFx1REY0OVxcdURGNTAtXFx1REY3NVxcdURGODAtXFx1REY5RFxcdURGQTAtXFx1REZDM1xcdURGQzgtXFx1REZDRl18XFx1RDgwMVtcXHVEQzAwLVxcdURDOURcXHVEQ0IwLVxcdURDRDNcXHVEQ0Q4LVxcdURDRkJcXHVERDAwLVxcdUREMjdcXHVERDMwLVxcdURENjNcXHVERTAwLVxcdURGMzZcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNjddfFxcdUQ4MDJbXFx1REMwMC1cXHVEQzA1XFx1REMwOFxcdURDMEEtXFx1REMzNVxcdURDMzdcXHVEQzM4XFx1REMzQ1xcdURDM0YtXFx1REM1NVxcdURDNjAtXFx1REM3NlxcdURDODAtXFx1REM5RVxcdURDRTAtXFx1RENGMlxcdURDRjRcXHVEQ0Y1XFx1REQwMC1cXHVERDE1XFx1REQyMC1cXHVERDM5XFx1REQ4MC1cXHVEREI3XFx1RERCRVxcdUREQkZcXHVERTAwXFx1REUxMC1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTM1XFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU0XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMlxcdUREMDAtXFx1REQyM1xcdURGMDAtXFx1REYxQ1xcdURGMjdcXHVERjMwLVxcdURGNDVcXHVERkUwLVxcdURGRjZdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ0NFxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM1RlxcdURDODAtXFx1RENBRlxcdURDQzRcXHVEQ0M1XFx1RENDN1xcdUREODAtXFx1RERBRVxcdURERDgtXFx1REREQlxcdURFMDAtXFx1REUyRlxcdURFNDRcXHVERTgwLVxcdURFQUFcXHVERUI4XFx1REYwMC1cXHVERjFBXXxcXHVEODA2W1xcdURDMDAtXFx1REMyQlxcdURDQTAtXFx1RENERlxcdURDRkZcXHVEREEwLVxcdUREQTdcXHVEREFBLVxcdURERDBcXHVEREUxXFx1RERFM1xcdURFMDBcXHVERTBCLVxcdURFMzJcXHVERTNBXFx1REU1MFxcdURFNUMtXFx1REU4OVxcdURFOURcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzJFXFx1REM0MFxcdURDNzItXFx1REM4RlxcdUREMDAtXFx1REQwNlxcdUREMDhcXHVERDA5XFx1REQwQi1cXHVERDMwXFx1REQ0NlxcdURENjAtXFx1REQ2NVxcdURENjdcXHVERDY4XFx1REQ2QS1cXHVERDg5XFx1REQ5OFxcdURFRTAtXFx1REVGMl18XFx1RDgwOFtcXHVEQzAwLVxcdURGOTldfFxcdUQ4MDlbXFx1REM4MC1cXHVERDQzXXxbXFx1RDgwQ1xcdUQ4MUMtXFx1RDgyMFxcdUQ4NDAtXFx1RDg2OFxcdUQ4NkEtXFx1RDg2Q1xcdUQ4NkYtXFx1RDg3MlxcdUQ4NzQtXFx1RDg3OV1bXFx1REMwMC1cXHVERkZGXXxcXHVEODBEW1xcdURDMDAtXFx1REMyRV18XFx1RDgxMVtcXHVEQzAwLVxcdURFNDZdfFxcdUQ4MUFbXFx1REMwMC1cXHVERTM4XFx1REU0MC1cXHVERTVFXFx1REVEMC1cXHVERUVEXFx1REYwMC1cXHVERjJGXFx1REY0MC1cXHVERjQzXFx1REY2My1cXHVERjc3XFx1REY3RC1cXHVERjhGXXxcXHVEODFCW1xcdURFNDAtXFx1REU3RlxcdURGMDAtXFx1REY0QVxcdURGNTBcXHVERjkzLVxcdURGOUZcXHVERkUwXFx1REZFMVxcdURGRTNdfFxcdUQ4MjFbXFx1REMwMC1cXHVERkY3XXxcXHVEODIyW1xcdURDMDAtXFx1REVGMl18XFx1RDgyQ1tcXHVEQzAwLVxcdUREMUVcXHVERDUwLVxcdURENTJcXHVERDY0LVxcdURENjdcXHVERDcwLVxcdURFRkJdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzZBXFx1REM3MC1cXHVEQzdDXFx1REM4MC1cXHVEQzg4XFx1REM5MC1cXHVEQzk5XXxcXHVEODM1W1xcdURDMDAtXFx1REM1NFxcdURDNTYtXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1REQwNVxcdUREMDctXFx1REQwQVxcdUREMEQtXFx1REQxNFxcdUREMTYtXFx1REQxQ1xcdUREMUUtXFx1REQzOVxcdUREM0ItXFx1REQzRVxcdURENDAtXFx1REQ0NFxcdURENDZcXHVERDRBLVxcdURENTBcXHVERDUyLVxcdURFQTVcXHVERUE4LVxcdURFQzBcXHVERUMyLVxcdURFREFcXHVERURDLVxcdURFRkFcXHVERUZDLVxcdURGMTRcXHVERjE2LVxcdURGMzRcXHVERjM2LVxcdURGNEVcXHVERjUwLVxcdURGNkVcXHVERjcwLVxcdURGODhcXHVERjhBLVxcdURGQThcXHVERkFBLVxcdURGQzJcXHVERkM0LVxcdURGQ0JdfFxcdUQ4MzhbXFx1REQwMC1cXHVERDJDXFx1REQzNy1cXHVERDNEXFx1REQ0RVxcdURFQzAtXFx1REVFQl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQzRcXHVERDAwLVxcdURENDNcXHVERDRCXXxcXHVEODNCW1xcdURFMDAtXFx1REUwM1xcdURFMDUtXFx1REUxRlxcdURFMjFcXHVERTIyXFx1REUyNFxcdURFMjdcXHVERTI5LVxcdURFMzJcXHVERTM0LVxcdURFMzdcXHVERTM5XFx1REUzQlxcdURFNDJcXHVERTQ3XFx1REU0OVxcdURFNEJcXHVERTRELVxcdURFNEZcXHVERTUxXFx1REU1MlxcdURFNTRcXHVERTU3XFx1REU1OVxcdURFNUJcXHVERTVEXFx1REU1RlxcdURFNjFcXHVERTYyXFx1REU2NFxcdURFNjctXFx1REU2QVxcdURFNkMtXFx1REU3MlxcdURFNzQtXFx1REU3N1xcdURFNzktXFx1REU3Q1xcdURFN0VcXHVERTgwLVxcdURFODlcXHVERThCLVxcdURFOUJcXHVERUExLVxcdURFQTNcXHVERUE1LVxcdURFQTlcXHVERUFCLVxcdURFQkJdfFxcdUQ4NjlbXFx1REMwMC1cXHVERUQ2XFx1REYwMC1cXHVERkZGXXxcXHVEODZEW1xcdURDMDAtXFx1REYzNFxcdURGNDAtXFx1REZGRl18XFx1RDg2RVtcXHVEQzAwLVxcdURDMURcXHVEQzIwLVxcdURGRkZdfFxcdUQ4NzNbXFx1REMwMC1cXHVERUExXFx1REVCMC1cXHVERkZGXXxcXHVEODdBW1xcdURDMDAtXFx1REZFMF18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdKSknXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZWdleCArPSBjLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJylcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2suX19DQUNIRV9fW2NhY2hlS2V5XSA9IHJlZ2V4XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZ2VuZXJhdGVQYXR0ZXJuRnJvbU1hc2suX19DQUNIRV9fW2NhY2hlS2V5XVxyXG59XHJcblxyXG4vKipcclxuICogVW5tYXNrIHRoZSBnaXZlbiB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFza2VkVmFsdWUgbWFza2VkIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFzayAgdGhlIHVzZWQgbWFzayB0byBwcm9kdWNlIHRoZSBtYXNrZWQgc3RyaW5nXHJcbiAqL1xyXG5jb25zdCB1bm1hc2sgPSAobWFza2VkVmFsdWUsIG1hc2spID0+IHtcclxuICBpZiAodHlwZW9mIHVubWFzay5fX0NBQ0hFX18gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB1bm1hc2suX19DQUNIRV9fID0ge31cclxuICB9XHJcblxyXG4gIGNvbnN0IGNhY2hlS2V5ID0gYCR7bWFza2VkVmFsdWV9LSR7bWFza31gXHJcblxyXG4gIGlmICghdW5tYXNrLl9fQ0FDSEVfX1tjYWNoZUtleV0pIHtcclxuICAgIGNvbnN0IG1hc2tBc0FycmF5ID0gbWFzay5zcGxpdCgnJylcclxuICAgIGNvbnN0IG1hc2tlZFZhbHVlQXNBcnJheSA9IG1hc2tlZFZhbHVlLnNwbGl0KCcnKVxyXG5cclxuICAgIGxldCB1bm1hc2tlZCA9ICcnXHJcblxyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1hc2tlZFZhbHVlQXNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgY29uc3QgZWwgPSBtYXNrZWRWYWx1ZUFzQXJyYXlbaW5kZXhdXHJcbiAgICAgIGNvbnN0IG1hc2sgPSBtYXNrQXNBcnJheVtpbmRleF1cclxuICAgICAgY29uc3QgZWxIYXNNYXNrID0gU1VQUE9SVEVEX01BU0tTLmluZGV4T2YobWFzaykgPiAtMVxyXG4gICAgICBpZiAoZWxIYXNNYXNrKSB7XHJcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzayhtYXNrKSxcclxuICAgICAgICAgIElTX1VOSUNPREVfUFJPUEVSVFlfU1VQUE9SVEVEID8gJ3UnIDogJydcclxuICAgICAgICApXHJcbiAgICAgICAgaWYgKHBhdHRlcm4udGVzdChlbCkpIHVubWFza2VkICs9IGVsXHJcbiAgICAgICAgZWxzZSBicmVha1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdW5tYXNrLl9fQ0FDSEVfX1tjYWNoZUtleV0gPSB1bm1hc2tlZC50b0xvY2FsZUxvd2VyQ2FzZSgpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdW5tYXNrLl9fQ0FDSEVfX1tjYWNoZUtleV1cclxufVxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHRoZSBtYXNrZWQgc3RyaW5nICwgZmluZCB0aGUgbmV4dCBjYXJldCBwb3NpdGlvbiBkZXBlbmRpbmcgb25cclxuICogd2hhdCBpcyBtaXNzaW5nIHRvIGNvbXBsZXRlIHRoZSBtYXNrXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrZWRWYWx1ZSBtYXNrZWQgc3RyaW5nXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrICB0aGUgdXNlZCBtYXNrIHRvIHByb2R1Y2UgdGhlIG1hc2tlZCBzdHJpbmdcclxuICovXHJcbmNvbnN0IGZpbmRDYXJldFBvc2l0aW9uID0gKG1hc2tlZFZhbHVlLCBtYXNrKSA9PiB7XHJcbiAgaWYgKHR5cGVvZiBmaW5kQ2FyZXRQb3NpdGlvbi5fX0NBQ0hFX18gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBmaW5kQ2FyZXRQb3NpdGlvbi5fX0NBQ0hFX18gPSB7fVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY2FjaGVLZXkgPSBgJHttYXNrZWRWYWx1ZX0tJHttYXNrfWBcclxuICBpZiAoIWZpbmRDYXJldFBvc2l0aW9uLl9fQ0FDSEVfX1tjYWNoZUtleV0pIHtcclxuICAgIGNvbnN0IG1hc2tBc0FycmF5ID0gbWFzay5zcGxpdCgnJylcclxuICAgIGxldCBtYXNrZWRWYWx1ZUFzQXJyYXkgPSBtYXNrZWRWYWx1ZS5zcGxpdCgnJylcclxuICAgIGlmIChtYXNrZWRWYWx1ZUFzQXJyYXkubGVuZ3RoIDwgbWFza0FzQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgIG1hc2tlZFZhbHVlQXNBcnJheSA9IG1hc2tlZFZhbHVlQXNBcnJheS5jb25jYXQoXHJcbiAgICAgICAgbmV3IEFycmF5KG1hc2tBc0FycmF5Lmxlbmd0aCAtIG1hc2tlZFZhbHVlQXNBcnJheS5sZW5ndGgpLmpvaW4oJyAnKS5zcGxpdCgnJylcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBwb3NpdGlvbiA9IC0xXHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWFza0FzQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gbWFza0FzQXJyYXlbaW5kZXhdXHJcbiAgICAgIGlmIChlbCAhPT0gbWFza2VkVmFsdWVBc0FycmF5W2luZGV4XSkge1xyXG4gICAgICAgIC8vIGlmIChtYXNrZWRWYWx1ZUFzQXJyYXlbaW5kZXhdID09PSAnICcpIHJldHVybiBpbmRleFxyXG4gICAgICAgIGlmIChTVVBQT1JURURfTUFTS1MuaW5kZXhPZihlbCkgPiAtMSkge1xyXG4gICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgIGdlbmVyYXRlUGF0dGVybkZyb21NYXNrKGVsKSxcclxuICAgICAgICAgICAgSVNfVU5JQ09ERV9QUk9QRVJUWV9TVVBQT1JURUQgPyAndScgOiAnJ1xyXG4gICAgICAgICAgKVxyXG5cclxuICAgICAgICAgIGlmICghcGF0dGVybi50ZXN0KG1hc2tlZFZhbHVlQXNBcnJheVtpbmRleF0pKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaW5kZXhcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmaW5kQ2FyZXRQb3NpdGlvbi5fX0NBQ0hFX19bY2FjaGVLZXldID1cclxuICAgICAgcG9zaXRpb24gPCAwID8gbWFza2VkVmFsdWVBc0FycmF5Lmxlbmd0aCA6IHBvc2l0aW9uXHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluZENhcmV0UG9zaXRpb24uX19DQUNIRV9fW2NhY2hlS2V5XVxyXG59XHJcblxyXG5leHBvcnQge1xyXG4gIGlzTWFza2VkVmFsdWUsXHJcbiAgbWFza0lmTm90TWFza2VkLFxyXG4gIHVubWFzayxcclxuICBmaW5kQ2FyZXRQb3NpdGlvbixcclxuICBnZW5lcmF0ZVBhdHRlcm5Gcm9tTWFzayxcclxuICBJU19VTklDT0RFX1BST1BFUlRZX1NVUFBPUlRFRCxcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVGV4dElucHV0L3Rvb2xzLmpzIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmFzaXMtaW5wdXQtbWFza2luZyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IE51bWJlcklucHV0IGZyb20gJy4vTnVtYmVySW5wdXQnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJJbnB1dFxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTnVtYmVySW5wdXQvaW5kZXguanMiLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYXNpcy1pbnB1dC1tYXNraW5nIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgTnVtYmVyTWFzayBmcm9tICdiYmotbWFza3Mvc3JjL051bWJlck1hc2snXHJcblxyXG5jb25zdCBjb3VudERlY2ltYWxzID0gdmFsdWUgPT4ge1xyXG4gIGlmICh2YWx1ZSAlIDEgIT0gMCkge1xyXG4gICAgY29uc3Qgc3BsaXQgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJylcclxuICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDIpIHJldHVybiBzcGxpdFsxXS5sZW5ndGhcclxuICB9XHJcbiAgcmV0dXJuIDBcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBgTnVtYmVySW5wdXRgIHdpbGwgd3JhcCB0ZXh0IGlucHV0cyBhbmQgYXBwbHkgdGhlIGdpdmVuIFtiYmogTnVtYmVyIG1hc2tdKGh0dHBzOi8vZ2l0aHViLmNvbS9CYXNpc0h1Yi9iYmotbWFza3MjbnVtYmVyLW1hc2tzKVxyXG4gKlxyXG4gKiAqKk9wdGlvbnMqKlxyXG4gKlxyXG4gKiBfT3B0aW9ucyBjYW4gYmUgcGFzc2VkIHZpYSBkYXRhIGF0dHJpYnV0ZXMgLiBGb3IgZGF0YSBhdHRyaWJ1dGVzLCBhcHBlbmQgdGhlIG9wdGlvbiBuYW1lIHRvIGRhdGEtLCBhcyBpbiBkYXRhLW1hc2tfXHJcbiAqXHJcbiAqIHwgT3B0aW9uICAgIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiB8LS0tLS0tLS0tLS18LS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcclxuICogfCBtYXNrIHwgICAgICAgICB8IFRoZSBiYmogbnVtYmVyIG1hc2sgQHNlZSBbQkJqIE51bWJlciBNYXNrc10oaHR0cHM6Ly9naXRodWIuY29tL0Jhc2lzSHViL2Jiai1tYXNrcyNudW1iZXItbWFza3MpIHxcclxuICogfCBtaW4gfCAgICAgICAgIHwgVGhlIG1heGltdW0gdmFsdWUgdG8gYWNjZXB0IGZvciB0aGlzIGlucHV0fFxyXG4gKiB8IG1heCB8ICAgICAgICAgfCBUaGUgbWluaW11bSB2YWx1ZSB0byBhY2NlcHQgZm9yIHRoaXMgaW5wdXR8XHJcbiAqIHwgc3RlcCB8ICAgICAgICAgfCBBIHN0ZXBwaW5nIGludGVydmFsIHRvIHVzZSB3aGVuIHVzaW5nIHVwIGFuZCBkb3duIGFycm93cyB0byBhZGp1c3QgdGhlIHZhbHVlLCBhcyB3ZWxsIGFzIGZvciB2YWxpZGF0aW9ufFxyXG4gKiB8Z3JvdXBpbmctc2VwYXJhdG9yIHwgLCB8IGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBncm91cGluZyBzZXBhcmF0b3IgfFxyXG4gKiB8ZGVjaW1hbC1zZXBhcmF0b3IgfCAuIHwgYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGRlY2ltYWwgc2VwYXJhdG9yIHxcclxuICogfGZvcmNlLXRyYWlsaW5nLXplcm9zIHwgZmFsc2UgfCBBZmZlY3RzIHRoZSBvdXRwdXQgYnkgc3dpdGNoaW5nIHRoZSB3YXkgYSBtYXNrIHdpdGggXCIjXCIgY2hhcmFjdGVycyBpbiB0aGUgdHJhaWxpbmcgcG9zaXRpb25zIGlzIGZpbGxlZC4gZm9yIGV4YW1wbGUsIHRoZSBmdW5jdGlvbiBOdW1iZXJNYXNrLm1hc2soLjEwOlwiIy4jI1wiKSByZXR1cm5zIC4xMCBpbnN0ZWFkIG9mIC4xfFxyXG4gKlxyXG4gKiAgPGJyPlxyXG4gKlxyXG4gKiAqKkV4YW1wbGUgOioqXHJcbiAqIGBgYGh0bWxcclxuICogIDxpbnB1dCBjbGFzcz1cImJiai1udW1iZXItbWFza2VkXCIgbmFtZT1cInRlc3RcIiBpZD1cInRlc3RcIiB2YWx1ZT1cIjEyMzRcIiBkYXRhLW1hc2s9XCIjIywjIzBcIj5cclxuICpcclxuICogIDxzY3JpcHQ+XHJcbiAqICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoZSkge1xyXG4gKiAgICAgIG5ldyBCYXNpcy5JbnB1dE1hc2tpbmcuTnVtYmVySW5wdXQoe1xyXG4gKlxyXG4gKiAgICAgICAgIC8vIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZU1hc2tlZCAgbWFza2VkIHZhbHVlXHJcbiAqICAgICAgICAgLy8gQHBhcmFtIHtOdW1iZXJ9IHZhbHVlVW5tYXNrZWQgIG9yaWdpbmFsIHZhbHVlXHJcbiAqICAgICAgICAgLy8gQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCB0aGUgYWN0dWFsIGlucHV0IGluc3RhbmNlXHJcbiAqICAgICAgICAgb25VcGRhdGU6ICh2YWx1ZU1hc2tlZCwgdmFsdWVVbm1hc2tlZCwgaW5wdXQsIGlzQXBwbGllZCwgaXNJbml0aWFsKSA9PiB7XHJcbiAqICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nXHJcbiAqICAgICAgICAgfSxcclxuICpcclxuICogICAgICAgICAvLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVycm9yIGxhc3Qgb2NjdXJyZWQgZXJyb3IuIGNvdWxkIGJlIG1hc2sgZXJyb3Igb3IgdmFsaWRhdGlvbiBlcnJvclxyXG4gKiAgICAgICAgIC8vIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgdGhlIGFjdHVhbCBpbnB1dCBpbnN0YW5jZVxyXG4gKiAgICAgICAgIG9uSW52YWxpZDogKGVyciAsIGlucHV0KSA9PiB7XHJcbiAqICAgICAgICAgICAgLy8gZG8gc29tZXRoaW5nXHJcbiAqICAgICAgICAgfVxyXG4gKiAgICAgIH0pXHJcbiAqICAgIH0pXHJcbiAqICA8L3NjcmlwdD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG5jbGFzcyBOdW1iZXJJbnB1dCB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IG5ldyBOdW1iZXJJbnB1dFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBvcHRpb25zIC0gVGhlIGlucHV0IG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtvcHRpb25zLmVsZW1lbnRzPVwiLmJiai1udW1iZXItbWFza2VkXCJdIC0gVGhlIGNsYXNzIG5hbWUgb3IgdGhlIG5vZGUgdG8gdXNlXHJcbiAgICogQHBhcmFtIHtIVE1MRG9jdW1lbnR9IFtvcHRpb25zLmRvY3VtZW50PWRvY3VtZW50XSAtIERvY3VtZW50IGluc3RhbmNlIHRvIHVzZVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jc3NDbGFzc0Vycm9yPVwiYmJqLW1hc2stZXJyb3JcIl0gLSBBIGNzcyBjbGFzcyB0byBhdHRhY2ggdG8gdGhlIGlucHV0IHdoZW4gaXQgaXMgaW52YWxpZFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3M9XCJiYmotbWFzay1zdWNjZXNzXCJdIC0gQSBjc3MgY2xhc3MgdG8gYXR0YWNoIHRvIHRoZSBpbnB1dCB3aGVuIGl0IGlzIHZhbGlkIGFmdGVyIHRoZSB1c2VyIGludGVyYWN0aW9uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25VcGRhdGU9bnVsbF0gLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiB0aGUgbmV3IG1hc2tlZCB2YWx1ZSBpcyBzZXRcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkludmFsaWQ9bnVsbF0gLSBBIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiB0aGUgaW5wdXQgb3IgdGhlIG1hc2sgaXMgaW52YWxpZFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgdGhpcy5vcHRpb25zID0ge1xyXG4gICAgICAuLi57XHJcbiAgICAgICAgZWxlbWVudHM6ICcuYmJqLW51bWJlci1tYXNrZWQnLFxyXG4gICAgICAgIGRvYzogZG9jdW1lbnQsXHJcbiAgICAgICAgY3NzQ2xhc3NFcnJvcjogJ2Jiai1tYXNrLWVycm9yJyxcclxuICAgICAgICBjc3NDbGFzc1N1Y2Nlc3M6ICdiYmotbWFzay1zdWNjZXNzJyxcclxuICAgICAgICBvblVwZGF0ZTogbnVsbCxcclxuICAgICAgICBvbkludmFsaWQ6IG51bGwsXHJcbiAgICAgIH0sXHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fYWN0dWFsSW5wdXRIYW5kbGVyID0gdGhpcy5fYWN0dWFsSW5wdXRIYW5kbGVyLmJpbmQodGhpcylcclxuICAgIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyID0gdGhpcy5fdW5tYXNrZWRJbnB1dEhhbmRsZXIuYmluZCh0aGlzKVxyXG4gICAgdGhpcy5yZWZyZXNoKClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBhbmQgd3JhcCB0aGUgaW5wdXQgZWxlbWVudHMgZm9yIG1hc2tpbmcgaW4gY2FzZVxyXG4gICAqIHRoZXkgYXJlIG5vdCB3cmFwcGVkIHlldFxyXG4gICAqL1xyXG4gIHJlZnJlc2goKSB7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9XHJcbiAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmVsZW1lbnRzKVxyXG4gICAgICAgIDogdGhpcy5vcHRpb25zLmVsZW1lbnRzXHJcbiAgICBsZXQgaW5wdXQsIHBhcmVudENsYXNzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpbnB1dCA9IGVsZW1lbnRzW2ldXHJcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcclxuICAgICAgICBwYXJlbnRDbGFzcyA9IGlucHV0LnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpXHJcblxyXG4gICAgICAgIGlmICghaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICAgIGBCQmpNYXNraW5nOiBJbnB1dCBoYXMgbm8gSUQuIFdpdGhvdXQgYW4gSUQgdGhlIGlucHV0IGNhbm5vdCBiZSBtYXNrZWRgLFxyXG4gICAgICAgICAgICBpbnB1dFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHdlIGRvbid0IGluaXRpYWxpemUgdGhlIGlucHV0J3Mgd3JhcCB0d2ljZVxyXG4gICAgICAgIGNvbnN0IGlzV3JhcHBlZCA9XHJcbiAgICAgICAgICBwYXJlbnRDbGFzcyAmJiBwYXJlbnRDbGFzcy5pbmRleE9mKCdudW1iZXJJbnB1dE1hc2tfX3dyYXAnKSA+IC0xXHJcbiAgICAgICAgdGhpcy5fd3JhcChpbnB1dCwgaXNXcmFwcGVkKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBCQmpNYXNraW5nOiBJbnZhbGlkIGlucHV0IGVsZW1lbnQuIFRoZSBlbGVtZW50IHdpbGwgYmUgaWdub3JlZGAsXHJcbiAgICAgICAgICBpbnB1dFxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVW53cmFwIHRoZSBpbnB1dCBlbGVtZW50cyBhbmQgcmVtb3ZlIGF0dGFjaGVkIGxpc3RlbmVyc1xyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9XHJcbiAgICAgIHR5cGVvZiB0aGlzLm9wdGlvbnMuZWxlbWVudHMgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgPyB0aGlzLm9wdGlvbnMuZG9jLnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5vcHRpb25zLmVsZW1lbnRzKVxyXG4gICAgICAgIDogdGhpcy5vcHRpb25zLmVsZW1lbnRzXHJcblxyXG4gICAgbGV0IGlucHV0LCBwYXJlbnQsIHBhcmVudENsYXNzXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpbnB1dCA9IGVsZW1lbnRzW2ldXHJcbiAgICAgIHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGVcclxuICAgICAgcGFyZW50Q2xhc3MgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpXHJcblxyXG4gICAgICBpZiAocGFyZW50Q2xhc3MgJiYgcGFyZW50Q2xhc3MuaW5kZXhPZignbnVtYmVySW5wdXRNYXNrX193cmFwJykgPiAtMSkge1xyXG4gICAgICAgIHRoaXMuX3Vud3JhcChwYXJlbnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgbnVtYmVyIG1hc2tpbmcgaW5wdXQgd3JhcHBlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBhY3R1YWxJbnB1dCB0aGUgaW5wdXQgZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNXcmFwcGVkIHdoZW4gdHJ1ZSB0aGUgaW5wdXQgaXMgYWxyZWFkeSB3cmFwcGVkIGFuZCB3ZSBuZWVkIHRvIGFkZCB3aGF0IGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZyBvbmx5XHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7SFRNTFNwYW5FbGVtZW50fSB3cmFwcGVyIGluc3RhbmNlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3dyYXAoYWN0dWFsSW5wdXQsIGlzV3JhcHBlZCkge1xyXG4gICAgY29uc3QgYWN0dWFsSW5wdXRJZCA9IGFjdHVhbElucHV0LmdldEF0dHJpYnV0ZSgnaWQnKSxcclxuICAgICAgYWN0dWFsSW5wdXROYW1lID0gYWN0dWFsSW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJyksXHJcbiAgICAgIGFjdHVhbElucHV0U3RlcCA9IGFjdHVhbElucHV0LmRhdGFzZXQuc3RlcCB8fCBudWxsLFxyXG4gICAgICBhY3R1YWxJbnB1dE1heCA9IGFjdHVhbElucHV0LmRhdGFzZXQubWF4IHx8IG51bGwsXHJcbiAgICAgIGFjdHVhbElucHV0TWluID0gYWN0dWFsSW5wdXQuZGF0YXNldC5taW4gfHwgbnVsbCxcclxuICAgICAgYWN0dWFsSW5wdXRHcm91cGluZ1NlcGFyYXRvciA9XHJcbiAgICAgICAgYWN0dWFsSW5wdXQuZGF0YXNldC5ncm91cGluZ1NlcGFyYXRvciB8fCAnLCcsXHJcbiAgICAgIGFjdHVhbElucHV0RGVjaW1hbFNlcGFyYXRvciA9IGFjdHVhbElucHV0LmRhdGFzZXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnLicsXHJcbiAgICAgIGFjdHVhbElucHV0Rm9yY2VUcmFpbGluZ1plcm9zID1cclxuICAgICAgICBhY3R1YWxJbnB1dC5kYXRhc2V0LmZvcmNlVHJhaWxpbmdaZXJvcyB8fCBudWxsLFxyXG4gICAgICBhY3R1YWxJbnB1dE1hc2sgPSBhY3R1YWxJbnB1dC5kYXRhc2V0Lm1hc2sgfHwgJycsXHJcbiAgICAgIGFjdHVhbElucHV0Q2xhc3NlcyA9IGFjdHVhbElucHV0LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcclxuICAgICAgYWN0dWFsSW5wdXRSZXF1aXJlZCA9IGFjdHVhbElucHV0LmdldEF0dHJpYnV0ZSgncmVxdWlyZWQnKSB8fCBudWxsXHJcblxyXG4gICAgbGV0IHdyYXAgPSBudWxsLFxyXG4gICAgICB1bm1hc2tlZElucHV0ID0gbnVsbFxyXG5cclxuICAgIGlmICghaXNXcmFwcGVkKSB7XHJcbiAgICAgIHdyYXAgPSB0aGlzLm9wdGlvbnMuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxyXG4gICAgICB1bm1hc2tlZElucHV0ID0gdGhpcy5vcHRpb25zLmRvYy5jcmVhdGVFbGVtZW50KCdpbnB1dCcpIC8vIGhpZGRlbiBpbnB1dCB3aXRoIHRoZSB1bm1hc2tlZCB2YWx1ZXMgZm9yIGZvcm1zXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cmFwID0gYWN0dWFsSW5wdXQucGFyZW50Tm9kZVxyXG4gICAgICB1bm1hc2tlZElucHV0ID0gd3JhcC5xdWVyeVNlbGVjdG9yKCcubnVtYmVySW5wdXRNYXNrX191bm1hc2tlZElucHV0JylcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25maWd1cmUgdGhlIGFjdHVhbCBpbnB1dFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIGlmICghaXNXcmFwcGVkKSB7XHJcbiAgICAgIGFjdHVhbElucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXAsIGFjdHVhbElucHV0KSAvLyBtb3ZlIHRoZSBpbnB1dCBvdXRzaWRlIHRoZSB3cmFwcGVyXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhKFxyXG4gICAgICAgICAgYWN0dWFsSW5wdXQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpIHx8XHJcbiAgICAgICAgICBhY3R1YWxJbnB1dC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcclxuICAgICAgICApXHJcbiAgICAgICkge1xyXG4gICAgICAgIGFjdHVhbElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYWN0dWFsSW5wdXRIYW5kbGVyKVxyXG4gICAgICAgIGFjdHVhbElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhY3R1YWxJbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWQgPSBhY3R1YWxJbnB1dC52YWx1ZSB8fCAwXHJcbiAgICBhY3R1YWxJbnB1dC5kYXRhc2V0Lmdyb3VwaW5nU2VwYXJhdG9yID0gYWN0dWFsSW5wdXRHcm91cGluZ1NlcGFyYXRvclxyXG4gICAgYWN0dWFsSW5wdXQuZGF0YXNldC5kZWNpbWFsU2VwYXJhdG9yID0gYWN0dWFsSW5wdXREZWNpbWFsU2VwYXJhdG9yXHJcbiAgICBhY3R1YWxJbnB1dC5kYXRhc2V0LmZvcmNlVHJhaWxpbmdaZXJvcyA9IGFjdHVhbElucHV0Rm9yY2VUcmFpbGluZ1plcm9zXHJcbiAgICBhY3R1YWxJbnB1dC52YWx1ZSA9IE51bWJlck1hc2subWFzayhcclxuICAgICAgYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkLFxyXG4gICAgICBhY3R1YWxJbnB1dE1hc2ssXHJcbiAgICAgIGFjdHVhbElucHV0R3JvdXBpbmdTZXBhcmF0b3IsXHJcbiAgICAgIGFjdHVhbElucHV0RGVjaW1hbFNlcGFyYXRvcixcclxuICAgICAgYWN0dWFsSW5wdXRGb3JjZVRyYWlsaW5nWmVyb3NcclxuICAgICkudHJpbSgpXHJcbiAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QuYWRkKFxyXG4gICAgICAnbnVtYmVySW5wdXRNYXNrX190ZXh0SW5wdXQnLFxyXG4gICAgICB0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzXHJcbiAgICApXHJcblxyXG4gICAgLy8gY29uZmlndXJlIHRoZSB1bm1hc2tlZCBpbnB1dFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdW5tYXNrZWRJbnB1dC52YWx1ZSA9IGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZFxyXG4gICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxyXG4gICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaGlkZGVuJylcclxuICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGFjdHVhbElucHV0Q2xhc3NlcylcclxuICAgIGlmIChhY3R1YWxJbnB1dElkKVxyXG4gICAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBgJHthY3R1YWxJbnB1dElkfS11bm1hc2tlZGApXHJcbiAgICBpZiAoYWN0dWFsSW5wdXROYW1lKVxyXG4gICAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnbmFtZScsIGAke2FjdHVhbElucHV0TmFtZX0tdW5tYXNrZWRgKVxyXG4gICAgaWYgKGFjdHVhbElucHV0UmVxdWlyZWQpIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsICdyZXF1aXJlZCcpXHJcblxyXG4gICAgaWYgKGFjdHVhbElucHV0U3RlcCkgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3N0ZXAnLCBhY3R1YWxJbnB1dFN0ZXApXHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgZGVjaW1hbHMgPSBjb3VudERlY2ltYWxzKHVubWFza2VkSW5wdXQudmFsdWUpXHJcbiAgICAgIGxldCBzdGVwID0gJzEnXHJcbiAgICAgIGlmIChkZWNpbWFscyA+IDApIHtcclxuICAgICAgICBzdGVwID0gYC4ke0FycmF5KGRlY2ltYWxzKS5qb2luKCcwJyl9MWBcclxuICAgICAgfVxyXG5cclxuICAgICAgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ3N0ZXAnLCBzdGVwKVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhY3R1YWxJbnB1dE1pbikgdW5tYXNrZWRJbnB1dC5zZXRBdHRyaWJ1dGUoJ21pbicsIGFjdHVhbElucHV0TWluKVxyXG4gICAgaWYgKGFjdHVhbElucHV0TWF4KSB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnbWF4JywgYWN0dWFsSW5wdXRNYXgpXHJcbiAgICB1bm1hc2tlZElucHV0LmRhdGFzZXQuaW5wdXRJZCA9IGFjdHVhbElucHV0SWRcclxuICAgIHVubWFza2VkSW5wdXQuZGF0YXNldC5tYXNrID0gYWN0dWFsSW5wdXRNYXNrXHJcbiAgICB1bm1hc2tlZElucHV0LmRhdGFzZXQuZ3JvdXBpbmdTZXBhcmF0b3IgPSBhY3R1YWxJbnB1dEdyb3VwaW5nU2VwYXJhdG9yXHJcbiAgICB1bm1hc2tlZElucHV0LmRhdGFzZXQuZGVjaW1hbFNlcGFyYXRvciA9IGFjdHVhbElucHV0RGVjaW1hbFNlcGFyYXRvclxyXG4gICAgaWYgKGFjdHVhbElucHV0Rm9yY2VUcmFpbGluZ1plcm9zKVxyXG4gICAgICB1bm1hc2tlZElucHV0LmRhdGFzZXQuZm9yY2VUcmFpbGluZ1plcm9zID0gYWN0dWFsSW5wdXRGb3JjZVRyYWlsaW5nWmVyb3NcclxuXHJcbiAgICBpZiAoIWlzV3JhcHBlZCkge1xyXG4gICAgICB1bm1hc2tlZElucHV0LmNsYXNzTGlzdC5hZGQoJ251bWJlcklucHV0TWFza19fdW5tYXNrZWRJbnB1dCcpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX3VubWFza2VkSW5wdXRIYW5kbGVyKVxyXG4gICAgICB1bm1hc2tlZElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fdW5tYXNrZWRJbnB1dEhhbmRsZXIpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlcilcclxuXHJcbiAgICAgIC8vIGNvbmZpZ3VyZSB0aGUgd3JhcHBlclxyXG4gICAgICB3cmFwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbnVtYmVySW5wdXRNYXNrX193cmFwJylcclxuICAgICAgd3JhcC5hcHBlbmRDaGlsZCh1bm1hc2tlZElucHV0KVxyXG4gICAgICB3cmFwLmFwcGVuZENoaWxkKGFjdHVhbElucHV0KVxyXG4gICAgfVxyXG5cclxuICAgIGlmICghaXNOYU4oTnVtYmVyKGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCkpKSB7XHJcbiAgICAgIGlmICh0aGlzLl92YWxpZGF0ZUlucHV0KHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0KSkge1xyXG4gICAgICAgIHRoaXMuX19maXJlT25VcGRhdGUoXHJcbiAgICAgICAgICBhY3R1YWxJbnB1dC52YWx1ZSxcclxuICAgICAgICAgIGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCxcclxuICAgICAgICAgIGFjdHVhbElucHV0XHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB3cmFwXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbndyYXAgdGhlIG1hc2tlZCBpbnB1dCBhbmQgcmVtb3ZlIHRoZSB2YWx1ZSBjaGFuZ2VkIGxpc3RlbmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxTcGFuRWxlbWVudH0gd3JhcHBlciB0aGUgd3JhcHBlciBzcGFuIGluc3RhbmNlXHJcbiAgICpcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXHJcbiAgX3Vud3JhcCh3cmFwcGVyKSB7XHJcbiAgICBjb25zdCBhY3R1YWxJbnB1dCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcignLm51bWJlcklucHV0TWFza19fdGV4dElucHV0JyksXHJcbiAgICAgIGFjdHVhbElucHV0SWQgPSBhY3R1YWxJbnB1dC5pZCxcclxuICAgICAgdW5tYXNrZWRJbnB1dCA9IHdyYXBwZXIucXVlcnlTZWxlY3RvcihgIyR7YWN0dWFsSW5wdXRJZH0tdW5tYXNrZWRgKVxyXG5cclxuICAgIHVubWFza2VkSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlcilcclxuICAgIHVubWFza2VkSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlcilcclxuICAgIHVubWFza2VkSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl91bm1hc2tlZElucHV0SGFuZGxlcilcclxuXHJcbiAgICB3cmFwcGVyLnJlbW92ZUNoaWxkKHVubWFza2VkSW5wdXQpXHJcblxyXG4gICAgYWN0dWFsSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9hY3R1YWxJbnB1dEhhbmRsZXIpXHJcbiAgICBhY3R1YWxJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYWN0dWFsSW5wdXRIYW5kbGVyKVxyXG4gICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSgnbnVtYmVySW5wdXRNYXNrX190ZXh0SW5wdXQnKVxyXG4gICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuICAgIGRlbGV0ZSBhY3R1YWxJbnB1dC5kYXRhc2V0LnZhbHVlVW5tYXNrZWRcclxuXHJcbiAgICB3cmFwcGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGFjdHVhbElucHV0LCB3cmFwcGVyKVxyXG4gICAgd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXBwZXIpXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gY2xpY2sgYW5kIGZvY3VzaW4gZXZlbnQgb24gdGhlIGFjdHVhbCBpbnB1dCBhbmQgdG9nZ2xlIHRoZSBudW1iZXIgaW5wdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IGVcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfYWN0dWFsSW5wdXRIYW5kbGVyKGUpIHtcclxuICAgIGNvbnN0IGFjdHVhbElucHV0ID0gZS50YXJnZXQsXHJcbiAgICAgIGFjdHVhbElucHV0SWQgPSBhY3R1YWxJbnB1dC5pZCxcclxuICAgICAgdW5tYXNrZWRJbnB1dCA9IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvcihcclxuICAgICAgICBgIyR7YWN0dWFsSW5wdXRJZH0tdW5tYXNrZWRgXHJcbiAgICAgIClcclxuXHJcbiAgICBhY3R1YWxJbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxyXG4gICAgYWN0dWFsSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2hpZGRlbicpXHJcblxyXG4gICAgdW5tYXNrZWRJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJylcclxuICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ251bWJlcicpXHJcbiAgICB0aGlzLl92YWxpZGF0ZUlucHV0KHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0KVxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHVubWFza2VkSW5wdXQuZm9jdXMoKVxyXG4gICAgICBjb25zdCBsZW5ndGggPSBTdHJpbmcodW5tYXNrZWRJbnB1dC52YWx1ZSkubGVuZ3RoXHJcbiAgICAgIHVubWFza2VkSW5wdXQudHlwZSA9ICd0ZXh0J1xyXG4gICAgICB1bm1hc2tlZElucHV0LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKVxyXG4gICAgICB1bm1hc2tlZElucHV0LnR5cGUgPSAnbnVtYmVyJ1xyXG4gICAgfSwgMClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byB0aGUgdW5tYXNrZWQgaW5wdXQga2V5ZG93biBhbmQgZm9jdXNvdXQgZXZlbnRzIGFuZCBjaGVja1xyXG4gICAqIGlmIHRoZSBpbnB1dCB2YWx1ZSBjYW4gYmUgbWFza2VkIG9yIG5vdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZVxyXG4gICAqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIF91bm1hc2tlZElucHV0SGFuZGxlcihlKSB7XHJcbiAgICBjb25zdCB1bm1hc2tlZElucHV0ID0gZS50YXJnZXQsXHJcbiAgICAgIGtleUNvZGUgPSBlLmtleUNvZGUsXHJcbiAgICAgIG1hc2sgPSB1bm1hc2tlZElucHV0LmRhdGFzZXQubWFzayxcclxuICAgICAgZ3JvdXBpbmdTZXBhcmF0b3IgPSB1bm1hc2tlZElucHV0LmRhdGFzZXQuZ3JvdXBpbmdTZXBhcmF0b3IsXHJcbiAgICAgIGRlY2ltYWxTZXBhcmF0b3IgPSB1bm1hc2tlZElucHV0LmRhdGFzZXQuZGVjaW1hbFNlcGFyYXRvcixcclxuICAgICAgZm9yY2VUcmFpbGluZ1plcm9zID0gdW5tYXNrZWRJbnB1dC5kYXRhc2V0LmZvcmNlVHJhaWxpbmdaZXJvcyxcclxuICAgICAgYWN0dWFsSW5wdXRJZCA9IHVubWFza2VkSW5wdXQuZGF0YXNldC5pbnB1dElkLFxyXG4gICAgICBhY3R1YWxJbnB1dCA9IHRoaXMub3B0aW9ucy5kb2MucXVlcnlTZWxlY3RvcihgIyR7YWN0dWFsSW5wdXRJZH1gKVxyXG5cclxuICAgIGxldCByZXN0b3JlID0gZmFsc2UsXHJcbiAgICAgIGFwcGx5ID0gZmFsc2UsXHJcbiAgICAgIG1hc2tlZFZhbHVlID0gZmFsc2UsXHJcbiAgICAgIGlzVmFsaWQgPSB0aGlzLl92YWxpZGF0ZUlucHV0KHVubWFza2VkSW5wdXQsIGFjdHVhbElucHV0KVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIG1hc2tlZFZhbHVlID0gTnVtYmVyTWFzay5tYXNrKFxyXG4gICAgICAgIHVubWFza2VkSW5wdXQudmFsdWUgfHwgMCxcclxuICAgICAgICBtYXNrLFxyXG4gICAgICAgIGdyb3VwaW5nU2VwYXJhdG9yLFxyXG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3IsXHJcbiAgICAgICAgZm9yY2VUcmFpbGluZ1plcm9zLFxyXG4gICAgICAgIGZhbHNlXHJcbiAgICAgICkudHJpbSgpXHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG1hc2tlZFZhbHVlID0gZmFsc2VcclxuICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZSh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCwgJ2Vycm9yJylcclxuICAgICAgdGhpcy5fX2ZpcmVPbkludmFsaWQoZSwgYWN0dWFsSW5wdXQpXHJcbiAgICB9XHJcblxyXG4gICAgcmVzdG9yZSA9IFsxMywgMjddLmluZGV4T2Yoa2V5Q29kZSkgPiAtMSB8fCBlLnR5cGUgPT09ICdmb2N1c291dCdcclxuICAgIGFwcGx5ID0gbWFza2VkVmFsdWUgJiYgaXNWYWxpZFxyXG5cclxuICAgIGlmIChyZXN0b3JlKSB7XHJcbiAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NFcnJvcilcclxuICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcblxyXG4gICAgICB1bm1hc2tlZElucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2hpZGRlbicpXHJcblxyXG4gICAgICBhY3R1YWxJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJylcclxuICAgICAgYWN0dWFsSW5wdXQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RleHQnKVxyXG5cclxuICAgICAgYWN0dWFsSW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG5cclxuICAgICAgaWYgKGFwcGx5KSB7XHJcbiAgICAgICAgYWN0dWFsSW5wdXQudmFsdWUgPSBtYXNrZWRWYWx1ZVxyXG4gICAgICAgIGFjdHVhbElucHV0LmRhdGFzZXQudmFsdWVVbm1hc2tlZCA9IHVubWFza2VkSW5wdXQudmFsdWVcclxuICAgICAgICB0aGlzLl9fZmlyZU9uVXBkYXRlKG1hc2tlZFZhbHVlLCB1bm1hc2tlZElucHV0LnZhbHVlLCBhY3R1YWxJbnB1dClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB1bm1hc2tlZElucHV0LnZhbHVlID0gYWN0dWFsSW5wdXQuZGF0YXNldC52YWx1ZVVubWFza2VkXHJcbiAgICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZSh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCwgJ3N1Y2Nlc3MnKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VyIGBjaGVja1ZhbGlkaXR5YCBvbiB0aGUgaW5wdXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gdW5tYXNrZWRJbnB1dFxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gYWN0dWFsSW5wdXRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIHdoZW4gdmFsaWQgLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBfdmFsaWRhdGVJbnB1dCh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCkge1xyXG4gICAgbGV0IGlzVmFsaWQgPSB0cnVlXHJcbiAgICBjb25zdCB2YWx1ZSA9IE51bWJlcih1bm1hc2tlZElucHV0LnZhbHVlKVxyXG4gICAgaWYgKHVubWFza2VkSW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICFpc05hTih2YWx1ZSkpIHtcclxuICAgICAgY29uc3QgbWF4ID0gdW5tYXNrZWRJbnB1dC5nZXRBdHRyaWJ1dGUoJ21heCcpXHJcbiAgICAgIGNvbnN0IG1pbiA9IHVubWFza2VkSW5wdXQuZ2V0QXR0cmlidXRlKCdtaW4nKVxyXG4gICAgICBjb25zdCBzdGVwID0gdW5tYXNrZWRJbnB1dC5nZXRBdHRyaWJ1dGUoJ3N0ZXAnKVxyXG5cclxuICAgICAgaWYgKG1pbikgaXNWYWxpZCA9IGlzVmFsaWQgJiYgdmFsdWUgPj0gTnVtYmVyKG1pbilcclxuICAgICAgaWYgKG1heCkgaXNWYWxpZCA9IGlzVmFsaWQgJiYgdmFsdWUgPD0gTnVtYmVyKG1heClcclxuXHJcbiAgICAgIGlmIChzdGVwKVxyXG4gICAgICAgIGlzVmFsaWQgPVxyXG4gICAgICAgICAgaXNWYWxpZCAmJiBjb3VudERlY2ltYWxzKHN0ZXApID09PSBjb3VudERlY2ltYWxzKHVubWFza2VkSW5wdXQudmFsdWUpXHJcbiAgICB9IGVsc2UgaXNWYWxpZCA9IHVubWFza2VkSW5wdXQuY2hlY2tWYWxpZGl0eSgpXHJcblxyXG4gICAgaWYgKGlzVmFsaWQpIHtcclxuICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZSh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCwgJ3N1Y2Nlc3MnKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fX2FwcGx5Q3NzQ2xhc3NTdGF0ZSh1bm1hc2tlZElucHV0LCBhY3R1YWxJbnB1dCwgJ2Vycm9yJylcclxuICAgICAgdGhpcy5fX2ZpcmVPbkludmFsaWQoXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC52YWxpZGF0aW9uTWVzc2FnZSB8fCAnVmFsaWRpdHkgY2hlY2sgZmFpbHMnLFxyXG4gICAgICAgIGFjdHVhbElucHV0XHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNWYWxpZFxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlTWFza2VkICBtYXNrZWQgdmFsdWVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVVbm1hc2tlZCAgb3JpZ2luYWwgdmFsdWVcclxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0IHRoZSBhY3R1YWwgaW5wdXQgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19maXJlT25VcGRhdGUodmFsdWVNYXNrZWQsIHZhbHVlVW5tYXNrZWQsIGlucHV0KSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVXBkYXRlKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZSh2YWx1ZU1hc2tlZCwgdmFsdWVVbm1hc2tlZCwgaW5wdXQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGVycm9yIGxhc3Qgb2NjdXJyZWQgZXJyb3IuIGNvdWxkIGJlIG1hc2sgZXJyb3Igb3IgdmFsaWRhdGlvbiBlcnJvclxyXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgdGhlIGFjdHVhbCBpbnB1dCBpbnN0YW5jZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2ZpcmVPbkludmFsaWQoZXJyb3IsIGlucHV0KSB7XHJcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW52YWxpZCkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMub25JbnZhbGlkKGVycm9yLCBpbnB1dClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19hcHBseUNzc0NsYXNzU3RhdGUodW5tYXNrZWRJbnB1dCwgYWN0dWFsSW5wdXQsIHN0YXRlKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIGFjdHVhbElucHV0Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKSB8fFxyXG4gICAgICBhY3R1YWxJbnB1dC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcclxuICAgICkge1xyXG4gICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc1N1Y2Nlc3MpXHJcblxyXG4gICAgICB1bm1hc2tlZElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzRXJyb3IpXHJcbiAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHN0YXRlID09PSAnc3VjY2VzcycpIHtcclxuICAgICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5hZGQodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LmFkZCh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcicpIHtcclxuICAgICAgICBhY3R1YWxJbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIGFjdHVhbElucHV0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmNzc0NsYXNzU3VjY2VzcylcclxuXHJcbiAgICAgICAgdW5tYXNrZWRJbnB1dC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5jc3NDbGFzc0Vycm9yKVxyXG4gICAgICAgIHVubWFza2VkSW5wdXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuY3NzQ2xhc3NTdWNjZXNzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOdW1iZXJJbnB1dFxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvTnVtYmVySW5wdXQvTnVtYmVySW5wdXQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcImNvbW1vbmpzXCI6XCJiYmotbWFza3Mvc3JjL051bWJlck1hc2tcIixcImNvbW1vbmpzMlwiOlwiYmJqLW1hc2tzL3NyYy9OdW1iZXJNYXNrXCIsXCJhbWRcIjpcImJiai1tYXNrcy9zcmMvTnVtYmVyTWFza1wiLFwicm9vdFwiOltcIkJCalwiLFwiTWFza3NcIixcIk51bWJlck1hc2tcIl19XG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiTWFza3NcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIkJCalwiXSA9IHJvb3RbXCJCQmpcIl0gfHwge30sIHJvb3RbXCJCQmpcIl1bXCJNYXNrc1wiXSA9IGZhY3RvcnkoKTtcclxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxyXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gXHR9XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcclxuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcclxuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcclxuLyoqKioqKi8gXHRcdFx0fSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1KTtcclxuLyoqKioqKi8gfSlcclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuLyoqKioqKi8gKFtcclxuLyogMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSB0b0ludGVnZXI7XHJcbmZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xyXG4gIGlmIChkaXJ0eU51bWJlciA9PT0gbnVsbCB8fCBkaXJ0eU51bWJlciA9PT0gdHJ1ZSB8fCBkaXJ0eU51bWJlciA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBOYU47XHJcbiAgfVxyXG5cclxuICB2YXIgbnVtYmVyID0gTnVtYmVyKGRpcnR5TnVtYmVyKTtcclxuXHJcbiAgaWYgKGlzTmFOKG51bWJlcikpIHtcclxuICAgIHJldHVybiBudW1iZXI7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVtYmVyIDwgMCA/IE1hdGguY2VpbChudW1iZXIpIDogTWF0aC5mbG9vcihudW1iZXIpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fTnVtYmVyTWFza19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImVcIl07IH0pO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fW1wiZ1wiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImhcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJoXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImFcIl07IH0pO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19EYXRlTWFza19fW1wiYlwiXTsgfSk7XHJcbi8qIGhhcm1vbnkgcmVleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX0RhdGVNYXNrX19bXCJkXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImZcIl07IH0pO1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gKF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fRGF0ZU1hc2tfX1tcImNcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSB0elBhcnNlVGltZXpvbmU7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3R6VG9rZW5pemVEYXRlX2luZGV4X2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG5cclxuXHJcbnZhciBNSUxMSVNFQ09ORFNfSU5fSE9VUiA9IDM2MDAwMDBcclxudmFyIE1JTExJU0VDT05EU19JTl9NSU5VVEUgPSA2MDAwMFxyXG5cclxudmFyIHBhdHRlcm5zID0ge1xyXG4gIHRpbWV6b25lOiAvKFtaKy1dLiopJC8sXHJcbiAgdGltZXpvbmVaOiAvXihaKSQvLFxyXG4gIHRpbWV6b25lSEg6IC9eKFsrLV0pKFxcZHsyfSkkLyxcclxuICB0aW1lem9uZUhITU06IC9eKFsrLV0pKFxcZHsyfSk6PyhcXGR7Mn0pJC8sXHJcbiAgdGltZXpvbmVJQU5BOiAvKFVUQ3woPzpbYS16QS1aXStcXC9bYS16QS1aX10rKD86XFwvW2EtekEtWl9dKyk/KSkkL1xyXG59XHJcblxyXG4vLyBQYXJzZSB2YXJpb3VzIHRpbWUgem9uZSBvZmZzZXQgZm9ybWF0cyB0byBhbiBvZmZzZXQgaW4gbWlsbGlzZWNvbmRzXHJcbmZ1bmN0aW9uIHR6UGFyc2VUaW1lem9uZSh0aW1lem9uZVN0cmluZywgZGF0ZSkge1xyXG4gIHZhciB0b2tlblxyXG4gIHZhciBhYnNvbHV0ZU9mZnNldFxyXG5cclxuICAvLyBaXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy50aW1lem9uZVouZXhlYyh0aW1lem9uZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIHJldHVybiAwXHJcbiAgfVxyXG5cclxuICB2YXIgaG91cnNcclxuXHJcbiAgLy8gwrFoaFxyXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISC5leGVjKHRpbWV6b25lU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaG91cnMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWV6b25lKGhvdXJzKSkge1xyXG4gICAgICByZXR1cm4gTmFOXHJcbiAgICB9XHJcblxyXG4gICAgYWJzb2x1dGVPZmZzZXQgPSBob3VycyAqIE1JTExJU0VDT05EU19JTl9IT1VSXHJcbiAgICByZXR1cm4gdG9rZW5bMV0gPT09ICcrJyA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XHJcbiAgfVxyXG5cclxuICAvLyDCsWhoOm1tIG9yIMKxaGhtbVxyXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVISE1NLmV4ZWModGltZXpvbmVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzJdLCAxMClcclxuICAgIHZhciBtaW51dGVzID0gcGFyc2VJbnQodG9rZW5bM10sIDEwKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykpIHtcclxuICAgICAgcmV0dXJuIE5hTlxyXG4gICAgfVxyXG5cclxuICAgIGFic29sdXRlT2Zmc2V0ID1cclxuICAgICAgaG91cnMgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFXHJcbiAgICByZXR1cm4gdG9rZW5bMV0gPT09ICcrJyA/IC1hYnNvbHV0ZU9mZnNldCA6IGFic29sdXRlT2Zmc2V0XHJcbiAgfVxyXG5cclxuICAvLyBJQU5BIHRpbWUgem9uZVxyXG4gIHRva2VuID0gcGF0dGVybnMudGltZXpvbmVJQU5BLmV4ZWModGltZXpvbmVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICAvLyB2YXIgW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXSA9IHR6VG9rZW5pemVEYXRlKGRhdGUsIHRpbWV6b25lU3RyaW5nKVxyXG4gICAgdmFyIHRva2VucyA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX3R6VG9rZW5pemVEYXRlX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRhdGUsIHRpbWV6b25lU3RyaW5nKVxyXG4gICAgdmFyIGFzVVRDID0gRGF0ZS5VVEMoXHJcbiAgICAgIHRva2Vuc1swXSxcclxuICAgICAgdG9rZW5zWzFdIC0gMSxcclxuICAgICAgdG9rZW5zWzJdLFxyXG4gICAgICB0b2tlbnNbM10sXHJcbiAgICAgIHRva2Vuc1s0XSxcclxuICAgICAgdG9rZW5zWzVdXHJcbiAgICApXHJcbiAgICB2YXIgdGltZXN0YW1wV2l0aE1zWmVyb2VkID0gZGF0ZS5nZXRUaW1lKCkgLSAoZGF0ZS5nZXRUaW1lKCkgJSAxMDAwKVxyXG4gICAgcmV0dXJuIC0oYXNVVEMgLSB0aW1lc3RhbXBXaXRoTXNaZXJvZWQpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gMFxyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWV6b25lKGhvdXJzLCBtaW51dGVzKSB7XHJcbiAgaWYgKG1pbnV0ZXMgIT0gbnVsbCAmJiAobWludXRlcyA8IDAgfHwgbWludXRlcyA+IDU5KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1N0cmluZ01hc2tfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19TdHJpbmdNYXNrX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlV0aWxzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gVXRpbHM7IH0pO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19OdW1iZXJNYXNrX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fU3RyaW5nTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fVHlwZXNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJUeXBlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fVHlwZXNfX1tcImFcIl07IH0pO1xyXG4vKiBoYXJtb255IHJlZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJOdW1iZXJNYXNrXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19OdW1iZXJNYXNrX19bXCJhXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiRGF0ZU1hc2tcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJjXCJdOyB9KTtcclxuLyogaGFybW9ueSByZWV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiU3RyaW5nTWFza1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fU3RyaW5nTWFza19fW1wiYVwiXTsgfSk7XHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxudmFyIFV0aWxzID0ge1xyXG4gIERhdGVzOiB7XHJcbiAgICBnZXREYXlPZlllYXI6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImVcIiAvKiBnZXREYXlPZlllYXIgKi9dLFxyXG4gICAgZ2V0V2Vla051bWJlcjogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fW1wiZ1wiIC8qIGdldFdlZWtOdW1iZXIgKi9dLFxyXG4gICAgZ2V0V2Vla1N0YXJ0QnlMb2NhbGU6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImhcIiAvKiBnZXRXZWVrU3RhcnRCeUxvY2FsZSAqL10sXHJcbiAgICBJU19EQVRFX1JFR0VYOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJhXCIgLyogSVNfREFURV9SRUdFWCAqL10sXHJcbiAgICBJU19USU1FX1JFR0VYOiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX0RhdGVNYXNrX19bXCJiXCIgLyogSVNfVElNRV9SRUdFWCAqL10sXHJcbiAgICBmaXhTaG9ydElTTzogX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fW1wiZFwiIC8qIGZpeFNob3J0SVNPICovXSxcclxuICAgIGdldFRpbWV6b25lT3JPZmZzZXQ6IF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImZcIiAvKiBnZXRUaW1lem9uZU9yT2Zmc2V0ICovXVxyXG4gIH1cclxufTtcclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1R5cGVzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiA2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxyXG5cclxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cclxuXHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE51bWJlck1hc2tcclxuICpcclxuICogQSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIGZvciBCQmogbnVtYmVycyBtYXNraW5nXHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG52YXIgTnVtYmVyTWFzayA9XHJcbi8qI19fUFVSRV9fKi9cclxuZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIE51bWJlck1hc2soKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyTWFzayk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoTnVtYmVyTWFzaywgbnVsbCwgW3tcclxuICAgIGtleTogXCJtYXNrXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXNrIHRoZSBnaXZlbiBudW1iZXIgd2l0aCB0aGUgZ2l2ZW4gbWFzayBhY2NvcmRpbmcgdG8gQkJqIHJ1bGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciB0aGUgbnVtYmVyIHRvIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgdGhlIG1hc2sgdG8gdXNlIGZvciBmb3JtYXR0aW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2dyb3VwaW5nU2VwYXJhdG9yPSxdIC0gYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGdyb3VwaW5nIHNlcGFyYXRvclxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtkZWNpbWFsU2VwYXJhdG9yPS5dICAtIGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBkZWNpbWFsIHNlcGFyYXRvclxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VUcmFpbGluZ1plcm9zPWZhbHNlXSAtIEFmZmVjdHMgdGhlIG91dHB1dCBieSBzd2l0Y2hpbmcgdGhlIHdheSBhIG1hc2sgd2l0aCBcIiNcIiBjaGFyYWN0ZXJzIGluIHRoZSB0cmFpbGluZyBwb3NpdGlvbnMgaXMgZmlsbGVkLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGV4YW1wbGUsIHRoZSBmdW5jdGlvbiBgTnVtYmVyTWFzay5tYXNrKC4xMDpcIiMuIyNcIilgIHJldHVybnMgYCAuMTBgIGluc3RlYWQgb2YgYCAuMSBgXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29zZT10cnVlXSB3aGVuIHRydWUgLCBlcnJvcnMgd2lsbCBiZSBpZ25vcmVkIGFuZCB0aGUgbWV0aG9kIHdpbGwgdHJ5IGF0IGFwcGx5IHRoZSBtYXNrXHJcbiAgICAgKiAgICAgICAgICAgICAgICBhbnl3YXkgLCBvdGhlcndpc2UgaXQgd2lsbCBzdG9wIGF0IGZpcnN0IGVycm9yIGFuZCB0aHJvdyBpdC5cclxuICAgICAqIFxyXG4gICAgICogQHRocm93cyB7TWFza0Vycm9yfSBvbmx5IGlmIGxvb3NlIGlzIGRpc2FibGVkXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgbnVtYmVyXHJcbiAgICAgKi9cclxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrKG51bWJlciwgX21hc2spIHtcclxuICAgICAgdmFyIGdyb3VwaW5nU2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLCc7XHJcbiAgICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLic7XHJcbiAgICAgIHZhciBmb3JjZVRyYWlsaW5nWmVyb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xyXG4gICAgICB2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XHJcbiAgICAgIHZhciBtYXNrTGVuID0gX21hc2subGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKDAgPT09IG1hc2tMZW4pIHtcclxuICAgICAgICBpZiAobG9vc2UpIHJldHVybiBzdHI7IC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgICAgZWxzZSB0aHJvdyB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYXNrRXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk1hc2tFcnJvcjogTWFzayBpcyBlbXB0eVwiXHJcbiAgICAgICAgICB9O1xyXG4gICAgICB9IC8vIEdldCBtYWduaXR1ZGUgYW5kIHByZWNpc2lvbiBvZiBNQVNLXHJcblxyXG5cclxuICAgICAgdmFyIG1hc2tCZWZvcmVEZWNpbWFsID0gMDtcclxuICAgICAgdmFyIG1hc2tBZnRlckRlY2ltYWwgPSAwO1xyXG4gICAgICB2YXIgZm91bmREZWNpbWFsID0gZmFsc2U7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hc2tMZW47ICsraSkge1xyXG4gICAgICAgIHZhciBtID0gX21hc2suY2hhckF0KGkpO1xyXG5cclxuICAgICAgICBpZiAobSA9PSAnMCcgfHwgbSA9PSAnIycpIHtcclxuICAgICAgICAgIGlmIChmb3VuZERlY2ltYWwpICsrbWFza0FmdGVyRGVjaW1hbDtlbHNlICsrbWFza0JlZm9yZURlY2ltYWw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtID09ICcuJykgZm91bmREZWNpbWFsID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG51bSA9IE51bWJlck1hc2suX3JvdW5kKG51bWJlciwgbWFza0FmdGVyRGVjaW1hbCk7XHJcblxyXG4gICAgICB2YXIgYnl0ZXMgPSBOdW1iZXJNYXNrLl90b0NoYXJBcnJheShudW0pOyAvLyBHZXQgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTlVNQkVSXHJcblxyXG5cclxuICAgICAgdmFyIGluTGVuID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICB2YXIgbnVtQmVmb3JlRGVjaW1hbCA9IDA7XHJcbiAgICAgIHZhciBudW1BZnRlckRlY2ltYWwgPSAwO1xyXG4gICAgICBmb3VuZERlY2ltYWwgPSBmYWxzZTtcclxuXHJcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbkxlbjsgKytfaSkge1xyXG4gICAgICAgIGlmIChieXRlc1tfaV0gPT0gJy4nKSBmb3VuZERlY2ltYWwgPSB0cnVlO2Vsc2Uge1xyXG4gICAgICAgICAgaWYgKGZvdW5kRGVjaW1hbCkgKytudW1BZnRlckRlY2ltYWw7ZWxzZSArK251bUJlZm9yZURlY2ltYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IC8vIGFsd2F5cyBpZ25vcmUgbWFzayBvdmVyZmxvd1xyXG5cclxuXHJcbiAgICAgIGlmIChudW1CZWZvcmVEZWNpbWFsID4gbWFza0JlZm9yZURlY2ltYWwpIHtcclxuICAgICAgICBpZiAobG9vc2UpIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTsgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgICBlbHNlIHRocm93IHtcclxuICAgICAgICAgICAgbmFtZTogJ01hc2tFcnJvcicsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiTWFza0Vycm9yOiBOdW1iZXIgaXMgdG9vIGxhcmdlIGZvciBtYXNrXCJcclxuICAgICAgICAgIH07XHJcbiAgICAgIH0gLy8gcm91bmQgaWYgbWFzayBpcyBmb3IgYSBsb3dlciBwcmVjaXNpb24gbnVtYmVyXHJcblxyXG5cclxuICAgICAgaWYgKG51bUFmdGVyRGVjaW1hbCA+IG1hc2tBZnRlckRlY2ltYWwpIHtcclxuICAgICAgICBudW0gPSBOdW1iZXJNYXNrLl9yb3VuZChudW0sIG1hc2tBZnRlckRlY2ltYWwpO1xyXG4gICAgICAgIGJ5dGVzID0gTnVtYmVyTWFzay5fdG9DaGFyQXJyYXkobnVtKTtcclxuICAgICAgICBpbkxlbiA9IGJ5dGVzLmxlbmd0aDsgLy8gR2V0IG5ldyBtYWduaXR1ZGUgYW5kIHByZWNpc2lvbiBvZiBOVU1CRVJcclxuXHJcbiAgICAgICAgbnVtQmVmb3JlRGVjaW1hbCA9IDA7XHJcbiAgICAgICAgbnVtQWZ0ZXJEZWNpbWFsID0gMDtcclxuICAgICAgICBmb3VuZERlY2ltYWwgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5MZW47ICsrX2kyKSB7XHJcbiAgICAgICAgICBpZiAoYnl0ZXNbX2kyXSA9PSAnLicpIGZvdW5kRGVjaW1hbCA9IHRydWU7ZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChmb3VuZERlY2ltYWwpICsrbnVtQWZ0ZXJEZWNpbWFsO2Vsc2UgKytudW1CZWZvcmVEZWNpbWFsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gYWx3YXlzIGlnbm9yZSBtYXNrIG92ZXJmbG93XHJcblxyXG5cclxuICAgICAgICBpZiAobnVtQmVmb3JlRGVjaW1hbCA+IG1hc2tCZWZvcmVEZWNpbWFsKSB7XHJcbiAgICAgICAgICBpZiAobG9vc2UpIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTsgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgICAgIGVsc2UgdGhyb3cge1xyXG4gICAgICAgICAgICAgIG5hbWU6ICdNYXNrRXJyb3InLFxyXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTWFza0Vycm9yOiBOdW1iZXIgaXMgdG9vIGxhcmdlIGZvciBtYXNrXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBmaWxsQnl0ZSA9ICcgJyxcclxuICAgICAgICAgIGZsb2F0Qnl0ZSA9ICcgJztcclxuICAgICAgdmFyIGluUG9zID0gMCxcclxuICAgICAgICAgIG91dFBvcyA9IDAsXHJcbiAgICAgICAgICBmbG9hdFBvcyA9IDA7XHJcbiAgICAgIGlmIChfbWFzay5jaGFyQXQoMCkgPT0gJyonKSBmaWxsQnl0ZSA9ICcqJztcclxuICAgICAgdmFyIGZpbGxJbml0ID0gZmlsbEJ5dGU7XHJcbiAgICAgIHZhciBpc05lZ2F0aXZlID0gTnVtYmVyTWFzay5fZ2V0U2lnbihudW0pIDwgMDtcclxuICAgICAgdmFyIGVtaXREZWNpbWFsID0gaW5MZW4gPiAwIHx8IF9tYXNrLmluZGV4T2YoJzAnKSA+PSAwO1xyXG4gICAgICB2YXIgZm91bmRaZXJvID0gZmFsc2U7XHJcbiAgICAgIHZhciBmb3VuZERpZ2l0ID0gZmFsc2U7XHJcbiAgICAgIHZhciBjdXJyZW5jeSA9IGZhbHNlO1xyXG4gICAgICBmb3VuZERlY2ltYWwgPSBmYWxzZTtcclxuICAgICAgdmFyIHJldCA9IG5ldyBBcnJheShtYXNrTGVuKTtcclxuXHJcbiAgICAgIGZvciAodmFyIG1hc2tQb3MgPSAwOyBtYXNrUG9zIDwgbWFza0xlbjsgKyttYXNrUG9zKSB7XHJcbiAgICAgICAgdmFyIF9tID0gX21hc2suY2hhckF0KG1hc2tQb3MpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKF9tKSB7XHJcbiAgICAgICAgICBjYXNlICcwJzpcclxuICAgICAgICAgICAgLS1tYXNrQmVmb3JlRGVjaW1hbDtcclxuXHJcbiAgICAgICAgICAgIGlmIChtYXNrQmVmb3JlRGVjaW1hbCA8IG51bUJlZm9yZURlY2ltYWwgJiYgaW5Qb3MgPCBpbkxlbikge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gYnl0ZXNbaW5Qb3NdO1xyXG4gICAgICAgICAgICAgICsraW5Qb3M7XHJcbiAgICAgICAgICAgICAgZm91bmREaWdpdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnMCc7XHJcbiAgICAgICAgICAgICAgZm91bmRaZXJvID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgICAtLW1hc2tCZWZvcmVEZWNpbWFsO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hc2tCZWZvcmVEZWNpbWFsIDwgbnVtQmVmb3JlRGVjaW1hbCAmJiBpblBvcyA8IGluTGVuKSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSBieXRlc1tpblBvc107XHJcbiAgICAgICAgICAgICAgKytpblBvcztcclxuICAgICAgICAgICAgICBmb3VuZERpZ2l0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZvdW5kRGVjaW1hbCAmJiBmb3JjZVRyYWlsaW5nWmVyb3MgJiYgTnVtYmVyTWFzay5fZ2V0U2lnbihudW0pICE9IDAgPyAnMCcgOiBmaWxsQnl0ZTtcclxuICAgICAgICAgICAgICBpZiAoIWZvdW5kRGVjaW1hbCkgZmxvYXRQb3MgPSBtYXNrUG9zO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICAgIGlmIChmb3VuZFplcm8gfHwgaW5Qb3MgPiAwKSByZXRbb3V0UG9zXSA9IGdyb3VwaW5nU2VwYXJhdG9yO2Vsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGU7XHJcbiAgICAgICAgICAgICAgaWYgKCFmb3VuZERlY2ltYWwpIGZsb2F0UG9zID0gbWFza1BvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnLSc6XHJcbiAgICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIGZsb2F0Qnl0ZSA9ICctJztcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W291dFBvc10gPSBpc05lZ2F0aXZlID8gJy0nIDogZmlsbEJ5dGU7XHJcblxyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgZmxvYXRCeXRlID0gaXNOZWdhdGl2ZSA/ICctJyA6ICcrJztcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W291dFBvc10gPSBpc05lZ2F0aXZlID8gJy0nIDogJysnO1xyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJyQnOlxyXG4gICAgICAgICAgICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgICAgIGZsb2F0Qnl0ZSA9ICckJztcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyQnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAvLyBjYXNlICcmJzpcclxuICAgICAgICAgIC8vICAgY3VycmVuY3kgPSB0cnVlXHJcbiAgICAgICAgICAvLyAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAvLyAgICAgZmxvYXRCeXRlID0gJyYnXHJcbiAgICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgICAgLy8gICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zXHJcbiAgICAgICAgICAvLyAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSAnJidcclxuICAgICAgICAgIC8vICAgfVxyXG4gICAgICAgICAgLy8gICArK291dFBvc1xyXG4gICAgICAgICAgLy8gICBicmVha1xyXG4gICAgICAgICAgLy8gY2FzZSAnQCc6XHJcbiAgICAgICAgICAvLyAgIGN1cnJlbmN5ID0gdHJ1ZVxyXG4gICAgICAgICAgLy8gICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgLy8gICAgIGZsb2F0Qnl0ZSA9ICdAJ1xyXG4gICAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgIC8vICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gJ0AnXHJcbiAgICAgICAgICAvLyAgIH1cclxuICAgICAgICAgIC8vICAgKytvdXRQb3NcclxuICAgICAgICAgIC8vICAgYnJlYWtcclxuXHJcbiAgICAgICAgICBjYXNlICcoJzpcclxuICAgICAgICAgICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkgZmxvYXRCeXRlID0gJygnO1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGU7XHJcbiAgICAgICAgICAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJygnO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZvdW5kRGVjaW1hbCA/ICcgJyA6IGZpbGxCeXRlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJyknOlxyXG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyknO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZm91bmREZWNpbWFsID8gJyAnIDogZmlsbEJ5dGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICsrb3V0UG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdDJzpcclxuICAgICAgICAgICAgaWYgKG1hc2tQb3MgPCBtYXNrTGVuIC0gMSAmJiBfbWFzay5jaGFyQXQobWFza1BvcyArIDEpID09ICdSJykge1xyXG4gICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdDJztcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3MgKyAxXSA9ICdSJztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnICc7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnICc7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBvdXRQb3MgKz0gMjtcclxuICAgICAgICAgICAgICArK21hc2tQb3M7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnQyc7XHJcbiAgICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICBpZiAobWFza1BvcyA8IG1hc2tMZW4gLSAxICYmIF9tYXNrLmNoYXJBdChtYXNrUG9zICsgMSkgPT0gJ1InKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0MnO1xyXG4gICAgICAgICAgICAgICAgcmV0W291dFBvcyArIDFdID0gJ1InO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdEJztcclxuICAgICAgICAgICAgICAgIHJldFtvdXRQb3MgKyAxXSA9ICdSJztcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIG91dFBvcyArPSAyO1xyXG4gICAgICAgICAgICAgICsrbWFza1BvcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdEJztcclxuICAgICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnKic6XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyonO1xyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZW1pdERlY2ltYWwgPyBkZWNpbWFsU2VwYXJhdG9yIDogZmlsbEJ5dGU7XHJcbiAgICAgICAgICAgIGZpbGxCeXRlID0gJyAnO1xyXG4gICAgICAgICAgICBmb3VuZERlY2ltYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICArK2luUG9zO1xyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnQic6XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyAnO1xyXG4gICAgICAgICAgICArK291dFBvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBfbTtcclxuICAgICAgICAgICAgKytvdXRQb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZsb2F0Qnl0ZSAhPSAnICcpIHtcclxuICAgICAgICBpZiAoZmxvYXRQb3MgPCAwKSBmbG9hdFBvcyA9IG91dFBvcztcclxuXHJcbiAgICAgICAgd2hpbGUgKGZsb2F0UG9zID49IG1hc2tMZW4pIHtcclxuICAgICAgICAgIC0tZmxvYXRQb3M7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmV0W2Zsb2F0UG9zXSA9PSBmaWxsSW5pdCkgcmV0W2Zsb2F0UG9zXSA9IGZsb2F0Qnl0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcclxuICAgIH1cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX3NoaWZ0XCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NoaWZ0KG51bWJlciwgcHJlY2lzaW9uLCByZXZlcnNlU2hpZnQpIHtcclxuICAgICAgaWYgKHJldmVyc2VTaGlmdCkgcHJlY2lzaW9uID0gLXByZWNpc2lvbjtcclxuICAgICAgdmFyIG51bUFycmF5ID0gKCcnICsgbnVtYmVyKS5zcGxpdCgnZScpO1xyXG4gICAgICByZXR1cm4gKyhudW1BcnJheVswXSArICdlJyArIChudW1BcnJheVsxXSA/ICtudW1BcnJheVsxXSArIHByZWNpc2lvbiA6IHByZWNpc2lvbikpO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIGtleTogXCJfcm91bmRcIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcm91bmQobnVtYmVyLCBwcmVjaXNpb24pIHtcclxuICAgICAgcmV0dXJuIE51bWJlck1hc2suX3NoaWZ0KE1hdGgucm91bmQoTnVtYmVyTWFzay5fc2hpZnQobnVtYmVyLCBwcmVjaXNpb24sIGZhbHNlKSksIHByZWNpc2lvbiwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgfSwge1xyXG4gICAga2V5OiBcIl90b0NoYXJBcnJheVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b0NoYXJBcnJheShudW1iZXIpIHtcclxuICAgICAgdmFyIHNpZ251bSA9IE51bWJlck1hc2suX2dldFNpZ24obnVtYmVyKTtcclxuXHJcbiAgICAgIHZhciBjaGFycyA9IFtdO1xyXG5cclxuICAgICAgaWYgKHNpZ251bSAhPT0gMCkge1xyXG4gICAgICAgIHZhciBzdHJpbmcgPSBzaWdudW0gPCAwID8gXCJcIi5jb25jYXQoLTEgKiBudW1iZXIudG9TdHJpbmcoKSkgOiBudW1iZXIudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdCgwKSA9PSAnMCcpIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMSk7IC8vIFRoZSBzdHJpbmcgY29udGFpbnMgb25seSBbMC05XSBhbmQgJy4nXHJcblxyXG4gICAgICAgIGNoYXJzID0gc3RyaW5nLnNwbGl0KCcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNoYXJzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduIG9mIGEgbnVtYmVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggbnVtYmVyXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHNpZ24gb2YgdGhlIGdpdmVuIGFyZ3VtZW50LlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgSWYgdGhlIGFyZ3VtZW50IGlzIGEgcG9zaXRpdmUgbnVtYmVyLCBuZWdhdGl2ZSBudW1iZXIsIHBvc2l0aXZlIHplcm9cclxuICAgICAqICAgICAgICAgICAgICAgICAgIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiAxLCAtMSwgMCBvciAtMCByZXNwZWN0aXZlbHkuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICBPdGhlcndpc2UsIE5hTiBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2dldFNpZ25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U2lnbih4KSB7XHJcbiAgICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreDtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBOdW1iZXJNYXNrO1xyXG59KCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE51bWJlck1hc2spO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJiXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSVNfVElNRV9SRUdFWDsgfSk7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gSVNfREFURV9SRUdFWDsgfSk7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2Vla1N0YXJ0QnlMb2NhbGU7IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldERheU9mWWVhcjsgfSk7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZml4U2hvcnRJU087IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZlwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFRpbWV6b25lT3JPZmZzZXQ7IH0pO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldFdlZWtOdW1iZXI7IH0pO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2RhdGVfZm5zX3R6X3V0Y1RvWm9uZWRUaW1lX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX3dlZWtzdGFydF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XHJcblxyXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxyXG5cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5cclxudmFyIElTX1RJTUVfUkVHRVggPSAvXigyWzAtM118WzAxXVswLTldKTo/KFswLTVdWzAtOV0pOj8oWzAtNV1bMC05XSkoWnxbKy1dKD86MlswLTNdfFswMV1bMC05XSkoPzo6Pyg/OlswLTVdWzAtOV0pKT8pJC87XHJcbnZhciBJU19EQVRFX1JFR0VYID0gL14oKFsxMl1cXGR7M30pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1cXGR8M1swMV0pKFp8WystXSg/OjJbMC0zXXxbMDFdWzAtOV0pKD86Oj8oPzpbMC01XVswLTldKSk/KSkkLztcclxuLyoqXHJcbiAqIEZpbmQgb3V0IHdoZW4gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgcGFzc2VkIGxvY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge2xvY2FsZX0gbG9jYWxlXHJcbiAqXHJcbiAqIEByZXR1cm4ge051bWJlcn0gYSBudW1iZXIgMCA9IHN1bmRheSAsIDEgPSBtb25kYXkgLCAuLi4uXHJcbiAqL1xyXG5cclxudmFyIGdldFdlZWtTdGFydEJ5TG9jYWxlID0gZnVuY3Rpb24gZ2V0V2Vla1N0YXJ0QnlMb2NhbGUobG9jYWxlKSB7XHJcbiAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfd2Vla3N0YXJ0X19bXCJhXCIgLyogZ2V0V2Vla1N0YXJ0QnlMb2NhbGUgKi9dKShsb2NhbGUpO1xyXG59O1xyXG4vKipcclxuICogIEdldCBkYXkgbnVtYmVyIGluIHRoZSB5ZWFyIG9mIHRoZSBwYXNzZWQgZGF0ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGV9IGRhdGVcclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSBkYXkgbnVtYmVyXHJcbiAqL1xyXG5cclxudmFyIGdldERheU9mWWVhciA9IGZ1bmN0aW9uIGdldERheU9mWWVhcihkYXRlKSB7XHJcbiAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAwKTtcclxuICB2YXIgZGlmZiA9IGRhdGUgLSBzdGFydCArIChzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpIC0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKSAqIDYwICogMTAwMDtcclxuICB2YXIgb25lRGF5ID0gMTAwMCAqIDYwICogNjAgKiAyNDtcclxuICB2YXIgZGF5ID0gTWF0aC5mbG9vcihkaWZmIC8gb25lRGF5KTtcclxuICByZXR1cm4gZGF5O1xyXG59O1xyXG4vKipcclxuICogVGFrZXMgaW5jb21wbGV0ZSBpc28gc3RyaW5nIGFuZCByZXR1cm4gYSBjb21wbGV0ZSBvbmVcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGUgaW5jb21wbGV0ZSBpc28gc3RyaW5nXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gY29tcGxldGUgaXNvIHN0cmluZ1xyXG4gKi9cclxuXHJcbnZhciBmaXhTaG9ydElTTyA9IGZ1bmN0aW9uIGZpeFNob3J0SVNPKGRhdGUpIHtcclxuICB2YXIgdmFsdWUgPSBkYXRlO1xyXG4gIHZhciBvZmZzZXQgPSAodmFsdWUubWF0Y2goL3okfFsrXFwtXVxcZFxcZDpcXGRcXGQkL2kpIHx8IFtdKVswXTtcclxuXHJcbiAgaWYgKCFvZmZzZXQpIHtcclxuICAgIG9mZnNldCA9ICdaJztcclxuICAgIHZhbHVlICs9IG9mZnNldDtcclxuICB9XHJcblxyXG4gIGlmIChJU19USU1FX1JFR0VYLnRlc3QodmFsdWUpKSB7XHJcbiAgICB2YWx1ZSA9IFwiMTk3MC0wMS0wMVRcIi5jb25jYXQodmFsdWUpO1xyXG4gIH0gZWxzZSBpZiAoSVNfREFURV9SRUdFWC50ZXN0KHZhbHVlKSkge1xyXG4gICAgdmFsdWUgPSBcIlwiLmNvbmNhdCh2YWx1ZS5zcGxpdChvZmZzZXQpWzBdLCBcIlQwMDowMDowMFwiKS5jb25jYXQob2Zmc2V0KTtcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWx1ZTtcclxufTtcclxuLyoqXHJcbiAqIEdldCB0aGUgYnJvd3NlciB0aW1lem9uZSBuYW1lICwgaWYgbm90IHN1cHBvcnRlZCB0aGVuIHRoZSBicm93c2VyXHJcbiAqIHRpbWV6b25lIG9mZnNldCBmb3JtYXR0ZWRcclxuICpcclxuICogQHJldHVybiB7U3RyaW5nfSB0aW1lem9uZSBvZiBvZmZzZXRcclxuICovXHJcblxyXG52YXIgZ2V0VGltZXpvbmVPck9mZnNldCA9IGZ1bmN0aW9uIGdldFRpbWV6b25lT3JPZmZzZXQoKSB7XHJcbiAgdmFyIHRpbWV6b25lID0gSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lO1xyXG5cclxuICBpZiAoIXRpbWV6b25lKSB7XHJcbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gcGFkKG51bWJlciwgbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBzdHIgPSAnJyArIG51bWJlcjtcclxuXHJcbiAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgc3RyID0gJzAnICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgb2Zmc2V0ID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpO1xyXG4gICAgb2Zmc2V0ID0gKG9mZnNldCA8IDAgPyAnKycgOiAnLScpICsgLy8gTm90ZSB0aGUgcmV2ZXJzZWQgc2lnbiFcclxuICAgIHBhZChwYXJzZUludChNYXRoLmFicyhvZmZzZXQgLyA2MCkpLCAyKSArIHBhZChNYXRoLmFicyhvZmZzZXQgJSA2MCksIDIpO1xyXG4gICAgcmV0dXJuIG9mZnNldDtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aW1lem9uZTtcclxufTtcclxuLyoqXHJcbiAqIEdldCB0aGUgV2VlayBOdW1iZXIgaW4gdGhlIHBhc3NlZCBkYXRlXHJcbiAqXHJcbiAqIEBwYXJhbSB7RGF0ZX0gZGF0ZSAtIERhdGUgb2JqZWN0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3ZWVrU3RhcnQgQSBudW1iZXIgd2hpY2ggZGVmaW5lcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrICgwICA9IHN1bmRheSAsIDEgPSBtb25kYXkgLCAuLi4pXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSB3ZWVrIG51bWJlclxyXG4gKi9cclxuXHJcbnZhciBnZXRXZWVrTnVtYmVyID0gZnVuY3Rpb24gZ2V0V2Vla051bWJlcihkYXRlLCB3ZWVrU3RhcnQpIHtcclxuICB2YXIgZCA9IG5ldyBEYXRlKERhdGUuVVRDKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSkpO1xyXG4gIHZhciBkYXlOdW0gPSBkLmdldFVUQ0RheSgpIC0gKHdlZWtTdGFydCAtIDEpIHx8IDc7XHJcbiAgZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpICsgNCAtIGRheU51bSk7XHJcbiAgdmFyIHllYXJTdGFydCA9IG5ldyBEYXRlKERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpO1xyXG4gIHJldHVybiBNYXRoLmNlaWwoKChkIC0geWVhclN0YXJ0KSAvIDg2NDAwMDAwICsgMSkgLyA3KTtcclxufTtcclxuLyoqXHJcbiAqIERhdGVNYXNrXHJcbiAqXHJcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBmb3IgQkJqIGRhdGVzIG1hc2tpbmdcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcblxyXG52YXIgRGF0ZU1hc2sgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBEYXRlTWFzaygpIHtcclxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEYXRlTWFzayk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoRGF0ZU1hc2ssIG51bGwsIFt7XHJcbiAgICBrZXk6IFwibWFza1wiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFzayBkYXRlXHJcbiAgICAgKlxyXG4gICAgICogTWFzayB0aGUgcGFzc2VkIGRhdGUgd2l0aCB0aGUgcGFzc2VkIG1hc2tcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0ZSBkYXRlIGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayBtYXNrIGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2xvY2FsZT1Ccm93c2VyJ3MgbG9jYWxlXSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGV4KGVuLVVTKS4gZGVmYXVsdCBpcyB0byB0aGUgc3lzdGVtIGxhbmd1YWdlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3RpbWV6b25lPVN5c3RlbSB0aW1lem9uZV0gdGhlIHRpbWUgem9uZSBkZXNjcmlwdG9yIChlLmcuIEFtZXJpY2EvTG9zX0FuZ2VsZXMpLiBkZWZhdWx0IHRvIHRoZSBzeXN0ZW1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gYSBkYXRlIG1hc2tlZCB3aXRoIHRoZSBnaXZlbiBtYXNrXHJcbiAgICAgKi9cclxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrKGRhdGUsIF9tYXNrLCBsb2NhbGUsIHRpbWV6b25lKSB7XHJcbiAgICAgIGlmICghZGF0ZSkgcmV0dXJuICcnO1xyXG4gICAgICBpZiAoIV9tYXNrKSByZXR1cm4gZGF0ZTtcclxuICAgICAgdGltZXpvbmUgPSB0aW1lem9uZSB8fCBnZXRUaW1lem9uZU9yT2Zmc2V0KCk7XHJcbiAgICAgIGxvY2FsZSA9IGxvY2FsZSB8fCBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlIHx8ICdlbi1VUyc7IC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgY29tcGxldGUgaXNvIHN0cmluZ1xyXG5cclxuICAgICAgZGF0ZSA9IGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gZGF0ZSA6IGZpeFNob3J0SVNPKGRhdGUpO1xyXG4gICAgICB2YXIgZGF0ZU9iamVjdCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfZGF0ZV9mbnNfdHpfdXRjVG9ab25lZFRpbWVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZGF0ZSwgdGltZXpvbmUpO1xyXG5cclxuICAgICAgdmFyIHRyYW5zbGF0aW9uID0gRGF0ZU1hc2suX2J1aWxkVHJhbnNsYXRpb24oe1xyXG4gICAgICAgIHllYXI6IGRhdGVPYmplY3QuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICBtb250aDogZGF0ZU9iamVjdC5nZXRNb250aCgpICsgMSxcclxuICAgICAgICBtb250aFNob3J0OiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbbG9jYWxlXSwge1xyXG4gICAgICAgICAgbW9udGg6ICdzaG9ydCdcclxuICAgICAgICB9KS5mb3JtYXQoZGF0ZU9iamVjdCksXHJcbiAgICAgICAgbW9udGhMb25nOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbbG9jYWxlXSwge1xyXG4gICAgICAgICAgbW9udGg6ICdsb25nJ1xyXG4gICAgICAgIH0pLmZvcm1hdChkYXRlT2JqZWN0KSxcclxuICAgICAgICBkYXk6IGRhdGVPYmplY3QuZ2V0RGF0ZSgpLFxyXG4gICAgICAgIGRheVNob3J0OiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbbG9jYWxlXSwge1xyXG4gICAgICAgICAgd2Vla2RheTogJ3Nob3J0J1xyXG4gICAgICAgIH0pLmZvcm1hdChkYXRlT2JqZWN0KSxcclxuICAgICAgICBkYXlMb25nOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChbbG9jYWxlXSwge1xyXG4gICAgICAgICAgd2Vla2RheTogJ2xvbmcnXHJcbiAgICAgICAgfSkuZm9ybWF0KGRhdGVPYmplY3QpLFxyXG4gICAgICAgIG1pbnV0ZXM6IGRhdGVPYmplY3QuZ2V0TWludXRlcygpLFxyXG4gICAgICAgIHNlY29uZHM6IGRhdGVPYmplY3QuZ2V0U2Vjb25kcygpLFxyXG5cclxuICAgICAgICBnZXQgaG91cnMyNCgpIHtcclxuICAgICAgICAgIHJldHVybiBkYXRlT2JqZWN0LmdldEhvdXJzKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IGhvdXJzMTIoKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5ob3VyczI0ICUgMTIgfHwgMTI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGF5T2ZZZWFyOiBnZXREYXlPZlllYXIoZGF0ZU9iamVjdCksXHJcbiAgICAgICAgZGF5T2ZXZWVrOiBkYXRlT2JqZWN0LmdldERheSgpICsgMSxcclxuICAgICAgICAvLyBTdW5kYXkgPSAxIGluIEJCaiBidXQgU3VuZGF5ID0gMCBpbiBKU1xyXG4gICAgICAgIHdlZWtOdW1iZXI6IGdldFdlZWtOdW1iZXIoZGF0ZU9iamVjdCwgZ2V0V2Vla1N0YXJ0QnlMb2NhbGUobG9jYWxlKSksXHJcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXHJcbiAgICAgICAgdGltZXpvbmU6IHRpbWV6b25lXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IF9tYXNrO1xyXG5cclxuICAgICAgZm9yICh2YXIgayBpbiB0cmFuc2xhdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKG5ldyBSZWdFeHAoJyglJyArIGsgKyAnKScsICdnJyksIHRyYW5zbGF0aW9uW2tdKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbWFwIG9iamVjdCB3aGljaCBjb250YWlucyBhbGwgcG9zc2libGUgZm9ybXMgb2YgbWFza3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0ZURldGFpbHMgZGF0ZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gZm9ybXMgbWFza3NcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiX2J1aWxkVHJhbnNsYXRpb25cIixcclxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUcmFuc2xhdGlvbihkYXRlRGV0YWlscykge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC8vIHllYXJcclxuICAgICAgICBZejogZGF0ZURldGFpbHMueWVhci50b1N0cmluZygpLnN1YnN0cigtMiksXHJcbiAgICAgICAgWXM6IGRhdGVEZXRhaWxzLnllYXIsXHJcbiAgICAgICAgWWw6IGRhdGVEZXRhaWxzLnllYXIsXHJcbiAgICAgICAgWXA6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMueWVhciksXHJcbiAgICAgICAgWWQ6IGRhdGVEZXRhaWxzLnllYXIsXHJcbiAgICAgICAgWTogZGF0ZURldGFpbHMueWVhcixcclxuICAgICAgICAvLyBtb250aFxyXG4gICAgICAgIE16OiBTdHJpbmcoZGF0ZURldGFpbHMubW9udGgpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMubW9udGggOiBkYXRlRGV0YWlscy5tb250aCxcclxuICAgICAgICBNczogZGF0ZURldGFpbHMubW9udGhTaG9ydCxcclxuICAgICAgICBNbDogZGF0ZURldGFpbHMubW9udGhMb25nLFxyXG4gICAgICAgIE1wOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLm1vbnRoKSxcclxuICAgICAgICBNZDogZGF0ZURldGFpbHMubW9udGgsXHJcbiAgICAgICAgTTogZGF0ZURldGFpbHMubW9udGgsXHJcbiAgICAgICAgLy8gZGF5XHJcbiAgICAgICAgRHo6IFN0cmluZyhkYXRlRGV0YWlscy5kYXkpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMuZGF5IDogZGF0ZURldGFpbHMuZGF5LFxyXG4gICAgICAgIERzOiBkYXRlRGV0YWlscy5kYXlTaG9ydCxcclxuICAgICAgICBEbDogZGF0ZURldGFpbHMuZGF5TG9uZyxcclxuICAgICAgICBEcDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRlRGV0YWlscy5kYXkpLFxyXG4gICAgICAgIERkOiBkYXRlRGV0YWlscy5kYXksXHJcbiAgICAgICAgRDogZGF0ZURldGFpbHMuZGF5LFxyXG4gICAgICAgIC8vIGhvdXIgMjRcclxuICAgICAgICBIejogU3RyaW5nKGRhdGVEZXRhaWxzLmhvdXJzMjQpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMuaG91cnMyNCA6IGRhdGVEZXRhaWxzLmhvdXJzMjQsXHJcbiAgICAgICAgSHM6IGRhdGVEZXRhaWxzLmhvdXJzMjQsXHJcbiAgICAgICAgSGw6IGRhdGVEZXRhaWxzLmhvdXJzMjQsXHJcbiAgICAgICAgSHA6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMuaG91cnMyNCksXHJcbiAgICAgICAgSGQ6IGRhdGVEZXRhaWxzLmhvdXJzMjQsXHJcbiAgICAgICAgSDogZGF0ZURldGFpbHMuaG91cnMyNCxcclxuICAgICAgICAvLyBob3VyIDEyXHJcbiAgICAgICAgaHo6IFN0cmluZyhkYXRlRGV0YWlscy5ob3VyczEyKS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLmhvdXJzMTIgOiBkYXRlRGV0YWlscy5ob3VyczEyLFxyXG4gICAgICAgIGhzOiBkYXRlRGV0YWlscy5ob3VyczEyLFxyXG4gICAgICAgIGhsOiBkYXRlRGV0YWlscy5ob3VyczEyLFxyXG4gICAgICAgIGhwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLmhvdXJzMTIpLFxyXG4gICAgICAgIGhkOiBkYXRlRGV0YWlscy5ob3VyczEyLFxyXG4gICAgICAgIGg6IGRhdGVEZXRhaWxzLmhvdXJzMTIsXHJcbiAgICAgICAgLy8gbWludXRlc1xyXG4gICAgICAgIG16OiBTdHJpbmcoZGF0ZURldGFpbHMubWludXRlcykubGVuZ3RoID09IDEgPyAnMCcgKyBkYXRlRGV0YWlscy5taW51dGVzIDogZGF0ZURldGFpbHMubWludXRlcyxcclxuICAgICAgICBtczogZGF0ZURldGFpbHMubWludXRlcyxcclxuICAgICAgICBtbDogZGF0ZURldGFpbHMubWludXRlcyxcclxuICAgICAgICBtcDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRlRGV0YWlscy5taW51dGVzKSxcclxuICAgICAgICBtZDogZGF0ZURldGFpbHMubWludXRlcyxcclxuICAgICAgICBtOiBkYXRlRGV0YWlscy5taW51dGVzLFxyXG4gICAgICAgIC8vIHNlY29uZHNcclxuICAgICAgICBzejogU3RyaW5nKGRhdGVEZXRhaWxzLnNlY29uZHMpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMuc2Vjb25kcyA6IGRhdGVEZXRhaWxzLnNlY29uZHMsXHJcbiAgICAgICAgc3M6IGRhdGVEZXRhaWxzLnNlY29uZHMsXHJcbiAgICAgICAgc2w6IGRhdGVEZXRhaWxzLnNlY29uZHMsXHJcbiAgICAgICAgc3A6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMuc2Vjb25kcyksXHJcbiAgICAgICAgc2Q6IGRhdGVEZXRhaWxzLnNlY29uZHMsXHJcbiAgICAgICAgczogZGF0ZURldGFpbHMuc2Vjb25kcyxcclxuICAgICAgICAvLyBBTSAsIFBNXHJcbiAgICAgICAgUFA6IGRhdGVEZXRhaWxzLmhvdXJzMjQgPiAxMiA/ICdQTScgOiAnUE0nLFxyXG4gICAgICAgIFA6IGRhdGVEZXRhaWxzLmhvdXJzMjQgPiAxMiA/ICdQTScgOiAnQU0nLFxyXG4gICAgICAgIHBwOiBkYXRlRGV0YWlscy5ob3VyczI0ID4gMTIgPyAncG0nIDogJ2FtJyxcclxuICAgICAgICBwOiBkYXRlRGV0YWlscy5ob3VyczI0ID4gMTIgPyAncG0nIDogJ2FtJyxcclxuICAgICAgICAvLyBEYXkgb2YgWWVhclxyXG4gICAgICAgIEp6OiBTdHJpbmcoZGF0ZURldGFpbHMuZGF5T2ZZZWFyKS5sZW5ndGggPT0gMSA/ICcwJyArIGRhdGVEZXRhaWxzLmRheU9mWWVhciA6IGRhdGVEZXRhaWxzLmRheU9mWWVhcixcclxuICAgICAgICBKczogZGF0ZURldGFpbHMuZGF5T2ZZZWFyLFxyXG4gICAgICAgIEpsOiBkYXRlRGV0YWlscy5kYXlPZlllYXIsXHJcbiAgICAgICAgSmQ6IGRhdGVEZXRhaWxzLmRheU9mWWVhcixcclxuICAgICAgICBKOiBkYXRlRGV0YWlscy5kYXlPZlllYXIsXHJcbiAgICAgICAgLy8gRGF5IE9mIFdlZWtcclxuICAgICAgICBXejogU3RyaW5nKGRhdGVEZXRhaWxzLmRheU9mV2VlaykubGVuZ3RoID09IDEgPyAnMCcgKyBkYXRlRGV0YWlscy5kYXlPZldlZWsgOiBkYXRlRGV0YWlscy5kYXlPZldlZWssXHJcbiAgICAgICAgV3M6IGRhdGVEZXRhaWxzLmRheU9mV2VlayxcclxuICAgICAgICBXbDogZGF0ZURldGFpbHMuZGF5T2ZXZWVrLFxyXG4gICAgICAgIFdwOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGVEZXRhaWxzLmRheU9mV2VlayksXHJcbiAgICAgICAgV2Q6IGRhdGVEZXRhaWxzLmRheU9mV2VlayxcclxuICAgICAgICBXOiBkYXRlRGV0YWlscy5kYXlPZldlZWssXHJcbiAgICAgICAgLy8gd2VlayBudW1iZXJcclxuICAgICAgICB3ejogU3RyaW5nKGRhdGVEZXRhaWxzLndlZWtOdW1iZXIpLmxlbmd0aCA9PSAxID8gJzAnICsgZGF0ZURldGFpbHMud2Vla051bWJlciA6IGRhdGVEZXRhaWxzLndlZWtOdW1iZXIsXHJcbiAgICAgICAgd3M6IGRhdGVEZXRhaWxzLndlZWtOdW1iZXIsXHJcbiAgICAgICAgd2w6IGRhdGVEZXRhaWxzLndlZWtOdW1iZXIsXHJcbiAgICAgICAgd3A6IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0ZURldGFpbHMud2Vla051bWJlciksXHJcbiAgICAgICAgd2Q6IGRhdGVEZXRhaWxzLndlZWtOdW1iZXIsXHJcbiAgICAgICAgdzogZGF0ZURldGFpbHMud2Vla051bWJlclxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIERhdGVNYXNrO1xyXG59KCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJjXCJdID0gKERhdGVNYXNrKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHV0Y1RvWm9uZWRUaW1lO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdHpQYXJzZVRpbWV6b25lX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2RhdGVfZm5zX2VzbV9zdWJNaWxsaXNlY29uZHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX190b0RhdGVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBuYW1lIHV0Y1RvWm9uZWRUaW1lXHJcbiAqIEBjYXRlZ29yeSBUaW1lIFpvbmUgSGVscGVyc1xyXG4gKiBAc3VtbWFyeSBHZXQgYSBkYXRlL3RpbWUgcmVwcmVzZW50aW5nIGxvY2FsIHRpbWUgaW4gYSBnaXZlbiB0aW1lIHpvbmUgZnJvbSB0aGUgVVRDIGRhdGVcclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJldHVybnMgYSBkYXRlIGluc3RhbmNlIHdpdGggdmFsdWVzIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgdGltZSBpbiB0aGUgdGltZSB6b25lXHJcbiAqIHNwZWNpZmllZCBvZiB0aGUgVVRDIHRpbWUgZnJvbSB0aGUgZGF0ZSBwcm92aWRlZC4gSW4gb3RoZXIgd29yZHMsIHdoZW4gdGhlIG5ldyBkYXRlXHJcbiAqIGlzIGZvcm1hdHRlZCBpdCB3aWxsIHNob3cgdGhlIGVxdWl2YWxlbnQgaG91cnMgaW4gdGhlIHRhcmdldCB0aW1lIHpvbmUgcmVnYXJkbGVzc1xyXG4gKiBvZiB0aGUgY3VycmVudCBzeXN0ZW0gdGltZSB6b25lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGV8U3RyaW5nfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHdpdGggdGhlIHJlbGV2YW50IFVUQyB0aW1lXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aW1lWm9uZSAtIHRoZSB0aW1lIHpvbmUgdG8gZ2V0IGxvY2FsIHRpbWUgZm9yLCBjYW4gYmUgYW4gb2Zmc2V0IG9yIElBTkEgdGltZSB6b25lXHJcbiAqIEBwYXJhbSB7T3B0aW9uc1dpdGhUWn0gW29wdGlvbnNdIC0gdGhlIG9iamVjdCB3aXRoIG9wdGlvbnMuIFNlZSBbT3B0aW9uc117QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy9PcHRpb25zfVxyXG4gKiBAcGFyYW0gezB8MXwyfSBbb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzPTJdIC0gcGFzc2VkIHRvIGB0b0RhdGVgLiBTZWUgW3RvRGF0ZV17QGxpbmsgaHR0cHM6Ly9kYXRlLWZucy5vcmcvZG9jcy90b0RhdGV9XHJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgbmV3IGRhdGUgd2l0aCB0aGUgZXF1aXZhbGVudCB0aW1lIGluIHRoZSB0aW1lIHpvbmVcclxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBJbiBKdW5lIDEwYW0gVVRDIGlzIDZhbSBpbiBOZXcgWW9yayAoLTA0OjAwKVxyXG4gKiBjb25zdCByZXN1bHQgPSB1dGNUb1pvbmVkVGltZSgnMjAxNC0wNi0yNVQxMDowMDowMC4wMDBaJywgJ0FtZXJpY2EvTmV3X1lvcmsnKVxyXG4gKiAvLz0+IEp1biAyNSAyMDE0IDA2OjAwOjAwXHJcbiAqL1xyXG5mdW5jdGlvbiB1dGNUb1pvbmVkVGltZShkaXJ0eURhdGUsIHRpbWVab25lLCBvcHRpb25zKSB7XHJcbiAgdmFyIGRhdGUgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX190b0RhdGVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoZGlydHlEYXRlLCBvcHRpb25zKVxyXG5cclxuICAvLyBUaGlzIGRhdGUgaGFzIHRoZSBVVEMgdGltZSB2YWx1ZXMgb2YgdGhlIGlucHV0IGRhdGUgYXQgdGhlIHN5c3RlbSB0aW1lIHpvbmVcclxuICB2YXIgdXRjRGF0ZSA9IG5ldyBEYXRlKFxyXG4gICAgZGF0ZS5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgZGF0ZS5nZXRVVENNb250aCgpLFxyXG4gICAgZGF0ZS5nZXRVVENEYXRlKCksXHJcbiAgICBkYXRlLmdldFVUQ0hvdXJzKCksXHJcbiAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcclxuICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxyXG4gICAgZGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKVxyXG4gIClcclxuICAvLyBXZSBqdXN0IG5lZWQgdG8gYXBwbHkgdGhlIG9mZnNldCBpbmRpY2F0ZWQgYnkgdGhlIHRpbWUgem9uZSB0byB0aGlzIGxvY2FsaXplZCBkYXRlXHJcbiAgdmFyIG9mZnNldE1pbGxpc2Vjb25kcyA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2xpYl90elBhcnNlVGltZXpvbmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkodGltZVpvbmUsIGRhdGUpXHJcblxyXG4gIHJldHVybiBvZmZzZXRNaWxsaXNlY29uZHNcclxuICAgID8gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fc3ViTWlsbGlzZWNvbmRzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKHV0Y0RhdGUsIG9mZnNldE1pbGxpc2Vjb25kcylcclxuICAgIDogdXRjRGF0ZVxyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gdHpUb2tlbml6ZURhdGU7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRzXSB0b2tlbnMgb2YgdGhlIHByb3ZpZGVkXHJcbiAqIGBkYXRlYCBhcyBpdCB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBgdGltZVpvbmVgLlxyXG4gKi9cclxuZnVuY3Rpb24gdHpUb2tlbml6ZURhdGUoZGF0ZSwgdGltZVpvbmUpIHtcclxuICB2YXIgZHRmID0gZ2V0RGF0ZVRpbWVGb3JtYXQodGltZVpvbmUpXHJcbiAgcmV0dXJuIGR0Zi5mb3JtYXRUb1BhcnRzID8gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSlcclxufVxyXG5cclxudmFyIHR5cGVUb1BvcyA9IHtcclxuICB5ZWFyOiAwLFxyXG4gIG1vbnRoOiAxLFxyXG4gIGRheTogMixcclxuICBob3VyOiAzLFxyXG4gIG1pbnV0ZTogNCxcclxuICBzZWNvbmQ6IDVcclxufVxyXG5cclxuZnVuY3Rpb24gcGFydHNPZmZzZXQoZHRmLCBkYXRlKSB7XHJcbiAgdmFyIGZvcm1hdHRlZCA9IGR0Zi5mb3JtYXRUb1BhcnRzKGRhdGUpXHJcbiAgdmFyIGZpbGxlZCA9IFtdXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBwb3MgPSB0eXBlVG9Qb3NbZm9ybWF0dGVkW2ldLnR5cGVdXHJcblxyXG4gICAgaWYgKHBvcyA+PSAwKSB7XHJcbiAgICAgIGZpbGxlZFtwb3NdID0gcGFyc2VJbnQoZm9ybWF0dGVkW2ldLnZhbHVlLCAxMClcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGZpbGxlZFxyXG59XHJcblxyXG5mdW5jdGlvbiBoYWNreU9mZnNldChkdGYsIGRhdGUpIHtcclxuICB2YXIgZm9ybWF0dGVkID0gZHRmLmZvcm1hdChkYXRlKS5yZXBsYWNlKC9cXHUyMDBFL2csICcnKVxyXG4gIHZhciBwYXJzZWQgPSAvKFxcZCspXFwvKFxcZCspXFwvKFxcZCspLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKVxyXG4gIC8vIHZhciBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWRcclxuICAvLyByZXR1cm4gW2ZZZWFyLCBmTW9udGgsIGZEYXksIGZIb3VyLCBmTWludXRlLCBmU2Vjb25kXVxyXG4gIHJldHVybiBbcGFyc2VkWzNdLCBwYXJzZWRbMV0sIHBhcnNlZFsyXSwgcGFyc2VkWzRdLCBwYXJzZWRbNV0sIHBhcnNlZFs2XV1cclxufVxyXG5cclxuLy8gR2V0IGEgY2FjaGVkIEludGwuRGF0ZVRpbWVGb3JtYXQgaW5zdGFuY2UgZm9yIHRoZSBJQU5BIGB0aW1lWm9uZWAuIFRoaXMgY2FuIGJlIHVzZWRcclxuLy8gdG8gZ2V0IGRldGVybWluaXN0aWMgbG9jYWwgZGF0ZS90aW1lIG91dHB1dCBhY2NvcmRpbmcgdG8gdGhlIGBlbi1VU2AgbG9jYWxlIHdoaWNoXHJcbi8vIGNhbiBiZSB1c2VkIHRvIGV4dHJhY3QgbG9jYWwgdGltZSBwYXJ0cyBhcyBuZWNlc3NhcnkuXHJcbnZhciBkdGZDYWNoZSA9IHt9XHJcbmZ1bmN0aW9uIGdldERhdGVUaW1lRm9ybWF0KHRpbWVab25lKSB7XHJcbiAgaWYgKCFkdGZDYWNoZVt0aW1lWm9uZV0pIHtcclxuICAgIC8vIE5ldyBicm93c2VycyB1c2UgYGhvdXJDeWNsZWAsIElFIGFuZCBDaHJvbWUgPDczIGRvZXMgbm90IHN1cHBvcnQgaXQgYW5kIHVzZXMgYGhvdXIxMmBcclxuICAgIHZhciB0ZXN0RGF0ZUZvcm1hdHRlZCA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHtcclxuICAgICAgaG91cjEyOiBmYWxzZSxcclxuICAgICAgdGltZVpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyxcclxuICAgICAgeWVhcjogJ251bWVyaWMnLFxyXG4gICAgICBtb250aDogJzItZGlnaXQnLFxyXG4gICAgICBkYXk6ICcyLWRpZ2l0JyxcclxuICAgICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgc2Vjb25kOiAnMi1kaWdpdCdcclxuICAgIH0pLmZvcm1hdChuZXcgRGF0ZSgnMjAxNC0wNi0yNVQwNDowMDowMC4xMjNaJykpXHJcbiAgICB2YXIgaG91ckN5Y2xlU3VwcG9ydGVkID1cclxuICAgICAgdGVzdERhdGVGb3JtYXR0ZWQgPT09ICcwNi8yNS8yMDE0LCAwMDowMDowMCcgfHxcclxuICAgICAgdGVzdERhdGVGb3JtYXR0ZWQgPT09ICfigI4wNuKAji/igI4yNeKAji/igI4yMDE04oCOIOKAjjAw4oCOOuKAjjAw4oCOOuKAjjAwJ1xyXG5cclxuICAgIGR0ZkNhY2hlW3RpbWVab25lXSA9IGhvdXJDeWNsZVN1cHBvcnRlZFxyXG4gICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCdlbi1VUycsIHtcclxuICAgICAgICAgIGhvdXIxMjogZmFsc2UsXHJcbiAgICAgICAgICB0aW1lWm9uZTogdGltZVpvbmUsXHJcbiAgICAgICAgICB5ZWFyOiAnbnVtZXJpYycsXHJcbiAgICAgICAgICBtb250aDogJzItZGlnaXQnLFxyXG4gICAgICAgICAgZGF5OiAnMi1kaWdpdCcsXHJcbiAgICAgICAgICBob3VyOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgICBtaW51dGU6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgIHNlY29uZDogJzItZGlnaXQnXHJcbiAgICAgICAgfSlcclxuICAgICAgOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCgnZW4tVVMnLCB7XHJcbiAgICAgICAgICBob3VyQ3ljbGU6ICdoMjMnLFxyXG4gICAgICAgICAgdGltZVpvbmU6IHRpbWVab25lLFxyXG4gICAgICAgICAgeWVhcjogJ251bWVyaWMnLFxyXG4gICAgICAgICAgbW9udGg6ICcyLWRpZ2l0JyxcclxuICAgICAgICAgIGRheTogJzItZGlnaXQnLFxyXG4gICAgICAgICAgaG91cjogJzItZGlnaXQnLFxyXG4gICAgICAgICAgbWludXRlOiAnMi1kaWdpdCcsXHJcbiAgICAgICAgICBzZWNvbmQ6ICcyLWRpZ2l0J1xyXG4gICAgICAgIH0pXHJcbiAgfVxyXG4gIHJldHVybiBkdGZDYWNoZVt0aW1lWm9uZV1cclxufVxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGltbXV0YWJsZSkgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSBzdWJNaWxsaXNlY29uZHM7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2xpYl90b0ludGVnZXJfaW5kZXhfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2FkZE1pbGxpc2Vjb25kc19pbmRleF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBuYW1lIHN1Yk1pbGxpc2Vjb25kc1xyXG4gKiBAY2F0ZWdvcnkgTWlsbGlzZWNvbmQgSGVscGVyc1xyXG4gKiBAc3VtbWFyeSBTdWJ0cmFjdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZ2l2ZW4gZGF0ZS5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFN1YnRyYWN0IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBnaXZlbiBkYXRlLlxyXG4gKlxyXG4gKiAjIyMgdjIuMC4wIGJyZWFraW5nIGNoYW5nZXM6XHJcbiAqXHJcbiAqIC0gW0NoYW5nZXMgdGhhdCBhcmUgY29tbW9uIGZvciB0aGUgd2hvbGUgbGlicmFyeV0oaHR0cHM6Ly9naXRodWIuY29tL2RhdGUtZm5zL2RhdGUtZm5zL2Jsb2IvbWFzdGVyL2RvY3MvdXBncmFkZUd1aWRlLm1kI0NvbW1vbi1DaGFuZ2VzKS5cclxuICpcclxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGJlIGNoYW5nZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIHRvIGJlIHN1YnRyYWN0ZWRcclxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgc3VidHJhY3RlZFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDIgYXJndW1lbnRzIHJlcXVpcmVkXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFN1YnRyYWN0IDc1MCBtaWxsaXNlY29uZHMgZnJvbSAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxyXG4gKiB2YXIgcmVzdWx0ID0gc3ViTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxyXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NToyOS4yNTBcclxuICovXHJcblxyXG5mdW5jdGlvbiBzdWJNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIgYW1vdW50ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fbGliX3RvSW50ZWdlcl9pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkaXJ0eUFtb3VudCk7XHJcbiAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2FkZE1pbGxpc2Vjb25kc19pbmRleF9qc19fW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShkaXJ0eURhdGUsIC1hbW91bnQpO1xyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gYWRkTWlsbGlzZWNvbmRzO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdG9JbnRlZ2VyX2luZGV4X2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX190b0RhdGVfaW5kZXhfanNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSBhZGRNaWxsaXNlY29uZHNcclxuICogQGNhdGVnb3J5IE1pbGxpc2Vjb25kIEhlbHBlcnNcclxuICogQHN1bW1hcnkgQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXHJcbiAqXHJcbiAqICMjIyB2Mi4wLjAgYnJlYWtpbmcgY2hhbmdlczpcclxuICpcclxuICogLSBbQ2hhbmdlcyB0aGF0IGFyZSBjb21tb24gZm9yIHRoZSB3aG9sZSBsaWJyYXJ5XShodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjQ29tbW9uLUNoYW5nZXMpLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlIC0gdGhlIGRhdGUgdG8gYmUgY2hhbmdlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gYmUgYWRkZWRcclxuICogQHJldHVybnMge0RhdGV9IHRoZSBuZXcgZGF0ZSB3aXRoIHRoZSBtaWxsaXNlY29uZHMgYWRkZWRcclxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBBZGQgNzUwIG1pbGxpc2Vjb25kcyB0byAxMCBKdWx5IDIwMTQgMTI6NDU6MzAuMDAwOlxyXG4gKiB2YXIgcmVzdWx0ID0gYWRkTWlsbGlzZWNvbmRzKG5ldyBEYXRlKDIwMTQsIDYsIDEwLCAxMiwgNDUsIDMwLCAwKSwgNzUwKVxyXG4gKiAvLz0+IFRodSBKdWwgMTAgMjAxNCAxMjo0NTozMC43NTBcclxuICovXHJcblxyXG5mdW5jdGlvbiBhZGRNaWxsaXNlY29uZHMoZGlydHlEYXRlLCBkaXJ0eUFtb3VudCkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMiBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBwcmVzZW50Jyk7XHJcbiAgfVxyXG5cclxuICB2YXIgdGltZXN0YW1wID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fdG9EYXRlX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRpcnR5RGF0ZSkuZ2V0VGltZSgpO1xyXG4gIHZhciBhbW91bnQgPSBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19saWJfdG9JbnRlZ2VyX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKGRpcnR5QW1vdW50KTtcclxuICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgYW1vdW50KTtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDEyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IHRvRGF0ZTtcclxuLyoqXHJcbiAqIEBuYW1lIHRvRGF0ZVxyXG4gKiBAY2F0ZWdvcnkgQ29tbW9uIEhlbHBlcnNcclxuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXHJcbiAqXHJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBpdHMgY2xvbmUuXHJcbiAqXHJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cclxuICpcclxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXHJcbiAqXHJcbiAqICoqTm90ZSoqOiAqYWxsKiBEYXRlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYW55ICpkYXRlLWZucyogZnVuY3Rpb24gaXMgcHJvY2Vzc2VkIGJ5IGB0b0RhdGVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBhcmd1bWVudCAtIHRoZSB2YWx1ZSB0byBjb252ZXJ0XHJcbiAqIEByZXR1cm5zIHtEYXRlfSB0aGUgcGFyc2VkIGRhdGUgaW4gdGhlIGxvY2FsIHRpbWUgem9uZVxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XHJcbiAqIGNvbnN0IHJlc3VsdCA9IHRvRGF0ZShuZXcgRGF0ZSgyMDE0LCAxLCAxMSwgMTEsIDMwLCAzMCkpXHJcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIENvbnZlcnQgdGhlIHRpbWVzdGFtcCB0byBkYXRlOlxyXG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcclxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcclxuICovXHJcbmZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCkge1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnKTtcclxuICB9XHJcblxyXG4gIHZhciBhcmdTdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpOyAvLyBDbG9uZSB0aGUgZGF0ZVxyXG5cclxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiYgYXJnU3RyID09PSAnW29iamVjdCBEYXRlXScpIHtcclxuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50LmdldFRpbWUoKSk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgTnVtYmVyXScpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICgodHlwZW9mIGFyZ3VtZW50ID09PSAnc3RyaW5nJyB8fCBhcmdTdHIgPT09ICdbb2JqZWN0IFN0cmluZ10nKSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgY29uc29sZS53YXJuKFwiU3RhcnRpbmcgd2l0aCB2Mi4wLjAtYmV0YS4xIGRhdGUtZm5zIGRvZXNuJ3QgYWNjZXB0IHN0cmluZ3MgYXMgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdC5pby9manVsZVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuXHJcbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoKS5zdGFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XHJcbiAgfVxyXG59XHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChpbW11dGFibGUpICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gdG9EYXRlO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2RhdGVfZm5zX2VzbV9saWJfdG9JbnRlZ2VyX2luZGV4X2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX2RhdGVfZm5zX2VzbV9saWJfZ2V0VGltZXpvbmVPZmZzZXRJbk1pbGxpc2Vjb25kc19pbmRleF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2xpYl90elBhcnNlVGltZXpvbmVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5cclxuXHJcblxyXG52YXIgTUlMTElTRUNPTkRTX0lOX0hPVVIgPSAzNjAwMDAwXHJcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDBcclxudmFyIERFRkFVTFRfQURESVRJT05BTF9ESUdJVFMgPSAyXHJcblxyXG52YXIgcGF0dGVybnMgPSB7XHJcbiAgZGF0ZVRpbWVEZWxpbWV0ZXI6IC9bVCBdLyxcclxuICBwbGFpblRpbWU6IC86LyxcclxuICB0aW1lWm9uZURlbGltZXRlcjogL1taIF0vaSxcclxuXHJcbiAgLy8geWVhciB0b2tlbnNcclxuICBZWTogL14oXFxkezJ9KSQvLFxyXG4gIFlZWTogW1xyXG4gICAgL14oWystXVxcZHsyfSkkLywgLy8gMCBhZGRpdGlvbmFsIGRpZ2l0c1xyXG4gICAgL14oWystXVxcZHszfSkkLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XHJcbiAgICAvXihbKy1dXFxkezR9KSQvIC8vIDIgYWRkaXRpb25hbCBkaWdpdHNcclxuICBdLFxyXG4gIFlZWVk6IC9eKFxcZHs0fSkvLFxyXG4gIFlZWVlZOiBbXHJcbiAgICAvXihbKy1dXFxkezR9KS8sIC8vIDAgYWRkaXRpb25hbCBkaWdpdHNcclxuICAgIC9eKFsrLV1cXGR7NX0pLywgLy8gMSBhZGRpdGlvbmFsIGRpZ2l0XHJcbiAgICAvXihbKy1dXFxkezZ9KS8gLy8gMiBhZGRpdGlvbmFsIGRpZ2l0c1xyXG4gIF0sXHJcblxyXG4gIC8vIGRhdGUgdG9rZW5zXHJcbiAgTU06IC9eLShcXGR7Mn0pJC8sXHJcbiAgREREOiAvXi0/KFxcZHszfSkkLyxcclxuICBNTUREOiAvXi0/KFxcZHsyfSktPyhcXGR7Mn0pJC8sXHJcbiAgV3d3OiAvXi0/VyhcXGR7Mn0pJC8sXHJcbiAgV3d3RDogL14tP1coXFxkezJ9KS0/KFxcZHsxfSkkLyxcclxuXHJcbiAgSEg6IC9eKFxcZHsyfShbLixdXFxkKik/KSQvLFxyXG4gIEhITU06IC9eKFxcZHsyfSk6PyhcXGR7Mn0oWy4sXVxcZCopPykkLyxcclxuICBISE1NU1M6IC9eKFxcZHsyfSk6PyhcXGR7Mn0pOj8oXFxkezJ9KFsuLF1cXGQqKT8pJC8sXHJcblxyXG4gIC8vIHRpbWV6b25lIHRva2VucyAodG8gaWRlbnRpZnkgdGhlIHByZXNlbmNlIG9mIGEgdHopXHJcbiAgdGltZXpvbmU6IC8oW1orLV0uKnwgVVRDfCg/OlthLXpBLVpdK1xcL1thLXpBLVpfXSsoPzpcXC9bYS16QS1aX10rKT8pKSQvXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAbmFtZSB0b0RhdGVcclxuICogQGNhdGVnb3J5IENvbW1vbiBIZWxwZXJzXHJcbiAqIEBzdW1tYXJ5IENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXHJcbiAqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcmd1bWVudCB0byBhbiBpbnN0YW5jZSBvZiBEYXRlLlxyXG4gKlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgRGF0ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgaXRzIGNsb25lLlxyXG4gKlxyXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXHJcbiAqXHJcbiAqIElmIGFuIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0aGUgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgaXQuXHJcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxyXG4gKiBJU08gODYwMTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMVxyXG4gKiBJZiB0aGUgZnVuY3Rpb24gY2Fubm90IHBhcnNlIHRoZSBzdHJpbmcgb3IgdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXHJcbiAqXHJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBub25lIG9mIHRoZSBhYm92ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgSW52YWxpZCBEYXRlLlxyXG4gKlxyXG4gKiAqKk5vdGUqKjogKmFsbCogRGF0ZSBhcmd1bWVudHMgcGFzc2VkIHRvIGFueSAqZGF0ZS1mbnMqIGZ1bmN0aW9uIGlzIHByb2Nlc3NlZCBieSBgdG9EYXRlYC5cclxuICogQWxsICpkYXRlLWZucyogZnVuY3Rpb25zIHdpbGwgdGhyb3cgYFJhbmdlRXJyb3JgIGlmIGBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHNgIGlzIG5vdCAwLCAxLCAyIG9yIHVuZGVmaW5lZC5cclxuICpcclxuICogQHBhcmFtIHtEYXRlfFN0cmluZ3xOdW1iZXJ9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcclxuICogQHBhcmFtIHtPcHRpb25zV2l0aFRafSBbb3B0aW9uc10gLSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucy4gU2VlIFtPcHRpb25zXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL09wdGlvbnN9XHJcbiAqIEBwYXJhbSB7MHwxfDJ9IFtvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHM9Ml0gLSB0aGUgYWRkaXRpb25hbCBudW1iZXIgb2YgZGlnaXRzIGluIHRoZSBleHRlbmRlZCB5ZWFyIGZvcm1hdFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltZVpvbmU9JyddIC0gdXNlZCB0byBzcGVjaWZ5IHRoZSBJQU5BIHRpbWUgem9uZSBvZmZzZXQgb2YgYSBkYXRlIFN0cmluZy5cclxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzYCBtdXN0IGJlIDAsIDEgb3IgMlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnMjAxNC0wMi0xMVQxMTozMDozMCcgdG8gZGF0ZTpcclxuICogdmFyIHJlc3VsdCA9IHRvRGF0ZSgnMjAxNC0wMi0xMVQxMTozMDozMCcpXHJcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIENvbnZlcnQgc3RyaW5nICcrMDIwMTQxMDEnIHRvIGRhdGUsXHJcbiAqIC8vIGlmIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0IGlzIDE6XHJcbiAqIHZhciByZXN1bHQgPSB0b0RhdGUoJyswMjAxNDEwMScsIHthZGRpdGlvbmFsRGlnaXRzOiAxfSlcclxuICogLy89PiBGcmkgQXByIDExIDIwMTQgMDA6MDA6MDBcclxuICovXHJcbmZ1bmN0aW9uIHRvRGF0ZShhcmd1bWVudCwgZGlydHlPcHRpb25zKSB7XHJcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgICAnMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIHByZXNlbnQnXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBpZiAoYXJndW1lbnQgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgfVxyXG5cclxuICB2YXIgb3B0aW9ucyA9IGRpcnR5T3B0aW9ucyB8fCB7fVxyXG5cclxuICB2YXIgYWRkaXRpb25hbERpZ2l0cyA9XHJcbiAgICBvcHRpb25zLmFkZGl0aW9uYWxEaWdpdHMgPT0gbnVsbFxyXG4gICAgICA/IERFRkFVTFRfQURESVRJT05BTF9ESUdJVFNcclxuICAgICAgOiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX2RhdGVfZm5zX2VzbV9saWJfdG9JbnRlZ2VyX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0cylcclxuICBpZiAoXHJcbiAgICBhZGRpdGlvbmFsRGlnaXRzICE9PSAyICYmXHJcbiAgICBhZGRpdGlvbmFsRGlnaXRzICE9PSAxICYmXHJcbiAgICBhZGRpdGlvbmFsRGlnaXRzICE9PSAwXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYWRkaXRpb25hbERpZ2l0cyBtdXN0IGJlIDAsIDEgb3IgMicpXHJcbiAgfVxyXG5cclxuICAvLyBDbG9uZSB0aGUgZGF0ZVxyXG4gIGlmIChcclxuICAgIGFyZ3VtZW50IGluc3RhbmNlb2YgRGF0ZSB8fFxyXG4gICAgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KSA9PT0gJ1tvYmplY3QgRGF0ZV0nKVxyXG4gICkge1xyXG4gICAgLy8gUHJldmVudCB0aGUgZGF0ZSB0byBsb3NlIHRoZSBtaWxsaXNlY29uZHMgd2hlbiBwYXNzZWQgdG8gbmV3IERhdGUoKSBpbiBJRTEwXHJcbiAgICByZXR1cm4gbmV3IERhdGUoYXJndW1lbnQuZ2V0VGltZSgpKVxyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICB0eXBlb2YgYXJndW1lbnQgPT09ICdudW1iZXInIHx8XHJcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xyXG4gICkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGFyZ3VtZW50KVxyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICAhKFxyXG4gICAgICB0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IFN0cmluZ10nXHJcbiAgICApXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gIH1cclxuXHJcbiAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KVxyXG5cclxuICB2YXIgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpXHJcbiAgdmFyIHllYXIgPSBwYXJzZVllYXJSZXN1bHQueWVhclxyXG4gIHZhciByZXN0RGF0ZVN0cmluZyA9IHBhcnNlWWVhclJlc3VsdC5yZXN0RGF0ZVN0cmluZ1xyXG5cclxuICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZShyZXN0RGF0ZVN0cmluZywgeWVhcilcclxuXHJcbiAgaWYgKGlzTmFOKGRhdGUpKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGUpIHtcclxuICAgIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKVxyXG4gICAgdmFyIHRpbWUgPSAwXHJcbiAgICB2YXIgb2Zmc2V0XHJcblxyXG4gICAgaWYgKGRhdGVTdHJpbmdzLnRpbWUpIHtcclxuICAgICAgdGltZSA9IHBhcnNlVGltZShkYXRlU3RyaW5ncy50aW1lKVxyXG5cclxuICAgICAgaWYgKGlzTmFOKHRpbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChkYXRlU3RyaW5ncy50aW1lem9uZSB8fCBvcHRpb25zLnRpbWVab25lKSB7XHJcbiAgICAgIG9mZnNldCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX2xpYl90elBhcnNlVGltZXpvbmVfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkoXHJcbiAgICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgfHwgb3B0aW9ucy50aW1lWm9uZSxcclxuICAgICAgICBuZXcgRGF0ZSh0aW1lc3RhbXAgKyB0aW1lKVxyXG4gICAgICApXHJcbiAgICAgIGlmIChpc05hTihvZmZzZXQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gZ2V0IG9mZnNldCBhY2N1cmF0ZSB0byBob3VyIGluIHRpbWV6b25lcyB0aGF0IGNoYW5nZSBvZmZzZXRcclxuICAgICAgb2Zmc2V0ID0gT2JqZWN0KF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9kYXRlX2Zuc19lc21fbGliX2dldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHNfaW5kZXhfanNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSkobmV3IERhdGUodGltZXN0YW1wICsgdGltZSkpXHJcbiAgICAgIG9mZnNldCA9IE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfZGF0ZV9mbnNfZXNtX2xpYl9nZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzX2luZGV4X2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pKFxyXG4gICAgICAgIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSArIG9mZnNldClcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwbGl0RGF0ZVN0cmluZyhkYXRlU3RyaW5nKSB7XHJcbiAgdmFyIGRhdGVTdHJpbmdzID0ge31cclxuICB2YXIgYXJyYXkgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLmRhdGVUaW1lRGVsaW1ldGVyKVxyXG4gIHZhciB0aW1lU3RyaW5nXHJcblxyXG4gIGlmIChwYXR0ZXJucy5wbGFpblRpbWUudGVzdChhcnJheVswXSkpIHtcclxuICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBudWxsXHJcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMF1cclxuICB9IGVsc2Uge1xyXG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGFycmF5WzBdXHJcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMV1cclxuICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gYXJyYXlbMl1cclxuICAgIGlmIChwYXR0ZXJucy50aW1lWm9uZURlbGltZXRlci50ZXN0KGRhdGVTdHJpbmdzLmRhdGUpKSB7XHJcbiAgICAgIGRhdGVTdHJpbmdzLmRhdGUgPSBkYXRlU3RyaW5nLnNwbGl0KHBhdHRlcm5zLnRpbWVab25lRGVsaW1ldGVyKVswXVxyXG4gICAgICB0aW1lU3RyaW5nID0gZGF0ZVN0cmluZy5zdWJzdHIoZGF0ZVN0cmluZ3MuZGF0ZS5sZW5ndGgsIGRhdGVTdHJpbmcubGVuZ3RoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHRpbWVTdHJpbmcpIHtcclxuICAgIHZhciB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lLmV4ZWModGltZVN0cmluZylcclxuICAgIGlmICh0b2tlbikge1xyXG4gICAgICBkYXRlU3RyaW5ncy50aW1lID0gdGltZVN0cmluZy5yZXBsYWNlKHRva2VuWzFdLCAnJylcclxuICAgICAgZGF0ZVN0cmluZ3MudGltZXpvbmUgPSB0b2tlblsxXVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGF0ZVN0cmluZ3MudGltZSA9IHRpbWVTdHJpbmdcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBkYXRlU3RyaW5nc1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXJzZVllYXIoZGF0ZVN0cmluZywgYWRkaXRpb25hbERpZ2l0cykge1xyXG4gIHZhciBwYXR0ZXJuWVlZID0gcGF0dGVybnMuWVlZW2FkZGl0aW9uYWxEaWdpdHNdXHJcbiAgdmFyIHBhdHRlcm5ZWVlZWSA9IHBhdHRlcm5zLllZWVlZW2FkZGl0aW9uYWxEaWdpdHNdXHJcblxyXG4gIHZhciB0b2tlblxyXG5cclxuICAvLyBZWVlZIG9yIMKxWVlZWVlcclxuICB0b2tlbiA9IHBhdHRlcm5zLllZWVkuZXhlYyhkYXRlU3RyaW5nKSB8fCBwYXR0ZXJuWVlZWVkuZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgdmFyIHllYXJTdHJpbmcgPSB0b2tlblsxXVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeWVhcjogcGFyc2VJbnQoeWVhclN0cmluZywgMTApLFxyXG4gICAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZSh5ZWFyU3RyaW5nLmxlbmd0aClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFlZIG9yIMKxWVlZXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5ZWS5leGVjKGRhdGVTdHJpbmcpIHx8IHBhdHRlcm5ZWVkuZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgdmFyIGNlbnR1cnlTdHJpbmcgPSB0b2tlblsxXVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeWVhcjogcGFyc2VJbnQoY2VudHVyeVN0cmluZywgMTApICogMTAwLFxyXG4gICAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZShjZW50dXJ5U3RyaW5nLmxlbmd0aClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB5ZWFyXHJcbiAgcmV0dXJuIHtcclxuICAgIHllYXI6IG51bGxcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlRGF0ZShkYXRlU3RyaW5nLCB5ZWFyKSB7XHJcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcclxuICBpZiAoeWVhciA9PT0gbnVsbCkge1xyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIHZhciB0b2tlblxyXG4gIHZhciBkYXRlXHJcbiAgdmFyIG1vbnRoXHJcbiAgdmFyIHdlZWtcclxuXHJcbiAgLy8gWVlZWVxyXG4gIGlmIChkYXRlU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpXHJcbiAgICByZXR1cm4gZGF0ZVxyXG4gIH1cclxuXHJcbiAgLy8gWVlZWS1NTVxyXG4gIHRva2VuID0gcGF0dGVybnMuTU0uZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXHJcbiAgICBtb250aCA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgICB9XHJcblxyXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aClcclxuICAgIHJldHVybiBkYXRlXHJcbiAgfVxyXG5cclxuICAvLyBZWVlZLURERCBvciBZWVlZREREXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5EREQuZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgZGF0ZSA9IG5ldyBEYXRlKDApXHJcbiAgICB2YXIgZGF5T2ZZZWFyID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVEYXlPZlllYXJEYXRlKHllYXIsIGRheU9mWWVhcikpIHtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTilcclxuICAgIH1cclxuXHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIsIDAsIGRheU9mWWVhcilcclxuICAgIHJldHVybiBkYXRlXHJcbiAgfVxyXG5cclxuICAvLyB5eXl5LU1NLWRkIG9yIFlZWVlNTUREXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5NTURELmV4ZWMoZGF0ZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGRhdGUgPSBuZXcgRGF0ZSgwKVxyXG4gICAgbW9udGggPSBwYXJzZUludCh0b2tlblsxXSwgMTApIC0gMVxyXG4gICAgdmFyIGRheSA9IHBhcnNlSW50KHRva2VuWzJdLCAxMClcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF5KSkge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gICAgfVxyXG5cclxuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeWVhciwgbW9udGgsIGRheSlcclxuICAgIHJldHVybiBkYXRlXHJcbiAgfVxyXG5cclxuICAvLyBZWVlZLVd3dyBvciBZWVlZV3d3XHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5Xd3cuZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgd2VlayA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWspKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRheU9mSVNPV2Vla1llYXIoeWVhciwgd2VlaylcclxuICB9XHJcblxyXG4gIC8vIFlZWVktV3d3LUQgb3IgWVlZWVd3d0RcclxuICB0b2tlbiA9IHBhdHRlcm5zLld3d0QuZXhlYyhkYXRlU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgd2VlayA9IHBhcnNlSW50KHRva2VuWzFdLCAxMCkgLSAxXHJcbiAgICB2YXIgZGF5T2ZXZWVrID0gcGFyc2VJbnQodG9rZW5bMl0sIDEwKSAtIDFcclxuXHJcbiAgICBpZiAoIXZhbGlkYXRlV2Vla0RhdGUoeWVhciwgd2VlaywgZGF5T2ZXZWVrKSkge1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUoTmFOKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWssIGRheU9mV2VlaylcclxuICB9XHJcblxyXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBkYXRlXHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuZnVuY3Rpb24gcGFyc2VUaW1lKHRpbWVTdHJpbmcpIHtcclxuICB2YXIgdG9rZW5cclxuICB2YXIgaG91cnNcclxuICB2YXIgbWludXRlc1xyXG5cclxuICAvLyBoaFxyXG4gIHRva2VuID0gcGF0dGVybnMuSEguZXhlYyh0aW1lU3RyaW5nKVxyXG4gIGlmICh0b2tlbikge1xyXG4gICAgaG91cnMgPSBwYXJzZUZsb2F0KHRva2VuWzFdLnJlcGxhY2UoJywnLCAnLicpKVxyXG5cclxuICAgIGlmICghdmFsaWRhdGVUaW1lKGhvdXJzKSkge1xyXG4gICAgICByZXR1cm4gTmFOXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChob3VycyAlIDI0KSAqIE1JTExJU0VDT05EU19JTl9IT1VSXHJcbiAgfVxyXG5cclxuICAvLyBoaDptbSBvciBoaG1tXHJcbiAgdG9rZW4gPSBwYXR0ZXJucy5ISE1NLmV4ZWModGltZVN0cmluZylcclxuICBpZiAodG9rZW4pIHtcclxuICAgIGhvdXJzID0gcGFyc2VJbnQodG9rZW5bMV0sIDEwKVxyXG4gICAgbWludXRlcyA9IHBhcnNlRmxvYXQodG9rZW5bMl0ucmVwbGFjZSgnLCcsICcuJykpXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMpKSB7XHJcbiAgICAgIHJldHVybiBOYU5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICAvLyBoaDptbTpzcyBvciBoaG1tc3NcclxuICB0b2tlbiA9IHBhdHRlcm5zLkhITU1TUy5leGVjKHRpbWVTdHJpbmcpXHJcbiAgaWYgKHRva2VuKSB7XHJcbiAgICBob3VycyA9IHBhcnNlSW50KHRva2VuWzFdLCAxMClcclxuICAgIG1pbnV0ZXMgPSBwYXJzZUludCh0b2tlblsyXSwgMTApXHJcbiAgICB2YXIgc2Vjb25kcyA9IHBhcnNlRmxvYXQodG9rZW5bM10ucmVwbGFjZSgnLCcsICcuJykpXHJcblxyXG4gICAgaWYgKCF2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpKSB7XHJcbiAgICAgIHJldHVybiBOYU5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAoaG91cnMgJSAyNCkgKiBNSUxMSVNFQ09ORFNfSU5fSE9VUiArXHJcbiAgICAgIG1pbnV0ZXMgKiBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFICtcclxuICAgICAgc2Vjb25kcyAqIDEwMDBcclxuICAgIClcclxuICB9XHJcblxyXG4gIC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCB0aW1lXHJcbiAgcmV0dXJuIG51bGxcclxufVxyXG5cclxuZnVuY3Rpb24gZGF5T2ZJU09XZWVrWWVhcihpc29XZWVrWWVhciwgd2VlaywgZGF5KSB7XHJcbiAgd2VlayA9IHdlZWsgfHwgMFxyXG4gIGRheSA9IGRheSB8fCAwXHJcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKVxyXG4gIGRhdGUuc2V0VVRDRnVsbFllYXIoaXNvV2Vla1llYXIsIDAsIDQpXHJcbiAgdmFyIGZvdXJ0aE9mSmFudWFyeURheSA9IGRhdGUuZ2V0VVRDRGF5KCkgfHwgN1xyXG4gIHZhciBkaWZmID0gd2VlayAqIDcgKyBkYXkgKyAxIC0gZm91cnRoT2ZKYW51YXJ5RGF5XHJcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlmZilcclxuICByZXR1cm4gZGF0ZVxyXG59XHJcblxyXG4vLyBWYWxpZGF0aW9uIGZ1bmN0aW9uc1xyXG5cclxudmFyIERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cclxudmFyIERBWVNfSU5fTU9OVEhfTEVBUF9ZRUFSID0gWzMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXHJcblxyXG5mdW5jdGlvbiBpc0xlYXBZZWFySW5kZXgoeWVhcikge1xyXG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8ICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKVxyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcclxuICBpZiAobW9udGggPCAwIHx8IG1vbnRoID4gMTEpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgaWYgKGRhdGUgIT0gbnVsbCkge1xyXG4gICAgaWYgKGRhdGUgPCAxKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBpc0xlYXBZZWFyID0gaXNMZWFwWWVhckluZGV4KHllYXIpXHJcbiAgICBpZiAoaXNMZWFwWWVhciAmJiBkYXRlID4gREFZU19JTl9NT05USF9MRUFQX1lFQVJbbW9udGhdKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG4gICAgaWYgKCFpc0xlYXBZZWFyICYmIGRhdGUgPiBEQVlTX0lOX01PTlRIW21vbnRoXSkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlRGF5T2ZZZWFyRGF0ZSh5ZWFyLCBkYXlPZlllYXIpIHtcclxuICBpZiAoZGF5T2ZZZWFyIDwgMSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICB2YXIgaXNMZWFwWWVhciA9IGlzTGVhcFllYXJJbmRleCh5ZWFyKVxyXG4gIGlmIChpc0xlYXBZZWFyICYmIGRheU9mWWVhciA+IDM2Nikge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG4gIGlmICghaXNMZWFwWWVhciAmJiBkYXlPZlllYXIgPiAzNjUpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVXZWVrRGF0ZSh5ZWFyLCB3ZWVrLCBkYXkpIHtcclxuICBpZiAod2VlayA8IDAgfHwgd2VlayA+IDUyKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIGlmIChkYXkgIT0gbnVsbCAmJiAoZGF5IDwgMCB8fCBkYXkgPiA2KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWUoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcclxuICBpZiAoaG91cnMgIT0gbnVsbCAmJiAoaG91cnMgPCAwIHx8IGhvdXJzID49IDI1KSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICBpZiAobWludXRlcyAhPSBudWxsICYmIChtaW51dGVzIDwgMCB8fCBtaW51dGVzID49IDYwKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICBpZiAoc2Vjb25kcyAhPSBudWxsICYmIChzZWNvbmRzIDwgMCB8fCBzZWNvbmRzID49IDYwKSkge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGV4cG9ydCAoaW1tdXRhYmxlKSAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IGdldFRpbWV6b25lT2Zmc2V0SW5NaWxsaXNlY29uZHM7XHJcbnZhciBNSUxMSVNFQ09ORFNfSU5fTUlOVVRFID0gNjAwMDA7XHJcbi8qKlxyXG4gKiBHb29nbGUgQ2hyb21lIGFzIG9mIDY3LjAuMzM5Ni44NyBpbnRyb2R1Y2VkIHRpbWV6b25lcyB3aXRoIG9mZnNldCB0aGF0IGluY2x1ZGVzIHNlY29uZHMuXHJcbiAqIFRoZXkgdXN1YWxseSBhcHBlYXIgZm9yIGRhdGVzIHRoYXQgZGVub3RlIHRpbWUgYmVmb3JlIHRoZSB0aW1lem9uZXMgd2VyZSBpbnRyb2R1Y2VkXHJcbiAqIChlLmcuIGZvciAnRXVyb3BlL1ByYWd1ZScgdGltZXpvbmUgdGhlIG9mZnNldCBpcyBHTVQrMDA6NTc6NDQgYmVmb3JlIDEgT2N0b2JlciAxODkxXHJcbiAqIGFuZCBHTVQrMDE6MDA6MDAgYWZ0ZXIgdGhhdCBkYXRlKVxyXG4gKlxyXG4gKiBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgdGhlIG9mZnNldCBpbiBtaW51dGVzIGFuZCB3b3VsZCByZXR1cm4gNTcgZm9yIHRoZSBleGFtcGxlIGFib3ZlLFxyXG4gKiB3aGljaCB3b3VsZCBsZWFkIHRvIGluY29ycmVjdCBjYWxjdWxhdGlvbnMuXHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgdGltZXpvbmUgb2Zmc2V0IGluIG1pbGxpc2Vjb25kcyB0aGF0IHRha2VzIHNlY29uZHMgaW4gYWNjb3VudC5cclxuICovXHJcblxyXG5mdW5jdGlvbiBnZXRUaW1lem9uZU9mZnNldEluTWlsbGlzZWNvbmRzKGRpcnR5RGF0ZSkge1xyXG4gIHZhciBkYXRlID0gbmV3IERhdGUoZGlydHlEYXRlLmdldFRpbWUoKSk7XHJcbiAgdmFyIGJhc2VUaW1lem9uZU9mZnNldCA9IE1hdGguY2VpbChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xyXG4gIGRhdGUuc2V0U2Vjb25kcygwLCAwKTtcclxuICB2YXIgbWlsbGlzZWNvbmRzUGFydE9mVGltZXpvbmVPZmZzZXQgPSBkYXRlLmdldFRpbWUoKSAlIE1JTExJU0VDT05EU19JTl9NSU5VVEU7XHJcbiAgcmV0dXJuIGJhc2VUaW1lem9uZU9mZnNldCAqIE1JTExJU0VDT05EU19JTl9NSU5VVEUgKyBtaWxsaXNlY29uZHNQYXJ0T2ZUaW1lem9uZU9mZnNldDtcclxufVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiB1bnVzZWQgaGFybW9ueSBleHBvcnQgZ2V0V2Vla1N0YXJ0QnlSZWdpb24gKi9cclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXZWVrU3RhcnRCeUxvY2FsZSQxOyB9KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fYXBpX2pzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fbGFuZ1JlZ2lvbk1hcF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX3JlZ2lvbkRheU1hcF9qc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRXZWVrU3RhcnRCeVJlZ2lvbiQxKHJlZ2lvbkNvZGUpIHtcclxuICAgIHJldHVybiBPYmplY3QoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19hcGlfanNfX1tcImJcIiAvKiBnZXRXZWVrU3RhcnRCeVJlZ2lvbiAqL10pKHJlZ2lvbkNvZGUsIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fcmVnaW9uRGF5TWFwX2pzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXZWVrU3RhcnRCeUxvY2FsZSQxKGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX2FwaV9qc19fW1wiYVwiIC8qIGdldFdlZWtTdGFydEJ5TG9jYWxlICovXSkobG9jYWxlLCBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX2xhbmdSZWdpb25NYXBfanNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSwgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19yZWdpb25EYXlNYXBfanNfX1tcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcbn1cclxuXHJcblxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmpzLm1hcFxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRXZWVrU3RhcnRCeVJlZ2lvbjsgfSk7XHJcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJhXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0V2Vla1N0YXJ0QnlMb2NhbGU7IH0pO1xyXG5mdW5jdGlvbiBnZXRXZWVrU3RhcnRCeVJlZ2lvbihyZWdpb25Db2RlLCByZWdpb25EYXlNYXApIHtcclxuICAgIHZhciBjb2RlID0gcmVnaW9uRGF5TWFwW3R5cGVvZiByZWdpb25Db2RlID09PSAnc3RyaW5nJyA/IHJlZ2lvbkNvZGUudG9VcHBlckNhc2UoKSA6IHJlZ2lvbkNvZGVdO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjb2RlID09PSAnbnVtYmVyJyA/IGNvZGUgOiAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRXZWVrU3RhcnRCeUxvY2FsZShsb2NhbGUsIGxhbmdSZWdpb25NYXAsIHJlZ2lvbkRheU1hcCkge1xyXG4gICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbG9jYWxlLnRvTG93ZXJDYXNlKCkuc3BsaXQoL1stX10vKTtcclxuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBkYXRhWzBdO1xyXG4gICAgICAgIHZhciBjb3VudHJ5O1xyXG4gICAgICAgIGlmIChkYXRhWzFdICYmIGRhdGFbMV0ubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgIGxhbmd1YWdlICs9IFwiX1wiICsgKGRhdGFbMV0pO1xyXG4gICAgICAgICAgICBjb3VudHJ5ID0gZGF0YVsyXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb3VudHJ5ID0gZGF0YVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb3VudHJ5KSB7XHJcbiAgICAgICAgICAgIGNvdW50cnkgPSBsYW5nUmVnaW9uTWFwW2xhbmd1YWdlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50cnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFdlZWtTdGFydEJ5UmVnaW9uKGNvdW50cnkubWF0Y2goL15cXGQrJC8pID8gTnVtYmVyKGNvdW50cnkpIDogY291bnRyeSwgcmVnaW9uRGF5TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMTtcclxufVxyXG5cclxuXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXBcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBsYW5nUmVnaW9uTWFwID0ge1xyXG4gICAgZW46ICdVUycsXHJcbiAgICB6aDogJ0NOJyxcclxuICAgIHpoX2hhbnM6ICdDTicsXHJcbiAgICBoYW5zOiAnQ04nLFxyXG4gICAgd3V1OiAnQ04nLFxyXG4gICAgaHNuOiAnQ04nLFxyXG4gICAgaGFrOiAnQ04nLFxyXG4gICAgbmFuOiAnQ04nLFxyXG4gICAgZ2FuOiAnQ04nLFxyXG4gICAgaGk6ICdJTicsXHJcbiAgICB0ZTogJ0lOJyxcclxuICAgIG1yOiAnSU4nLFxyXG4gICAgdGE6ICdJTicsXHJcbiAgICBndTogJ0lOJyxcclxuICAgIGtuOiAnSU4nLFxyXG4gICAgb3I6ICdJTicsXHJcbiAgICBtbDogJ0lOJyxcclxuICAgIHBhX2d1cnU6ICdJTicsXHJcbiAgICBiaG86ICdJTicsXHJcbiAgICBhd2E6ICdJTicsXHJcbiAgICBhczogJ0lOJyxcclxuICAgIG13cjogJ0lOJyxcclxuICAgIG1haTogJ0lOJyxcclxuICAgIG1hZzogJ0lOJyxcclxuICAgIGJnYzogJ0lOJyxcclxuICAgIGhuZTogJ0lOJyxcclxuICAgIGRjYzogJ0lOJyxcclxuICAgIGR6OiAnQlQnLFxyXG4gICAgdG46ICdCVycsXHJcbiAgICBhbTogJ0VUJyxcclxuICAgIG9tOiAnRVQnLFxyXG4gICAgcXVjOiAnR1QnLFxyXG4gICAgaWQ6ICdJRCcsXHJcbiAgICBqdjogJ0lEJyxcclxuICAgIHN1OiAnSUQnLFxyXG4gICAgbWFkOiAnSUQnLFxyXG4gICAgbXNfYXJhYjogJ0lEJyxcclxuICAgIGdhOiAnSUUnLFxyXG4gICAgaGU6ICdJTCcsXHJcbiAgICBqYW06ICdKTScsXHJcbiAgICBqYTogJ0pQJyxcclxuICAgIGttOiAnS0gnLFxyXG4gICAga286ICdLUicsXHJcbiAgICBsbzogJ0xBJyxcclxuICAgIG1oOiAnTUgnLFxyXG4gICAgbXk6ICdNTScsXHJcbiAgICBtdDogJ01UJyxcclxuICAgIG5lOiAnTlAnLFxyXG4gICAgZmlsOiAnUEgnLFxyXG4gICAgY2ViOiAnUEgnLFxyXG4gICAgaWxvOiAnUEgnLFxyXG4gICAgdXI6ICdQSycsXHJcbiAgICBwYTogJ1BLJyxcclxuICAgIHBhX2FyYWI6ICdQSycsXHJcbiAgICBhcmFiOiAnUEsnLFxyXG4gICAgbGFoOiAnUEsnLFxyXG4gICAgcHM6ICdQSycsXHJcbiAgICBzZDogJ1BLJyxcclxuICAgIHNkX2FyYWI6ICdQSycsXHJcbiAgICBza3I6ICdQSycsXHJcbiAgICBnbjogJ1BZJyxcclxuICAgIHRoOiAnVEgnLFxyXG4gICAgdHRzOiAnVEgnLFxyXG4gICAgYWViOiAnVE4nLFxyXG4gICAgemhfaGFudDogJ1RXJyxcclxuICAgIGhhbnQ6ICdUVycsXHJcbiAgICBzbTogJ1dTJyxcclxuICAgIHp1OiAnWkEnLFxyXG4gICAgc246ICdaVycsXHJcbiAgICBhcnE6ICdEWicsXHJcbiAgICBhcjogJ0VHJyxcclxuICAgIGFyejogJ0VHJyxcclxuICAgIGZhOiAnSVInLFxyXG4gICAgYXpfYXJhYjogJ0lSJyxcclxuICAgIGFyeTogJ01BJyxcclxuICAgIGJuOiAnQkQnLFxyXG4gICAgcmt0OiAnQkQnLFxyXG4gICAgZHY6ICdNVidcclxufTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAobGFuZ1JlZ2lvbk1hcCk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdSZWdpb25NYXAuanMubWFwXHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG52YXIgcmVnaW9uRGF5TWFwID0ge1xyXG4gICAgQUc6IDAsXHJcbiAgICBBVEc6IDAsXHJcbiAgICAyODogMCxcclxuICAgIEFSOiAwLFxyXG4gICAgQVJHOiAwLFxyXG4gICAgMzI6IDAsXHJcbiAgICBBUzogMCxcclxuICAgIEFTTTogMCxcclxuICAgIDE2OiAwLFxyXG4gICAgQVU6IDAsXHJcbiAgICBBVVM6IDAsXHJcbiAgICAzNjogMCxcclxuICAgIEJSOiAwLFxyXG4gICAgQlJBOiAwLFxyXG4gICAgNzY6IDAsXHJcbiAgICBCUzogMCxcclxuICAgIEJIUzogMCxcclxuICAgIDQ0OiAwLFxyXG4gICAgQlQ6IDAsXHJcbiAgICBCVE46IDAsXHJcbiAgICA2NDogMCxcclxuICAgIEJXOiAwLFxyXG4gICAgQldBOiAwLFxyXG4gICAgNzI6IDAsXHJcbiAgICBCWjogMCxcclxuICAgIEJMWjogMCxcclxuICAgIDg0OiAwLFxyXG4gICAgQ0E6IDAsXHJcbiAgICBDQU46IDAsXHJcbiAgICAxMjQ6IDAsXHJcbiAgICBDTjogMCxcclxuICAgIENITjogMCxcclxuICAgIDE1NjogMCxcclxuICAgIENPOiAwLFxyXG4gICAgQ09MOiAwLFxyXG4gICAgMTcwOiAwLFxyXG4gICAgRE06IDAsXHJcbiAgICBETUE6IDAsXHJcbiAgICAyMTI6IDAsXHJcbiAgICBETzogMCxcclxuICAgIERPTTogMCxcclxuICAgIDIxNDogMCxcclxuICAgIEVUOiAwLFxyXG4gICAgRVRIOiAwLFxyXG4gICAgMjMxOiAwLFxyXG4gICAgR1Q6IDAsXHJcbiAgICBHVE06IDAsXHJcbiAgICAzMjA6IDAsXHJcbiAgICBHVTogMCxcclxuICAgIEdVTTogMCxcclxuICAgIDMxNjogMCxcclxuICAgIEhLOiAwLFxyXG4gICAgSEtHOiAwLFxyXG4gICAgMzQ0OiAwLFxyXG4gICAgSE46IDAsXHJcbiAgICBITkQ6IDAsXHJcbiAgICAzNDA6IDAsXHJcbiAgICBJRDogMCxcclxuICAgIElETjogMCxcclxuICAgIDM2MDogMCxcclxuICAgIElFOiAwLFxyXG4gICAgSVJMOiAwLFxyXG4gICAgMzcyOiAwLFxyXG4gICAgSUw6IDAsXHJcbiAgICBJU1I6IDAsXHJcbiAgICAzNzY6IDAsXHJcbiAgICBJTjogMCxcclxuICAgIElORDogMCxcclxuICAgIDM1NjogMCxcclxuICAgIEpNOiAwLFxyXG4gICAgSkFNOiAwLFxyXG4gICAgMzg4OiAwLFxyXG4gICAgSlA6IDAsXHJcbiAgICBKUE46IDAsXHJcbiAgICAzOTI6IDAsXHJcbiAgICBLRTogMCxcclxuICAgIEtFTjogMCxcclxuICAgIDQwNDogMCxcclxuICAgIEtIOiAwLFxyXG4gICAgS0hNOiAwLFxyXG4gICAgMTE2OiAwLFxyXG4gICAgS1I6IDAsXHJcbiAgICBLT1I6IDAsXHJcbiAgICA0MTA6IDAsXHJcbiAgICBMQTogMCxcclxuICAgIExBMDogMCxcclxuICAgIDQxODogMCxcclxuICAgIE1IOiAwLFxyXG4gICAgTUhMOiAwLFxyXG4gICAgNTg0OiAwLFxyXG4gICAgTU06IDAsXHJcbiAgICBNTVI6IDAsXHJcbiAgICAxMDQ6IDAsXHJcbiAgICBNTzogMCxcclxuICAgIE1BQzogMCxcclxuICAgIDQ0NjogMCxcclxuICAgIE1UOiAwLFxyXG4gICAgTUxUOiAwLFxyXG4gICAgNDcwOiAwLFxyXG4gICAgTVg6IDAsXHJcbiAgICBNRVg6IDAsXHJcbiAgICA0ODQ6IDAsXHJcbiAgICBNWjogMCxcclxuICAgIE1PWjogMCxcclxuICAgIDUwODogMCxcclxuICAgIE5JOiAwLFxyXG4gICAgTklDOiAwLFxyXG4gICAgNTU4OiAwLFxyXG4gICAgTlA6IDAsXHJcbiAgICBOUEw6IDAsXHJcbiAgICA1MjQ6IDAsXHJcbiAgICBOWjogMCxcclxuICAgIE5aTDogMCxcclxuICAgIDU1NDogMCxcclxuICAgIFBBOiAwLFxyXG4gICAgUEFOOiAwLFxyXG4gICAgNTkxOiAwLFxyXG4gICAgUEU6IDAsXHJcbiAgICBQRVI6IDAsXHJcbiAgICA2MDQ6IDAsXHJcbiAgICBQSDogMCxcclxuICAgIFBITDogMCxcclxuICAgIDYwODogMCxcclxuICAgIFBLOiAwLFxyXG4gICAgUEFLOiAwLFxyXG4gICAgNTg2OiAwLFxyXG4gICAgUFI6IDAsXHJcbiAgICBQUkk6IDAsXHJcbiAgICA2MzA6IDAsXHJcbiAgICBQWTogMCxcclxuICAgIFBSWTogMCxcclxuICAgIDYwMDogMCxcclxuICAgIFNBOiAwLFxyXG4gICAgU0FVOiAwLFxyXG4gICAgNjgyOiAwLFxyXG4gICAgU0c6IDAsXHJcbiAgICBTR1A6IDAsXHJcbiAgICA3MDI6IDAsXHJcbiAgICBTVjogMCxcclxuICAgIFNMVjogMCxcclxuICAgIDIyMjogMCxcclxuICAgIFRIOiAwLFxyXG4gICAgVEhBOiAwLFxyXG4gICAgNzY0OiAwLFxyXG4gICAgVE46IDAsXHJcbiAgICBUVU46IDAsXHJcbiAgICA3ODg6IDAsXHJcbiAgICBUVDogMCxcclxuICAgIFRUTzogMCxcclxuICAgIDc4MDogMCxcclxuICAgIFRXOiAwLFxyXG4gICAgVFdOOiAwLFxyXG4gICAgMTU4OiAwLFxyXG4gICAgVU06IDAsXHJcbiAgICBVTUk6IDAsXHJcbiAgICA1ODE6IDAsXHJcbiAgICBVUzogMCxcclxuICAgIFVTQTogMCxcclxuICAgIDg0MDogMCxcclxuICAgIFZFOiAwLFxyXG4gICAgVkVOOiAwLFxyXG4gICAgODYyOiAwLFxyXG4gICAgVkk6IDAsXHJcbiAgICBWSVI6IDAsXHJcbiAgICA4NTA6IDAsXHJcbiAgICBXUzogMCxcclxuICAgIFdTTTogMCxcclxuICAgIDg4MjogMCxcclxuICAgIFlFOiAwLFxyXG4gICAgWUVNOiAwLFxyXG4gICAgODg3OiAwLFxyXG4gICAgWkE6IDAsXHJcbiAgICBaQUY6IDAsXHJcbiAgICA3MTA6IDAsXHJcbiAgICBaVzogMCxcclxuICAgIFpXRTogMCxcclxuICAgIDcxNjogMCxcclxuICAgIEFFOiA2LFxyXG4gICAgQVJFOiA2LFxyXG4gICAgNzg0OiA2LFxyXG4gICAgQUY6IDYsXHJcbiAgICBBRkc6IDYsXHJcbiAgICA0OiA2LFxyXG4gICAgQkg6IDYsXHJcbiAgICBCSFI6IDYsXHJcbiAgICA0ODogNixcclxuICAgIERKOiA2LFxyXG4gICAgREpJOiA2LFxyXG4gICAgMjYyOiA2LFxyXG4gICAgRFo6IDYsXHJcbiAgICBEWkE6IDYsXHJcbiAgICAxMjogNixcclxuICAgIEVHOiA2LFxyXG4gICAgRUdZOiA2LFxyXG4gICAgODE4OiA2LFxyXG4gICAgSVE6IDYsXHJcbiAgICBJUlE6IDYsXHJcbiAgICAzNjg6IDYsXHJcbiAgICBJUjogNixcclxuICAgIElSTjogNixcclxuICAgIDM2NDogNixcclxuICAgIEpPOiA2LFxyXG4gICAgSk9SOiA2LFxyXG4gICAgNDAwOiA2LFxyXG4gICAgS1c6IDYsXHJcbiAgICBLV1Q6IDYsXHJcbiAgICA0MTQ6IDYsXHJcbiAgICBMWTogNixcclxuICAgIExCWTogNixcclxuICAgIDQzNDogNixcclxuICAgIE1BOiA2LFxyXG4gICAgTUFSOiA2LFxyXG4gICAgNTA0OiA2LFxyXG4gICAgT006IDYsXHJcbiAgICBPTU46IDYsXHJcbiAgICA1MTI6IDYsXHJcbiAgICBRQTogNixcclxuICAgIFFBVDogNixcclxuICAgIDYzNDogNixcclxuICAgIFNEOiA2LFxyXG4gICAgU0ROOiA2LFxyXG4gICAgNzI5OiA2LFxyXG4gICAgU1k6IDYsXHJcbiAgICBTWVI6IDYsXHJcbiAgICA3NjA6IDYsXHJcbiAgICBCRDogNSxcclxuICAgIEJHRDogNSxcclxuICAgIDUwOiA1LFxyXG4gICAgTVY6IDUsXHJcbiAgICBNRFY6IDUsXHJcbiAgICA0NjI6IDVcclxufTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAocmVnaW9uRGF5TWFwKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaW9uRGF5TWFwLmpzLm1hcFxyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcblxyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxudmFyIGlzTnVtYmVyUmVnZXggPSAvXlxcZCskLztcclxudmFyIGlzV2hpdGVzcGFjZVJlZ2V4ID0gL1xccy87XHJcbnZhciBwdW5jdHVhdGlvbkxpc3QgPSAnIVwiIyQlJlxcJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fic7XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGluIGxvd2VyIGNhc2VcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKi9cclxuXHJcbnZhciBpc0xvd2VyQ2FzZSA9IGZ1bmN0aW9uIGlzTG93ZXJDYXNlKHN0cikge1xyXG4gIHJldHVybiBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgc3RyICE9IHN0ci50b1VwcGVyQ2FzZSgpO1xyXG59O1xyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBpbiB1cHBlciBjYXNlXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICovXHJcblxyXG5cclxudmFyIGlzVXBwZXJDYXNlID0gZnVuY3Rpb24gaXNVcHBlckNhc2Uoc3RyKSB7XHJcbiAgcmV0dXJuIHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiBzdHIgIT0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbn07XHJcblxyXG52YXIgcGFzc09yVGhyb3dFcnJvciA9IGZ1bmN0aW9uIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKSB7XHJcbiAgaWYgKCFsb29zZSkge1xyXG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJBdChpKTtcclxuXHJcbiAgICB2YXIgcG9zID0gaSArIDE7XHJcbiAgICB0aHJvdyB7XHJcbiAgICAgIG5hbWU6ICdTdHJpbmdNYXNrRXJyb3InLFxyXG4gICAgICBtZXNzYWdlOiBcIlN0cmluZ01hc2tFcnJvcjogZXJyb3IgYXBwbHlpbmcgbWFzayBhdCBwb3NpdGlvbiBcXFwiXCIuY29uY2F0KHBvcywgXCJcXFwiICwgY2hhciBcXFwiXCIpLmNvbmNhdChfY2hhciwgXCJcXFwiXCIpLFxyXG4gICAgICBwb3M6IHBvcyxcclxuICAgICAgXCJjaGFyXCI6IF9jaGFyXHJcbiAgICB9O1xyXG4gIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcbn07XHJcbi8qKlxyXG4gKiBOdW1iZXJNYXNrXHJcbiAqXHJcbiAqIEEgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBmb3IgQkJqIG51bWJlcnMgbWFza2luZ1xyXG4gKlxyXG4gKiBAYXV0aG9yIEh5eWFuIEFibyBGYWtoZXIgPGhhYm9mYWtoZXJAYmFzaXMuY29tPlxyXG4gKi9cclxuXHJcblxyXG52YXIgU3RyaW5nTWFzayA9XHJcbi8qI19fUFVSRV9fKi9cclxuZnVuY3Rpb24gKCkge1xyXG4gIGZ1bmN0aW9uIFN0cmluZ01hc2soKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaW5nTWFzayk7XHJcbiAgfVxyXG5cclxuICBfY3JlYXRlQ2xhc3MoU3RyaW5nTWFzaywgbnVsbCwgW3tcclxuICAgIGtleTogXCJtYXNrXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXNrIHRoZSBnaXZlbiBzdHJpbmcgd2l0aCB0aGUgZ2l2ZW4gbWFzayBhY2NvcmRpbmcgdG8gQkJqIHJ1bGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIG1hc2tcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrIHRoZSBtYXNrIHRvIHVzZSBmb3IgZm9ybWF0dGluZ1xyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9dHJ1ZV0gd2hlbiB0cnVlICwgZXJyb3JzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCB3aWxsIHRyeSBhdCBhcHBseSB0aGUgbWFza1xyXG4gICAgICogICAgICAgICAgICAgICAgYW55d2F5ICwgb3RoZXJ3aXNlIGl0IHdpbGwgc3RvcCBhdCBmaXJzdCBlcnJvciBhbmQgdGhyb3cgaXQuXHJcbiAgICAgKiBcclxuICAgICAqIEB0aHJvd3Mge01hc2tJc1Rvb1Nob3J0RXJyb3J9XHJcbiAgICAgKiBAdGhyb3dzIHtTdHJpbmdNYXNrRXJyb3J9XHJcbiAgICAgKiBAdGhyb3dzIHtNYXNrRXJyb3J9XHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBtYXNrZWQgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXNrKHN0ciwgX21hc2spIHtcclxuICAgICAgdmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xyXG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcclxuICAgICAgX21hc2sgPSBTdHJpbmcoX21hc2spO1xyXG4gICAgICB2YXIgbWFza0xlbiA9IF9tYXNrLmxlbmd0aDtcclxuICAgICAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoc3RyTGVuID4gbWFza0xlbikge1xyXG4gICAgICAgIGlmIChsb29zZSkgcmV0dXJuIHN0cjsgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgICBlbHNlIHRocm93IHtcclxuICAgICAgICAgICAgbmFtZTogJ01hc2tJc1Rvb1Nob3J0RXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBcIk1hc2tJc1Rvb1Nob3J0RXJyb3I6IE1hc2sgaXMgc2hvcnRlciB0aGFuIHRoZSBwYXNzZWQgc3RyaW5nXCJcclxuICAgICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciByZXQgPSBuZXcgQXJyYXkobWFza0xlbik7XHJcbiAgICAgIHZhciBwb3MgPSAwOyAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBzdHJcclxuXHJcbiAgICAgIHZhciBtYXNrQnl0ZSA9ICcnO1xyXG5cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrTGVuOyBpKyspIHtcclxuICAgICAgICBtYXNrQnl0ZSA9IF9tYXNrLmNoYXJBdChpKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChtYXNrQnl0ZSkge1xyXG4gICAgICAgICAgY2FzZSAnWCc6XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGFueSBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgcmV0W2ldID0gcG9zIDwgc3RyTGVuID8gc3RyLmNoYXJBdChwb3MpIDogJyAnO1xyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnQSc6XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGxldHRlcjsgZm9yY2UgdXBwZXIgY2FzZVxyXG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9ieXRlID0gc3RyLmNoYXJBdChwb3MpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaXNVcHBlckNhc2UoX2J5dGUpKSByZXRbaV0gPSBfYnl0ZTtlbHNlIGlmIChpc0xvd2VyQ2FzZShfYnl0ZSkpIHJldFtpXSA9IF9ieXRlLnRvVXBwZXJDYXNlKCk7ZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcblxyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnYSc6XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGxldHRlclxyXG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9ieXRlMiA9IHN0ci5jaGFyQXQocG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKF9ieXRlMikgfHwgaXNMb3dlckNhc2UoX2J5dGUyKSkgcmV0W2ldID0gX2J5dGUyO2Vsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnO1xyXG5cclxuICAgICAgICAgICAgKytwb3M7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBkaWdpdFxyXG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9ieXRlMyA9IHN0ci5jaGFyQXQocG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyUmVnZXgudGVzdChfYnl0ZTMpKSByZXRbaV0gPSBfYnl0ZTM7ZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcblxyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgICAgIC8vIG1hdGNoIGxldHRlciBvciBkaWdpdDsgZm9yY2UgdXBwZXIgY2FzZVxyXG4gICAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgICAgdmFyIF9ieXRlNCA9IHN0ci5jaGFyQXQocG9zKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKF9ieXRlNCkgfHwgaXNOdW1iZXJSZWdleC50ZXN0KF9ieXRlNCkpIHJldFtpXSA9IF9ieXRlNDtlbHNlIGlmIChpc0xvd2VyQ2FzZShfYnl0ZTQpKSByZXRbaV0gPSBfYnl0ZTQudG9VcHBlckNhc2UoKTtlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJztcclxuXHJcbiAgICAgICAgICAgICsrcG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICd6JzpcclxuICAgICAgICAgICAgLy8gbWF0Y2ggbGV0dGVyIG9yIGRpZ2l0XHJcbiAgICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgICB2YXIgX2J5dGU1ID0gc3RyLmNoYXJBdChwb3MpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaXNVcHBlckNhc2UoX2J5dGU1KSB8fCBpc0xvd2VyQ2FzZShfYnl0ZTUpIHx8IGlzTnVtYmVyUmVnZXgudGVzdChfYnl0ZTUpKSByZXRbaV0gPSBfYnl0ZTU7ZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cik7XHJcbiAgICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICc7XHJcblxyXG4gICAgICAgICAgICArK3BvcztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ1UnOlxyXG4gICAgICAgICAgICAvLyBtYXRjaCBsZXR0ZXIgKGZvcmNlIHVwcGVyIGNhc2UpLCBkaWdpdCwgd2hpdGVzcGFjZSBvciBwdW5jdHVhdGlvbi5cclxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICAgIHZhciBfYnl0ZTYgPSBzdHIuY2hhckF0KHBvcyk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChpc0xvd2VyQ2FzZShfYnl0ZTYpKSByZXRbaV0gPSBfYnl0ZTYudG9VcHBlckNhc2UoKTtlbHNlIGlmIChpc1VwcGVyQ2FzZShfYnl0ZTYpIHx8IGlzTnVtYmVyUmVnZXgudGVzdChfYnl0ZTYpIHx8IGlzV2hpdGVzcGFjZVJlZ2V4LnRlc3QoX2J5dGU2KSB8fCBwdW5jdHVhdGlvbkxpc3QuaW5kZXhPZihfYnl0ZTYpID4gLTEpIHJldFtpXSA9IF9ieXRlNjtlbHNlIHBhc3NPclRocm93RXJyb3IobG9vc2UsIHJldCwgaSwgc3RyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHJldFtpXSA9ICcgJztcclxuXHJcbiAgICAgICAgICAgICsrcG9zO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXRbaV0gPSBtYXNrQnl0ZTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgaWYgKCFsb29zZSkge1xyXG4gICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICBuYW1lOiAnTWFza0Vycm9yJyxcclxuICAgICAgICAgICAgbWVzc2FnZTogJ01hc2sgY2Fubm90IGJlIGFwcGxpZWQnXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcclxuICAgIH1cclxuICB9XSk7XHJcblxyXG4gIHJldHVybiBTdHJpbmdNYXNrO1xyXG59KCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFN0cmluZ01hc2spO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIwICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19UeXBlc19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1R5cGVzX19bXCJhXCIgLyogZGVmYXVsdCAqL10pO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19OdW1iZXJNYXNrX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19EYXRlTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fU3RyaW5nTWFza19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cclxuXHJcbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XHJcblxyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGVzXHJcbiAqXHJcbiAqIEJCaiBtYXNrcyBmYWN0b3J5XHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG5cclxudmFyIFR5cGVzID1cclxuLyojX19QVVJFX18qL1xyXG5mdW5jdGlvbiAoKSB7XHJcbiAgZnVuY3Rpb24gVHlwZXMoKSB7XHJcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZXMpO1xyXG4gIH1cclxuXHJcbiAgX2NyZWF0ZUNsYXNzKFR5cGVzLCBudWxsLCBbe1xyXG4gICAga2V5OiBcIm51bWJlclwiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFzayB0aGUgZ2l2ZW4gbnVtYmVyIHdpdGggdGhlIGdpdmVuIG1hc2sgYWNjb3JkaW5nIHRvIEJCaiBydWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgdGhlIG51bWJlciB0byBmb3JtYXRcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrIHRoZSBtYXNrIHRvIHVzZSBmb3IgZm9ybWF0dGluZ1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtncm91cGluZ1NlcGFyYXRvcj0sXSAtIGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBncm91cGluZyBzZXBhcmF0b3JcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZGVjaW1hbFNlcGFyYXRvcj0uXSAgLSBhIGNoYXIgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGEgZGVjaW1hbCBzZXBhcmF0b3JcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlVHJhaWxpbmdaZXJvcz1mYWxzZV0gLSBBZmZlY3RzIHRoZSBvdXRwdXQgYnkgc3dpdGNoaW5nIHRoZSB3YXkgYSBtYXNrIHdpdGggXCIjXCIgY2hhcmFjdGVycyBpbiB0aGUgdHJhaWxpbmcgcG9zaXRpb25zIGlzIGZpbGxlZC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCB0aGUgZnVuY3Rpb24gYE51bWJlck1hc2subWFzayguMTA6XCIjLiMjXCIpYCByZXR1cm5zIGAgLjEwYCBpbnN0ZWFkIG9mIGAgLjEgYFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9dHJ1ZV0gd2hlbiB0cnVlICwgZXJyb3JzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCB3aWxsIHRyeSBhdCBhcHBseSB0aGUgbWFza1xyXG4gICAgICogICAgICAgICAgICAgICAgYW55d2F5ICwgb3RoZXJ3aXNlIGl0IHdpbGwgc3RvcCBhdCBmaXJzdCBlcnJvciBhbmQgdGhyb3cgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIG1hc2tlZCBudW1iZXJcclxuICAgICAqL1xyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bWJlcihfbnVtYmVyLCBtYXNrKSB7XHJcbiAgICAgIHZhciBncm91cGluZ1NlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJywnO1xyXG4gICAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJy4nO1xyXG4gICAgICB2YXIgZm9yY2VUcmFpbGluZ1plcm9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcclxuICAgICAgdmFyIGxvb3NlID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xyXG4gICAgICByZXR1cm4gX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19OdW1iZXJNYXNrX19bXCJhXCIgLyogZGVmYXVsdCAqL10ubWFzayhfbnVtYmVyLCBtYXNrLCBncm91cGluZ1NlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciwgZm9yY2VUcmFpbGluZ1plcm9zLCBsb29zZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1hc2sgYSBkYXRlIGFjY29yZGluZyB0byBiYmogbWFza2luZyBydWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRlIGRhdGUgYXMgYSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXNrIG1hc2sgYXMgYSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbG9jYWxlPUJyb3dzZXIncyBsb2NhbGVdIHRoZSBsYW5ndWFnZSB0byB1c2UgZXgoZW4tVVMpLiBkZWZhdWx0IGlzIHRvIHRoZSBzeXN0ZW0gbGFuZ3VhZ2VcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbdGltZXpvbmU9U3lzdGVtIHRpbWV6b25lXSB0aGUgdGltZSB6b25lIGRlc2NyaXB0b3IgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcykuIGRlZmF1bHQgdG8gdGhlIHN5c3RlbVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWV6b25lXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBudW1iZXIgbWFza2VkIHdpdGggdGhlIGdpdmVuIG1hc2tcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwiZGF0ZVwiLFxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRhdGUoX2RhdGUsIG1hc2ssIGxvY2FsZSwgdGltZXpvbmUpIHtcclxuICAgICAgcmV0dXJuIF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fRGF0ZU1hc2tfX1tcImNcIiAvKiBkZWZhdWx0ICovXS5tYXNrKF9kYXRlLCBtYXNrLCBsb2NhbGUsIHRpbWV6b25lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFzayB0aGUgZ2l2ZW4gc3RyaW5nIHdpdGggdGhlIGdpdmVuIG1hc2sgYWNjb3JkaW5nIHRvIEJCaiBydWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBtYXNrXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzayB0aGUgbWFzayB0byB1c2UgZm9yIGZvcm1hdHRpbmdcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3NlPXRydWVdIHdoZW4gdHJ1ZSAsIGVycm9ycyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBtZXRob2Qgd2lsbCB0cnkgYXQgYXBwbHkgdGhlIG1hc2tcclxuICAgICAqICAgICAgICAgICAgICAgIGFueXdheSAsIG90aGVyd2lzZSBpdCB3aWxsIHN0b3AgYXQgZmlyc3QgZXJyb3IgYW5kIHRocm93IGl0LlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3Mge01hc2tJc1Rvb1Nob3J0RXJyb3J9XHJcbiAgICAgKiBAdGhyb3dzIHtTdHJpbmdNYXNrRXJyb3J9XHJcbiAgICAgKiBAdGhyb3dzIHtNYXNrRXJyb3J9XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdGhlIG1hc2tlZCBzdHJpbmdcclxuICAgICAqL1xyXG5cclxuICB9LCB7XHJcbiAgICBrZXk6IFwic3RyaW5nXCIsXHJcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RyaW5nKHN0ciwgbWFzaykge1xyXG4gICAgICB2YXIgbG9vc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XHJcbiAgICAgIHJldHVybiBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1N0cmluZ01hc2tfX1tcImFcIiAvKiBkZWZhdWx0ICovXS5tYXNrKHN0ciwgbWFzaywgbG9vc2UpO1xyXG4gICAgfVxyXG4gIH1dKTtcclxuXHJcbiAgcmV0dXJuIFR5cGVzO1xyXG59KCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFR5cGVzKTtcclxuXHJcbi8qKiovIH0pXHJcbi8qKioqKiovIF0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmJqLW1hc2tzLmpzLm1hcCIsIi8qIGZsYXRwaWNrciB2NC42LjYsIEBsaWNlbnNlIE1JVCAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5mbGF0cGlja3IgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XG5cbiAgICB2YXIgSE9PS1MgPSBbXG4gICAgICAgIFwib25DaGFuZ2VcIixcbiAgICAgICAgXCJvbkNsb3NlXCIsXG4gICAgICAgIFwib25EYXlDcmVhdGVcIixcbiAgICAgICAgXCJvbkRlc3Ryb3lcIixcbiAgICAgICAgXCJvbktleURvd25cIixcbiAgICAgICAgXCJvbk1vbnRoQ2hhbmdlXCIsXG4gICAgICAgIFwib25PcGVuXCIsXG4gICAgICAgIFwib25QYXJzZUNvbmZpZ1wiLFxuICAgICAgICBcIm9uUmVhZHlcIixcbiAgICAgICAgXCJvblZhbHVlVXBkYXRlXCIsXG4gICAgICAgIFwib25ZZWFyQ2hhbmdlXCIsXG4gICAgICAgIFwib25QcmVDYWxlbmRhclBvc2l0aW9uXCIsXG4gICAgXTtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIF9kaXNhYmxlOiBbXSxcbiAgICAgICAgX2VuYWJsZTogW10sXG4gICAgICAgIGFsbG93SW5wdXQ6IGZhbHNlLFxuICAgICAgICBhbGxvd0ludmFsaWRQcmVsb2FkOiBmYWxzZSxcbiAgICAgICAgYWx0Rm9ybWF0OiBcIkYgaiwgWVwiLFxuICAgICAgICBhbHRJbnB1dDogZmFsc2UsXG4gICAgICAgIGFsdElucHV0Q2xhc3M6IFwiZm9ybS1jb250cm9sIGlucHV0XCIsXG4gICAgICAgIGFuaW1hdGU6IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpID09PSAtMSxcbiAgICAgICAgYXJpYURhdGVGb3JtYXQ6IFwiRiBqLCBZXCIsXG4gICAgICAgIGF1dG9GaWxsRGVmYXVsdFRpbWU6IHRydWUsXG4gICAgICAgIGNsaWNrT3BlbnM6IHRydWUsXG4gICAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXG4gICAgICAgIGNvbmp1bmN0aW9uOiBcIiwgXCIsXG4gICAgICAgIGRhdGVGb3JtYXQ6IFwiWS1tLWRcIixcbiAgICAgICAgZGVmYXVsdEhvdXI6IDEyLFxuICAgICAgICBkZWZhdWx0TWludXRlOiAwLFxuICAgICAgICBkZWZhdWx0U2Vjb25kczogMCxcbiAgICAgICAgZGlzYWJsZTogW10sXG4gICAgICAgIGRpc2FibGVNb2JpbGU6IGZhbHNlLFxuICAgICAgICBlbmFibGU6IFtdLFxuICAgICAgICBlbmFibGVTZWNvbmRzOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlVGltZTogZmFsc2UsXG4gICAgICAgIGVycm9ySGFuZGxlcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRXZWVrOiBmdW5jdGlvbiAoZ2l2ZW5EYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGdpdmVuRGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIC8vIFRodXJzZGF5IGluIGN1cnJlbnQgd2VlayBkZWNpZGVzIHRoZSB5ZWFyLlxuICAgICAgICAgICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgMyAtICgoZGF0ZS5nZXREYXkoKSArIDYpICUgNykpO1xuICAgICAgICAgICAgLy8gSmFudWFyeSA0IGlzIGFsd2F5cyBpbiB3ZWVrIDEuXG4gICAgICAgICAgICB2YXIgd2VlazEgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHRvIFRodXJzZGF5IGluIHdlZWsgMSBhbmQgY291bnQgbnVtYmVyIG9mIHdlZWtzIGZyb20gZGF0ZSB0byB3ZWVrMS5cbiAgICAgICAgICAgIHJldHVybiAoMSArXG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCgoKGRhdGUuZ2V0VGltZSgpIC0gd2VlazEuZ2V0VGltZSgpKSAvIDg2NDAwMDAwIC1cbiAgICAgICAgICAgICAgICAgICAgMyArXG4gICAgICAgICAgICAgICAgICAgICgod2VlazEuZ2V0RGF5KCkgKyA2KSAlIDcpKSAvXG4gICAgICAgICAgICAgICAgICAgIDcpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaG91ckluY3JlbWVudDogMSxcbiAgICAgICAgaWdub3JlZEZvY3VzRWxlbWVudHM6IFtdLFxuICAgICAgICBpbmxpbmU6IGZhbHNlLFxuICAgICAgICBsb2NhbGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBtaW51dGVJbmNyZW1lbnQ6IDUsXG4gICAgICAgIG1vZGU6IFwic2luZ2xlXCIsXG4gICAgICAgIG1vbnRoU2VsZWN0b3JUeXBlOiBcImRyb3Bkb3duXCIsXG4gICAgICAgIG5leHRBcnJvdzogXCI8c3ZnIHZlcnNpb249JzEuMScgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB4bWxuczp4bGluaz0naHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycgdmlld0JveD0nMCAwIDE3IDE3Jz48Zz48L2c+PHBhdGggZD0nTTEzLjIwNyA4LjQ3MmwtNy44NTQgNy44NTQtMC43MDctMC43MDcgNy4xNDYtNy4xNDYtNy4xNDYtNy4xNDggMC43MDctMC43MDcgNy44NTQgNy44NTR6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBub0NhbGVuZGFyOiBmYWxzZSxcbiAgICAgICAgbm93OiBuZXcgRGF0ZSgpLFxuICAgICAgICBvbkNoYW5nZTogW10sXG4gICAgICAgIG9uQ2xvc2U6IFtdLFxuICAgICAgICBvbkRheUNyZWF0ZTogW10sXG4gICAgICAgIG9uRGVzdHJveTogW10sXG4gICAgICAgIG9uS2V5RG93bjogW10sXG4gICAgICAgIG9uTW9udGhDaGFuZ2U6IFtdLFxuICAgICAgICBvbk9wZW46IFtdLFxuICAgICAgICBvblBhcnNlQ29uZmlnOiBbXSxcbiAgICAgICAgb25SZWFkeTogW10sXG4gICAgICAgIG9uVmFsdWVVcGRhdGU6IFtdLFxuICAgICAgICBvblllYXJDaGFuZ2U6IFtdLFxuICAgICAgICBvblByZUNhbGVuZGFyUG9zaXRpb246IFtdLFxuICAgICAgICBwbHVnaW5zOiBbXSxcbiAgICAgICAgcG9zaXRpb246IFwiYXV0b1wiLFxuICAgICAgICBwb3NpdGlvbkVsZW1lbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJldkFycm93OiBcIjxzdmcgdmVyc2lvbj0nMS4xJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgMTcgMTcnPjxnPjwvZz48cGF0aCBkPSdNNS4yMDcgOC40NzFsNy4xNDYgNy4xNDctMC43MDcgMC43MDctNy44NTMtNy44NTQgNy44NTQtNy44NTMgMC43MDcgMC43MDctNy4xNDcgNy4xNDZ6JyAvPjwvc3ZnPlwiLFxuICAgICAgICBzaG9ydGhhbmRDdXJyZW50TW9udGg6IGZhbHNlLFxuICAgICAgICBzaG93TW9udGhzOiAxLFxuICAgICAgICBzdGF0aWM6IGZhbHNlLFxuICAgICAgICB0aW1lXzI0aHI6IGZhbHNlLFxuICAgICAgICB3ZWVrTnVtYmVyczogZmFsc2UsXG4gICAgICAgIHdyYXA6IGZhbHNlLFxuICAgIH07XG5cbiAgICB2YXIgZW5nbGlzaCA9IHtcbiAgICAgICAgd2Vla2RheXM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxuICAgICAgICAgICAgbG9uZ2hhbmQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bmRheVwiLFxuICAgICAgICAgICAgICAgIFwiTW9uZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJUdWVzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJXZWRuZXNkYXlcIixcbiAgICAgICAgICAgICAgICBcIlRodXJzZGF5XCIsXG4gICAgICAgICAgICAgICAgXCJGcmlkYXlcIixcbiAgICAgICAgICAgICAgICBcIlNhdHVyZGF5XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICBtb250aHM6IHtcbiAgICAgICAgICAgIHNob3J0aGFuZDogW1xuICAgICAgICAgICAgICAgIFwiSmFuXCIsXG4gICAgICAgICAgICAgICAgXCJGZWJcIixcbiAgICAgICAgICAgICAgICBcIk1hclwiLFxuICAgICAgICAgICAgICAgIFwiQXByXCIsXG4gICAgICAgICAgICAgICAgXCJNYXlcIixcbiAgICAgICAgICAgICAgICBcIkp1blwiLFxuICAgICAgICAgICAgICAgIFwiSnVsXCIsXG4gICAgICAgICAgICAgICAgXCJBdWdcIixcbiAgICAgICAgICAgICAgICBcIlNlcFwiLFxuICAgICAgICAgICAgICAgIFwiT2N0XCIsXG4gICAgICAgICAgICAgICAgXCJOb3ZcIixcbiAgICAgICAgICAgICAgICBcIkRlY1wiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGxvbmdoYW5kOiBbXG4gICAgICAgICAgICAgICAgXCJKYW51YXJ5XCIsXG4gICAgICAgICAgICAgICAgXCJGZWJydWFyeVwiLFxuICAgICAgICAgICAgICAgIFwiTWFyY2hcIixcbiAgICAgICAgICAgICAgICBcIkFwcmlsXCIsXG4gICAgICAgICAgICAgICAgXCJNYXlcIixcbiAgICAgICAgICAgICAgICBcIkp1bmVcIixcbiAgICAgICAgICAgICAgICBcIkp1bHlcIixcbiAgICAgICAgICAgICAgICBcIkF1Z3VzdFwiLFxuICAgICAgICAgICAgICAgIFwiU2VwdGVtYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJPY3RvYmVyXCIsXG4gICAgICAgICAgICAgICAgXCJOb3ZlbWJlclwiLFxuICAgICAgICAgICAgICAgIFwiRGVjZW1iZXJcIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheXNJbk1vbnRoOiBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV0sXG4gICAgICAgIGZpcnN0RGF5T2ZXZWVrOiAwLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnRoKSB7XG4gICAgICAgICAgICB2YXIgcyA9IG50aCAlIDEwMDtcbiAgICAgICAgICAgIGlmIChzID4gMyAmJiBzIDwgMjEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIHN3aXRjaCAocyAlIDEwKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJkXCI7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmFuZ2VTZXBhcmF0b3I6IFwiIHRvIFwiLFxuICAgICAgICB3ZWVrQWJicmV2aWF0aW9uOiBcIldrXCIsXG4gICAgICAgIHNjcm9sbFRpdGxlOiBcIlNjcm9sbCB0byBpbmNyZW1lbnRcIixcbiAgICAgICAgdG9nZ2xlVGl0bGU6IFwiQ2xpY2sgdG8gdG9nZ2xlXCIsXG4gICAgICAgIGFtUE06IFtcIkFNXCIsIFwiUE1cIl0sXG4gICAgICAgIHllYXJBcmlhTGFiZWw6IFwiWWVhclwiLFxuICAgICAgICBtb250aEFyaWFMYWJlbDogXCJNb250aFwiLFxuICAgICAgICBob3VyQXJpYUxhYmVsOiBcIkhvdXJcIixcbiAgICAgICAgbWludXRlQXJpYUxhYmVsOiBcIk1pbnV0ZVwiLFxuICAgICAgICB0aW1lXzI0aHI6IGZhbHNlLFxuICAgIH07XG5cbiAgICB2YXIgcGFkID0gZnVuY3Rpb24gKG51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IHZvaWQgMCkgeyBsZW5ndGggPSAyOyB9XG4gICAgICAgIHJldHVybiAoXCIwMDBcIiArIG51bWJlcikuc2xpY2UobGVuZ3RoICogLTEpO1xuICAgIH07XG4gICAgdmFyIGludCA9IGZ1bmN0aW9uIChib29sKSB7IHJldHVybiAoYm9vbCA9PT0gdHJ1ZSA/IDEgOiAwKTsgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgICAgICBpZiAoaW1tZWRpYXRlID09PSB2b2lkIDApIHsgaW1tZWRpYXRlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICB0aW1lb3V0ICE9PSBudWxsICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFpbW1lZGlhdGUpXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgICAgIGlmIChpbW1lZGlhdGUgJiYgIXRpbWVvdXQpXG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFycmF5aWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgPyBvYmogOiBbb2JqXTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbSwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgICAgIGlmIChib29sID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGNsYXNzTmFtZSwgY29udGVudCkge1xuICAgICAgICB2YXIgZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZSB8fCBcIlwiO1xuICAgICAgICBjb250ZW50ID0gY29udGVudCB8fCBcIlwiO1xuICAgICAgICBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGUudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFBhcmVudChub2RlLCBjb25kaXRpb24pIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmluZFBhcmVudChub2RlLnBhcmVudE5vZGUsIGNvbmRpdGlvbik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIG5vdGhpbmcgZm91bmRcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTnVtYmVySW5wdXQoaW5wdXRDbGFzc05hbWUsIG9wdHMpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwibnVtSW5wdXRXcmFwcGVyXCIpLCBudW1JbnB1dCA9IGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBcIm51bUlucHV0IFwiICsgaW5wdXRDbGFzc05hbWUpLCBhcnJvd1VwID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJhcnJvd1VwXCIpLCBhcnJvd0Rvd24gPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImFycm93RG93blwiKTtcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUUgOS4wXCIpID09PSAtMSkge1xuICAgICAgICAgICAgbnVtSW5wdXQudHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudW1JbnB1dC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICAgICBudW1JbnB1dC5wYXR0ZXJuID0gXCJcXFxcZCpcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgICAgICAgbnVtSW5wdXQuc2V0QXR0cmlidXRlKGtleSwgb3B0c1trZXldKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChudW1JbnB1dCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dVcCk7XG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoYXJyb3dEb3duKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50LmNvbXBvc2VkUGF0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRvTm90aGluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfTtcbiAgICB2YXIgbW9udGhUb1N0ciA9IGZ1bmN0aW9uIChtb250aE51bWJlciwgc2hvcnRoYW5kLCBsb2NhbGUpIHsgcmV0dXJuIGxvY2FsZS5tb250aHNbc2hvcnRoYW5kID8gXCJzaG9ydGhhbmRcIiA6IFwibG9uZ2hhbmRcIl1bbW9udGhOdW1iZXJdOyB9O1xuICAgIHZhciByZXZGb3JtYXQgPSB7XG4gICAgICAgIEQ6IGRvTm90aGluZyxcbiAgICAgICAgRjogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoTmFtZSwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMubG9uZ2hhbmQuaW5kZXhPZihtb250aE5hbWUpKTtcbiAgICAgICAgfSxcbiAgICAgICAgRzogZnVuY3Rpb24gKGRhdGVPYmosIGhvdXIpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0SG91cnMocGFyc2VGbG9hdChob3VyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIEg6IGZ1bmN0aW9uIChkYXRlT2JqLCBob3VyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEhvdXJzKHBhcnNlRmxvYXQoaG91cikpO1xuICAgICAgICB9LFxuICAgICAgICBKOiBmdW5jdGlvbiAoZGF0ZU9iaiwgZGF5KSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldERhdGUocGFyc2VGbG9hdChkYXkpKTtcbiAgICAgICAgfSxcbiAgICAgICAgSzogZnVuY3Rpb24gKGRhdGVPYmosIGFtUE0sIGxvY2FsZSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycygoZGF0ZU9iai5nZXRIb3VycygpICUgMTIpICtcbiAgICAgICAgICAgICAgICAxMiAqIGludChuZXcgUmVnRXhwKGxvY2FsZS5hbVBNWzFdLCBcImlcIikudGVzdChhbVBNKSkpO1xuICAgICAgICB9LFxuICAgICAgICBNOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2hvcnRNb250aCwgbG9jYWxlKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKGxvY2FsZS5tb250aHMuc2hvcnRoYW5kLmluZGV4T2Yoc2hvcnRNb250aCkpO1xuICAgICAgICB9LFxuICAgICAgICBTOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRTZWNvbmRzKHBhcnNlRmxvYXQoc2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICBVOiBmdW5jdGlvbiAoXywgdW5peFNlY29uZHMpIHsgcmV0dXJuIG5ldyBEYXRlKHBhcnNlRmxvYXQodW5peFNlY29uZHMpICogMTAwMCk7IH0sXG4gICAgICAgIFc6IGZ1bmN0aW9uIChkYXRlT2JqLCB3ZWVrTnVtLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrTnVtYmVyID0gcGFyc2VJbnQod2Vla051bSk7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgMCwgMiArICh3ZWVrTnVtYmVyIC0gMSkgKiA3LCAwLCAwLCAwLCAwKTtcbiAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGRhdGUuZ2V0RGF5KCkgKyBsb2NhbGUuZmlyc3REYXlPZldlZWspO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlT2JqLCB5ZWFyKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldEZ1bGxZZWFyKHBhcnNlRmxvYXQoeWVhcikpO1xuICAgICAgICB9LFxuICAgICAgICBaOiBmdW5jdGlvbiAoXywgSVNPRGF0ZSkgeyByZXR1cm4gbmV3IERhdGUoSVNPRGF0ZSk7IH0sXG4gICAgICAgIGQ6IGZ1bmN0aW9uIChkYXRlT2JqLCBkYXkpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0RGF0ZShwYXJzZUZsb2F0KGRheSkpO1xuICAgICAgICB9LFxuICAgICAgICBoOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaG91cikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRIb3VycyhwYXJzZUZsb2F0KGhvdXIpKTtcbiAgICAgICAgfSxcbiAgICAgICAgaTogZnVuY3Rpb24gKGRhdGVPYmosIG1pbnV0ZXMpIHtcbiAgICAgICAgICAgIGRhdGVPYmouc2V0TWludXRlcyhwYXJzZUZsb2F0KG1pbnV0ZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgajogZnVuY3Rpb24gKGRhdGVPYmosIGRheSkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXREYXRlKHBhcnNlRmxvYXQoZGF5KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGw6IGRvTm90aGluZyxcbiAgICAgICAgbTogZnVuY3Rpb24gKGRhdGVPYmosIG1vbnRoKSB7XG4gICAgICAgICAgICBkYXRlT2JqLnNldE1vbnRoKHBhcnNlRmxvYXQobW9udGgpIC0gMSk7XG4gICAgICAgIH0sXG4gICAgICAgIG46IGZ1bmN0aW9uIChkYXRlT2JqLCBtb250aCkge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRNb250aChwYXJzZUZsb2F0KG1vbnRoKSAtIDEpO1xuICAgICAgICB9LFxuICAgICAgICBzOiBmdW5jdGlvbiAoZGF0ZU9iaiwgc2Vjb25kcykge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRTZWNvbmRzKHBhcnNlRmxvYXQoc2Vjb25kcykpO1xuICAgICAgICB9LFxuICAgICAgICB1OiBmdW5jdGlvbiAoXywgdW5peE1pbGxTZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VGbG9hdCh1bml4TWlsbFNlY29uZHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdzogZG9Ob3RoaW5nLFxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZU9iaiwgeWVhcikge1xuICAgICAgICAgICAgZGF0ZU9iai5zZXRGdWxsWWVhcigyMDAwICsgcGFyc2VGbG9hdCh5ZWFyKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB2YXIgdG9rZW5SZWdleCA9IHtcbiAgICAgICAgRDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBGOiBcIihcXFxcdyspXCIsXG4gICAgICAgIEc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEg6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIEo6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXFxcXHcrXCIsXG4gICAgICAgIEs6IFwiXCIsXG4gICAgICAgIE06IFwiKFxcXFx3KylcIixcbiAgICAgICAgUzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgVTogXCIoLispXCIsXG4gICAgICAgIFc6IFwiKFxcXFxkXFxcXGR8XFxcXGQpXCIsXG4gICAgICAgIFk6IFwiKFxcXFxkezR9KVwiLFxuICAgICAgICBaOiBcIiguKylcIixcbiAgICAgICAgZDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaDogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgaTogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgajogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgbDogXCIoXFxcXHcrKVwiLFxuICAgICAgICBtOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBuOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICBzOiBcIihcXFxcZFxcXFxkfFxcXFxkKVwiLFxuICAgICAgICB1OiBcIiguKylcIixcbiAgICAgICAgdzogXCIoXFxcXGRcXFxcZHxcXFxcZClcIixcbiAgICAgICAgeTogXCIoXFxcXGR7Mn0pXCIsXG4gICAgfTtcbiAgICB2YXIgZm9ybWF0cyA9IHtcbiAgICAgICAgLy8gZ2V0IHRoZSBkYXRlIGluIFVUQ1xuICAgICAgICBaOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpOyB9LFxuICAgICAgICAvLyB3ZWVrZGF5IG5hbWUsIHNob3J0LCBlLmcuIFRodVxuICAgICAgICBEOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzLnNob3J0aGFuZFtmb3JtYXRzLncoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZ1bGwgbW9udGggbmFtZSBlLmcuIEphbnVhcnlcbiAgICAgICAgRjogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZm9ybWF0cy5uKGRhdGUsIGxvY2FsZSwgb3B0aW9ucykgLSAxLCBmYWxzZSwgbG9jYWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcGFkZGVkIGhvdXIgMS0xMlxuICAgICAgICBHOiBmdW5jdGlvbiAoZGF0ZSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFkKGZvcm1hdHMuaChkYXRlLCBsb2NhbGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaG91cnMgd2l0aCBsZWFkaW5nIHplcm8gZS5nLiAwM1xuICAgICAgICBIOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0SG91cnMoKSk7IH0sXG4gICAgICAgIC8vIGRheSAoMS0zMCkgd2l0aCBvcmRpbmFsIHN1ZmZpeCBlLmcuIDFzdCwgMm5kXG4gICAgICAgIEo6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUub3JkaW5hbCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBkYXRlLmdldERhdGUoKSArIGxvY2FsZS5vcmRpbmFsKGRhdGUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgICAgIDogZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFNL1BNXG4gICAgICAgIEs6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHsgcmV0dXJuIGxvY2FsZS5hbVBNW2ludChkYXRlLmdldEhvdXJzKCkgPiAxMSldOyB9LFxuICAgICAgICAvLyBzaG9ydGhhbmQgbW9udGggZS5nLiBKYW4sIFNlcCwgT2N0LCBldGNcbiAgICAgICAgTTogZnVuY3Rpb24gKGRhdGUsIGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vbnRoVG9TdHIoZGF0ZS5nZXRNb250aCgpLCB0cnVlLCBsb2NhbGUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBzZWNvbmRzIDAwLTU5XG4gICAgICAgIFM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRTZWNvbmRzKCkpOyB9LFxuICAgICAgICAvLyB1bml4IHRpbWVzdGFtcFxuICAgICAgICBVOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRUaW1lKCkgLyAxMDAwOyB9LFxuICAgICAgICBXOiBmdW5jdGlvbiAoZGF0ZSwgXywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZ2V0V2VlayhkYXRlKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZnVsbCB5ZWFyIGUuZy4gMjAxNiwgcGFkZGVkICgwMDAxLTk5OTkpXG4gICAgICAgIFk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTsgfSxcbiAgICAgICAgLy8gZGF5IGluIG1vbnRoLCBwYWRkZWQgKDAxLTMwKVxuICAgICAgICBkOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0RGF0ZSgpKTsgfSxcbiAgICAgICAgLy8gaG91ciBmcm9tIDEtMTIgKGFtL3BtKVxuICAgICAgICBoOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gKGRhdGUuZ2V0SG91cnMoKSAlIDEyID8gZGF0ZS5nZXRIb3VycygpICUgMTIgOiAxMik7IH0sXG4gICAgICAgIC8vIG1pbnV0ZXMsIHBhZGRlZCB3aXRoIGxlYWRpbmcgemVybyBlLmcuIDA5XG4gICAgICAgIGk6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBwYWQoZGF0ZS5nZXRNaW51dGVzKCkpOyB9LFxuICAgICAgICAvLyBkYXkgaW4gbW9udGggKDEtMzApXG4gICAgICAgIGo6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldERhdGUoKTsgfSxcbiAgICAgICAgLy8gd2Vla2RheSBuYW1lLCBmdWxsLCBlLmcuIFRodXJzZGF5XG4gICAgICAgIGw6IGZ1bmN0aW9uIChkYXRlLCBsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXMubG9uZ2hhbmRbZGF0ZS5nZXREYXkoKV07XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhZGRlZCBtb250aCBudW1iZXIgKDAxLTEyKVxuICAgICAgICBtOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gcGFkKGRhdGUuZ2V0TW9udGgoKSArIDEpOyB9LFxuICAgICAgICAvLyB0aGUgbW9udGggbnVtYmVyICgxLTEyKVxuICAgICAgICBuOiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXRNb250aCgpICsgMTsgfSxcbiAgICAgICAgLy8gc2Vjb25kcyAwLTU5XG4gICAgICAgIHM6IGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBkYXRlLmdldFNlY29uZHMoKTsgfSxcbiAgICAgICAgLy8gVW5peCBNaWxsaXNlY29uZHNcbiAgICAgICAgdTogZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIGRhdGUuZ2V0VGltZSgpOyB9LFxuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xuICAgICAgICB3OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZS5nZXREYXkoKTsgfSxcbiAgICAgICAgLy8gbGFzdCB0d28gZGlnaXRzIG9mIHllYXIgZS5nLiAxNiBmb3IgMjAxNlxuICAgICAgICB5OiBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gU3RyaW5nKGRhdGUuZ2V0RnVsbFllYXIoKSkuc3Vic3RyaW5nKDIpOyB9LFxuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0ZUZvcm1hdHRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfYS5jb25maWcsIGNvbmZpZyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyA6IF9iLCBfYyA9IF9hLmwxMG4sIGwxMG4gPSBfYyA9PT0gdm9pZCAwID8gZW5nbGlzaCA6IF9jLCBfZCA9IF9hLmlzTW9iaWxlLCBpc01vYmlsZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGVPYmosIGZybXQsIG92ZXJyaWRlTG9jYWxlKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gb3ZlcnJpZGVMb2NhbGUgfHwgbDEwbjtcbiAgICAgICAgICAgIGlmIChjb25maWcuZm9ybWF0RGF0ZSAhPT0gdW5kZWZpbmVkICYmICFpc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maWcuZm9ybWF0RGF0ZShkYXRlT2JqLCBmcm10LCBsb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZybXRcbiAgICAgICAgICAgICAgICAuc3BsaXQoXCJcIilcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjLCBpLCBhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0c1tjXSAmJiBhcnJbaSAtIDFdICE9PSBcIlxcXFxcIlxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbY10oZGF0ZU9iaiwgbG9jYWxlLCBjb25maWcpXG4gICAgICAgICAgICAgICAgICAgIDogYyAhPT0gXCJcXFxcXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIlwiKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVEYXRlUGFyc2VyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9hLmNvbmZpZywgY29uZmlnID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRzIDogX2IsIF9jID0gX2EubDEwbiwgbDEwbiA9IF9jID09PSB2b2lkIDAgPyBlbmdsaXNoIDogX2M7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSwgZ2l2ZW5Gb3JtYXQsIHRpbWVsZXNzLCBjdXN0b21Mb2NhbGUpIHtcbiAgICAgICAgICAgIGlmIChkYXRlICE9PSAwICYmICFkYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gY3VzdG9tTG9jYWxlIHx8IGwxMG47XG4gICAgICAgICAgICB2YXIgcGFyc2VkRGF0ZTtcbiAgICAgICAgICAgIHZhciBkYXRlT3JpZyA9IGRhdGU7XG4gICAgICAgICAgICBpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRlICE9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZGF0ZS50b0ZpeGVkICE9PSB1bmRlZmluZWQgLy8gdGltZXN0YW1wXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29weVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0ZSBzdHJpbmdcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gZ2l2ZW5Gb3JtYXQgfHwgKGNvbmZpZyB8fCBkZWZhdWx0cykuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZXN0ciA9IFN0cmluZyhkYXRlKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzdHIgPT09IFwidG9kYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvWiQvLnRlc3QoZGF0ZXN0cikgfHxcbiAgICAgICAgICAgICAgICAgICAgL0dNVCQvLnRlc3QoZGF0ZXN0cikgLy8gZGF0ZXN0cmluZ3Mgdy8gdGltZXpvbmVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25maWcgJiYgY29uZmlnLnBhcnNlRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9IGNvbmZpZy5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAhY29uZmlnIHx8ICFjb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCAwLCAxLCAwLCAwLCAwLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVkID0gdm9pZCAwLCBvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG1hdGNoSW5kZXggPSAwLCByZWdleFN0ciA9IFwiXCI7IGkgPCBmb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbl8xID0gZm9ybWF0W2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQmFja1NsYXNoID0gdG9rZW5fMSA9PT0gXCJcXFxcXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXNjYXBlZCA9IGZvcm1hdFtpIC0gMV0gPT09IFwiXFxcXFwiIHx8IGlzQmFja1NsYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuUmVnZXhbdG9rZW5fMV0gJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleFN0ciArPSB0b2tlblJlZ2V4W3Rva2VuXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IG5ldyBSZWdFeHAocmVnZXhTdHIpLmV4ZWMoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIChtYXRjaGVkID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BzW3Rva2VuXzEgIT09IFwiWVwiID8gXCJwdXNoXCIgOiBcInVuc2hpZnRcIl0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm46IHJldkZvcm1hdFt0b2tlbl8xXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogbWF0Y2hbKyttYXRjaEluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQmFja1NsYXNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4U3RyICs9IFwiLlwiOyAvLyBkb24ndCByZWFsbHkgY2FyZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gX2EuZm4sIHZhbCA9IF9hLnZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhcnNlZERhdGUgPSBmbihwYXJzZWREYXRlLCB2YWwsIGxvY2FsZSkgfHwgcGFyc2VkRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJzZWREYXRlID0gbWF0Y2hlZCA/IHBhcnNlZERhdGUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghKHBhcnNlZERhdGUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTihwYXJzZWREYXRlLmdldFRpbWUoKSkpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgcHJvdmlkZWQ6IFwiICsgZGF0ZU9yaWcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVsZXNzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHBhcnNlZERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIGRpZmZlcmVuY2UgaW4gZGF0ZXMsIG1lYXN1cmVkIGluIG1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFyZURhdGVzKGRhdGUxLCBkYXRlMiwgdGltZWxlc3MpIHtcbiAgICAgICAgaWYgKHRpbWVsZXNzID09PSB2b2lkIDApIHsgdGltZWxlc3MgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0aW1lbGVzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiAobmV3IERhdGUoZGF0ZTEuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKSAtXG4gICAgICAgICAgICAgICAgbmV3IERhdGUoZGF0ZTIuZ2V0VGltZSgpKS5zZXRIb3VycygwLCAwLCAwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUxLmdldFRpbWUoKSAtIGRhdGUyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgdmFyIGlzQmV0d2VlbiA9IGZ1bmN0aW9uICh0cywgdHMxLCB0czIpIHtcbiAgICAgICAgcmV0dXJuIHRzID4gTWF0aC5taW4odHMxLCB0czIpICYmIHRzIDwgTWF0aC5tYXgodHMxLCB0czIpO1xuICAgIH07XG4gICAgdmFyIGR1cmF0aW9uID0ge1xuICAgICAgICBEQVk6IDg2NDAwMDAwLFxuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKHRhcmdldFtrZXldID0gc291cmNlW2tleV0pOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXJnc18xW19hXTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBERUJPVU5DRURfQ0hBTkdFX01TID0gMzAwO1xuICAgIGZ1bmN0aW9uIEZsYXRwaWNrckluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlQ29uZmlnKSB7XG4gICAgICAgIHZhciBzZWxmID0ge1xuICAgICAgICAgICAgY29uZmlnOiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdHMpLCBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyksXG4gICAgICAgICAgICBsMTBuOiBlbmdsaXNoLFxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnBhcnNlRGF0ZSA9IGNyZWF0ZURhdGVQYXJzZXIoeyBjb25maWc6IHNlbGYuY29uZmlnLCBsMTBuOiBzZWxmLmwxMG4gfSk7XG4gICAgICAgIHNlbGYuX2hhbmRsZXJzID0gW107XG4gICAgICAgIHNlbGYucGx1Z2luRWxlbWVudHMgPSBbXTtcbiAgICAgICAgc2VsZi5sb2FkZWRQbHVnaW5zID0gW107XG4gICAgICAgIHNlbGYuX2JpbmQgPSBiaW5kO1xuICAgICAgICBzZWxmLl9zZXRIb3Vyc0Zyb21EYXRlID0gc2V0SG91cnNGcm9tRGF0ZTtcbiAgICAgICAgc2VsZi5fcG9zaXRpb25DYWxlbmRhciA9IHBvc2l0aW9uQ2FsZW5kYXI7XG4gICAgICAgIHNlbGYuY2hhbmdlTW9udGggPSBjaGFuZ2VNb250aDtcbiAgICAgICAgc2VsZi5jaGFuZ2VZZWFyID0gY2hhbmdlWWVhcjtcbiAgICAgICAgc2VsZi5jbGVhciA9IGNsZWFyO1xuICAgICAgICBzZWxmLmNsb3NlID0gY2xvc2U7XG4gICAgICAgIHNlbGYuX2NyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuICAgICAgICBzZWxmLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IGlzRW5hYmxlZDtcbiAgICAgICAgc2VsZi5qdW1wVG9EYXRlID0ganVtcFRvRGF0ZTtcbiAgICAgICAgc2VsZi5vcGVuID0gb3BlbjtcbiAgICAgICAgc2VsZi5yZWRyYXcgPSByZWRyYXc7XG4gICAgICAgIHNlbGYuc2V0ID0gc2V0O1xuICAgICAgICBzZWxmLnNldERhdGUgPSBzZXREYXRlO1xuICAgICAgICBzZWxmLnRvZ2dsZSA9IHRvZ2dsZTtcbiAgICAgICAgZnVuY3Rpb24gc2V0dXBIZWxwZXJGdW5jdGlvbnMoKSB7XG4gICAgICAgICAgICBzZWxmLnV0aWxzID0ge1xuICAgICAgICAgICAgICAgIGdldERheXNJbk1vbnRoOiBmdW5jdGlvbiAobW9udGgsIHlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gdm9pZCAwKSB7IG1vbnRoID0gc2VsZi5jdXJyZW50TW9udGg7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlyID09PSB2b2lkIDApIHsgeXIgPSBzZWxmLmN1cnJlbnRZZWFyOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gMSAmJiAoKHlyICUgNCA9PT0gMCAmJiB5ciAlIDEwMCAhPT0gMCkgfHwgeXIgJSA0MDAgPT09IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5sMTBuLmRheXNJbk1vbnRoW21vbnRoXTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICAgICAgc2VsZi5lbGVtZW50ID0gc2VsZi5pbnB1dCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcGFyc2VDb25maWcoKTtcbiAgICAgICAgICAgIHNldHVwTG9jYWxlKCk7XG4gICAgICAgICAgICBzZXR1cElucHV0cygpO1xuICAgICAgICAgICAgc2V0dXBEYXRlcygpO1xuICAgICAgICAgICAgc2V0dXBIZWxwZXJGdW5jdGlvbnMoKTtcbiAgICAgICAgICAgIGlmICghc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICBidWlsZCgpO1xuICAgICAgICAgICAgYmluZEV2ZW50cygpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggfHwgc2VsZi5jb25maWcubm9DYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdXJzRnJvbURhdGUoc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiB8fCBzZWxmLmNvbmZpZy5taW5EYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENhbGVuZGFyV2lkdGgoKTtcbiAgICAgICAgICAgIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgICAgICAvKiBUT0RPOiBpbnZlc3RpZ2F0ZSB0aGlzIGZ1cnRoZXJcbiAgICAgICAgXG4gICAgICAgICAgICAgIEN1cnJlbnRseSwgdGhlcmUgaXMgd2VpcmQgcG9zaXRpb25pbmcgYmVoYXZpb3IgaW4gc2FmYXJpIGNhdXNpbmcgcGFnZXNcbiAgICAgICAgICAgICAgdG8gc2Nyb2xsIHVwLiBodHRwczovL2dpdGh1Yi5jb20vY2htbG4vZmxhdHBpY2tyL2lzc3Vlcy81NjNcbiAgICAgICAgXG4gICAgICAgICAgICAgIEhvd2V2ZXIsIG1vc3QgYnJvd3NlcnMgYXJlIG5vdCBTYWZhcmkgYW5kIHBvc2l0aW9uaW5nIGlzIGV4cGVuc2l2ZSB3aGVuIHVzZWRcbiAgICAgICAgICAgICAgaW4gc2NhbGUuIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG1sbi9mbGF0cGlja3IvaXNzdWVzLzEwOTZcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNNb2JpbGUgJiYgaXNTYWZhcmkpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkNhbGVuZGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblJlYWR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRUb0luc3RhbmNlKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYmluZChzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRDYWxlbmRhcldpZHRoKCkge1xuICAgICAgICAgICAgdmFyIGNvbmZpZyA9IHNlbGYuY29uZmlnO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWVrTnVtYmVycyA9PT0gZmFsc2UgJiYgY29uZmlnLnNob3dNb250aHMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcubm9DYWxlbmRhciAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRheXNXaWR0aCA9IChzZWxmLmRheXMub2Zmc2V0V2lkdGggKyAxKSAqIGNvbmZpZy5zaG93TW9udGhzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gZGF5c1dpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5c1dpZHRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYud2Vla1dyYXBwZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLndlZWtXcmFwcGVyLm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInZpc2liaWxpdHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFuZGxlciBmb3IgYWxsIGV2ZW50cyB0YXJnZXRpbmcgdGhlIHRpbWUgaW5wdXRzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVUaW1lKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRlID0gc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IERhdGUoc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0SG91cnMoKSwgaG91cnMgPSBfYS5ob3VycywgbWludXRlcyA9IF9hLm1pbnV0ZXMsIHNlY29uZHMgPSBfYS5zZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHREYXRlLnNldEhvdXJzKGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCAwKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoZGVmYXVsdERhdGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlICE9PSB1bmRlZmluZWQgJiYgZS50eXBlICE9PSBcImJsdXJcIikge1xuICAgICAgICAgICAgICAgIHRpbWVXcmFwcGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZWYWx1ZSA9IHNlbGYuX2lucHV0LnZhbHVlO1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuX2lucHV0LnZhbHVlICE9PSBwcmV2VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhbXBtMm1pbGl0YXJ5KGhvdXIsIGFtUE0pIHtcbiAgICAgICAgICAgIHJldHVybiAoaG91ciAlIDEyKSArIDEyICogaW50KGFtUE0gPT09IHNlbGYubDEwbi5hbVBNWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaWxpdGFyeTJhbXBtKGhvdXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG91ciAlIDI0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaG91ciAlIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTeW5jcyB0aGUgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgdGltZSB3aXRoIHVzZXIncyB0aW1lIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzZXRIb3Vyc0Zyb21JbnB1dHMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5ob3VyRWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IHNlbGYubWludXRlRWxlbWVudCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBob3VycyA9IChwYXJzZUludChzZWxmLmhvdXJFbGVtZW50LnZhbHVlLnNsaWNlKC0yKSwgMTApIHx8IDApICUgMjQsIG1pbnV0ZXMgPSAocGFyc2VJbnQoc2VsZi5taW51dGVFbGVtZW50LnZhbHVlLCAxMCkgfHwgMCkgJSA2MCwgc2Vjb25kcyA9IHNlbGYuc2Vjb25kRWxlbWVudCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyAocGFyc2VJbnQoc2VsZi5zZWNvbmRFbGVtZW50LnZhbHVlLCAxMCkgfHwgMCkgJSA2MFxuICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhvdXJzID0gYW1wbTJtaWxpdGFyeShob3Vycywgc2VsZi5hbVBNLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaW1pdE1pbkhvdXJzID0gc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5taW5EYXRlSGFzVGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYuY29uZmlnLm1pbkRhdGUsIHRydWUpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gICAgICAgICAgICB2YXIgbGltaXRNYXhIb3VycyA9IHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubWF4RGF0ZUhhc1RpbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLCBzZWxmLmNvbmZpZy5tYXhEYXRlLCB0cnVlKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIDApO1xuICAgICAgICAgICAgaWYgKGxpbWl0TWF4SG91cnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4VGltZSA9IHNlbGYuY29uZmlnLm1heFRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heFRpbWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5taW4oaG91cnMsIG1heFRpbWUuZ2V0SG91cnMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhUaW1lLmdldEhvdXJzKCkpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1pbihtaW51dGVzLCBtYXhUaW1lLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbnV0ZXMgPT09IG1heFRpbWUuZ2V0TWludXRlcygpKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5taW4oc2Vjb25kcywgbWF4VGltZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0TWluSG91cnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWluVGltZSA9IHNlbGYuY29uZmlnLm1pblRpbWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pblRpbWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5taW5EYXRlO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5tYXgoaG91cnMsIG1pblRpbWUuZ2V0SG91cnMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtaW5UaW1lLmdldEhvdXJzKCkpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1heChtaW51dGVzLCBtaW5UaW1lLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1pbnV0ZXMgPT09IG1pblRpbWUuZ2V0TWludXRlcygpKVxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5tYXgoc2Vjb25kcywgbWluVGltZS5nZXRTZWNvbmRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTeW5jcyB0aW1lIGlucHV0IHZhbHVlcyB3aXRoIGEgZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IGRhdGVPYmogfHwgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmo7XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksIGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXREZWZhdWx0SG91cnMoKSB7XG4gICAgICAgICAgICB2YXIgaG91cnMgPSBzZWxmLmNvbmZpZy5kZWZhdWx0SG91cjtcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZTtcbiAgICAgICAgICAgIHZhciBzZWNvbmRzID0gc2VsZi5jb25maWcuZGVmYXVsdFNlY29uZHM7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkhyID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgICAgIHZhciBtaW5NaW51dGVzID0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgaG91cnMgPSBNYXRoLm1heChob3VycywgbWluSHIpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWluSHIpXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLm1heChtaW5NaW51dGVzLCBtaW51dGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaG91cnMgPT09IG1pbkhyICYmIG1pbnV0ZXMgPT09IG1pbk1pbnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4SHIgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG1heE1pbnV0ZXMgPSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IE1hdGgubWluKGhvdXJzLCBtYXhIcik7XG4gICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBtYXhIcilcbiAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IE1hdGgubWluKG1heE1pbnV0ZXMsIG1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChob3VycyA9PT0gbWF4SHIgJiYgbWludXRlcyA9PT0gbWF4TWludXRlcylcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0U2Vjb25kcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgaG91cnM6IGhvdXJzLCBtaW51dGVzOiBtaW51dGVzLCBzZWNvbmRzOiBzZWNvbmRzIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGhvdXJzLCBtaW51dGVzLCBhbmQgb3B0aW9uYWxseSBzZWNvbmRzXG4gICAgICAgICAqIG9mIHRoZSBsYXRlc3Qgc2VsZWN0ZWQgZGF0ZSBvYmplY3QgYW5kIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHRpbWUgaW5wdXRzXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyB0aGUgaG91ci4gd2hldGhlciBpdHMgbWlsaXRhcnlcbiAgICAgICAgICogICAgICAgICAgICAgICAgIG9yIGFtLXBtIGdldHMgaW5mZXJyZWQgZnJvbSBjb25maWdcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgdGhlIG1pbnV0ZXNcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNlY29uZHMgdGhlIHNlY29uZHMgKG9wdGlvbmFsKVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouc2V0SG91cnMoaG91cnMgJSAyNCwgbWludXRlcywgc2Vjb25kcyB8fCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5ob3VyRWxlbWVudCB8fCAhc2VsZi5taW51dGVFbGVtZW50IHx8IHNlbGYuaXNNb2JpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZCghc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgPyAoKDEyICsgaG91cnMpICUgMTIpICsgMTIgKiBpbnQoaG91cnMgJSAxMiA9PT0gMClcbiAgICAgICAgICAgICAgICA6IGhvdXJzKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC52YWx1ZSA9IHBhZChtaW51dGVzKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGV4dENvbnRlbnQgPSBzZWxmLmwxMG4uYW1QTVtpbnQoaG91cnMgPj0gMTIpXTtcbiAgICAgICAgICAgIGlmIChzZWxmLnNlY29uZEVsZW1lbnQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgdGhlIHllYXIgaW5wdXQgYW5kIGluY3JlbWVudGluZyBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhlIGtleXVwIG9yIGluY3JlbWVudCBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gb25ZZWFySW5wdXQoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoZXZlbnRUYXJnZXQudmFsdWUpICsgKGV2ZW50LmRlbHRhIHx8IDApO1xuICAgICAgICAgICAgaWYgKHllYXIgLyAxMDAwID4gMSB8fFxuICAgICAgICAgICAgICAgIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiAmJiAhL1teXFxkXS8udGVzdCh5ZWFyLnRvU3RyaW5nKCkpKSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzc2VudGlhbGx5IGFkZEV2ZW50TGlzdGVuZXIgKyB0cmFja2luZ1xuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gYWRkRXZlbnRMaXN0ZW5lciB0b1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZChlbGVtZW50LCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGV2KSB7IHJldHVybiBiaW5kKGVsZW1lbnQsIGV2LCBoYW5kbGVyLCBvcHRpb25zKTsgfSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24gKGVsKSB7IHJldHVybiBiaW5kKGVsLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7IH0pO1xuICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJDaGFuZ2UoKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhbGwgdGhlIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcud3JhcCkge1xuICAgICAgICAgICAgICAgIFtcIm9wZW5cIiwgXCJjbG9zZVwiLCBcInRvZ2dsZVwiLCBcImNsZWFyXCJdLmZvckVhY2goZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHNlbGYuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtXCIgKyBldnQgKyBcIl1cIiksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQoZWwsIFwiY2xpY2tcIiwgc2VsZltldnRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSkge1xuICAgICAgICAgICAgICAgIHNldHVwTW9iaWxlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRlYm91bmNlZFJlc2l6ZSA9IGRlYm91bmNlKG9uUmVzaXplLCA1MCk7XG4gICAgICAgICAgICBzZWxmLl9kZWJvdW5jZWRDaGFuZ2UgPSBkZWJvdW5jZSh0cmlnZ2VyQ2hhbmdlLCBERUJPVU5DRURfQ0hBTkdFX01TKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgJiYgIS9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSlcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuZGF5c0NvbnRhaW5lciwgXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyKGdldEV2ZW50VGFyZ2V0KGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LmJvZHksIFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5pbmxpbmUgJiYgIXNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdywgXCJyZXNpemVcIiwgZGVib3VuY2VkUmVzaXplKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cub250b3VjaHN0YXJ0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgYmluZCh3aW5kb3cuZG9jdW1lbnQsIFwidG91Y2hzdGFydFwiLCBkb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiaW5kKHdpbmRvdy5kb2N1bWVudCwgXCJjbGlja1wiLCBkb2N1bWVudENsaWNrKTtcbiAgICAgICAgICAgIGJpbmQod2luZG93LmRvY3VtZW50LCBcImZvY3VzXCIsIGRvY3VtZW50Q2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbGlja09wZW5zID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJmb2N1c1wiLCBzZWxmLm9wZW4pO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5faW5wdXQsIFwiY2xpY2tcIiwgc2VsZi5vcGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aE5hdiwgXCJjbGlja1wiLCBvbk1vbnRoTmF2Q2xpY2spO1xuICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5tb250aE5hdiwgW1wia2V5dXBcIiwgXCJpbmNyZW1lbnRcIl0sIG9uWWVhcklucHV0KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYuZGF5c0NvbnRhaW5lciwgXCJjbGlja1wiLCBzZWxlY3REYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLnRpbWVDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbFRleHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXZlbnRUYXJnZXQoZSkuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgW1wiaW5jcmVtZW50XCJdLCB1cGRhdGVUaW1lKTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJibHVyXCIsIHVwZGF0ZVRpbWUsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiaW5kKHNlbGYudGltZUNvbnRhaW5lciwgXCJjbGlja1wiLCB0aW1lSW5jcmVtZW50KTtcbiAgICAgICAgICAgICAgICBiaW5kKFtzZWxmLmhvdXJFbGVtZW50LCBzZWxmLm1pbnV0ZUVsZW1lbnRdLCBbXCJmb2N1c1wiLCBcImNsaWNrXCJdLCBzZWxUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWNvbmRFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGJpbmQoc2VsZi5zZWNvbmRFbGVtZW50LCBcImZvY3VzXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuc2Vjb25kRWxlbWVudCAmJiBzZWxmLnNlY29uZEVsZW1lbnQuc2VsZWN0KCk7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kKHNlbGYuYW1QTSwgXCJjbGlja1wiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsbG93SW5wdXQpXG4gICAgICAgICAgICAgICAgYmluZChzZWxmLl9pbnB1dCwgXCJibHVyXCIsIG9uQmx1cik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgY2FsZW5kYXIgdmlldyB0byBhIHBhcnRpY3VsYXIgZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHtEYXRlfSBqdW1wRGF0ZSB0aGUgZGF0ZSB0byBzZXQgdGhlIHZpZXcgdG9cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB0cmlnZ2VyQ2hhbmdlIGlmIGNoYW5nZSBldmVudHMgc2hvdWxkIGJlIHRyaWdnZXJlZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24ganVtcFRvRGF0ZShqdW1wRGF0ZSwgdHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIGp1bXBUbyA9IGp1bXBEYXRlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHNlbGYucGFyc2VEYXRlKGp1bXBEYXRlKVxuICAgICAgICAgICAgICAgIDogc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiYgc2VsZi5jb25maWcubWluRGF0ZSA+IHNlbGYubm93XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1pbkRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWF4RGF0ZSAmJiBzZWxmLmNvbmZpZy5tYXhEYXRlIDwgc2VsZi5ub3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93KTtcbiAgICAgICAgICAgIHZhciBvbGRZZWFyID0gc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIHZhciBvbGRNb250aCA9IHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IGp1bXBUby5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IGp1bXBUby5nZXRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSBcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBqdW1wVG87XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UgJiYgc2VsZi5jdXJyZW50WWVhciAhPT0gb2xkWWVhcikge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSAmJlxuICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyICE9PSBvbGRZZWFyIHx8IHNlbGYuY3VycmVudE1vbnRoICE9PSBvbGRNb250aCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVwL2Rvd24gYXJyb3cgaGFuZGxlciBmb3IgdGltZSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZSB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVJbmNyZW1lbnQoZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICBpZiAofmV2ZW50VGFyZ2V0LmNsYXNzTmFtZS5pbmRleE9mKFwiYXJyb3dcIikpXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50TnVtSW5wdXQoZSwgZXZlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dVcFwiKSA/IDEgOiAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluY3JlbWVudHMvZGVjcmVtZW50cyB0aGUgdmFsdWUgb2YgaW5wdXQgYXNzb2NpLVxuICAgICAgICAgKiBhdGVkIHdpdGggdGhlIHVwL2Rvd24gYXJyb3cgYnkgZGlzcGF0Y2hpbmcgYW5cbiAgICAgICAgICogXCJpbmNyZW1lbnRcIiBldmVudCBvbiB0aGUgaW5wdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgdGhlIGNsaWNrIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YSB0aGUgZGlmZiAodXN1YWxseSAxIG9yIC0xKVxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGlucHV0RWxlbSB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaW5jcmVtZW50TnVtSW5wdXQoZSwgZGVsdGEsIGlucHV0RWxlbSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUgJiYgZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBpbnB1dEVsZW0gfHxcbiAgICAgICAgICAgICAgICAodGFyZ2V0ICYmIHRhcmdldC5wYXJlbnROb2RlICYmIHRhcmdldC5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlRXZlbnQoXCJpbmNyZW1lbnRcIik7XG4gICAgICAgICAgICBldmVudC5kZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgaW5wdXQgJiYgaW5wdXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGQoKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItY2FsZW5kYXJcIik7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICBpZiAoIXNlbGYuY29uZmlnLm5vQ2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChidWlsZE1vbnRoTmF2KCkpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLWlubmVyQ29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy53ZWVrTnVtYmVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBidWlsZFdlZWtzKCksIHdlZWtXcmFwcGVyID0gX2Eud2Vla1dyYXBwZXIsIHdlZWtOdW1iZXJzID0gX2Eud2Vla051bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQod2Vla1dyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLndlZWtOdW1iZXJzID0gd2Vla051bWJlcnM7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYud2Vla1dyYXBwZXIgPSB3ZWVrV3JhcHBlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5yQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1yQ29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChidWlsZFdlZWtkYXlzKCkpO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZi5kYXlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItZGF5c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgICAgIHNlbGYuckNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5yQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChzZWxmLmlubmVyQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGVUaW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoYnVpbGRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJyYW5nZU1vZGVcIiwgc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYW5pbWF0ZVwiLCBzZWxmLmNvbmZpZy5hbmltYXRlID09PSB0cnVlKTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwibXVsdGlNb250aFwiLCBzZWxmLmNvbmZpZy5zaG93TW9udGhzID4gMSk7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgICAgIHZhciBjdXN0b21BcHBlbmQgPSBzZWxmLmNvbmZpZy5hcHBlbmRUbyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuYXBwZW5kVG8ubm9kZVR5cGUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5pbmxpbmUgfHwgc2VsZi5jb25maWcuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHNlbGYuY29uZmlnLmlubGluZSA/IFwiaW5saW5lXCIgOiBcInN0YXRpY1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuaW5saW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VzdG9tQXBwZW5kICYmIHNlbGYuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIHNlbGYuX2lucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmFwcGVuZFRvLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13cmFwcGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lbGVtZW50LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod3JhcHBlciwgc2VsZi5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzZWxmLmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5hbHRJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoc2VsZi5jYWxlbmRhckNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgIXNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcuYXBwZW5kVG8gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmFwcGVuZFRvXG4gICAgICAgICAgICAgICAgICAgIDogd2luZG93LmRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZURheShjbGFzc05hbWUsIGRhdGUsIGRheU51bWJlciwgaSkge1xuICAgICAgICAgICAgdmFyIGRhdGVJc0VuYWJsZWQgPSBpc0VuYWJsZWQoZGF0ZSwgdHJ1ZSksIGRheUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci1kYXkgXCIgKyBjbGFzc05hbWUsIGRhdGUuZ2V0RGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZGF5RWxlbWVudC5kYXRlT2JqID0gZGF0ZTtcbiAgICAgICAgICAgIGRheUVsZW1lbnQuJGkgPSBpO1xuICAgICAgICAgICAgZGF5RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNlbGYuZm9ybWF0RGF0ZShkYXRlLCBzZWxmLmNvbmZpZy5hcmlhRGF0ZUZvcm1hdCkpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLm5vdykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLnRvZGF5RGF0ZUVsZW0gPSBkYXlFbGVtZW50O1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInRvZGF5XCIpO1xuICAgICAgICAgICAgICAgIGRheUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1jdXJyZW50XCIsIFwiZGF0ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlSXNFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGVTZWxlY3RlZChkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gZGF5RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoZGF5RWxlbWVudCwgXCJzdGFydFJhbmdlXCIsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpID09PSAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGRheUVsZW1lbnQsIFwiZW5kUmFuZ2VcIiwgc2VsZi5zZWxlY3RlZERhdGVzWzFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1sxXSwgdHJ1ZSkgPT09IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gXCJuZXh0TW9udGhEYXlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZmxhdHBpY2tyLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGVJblJhbmdlKGRhdGUpICYmICFpc0RhdGVTZWxlY3RlZChkYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgZGF5RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaW5SYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuc2hvd01vbnRocyA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSAhPT0gXCJwcmV2TW9udGhEYXlcIiAmJlxuICAgICAgICAgICAgICAgIGRheU51bWJlciAlIDcgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtOdW1iZXJzLmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBcIjxzcGFuIGNsYXNzPSdmbGF0cGlja3ItZGF5Jz5cIiArIHNlbGYuY29uZmlnLmdldFdlZWsoZGF0ZSkgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbkRheUNyZWF0ZVwiLCBkYXlFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBkYXlFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzT25EYXlFbGVtKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIpXG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIodGFyZ2V0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0Rmlyc3RBdmFpbGFibGVEYXkoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE1vbnRoID0gZGVsdGEgPiAwID8gMCA6IHNlbGYuY29uZmlnLnNob3dNb250aHMgLSAxO1xuICAgICAgICAgICAgdmFyIGVuZE1vbnRoID0gZGVsdGEgPiAwID8gc2VsZi5jb25maWcuc2hvd01vbnRocyA6IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgbSA9IHN0YXJ0TW9udGg7IG0gIT0gZW5kTW9udGg7IG0gKz0gZGVsdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBzZWxmLmRheXNDb250YWluZXIuY2hpbGRyZW5bbV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBkZWx0YSA+IDAgPyAwIDogbW9udGguY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBkZWx0YSA+IDAgPyBtb250aC5jaGlsZHJlbi5sZW5ndGggOiAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSArPSBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1vbnRoLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5jbGFzc05hbWUuaW5kZXhPZihcImhpZGRlblwiKSA9PT0gLTEgJiYgaXNFbmFibGVkKGMuZGF0ZU9iaikpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRBdmFpbGFibGVEYXkoY3VycmVudCwgZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBnaXZlbk1vbnRoID0gY3VycmVudC5jbGFzc05hbWUuaW5kZXhPZihcIk1vbnRoXCIpID09PSAtMVxuICAgICAgICAgICAgICAgID8gY3VycmVudC5kYXRlT2JqLmdldE1vbnRoKClcbiAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudE1vbnRoO1xuICAgICAgICAgICAgdmFyIGVuZE1vbnRoID0gZGVsdGEgPiAwID8gc2VsZi5jb25maWcuc2hvd01vbnRocyA6IC0xO1xuICAgICAgICAgICAgdmFyIGxvb3BEZWx0YSA9IGRlbHRhID4gMCA/IDEgOiAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBnaXZlbk1vbnRoIC0gc2VsZi5jdXJyZW50TW9udGg7IG0gIT0gZW5kTW9udGg7IG0gKz0gbG9vcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gc2VsZi5kYXlzQ29udGFpbmVyLmNoaWxkcmVuW21dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gZ2l2ZW5Nb250aCAtIHNlbGYuY3VycmVudE1vbnRoID09PSBtXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudC4kaSArIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgIDogZGVsdGEgPCAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG1vbnRoLmNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgbnVtTW9udGhEYXlzID0gbW9udGguY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpID49IDAgJiYgaSA8IG51bU1vbnRoRGF5cyAmJiBpICE9IChkZWx0YSA+IDAgPyBudW1Nb250aERheXMgOiAtMSk7IGkgKz0gbG9vcERlbHRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbW9udGguY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmFibGVkKGMuZGF0ZU9iaikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGN1cnJlbnQuJGkgLSBpKSA+PSBNYXRoLmFicyhkZWx0YSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNPbkRheUVsZW0oYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5jaGFuZ2VNb250aChsb29wRGVsdGEpO1xuICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheShsb29wRGVsdGEpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9jdXNPbkRheShjdXJyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHZhciBkYXlGb2N1c2VkID0gaXNJblZpZXcoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgIHZhciBzdGFydEVsZW0gPSBjdXJyZW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA6IGRheUZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5zZWxlY3RlZERhdGVFbGVtICE9PSB1bmRlZmluZWQgJiYgaXNJblZpZXcoc2VsZi5zZWxlY3RlZERhdGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLnNlbGVjdGVkRGF0ZUVsZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2VsZi50b2RheURhdGVFbGVtICE9PSB1bmRlZmluZWQgJiYgaXNJblZpZXcoc2VsZi50b2RheURhdGVFbGVtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi50b2RheURhdGVFbGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRGaXJzdEF2YWlsYWJsZURheShvZmZzZXQgPiAwID8gMSA6IC0xKTtcbiAgICAgICAgICAgIGlmIChzdGFydEVsZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF5Rm9jdXNlZCkge1xuICAgICAgICAgICAgICAgIGZvY3VzT25EYXlFbGVtKHN0YXJ0RWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXROZXh0QXZhaWxhYmxlRGF5KHN0YXJ0RWxlbSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoRGF5cyh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0T2ZNb250aCA9IChuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCkgLSBzZWxmLmwxMG4uZmlyc3REYXlPZldlZWsgKyA3KSAlIDc7XG4gICAgICAgICAgICB2YXIgcHJldk1vbnRoRGF5cyA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgoKG1vbnRoIC0gMSArIDEyKSAlIDEyLCB5ZWFyKTtcbiAgICAgICAgICAgIHZhciBkYXlzSW5Nb250aCA9IHNlbGYudXRpbHMuZ2V0RGF5c0luTW9udGgobW9udGgsIHllYXIpLCBkYXlzID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgaXNNdWx0aU1vbnRoID0gc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEsIHByZXZNb250aERheUNsYXNzID0gaXNNdWx0aU1vbnRoID8gXCJwcmV2TW9udGhEYXkgaGlkZGVuXCIgOiBcInByZXZNb250aERheVwiLCBuZXh0TW9udGhEYXlDbGFzcyA9IGlzTXVsdGlNb250aCA/IFwibmV4dE1vbnRoRGF5IGhpZGRlblwiIDogXCJuZXh0TW9udGhEYXlcIjtcbiAgICAgICAgICAgIHZhciBkYXlOdW1iZXIgPSBwcmV2TW9udGhEYXlzICsgMSAtIGZpcnN0T2ZNb250aCwgZGF5SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gcHJlcGVuZCBkYXlzIGZyb20gdGhlIGVuZGluZyBvZiBwcmV2aW91cyBtb250aFxuICAgICAgICAgICAgZm9yICg7IGRheU51bWJlciA8PSBwcmV2TW9udGhEYXlzOyBkYXlOdW1iZXIrKywgZGF5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGRheXMuYXBwZW5kQ2hpbGQoY3JlYXRlRGF5KHByZXZNb250aERheUNsYXNzLCBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDEgc2luY2UgdGhlcmUgaXMgbm8gMHRoIGRheVxuICAgICAgICAgICAgZm9yIChkYXlOdW1iZXIgPSAxOyBkYXlOdW1iZXIgPD0gZGF5c0luTW9udGg7IGRheU51bWJlcisrLCBkYXlJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZGF5cy5hcHBlbmRDaGlsZChjcmVhdGVEYXkoXCJcIiwgbmV3IERhdGUoeWVhciwgbW9udGgsIGRheU51bWJlciksIGRheU51bWJlciwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFwcGVuZCBkYXlzIGZyb20gdGhlIG5leHQgbW9udGhcbiAgICAgICAgICAgIGZvciAodmFyIGRheU51bSA9IGRheXNJbk1vbnRoICsgMTsgZGF5TnVtIDw9IDQyIC0gZmlyc3RPZk1vbnRoICYmXG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPT09IDEgfHwgZGF5SW5kZXggJSA3ICE9PSAwKTsgZGF5TnVtKyssIGRheUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBkYXlzLmFwcGVuZENoaWxkKGNyZWF0ZURheShuZXh0TW9udGhEYXlDbGFzcywgbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCBkYXlOdW0gJSBkYXlzSW5Nb250aCksIGRheU51bSwgZGF5SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgdmFyIGRheUNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJkYXlDb250YWluZXJcIik7XG4gICAgICAgICAgICBkYXlDb250YWluZXIuYXBwZW5kQ2hpbGQoZGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZGF5Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRGF5cygpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLmRheXNDb250YWluZXIpO1xuICAgICAgICAgICAgLy8gVE9ETzogd2VlayBudW1iZXJzIGZvciBlYWNoIG1vbnRoXG4gICAgICAgICAgICBpZiAoc2VsZi53ZWVrTnVtYmVycylcbiAgICAgICAgICAgICAgICBjbGVhck5vZGUoc2VsZi53ZWVrTnVtYmVycyk7XG4gICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcuc2hvd01vbnRoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoYnVpbGRNb250aERheXMoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGF5c0NvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnKTtcbiAgICAgICAgICAgIHNlbGYuZGF5cyA9IHNlbGYuZGF5c0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIiAmJiBzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgb25Nb3VzZU92ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBidWlsZE1vbnRoU3dpdGNoKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnNob3dNb250aHMgPiAxIHx8XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9udGhTZWxlY3RvclR5cGUgIT09IFwiZHJvcGRvd25cIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2hvdWxkQnVpbGRNb250aCA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5taW5EYXRlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRNb250aCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEoc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXIgPT09IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgICAgICBtb250aCA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TW9udGgoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaG91bGRCdWlsZE1vbnRoKGkpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBjcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIFwiZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhcIik7XG4gICAgICAgICAgICAgICAgbW9udGgudmFsdWUgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBpKS5nZXRNb250aCgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbW9udGgudGV4dENvbnRlbnQgPSBtb250aFRvU3RyKGksIHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCwgc2VsZi5sMTBuKTtcbiAgICAgICAgICAgICAgICBtb250aC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmN1cnJlbnRNb250aCA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBtb250aC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYubW9udGhzRHJvcGRvd25Db250YWluZXIuYXBwZW5kQ2hpbGQobW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkTW9udGgoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci1tb250aFwiKTtcbiAgICAgICAgICAgIHZhciBtb250aE5hdkZyYWdtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgIHZhciBtb250aEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc2hvd01vbnRocyA+IDEgfHxcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb250aFNlbGVjdG9yVHlwZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgIG1vbnRoRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIFwiY3VyLW1vbnRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgXCJmbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aHNcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHNlbGYubDEwbi5tb250aEFyaWFMYWJlbCk7XG4gICAgICAgICAgICAgICAgYmluZChzZWxmLm1vbnRoc0Ryb3Bkb3duQ29udGFpbmVyLCBcImNoYW5nZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE1vbnRoID0gcGFyc2VJbnQodGFyZ2V0LnZhbHVlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlTW9udGgoc2VsZWN0ZWRNb250aCAtIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICAgICAgbW9udGhFbGVtZW50ID0gc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB5ZWFySW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImN1ci15ZWFyXCIsIHsgdGFiaW5kZXg6IFwiLTFcIiB9KTtcbiAgICAgICAgICAgIHZhciB5ZWFyRWxlbWVudCA9IHllYXJJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgeWVhckVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzZWxmLmwxMG4ueWVhckFyaWFMYWJlbCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1pblwiLCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgeWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRNb250aCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3ItY3VycmVudC1tb250aFwiKTtcbiAgICAgICAgICAgIGN1cnJlbnRNb250aC5hcHBlbmRDaGlsZChtb250aEVsZW1lbnQpO1xuICAgICAgICAgICAgY3VycmVudE1vbnRoLmFwcGVuZENoaWxkKHllYXJJbnB1dCk7XG4gICAgICAgICAgICBtb250aE5hdkZyYWdtZW50LmFwcGVuZENoaWxkKGN1cnJlbnRNb250aCk7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobW9udGhOYXZGcmFnbWVudCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHllYXJFbGVtZW50OiB5ZWFyRWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb250aEVsZW1lbnQ6IG1vbnRoRWxlbWVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aHMoKSB7XG4gICAgICAgICAgICBjbGVhck5vZGUoc2VsZi5tb250aE5hdik7XG4gICAgICAgICAgICBzZWxmLm1vbnRoTmF2LmFwcGVuZENoaWxkKHNlbGYucHJldk1vbnRoTmF2KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93TW9udGhzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi55ZWFyRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBtLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoID0gYnVpbGRNb250aCgpO1xuICAgICAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLnB1c2gobW9udGgueWVhckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHNlbGYubW9udGhFbGVtZW50cy5wdXNoKG1vbnRoLm1vbnRoRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChtb250aC5jb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5tb250aE5hdi5hcHBlbmRDaGlsZChzZWxmLm5leHRNb250aE5hdik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRNb250aE5hdigpIHtcbiAgICAgICAgICAgIHNlbGYubW9udGhOYXYgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLW1vbnRoc1wiKTtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzID0gW107XG4gICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItcHJldi1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYucHJldk1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLnByZXZBcnJvdztcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2ID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItbmV4dC1tb250aFwiKTtcbiAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoTmF2LmlubmVySFRNTCA9IHNlbGYuY29uZmlnLm5leHRBcnJvdztcbiAgICAgICAgICAgIGJ1aWxkTW9udGhzKCk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZVByZXZNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlUHJldk1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5wcmV2TW9udGhOYXYsIFwiZmxhdHBpY2tyLWRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVQcmV2TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJfaGlkZU5leHRNb250aEFycm93XCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuX19oaWRlTmV4dE1vbnRoQXJyb3c7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyAhPT0gYm9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5uZXh0TW9udGhOYXYsIFwiZmxhdHBpY2tyLWRpc2FibGVkXCIsIGJvb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fX2hpZGVOZXh0TW9udGhBcnJvdyA9IGJvb2w7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyRWxlbWVudCA9IHNlbGYueWVhckVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYubW9udGhOYXY7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVpbGRUaW1lKCkge1xuICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzVGltZVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5ub0NhbGVuZGFyKVxuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vQ2FsZW5kYXJcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXRpbWVcIik7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3IgPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci10aW1lLXNlcGFyYXRvclwiLCBcIjpcIik7XG4gICAgICAgICAgICB2YXIgaG91cklucHV0ID0gY3JlYXRlTnVtYmVySW5wdXQoXCJmbGF0cGlja3ItaG91clwiLCB7XG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHNlbGYubDEwbi5ob3VyQXJpYUxhYmVsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ID0gaG91cklucHV0LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIilbMF07XG4gICAgICAgICAgICB2YXIgbWludXRlSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1taW51dGVcIiwge1xuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBzZWxmLmwxMG4ubWludXRlQXJpYUxhYmVsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQgPSBtaW51dGVJbnB1dC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpWzBdO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC50YWJJbmRleCA9IHNlbGYubWludXRlRWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC52YWx1ZSA9IHBhZChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgID8gc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmouZ2V0SG91cnMoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcudGltZV8yNGhyXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuZGVmYXVsdEhvdXJcbiAgICAgICAgICAgICAgICAgICAgOiBtaWxpdGFyeTJhbXBtKHNlbGYuY29uZmlnLmRlZmF1bHRIb3VyKSk7XG4gICAgICAgICAgICBzZWxmLm1pbnV0ZUVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICA/IHNlbGYubGF0ZXN0U2VsZWN0ZWREYXRlT2JqLmdldE1pbnV0ZXMoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGVmYXVsdE1pbnV0ZSk7XG4gICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgc2VsZi5jb25maWcuaG91ckluY3JlbWVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzdGVwXCIsIHNlbGYuY29uZmlnLm1pbnV0ZUluY3JlbWVudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWluXCIsIHNlbGYuY29uZmlnLnRpbWVfMjRociA/IFwiMFwiIDogXCIxXCIpO1xuICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgc2VsZi5jb25maWcudGltZV8yNGhyID8gXCIyM1wiIDogXCIxMlwiKTtcbiAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgXCIwXCIpO1xuICAgICAgICAgICAgc2VsZi5taW51dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1heFwiLCBcIjU5XCIpO1xuICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKGhvdXJJbnB1dCk7XG4gICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtaW51dGVJbnB1dCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcudGltZV8yNGhyKVxuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGltZTI0aHJcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIHNlbGYudGltZUNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGFzU2Vjb25kc1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc2Vjb25kSW5wdXQgPSBjcmVhdGVOdW1iZXJJbnB1dChcImZsYXRwaWNrci1zZWNvbmRcIik7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50ID0gc2Vjb25kSW5wdXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpbnB1dFwiKVswXTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlY29uZEVsZW1lbnQudmFsdWUgPSBwYWQoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmpcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iai5nZXRTZWNvbmRzKClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kZWZhdWx0U2Vjb25kcyk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LnNldEF0dHJpYnV0ZShcInN0ZXBcIiwgc2VsZi5taW51dGVFbGVtZW50LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtaW5cIiwgXCIwXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuc2Vjb25kRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtYXhcIiwgXCI1OVwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItdGltZS1zZXBhcmF0b3JcIiwgXCI6XCIpKTtcbiAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuYXBwZW5kQ2hpbGQoc2Vjb25kSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy50aW1lXzI0aHIpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgc2VsZi5hbVBNIGlmIGFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNID0gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgXCJmbGF0cGlja3ItYW0tcG1cIiwgc2VsZi5sMTBuLmFtUE1baW50KChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9ialxuICAgICAgICAgICAgICAgICAgICA/IHNlbGYuaG91ckVsZW1lbnQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kZWZhdWx0SG91cikgPiAxMSldKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFtUE0udGl0bGUgPSBzZWxmLmwxMG4udG9nZ2xlVGl0bGU7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgc2VsZi50aW1lQ29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuYW1QTSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50aW1lQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla2RheXMoKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYud2Vla2RheUNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBzZWxmLndlZWtkYXlDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtkYXlzXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNsZWFyTm9kZShzZWxmLndlZWtkYXlDb250YWluZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuY29uZmlnLnNob3dNb250aHM7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiLCBcImZsYXRwaWNrci13ZWVrZGF5Y29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYud2Vla2RheUNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlV2Vla2RheXMoKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLndlZWtkYXlDb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlV2Vla2RheXMoKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYud2Vla2RheUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmaXJzdERheU9mV2VlayA9IHNlbGYubDEwbi5maXJzdERheU9mV2VlaztcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5cyA9IF9fc3ByZWFkQXJyYXlzKHNlbGYubDEwbi53ZWVrZGF5cy5zaG9ydGhhbmQpO1xuICAgICAgICAgICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCAmJiBmaXJzdERheU9mV2VlayA8IHdlZWtkYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlzID0gX19zcHJlYWRBcnJheXMod2Vla2RheXMuc3BsaWNlKGZpcnN0RGF5T2ZXZWVrLCB3ZWVrZGF5cy5sZW5ndGgpLCB3ZWVrZGF5cy5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmNvbmZpZy5zaG93TW9udGhzOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgc2VsZi53ZWVrZGF5Q29udGFpbmVyLmNoaWxkcmVuW2ldLmlubmVySFRNTCA9IFwiXFxuICAgICAgPHNwYW4gY2xhc3M9J2ZsYXRwaWNrci13ZWVrZGF5Jz5cXG4gICAgICAgIFwiICsgd2Vla2RheXMuam9pbihcIjwvc3Bhbj48c3BhbiBjbGFzcz0nZmxhdHBpY2tyLXdlZWtkYXknPlwiKSArIFwiXFxuICAgICAgPC9zcGFuPlxcbiAgICAgIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkV2Vla3MoKSB7XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoYXNXZWVrc1wiKTtcbiAgICAgICAgICAgIHZhciB3ZWVrV3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgXCJmbGF0cGlja3Itd2Vla3dyYXBwZXJcIik7XG4gICAgICAgICAgICB3ZWVrV3JhcHBlci5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KFwic3BhblwiLCBcImZsYXRwaWNrci13ZWVrZGF5XCIsIHNlbGYubDEwbi53ZWVrQWJicmV2aWF0aW9uKSk7XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlcnMgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIFwiZmxhdHBpY2tyLXdlZWtzXCIpO1xuICAgICAgICAgICAgd2Vla1dyYXBwZXIuYXBwZW5kQ2hpbGQod2Vla051bWJlcnMpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3ZWVrV3JhcHBlcjogd2Vla1dyYXBwZXIsXG4gICAgICAgICAgICAgICAgd2Vla051bWJlcnM6IHdlZWtOdW1iZXJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VNb250aCh2YWx1ZSwgaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChpc09mZnNldCA9PT0gdm9pZCAwKSB7IGlzT2Zmc2V0ID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRlbHRhID0gaXNPZmZzZXQgPyB2YWx1ZSA6IHZhbHVlIC0gc2VsZi5jdXJyZW50TW9udGg7XG4gICAgICAgICAgICBpZiAoKGRlbHRhIDwgMCAmJiBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPT09IHRydWUpIHx8XG4gICAgICAgICAgICAgICAgKGRlbHRhID4gMCAmJiBzZWxmLl9oaWRlTmV4dE1vbnRoQXJyb3cgPT09IHRydWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICs9IGRlbHRhO1xuICAgICAgICAgICAgaWYgKHNlbGYuY3VycmVudE1vbnRoIDwgMCB8fCBzZWxmLmN1cnJlbnRNb250aCA+IDExKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciArPSBzZWxmLmN1cnJlbnRNb250aCA+IDExID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoID0gKHNlbGYuY3VycmVudE1vbnRoICsgMTIpICUgMTI7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1aWxkRGF5cygpO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25Nb250aENoYW5nZVwiKTtcbiAgICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhcih0cmlnZ2VyQ2hhbmdlRXZlbnQsIHRvSW5pdGlhbCkge1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCA9PT0gdm9pZCAwKSB7IHRyaWdnZXJDaGFuZ2VFdmVudCA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmICh0b0luaXRpYWwgPT09IHZvaWQgMCkgeyB0b0luaXRpYWwgPSB0cnVlOyB9XG4gICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQudmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW107XG4gICAgICAgICAgICBzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0b0luaXRpYWwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZi5faW5pdGlhbERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGYuX2luaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IGdldERlZmF1bHRIb3VycygpLCBob3VycyA9IF9hLmhvdXJzLCBtaW51dGVzID0gX2EubWludXRlcywgc2Vjb25kcyA9IF9hLnNlY29uZHM7XG4gICAgICAgICAgICAgICAgc2V0SG91cnMoaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpXG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlckNoYW5nZUV2ZW50IGlzIHRydWUgKGRlZmF1bHQpIG9yIGFuIEV2ZW50XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICBzZWxmLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2FsZW5kYXJDb250YWluZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGVuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5faW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uRGVzdHJveVwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLl9oYW5kbGVycy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHNlbGYuX2hhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGguZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGguZXZlbnQsIGguaGFuZGxlciwgaC5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzID0gW107XG4gICAgICAgICAgICBpZiAoc2VsZi5tb2JpbGVJbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLm1vYmlsZUlucHV0KTtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciAmJiBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25maWcuc3RhdGljICYmIHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IHNlbGYuY2FsZW5kYXJDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5sYXN0Q2hpbGQgJiYgd3JhcHBlci5yZW1vdmVDaGlsZCh3cmFwcGVyLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3cmFwcGVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh3cmFwcGVyLmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh3cmFwcGVyLmZpcnN0Q2hpbGQsIHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuY2FsZW5kYXJDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuYWx0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsZi5hbHRJbnB1dCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYuYWx0SW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IHNlbGYuaW5wdXQuX3R5cGU7XG4gICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc0xpc3QucmVtb3ZlKFwiZmxhdHBpY2tyLWlucHV0XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgXCJfc2hvd1RpbWVJbnB1dFwiLFxuICAgICAgICAgICAgICAgIFwibGF0ZXN0U2VsZWN0ZWREYXRlT2JqXCIsXG4gICAgICAgICAgICAgICAgXCJfaGlkZU5leHRNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJfaGlkZVByZXZNb250aEFycm93XCIsXG4gICAgICAgICAgICAgICAgXCJfX2hpZGVOZXh0TW9udGhBcnJvd1wiLFxuICAgICAgICAgICAgICAgIFwiX19oaWRlUHJldk1vbnRoQXJyb3dcIixcbiAgICAgICAgICAgICAgICBcImlzTW9iaWxlXCIsXG4gICAgICAgICAgICAgICAgXCJpc09wZW5cIixcbiAgICAgICAgICAgICAgICBcInNlbGVjdGVkRGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcIm1pbkRhdGVIYXNUaW1lXCIsXG4gICAgICAgICAgICAgICAgXCJtYXhEYXRlSGFzVGltZVwiLFxuICAgICAgICAgICAgICAgIFwiZGF5c1wiLFxuICAgICAgICAgICAgICAgIFwiZGF5c0NvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwiX2lucHV0XCIsXG4gICAgICAgICAgICAgICAgXCJfcG9zaXRpb25FbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgXCJpbm5lckNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwickNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgIFwibW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcInRvZGF5RGF0ZUVsZW1cIixcbiAgICAgICAgICAgICAgICBcImNhbGVuZGFyQ29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWVrZGF5Q29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgXCJwcmV2TW9udGhOYXZcIixcbiAgICAgICAgICAgICAgICBcIm5leHRNb250aE5hdlwiLFxuICAgICAgICAgICAgICAgIFwibW9udGhzRHJvcGRvd25Db250YWluZXJcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRNb250aEVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBcImN1cnJlbnRZZWFyRWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIFwibmF2aWdhdGlvbkN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwic2VsZWN0ZWREYXRlRWxlbVwiLFxuICAgICAgICAgICAgICAgIFwiY29uZmlnXCIsXG4gICAgICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2VsZltrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNDYWxlbmRhckVsZW0oZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFwcGVuZFRvICYmIHNlbGYuY29uZmlnLmFwcGVuZFRvLmNvbnRhaW5zKGVsZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY29udGFpbnMoZWxlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRDbGljayhlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pc09wZW4gJiYgIXNlbGYuY29uZmlnLmlubGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFRhcmdldF8xID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzQ2FsZW5kYXJFbGVtZW50ID0gaXNDYWxlbmRhckVsZW0oZXZlbnRUYXJnZXRfMSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5wdXQgPSBldmVudFRhcmdldF8xID09PSBzZWxmLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0XzEgPT09IHNlbGYuYWx0SW5wdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50LmNvbnRhaW5zKGV2ZW50VGFyZ2V0XzEpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlYiBjb21wb25lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIGUucGF0aCBpcyBub3QgcHJlc2VudCBpbiBhbGwgYnJvd3NlcnMuIGNpcmN1bXZlbnRpbmcgdHlwZWNoZWNrc1xuICAgICAgICAgICAgICAgICAgICAoZS5wYXRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnBhdGguaW5kZXhPZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKH5lLnBhdGguaW5kZXhPZihzZWxmLmlucHV0KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH5lLnBhdGguaW5kZXhPZihzZWxmLmFsdElucHV0KSkpO1xuICAgICAgICAgICAgICAgIHZhciBsb3N0Rm9jdXMgPSBlLnR5cGUgPT09IFwiYmx1clwiXG4gICAgICAgICAgICAgICAgICAgID8gaXNJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICA6ICFpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaXNDYWxlbmRhckVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0NhbGVuZGFyRWxlbShlLnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpc0lnbm9yZWQgPSAhc2VsZi5jb25maWcuaWdub3JlZEZvY3VzRWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5jb250YWlucyhldmVudFRhcmdldF8xKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobG9zdEZvY3VzICYmIGlzSWdub3JlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi50aW1lQ29udGFpbmVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgIT09IFwiXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlID09PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VZZWFyKG5ld1llYXIpIHtcbiAgICAgICAgICAgIGlmICghbmV3WWVhciB8fFxuICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlICYmIG5ld1llYXIgPCBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHx8XG4gICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUgJiYgbmV3WWVhciA+IHNlbGYuY29uZmlnLm1heERhdGUuZ2V0RnVsbFllYXIoKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG5ld1llYXJOdW0gPSBuZXdZZWFyLCBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBuZXdZZWFyTnVtO1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IG5ld1llYXJOdW0gfHwgc2VsZi5jdXJyZW50WWVhcjtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRGdWxsWWVhcigpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBNYXRoLm1pbihzZWxmLmNvbmZpZy5tYXhEYXRlLmdldE1vbnRoKCksIHNlbGYuY3VycmVudE1vbnRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5taW5EYXRlLmdldEZ1bGxZZWFyKCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IE1hdGgubWF4KHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKSwgc2VsZi5jdXJyZW50TW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmV3WWVhcikge1xuICAgICAgICAgICAgICAgIHNlbGYucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25ZZWFyQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIGJ1aWxkTW9udGhTd2l0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VuYWJsZWQoZGF0ZSwgdGltZWxlc3MpIHtcbiAgICAgICAgICAgIGlmICh0aW1lbGVzcyA9PT0gdm9pZCAwKSB7IHRpbWVsZXNzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIGRhdGVUb0NoZWNrID0gc2VsZi5wYXJzZURhdGUoZGF0ZSwgdW5kZWZpbmVkLCB0aW1lbGVzcyk7IC8vIHRpbWVsZXNzXG4gICAgICAgICAgICBpZiAoKHNlbGYuY29uZmlnLm1pbkRhdGUgJiZcbiAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlVG9DaGVjaywgc2VsZi5jb25maWcubWluRGF0ZSwgdGltZWxlc3MgIT09IHVuZGVmaW5lZCA/IHRpbWVsZXNzIDogIXNlbGYubWluRGF0ZUhhc1RpbWUpIDwgMCkgfHxcbiAgICAgICAgICAgICAgICAoc2VsZi5jb25maWcubWF4RGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlVG9DaGVjayAmJlxuICAgICAgICAgICAgICAgICAgICBjb21wYXJlRGF0ZXMoZGF0ZVRvQ2hlY2ssIHNlbGYuY29uZmlnLm1heERhdGUsIHRpbWVsZXNzICE9PSB1bmRlZmluZWQgPyB0aW1lbGVzcyA6ICFzZWxmLm1heERhdGVIYXNUaW1lKSA+IDApKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID09PSAwICYmIHNlbGYuY29uZmlnLmRpc2FibGUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGVUb0NoZWNrID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBzZWxmLmNvbmZpZy5lbmFibGUubGVuZ3RoID4gMCwgYXJyYXkgPSBib29sID8gc2VsZi5jb25maWcuZW5hYmxlIDogc2VsZi5jb25maWcuZGlzYWJsZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkID0gdm9pZCAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZChkYXRlVG9DaGVjaykgLy8gZGlzYWJsZWQgYnkgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgYnkgZGF0ZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gXCJzdHJpbmdcIiAmJiBkYXRlVG9DaGVjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRpc2FibGVkIGJ5IGRhdGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBzZWxmLnBhcnNlRGF0ZShkLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkICYmIHBhcnNlZC5nZXRUaW1lKCkgPT09IGRhdGVUb0NoZWNrLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICFib29sO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAvLyBkaXNhYmxlZCBieSByYW5nZVxuICAgICAgICAgICAgICAgIHR5cGVvZiBkID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGVUb0NoZWNrICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZC5mcm9tICYmXG4gICAgICAgICAgICAgICAgICAgIGQudG8gJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpID49IGQuZnJvbS5nZXRUaW1lKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGF0ZVRvQ2hlY2suZ2V0VGltZSgpIDw9IGQudG8uZ2V0VGltZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAhYm9vbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0luVmlldyhlbGVtKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5kYXlzQ29udGFpbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiaGlkZGVuXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZS5pbmRleE9mKFwiZmxhdHBpY2tyLWRpc2FibGVkXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRheXNDb250YWluZXIuY29udGFpbnMoZWxlbSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uQmx1cihlKSB7XG4gICAgICAgICAgICB2YXIgaXNJbnB1dCA9IGUudGFyZ2V0ID09PSBzZWxmLl9pbnB1dDtcbiAgICAgICAgICAgIGlmIChpc0lucHV0ICYmXG4gICAgICAgICAgICAgICAgIShlLnJlbGF0ZWRUYXJnZXQgJiYgaXNDYWxlbmRhckVsZW0oZS5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5faW5wdXQudmFsdWUsIHRydWUsIGUudGFyZ2V0ID09PSBzZWxmLmFsdElucHV0XG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcuYWx0Rm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25LZXlEb3duKGUpIHtcbiAgICAgICAgICAgIC8vIGUua2V5ICAgICAgICAgICAgICAgICAgICAgIGUua2V5Q29kZVxuICAgICAgICAgICAgLy8gXCJCYWNrc3BhY2VcIiAgICAgICAgICAgICAgICAgICAgICAgIDhcbiAgICAgICAgICAgIC8vIFwiVGFiXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA5XG4gICAgICAgICAgICAvLyBcIkVudGVyXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAxM1xuICAgICAgICAgICAgLy8gXCJFc2NhcGVcIiAgICAgKElFIFwiRXNjXCIpICAgICAgICAgICAyN1xuICAgICAgICAgICAgLy8gXCJBcnJvd0xlZnRcIiAgKElFIFwiTGVmdFwiKSAgICAgICAgICAzN1xuICAgICAgICAgICAgLy8gXCJBcnJvd1VwXCIgICAgKElFIFwiVXBcIikgICAgICAgICAgICAzOFxuICAgICAgICAgICAgLy8gXCJBcnJvd1JpZ2h0XCIgKElFIFwiUmlnaHRcIikgICAgICAgICAzOVxuICAgICAgICAgICAgLy8gXCJBcnJvd0Rvd25cIiAgKElFIFwiRG93blwiKSAgICAgICAgICA0MFxuICAgICAgICAgICAgLy8gXCJEZWxldGVcIiAgICAgKElFIFwiRGVsXCIpICAgICAgICAgICA0NlxuICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICB2YXIgaXNJbnB1dCA9IHNlbGYuY29uZmlnLndyYXBcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpXG4gICAgICAgICAgICAgICAgOiBldmVudFRhcmdldCA9PT0gc2VsZi5faW5wdXQ7XG4gICAgICAgICAgICB2YXIgYWxsb3dJbnB1dCA9IHNlbGYuY29uZmlnLmFsbG93SW5wdXQ7XG4gICAgICAgICAgICB2YXIgYWxsb3dLZXlkb3duID0gc2VsZi5pc09wZW4gJiYgKCFhbGxvd0lucHV0IHx8ICFpc0lucHV0KTtcbiAgICAgICAgICAgIHZhciBhbGxvd0lubGluZUtleWRvd24gPSBzZWxmLmNvbmZpZy5pbmxpbmUgJiYgaXNJbnB1dCAmJiAhYWxsb3dJbnB1dDtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzICYmIGlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoc2VsZi5faW5wdXQudmFsdWUsIHRydWUsIGV2ZW50VGFyZ2V0ID09PSBzZWxmLmFsdElucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmFsdEZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5kYXRlRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50VGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ2FsZW5kYXJFbGVtKGV2ZW50VGFyZ2V0KSB8fFxuICAgICAgICAgICAgICAgIGFsbG93S2V5ZG93biB8fFxuICAgICAgICAgICAgICAgIGFsbG93SW5saW5lS2V5ZG93bikge1xuICAgICAgICAgICAgICAgIHZhciBpc1RpbWVPYmogPSAhIXNlbGYudGltZUNvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLnRpbWVDb250YWluZXIuY29udGFpbnMoZXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNUaW1lT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0RGF0ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzQW5kQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnB1dCAmJiAhc2VsZi5jb25maWcuYWxsb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmICFpc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmRheXNDb250YWluZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWxsb3dJbnB1dCA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGlzSW5WaWV3KGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhXzEgPSBlLmtleUNvZGUgPT09IDM5ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuY3RybEtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlTW9udGgoZGVsdGFfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c09uRGF5KGdldEZpcnN0QXZhaWxhYmxlRGF5KDEpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBlLmtleUNvZGUgPT09IDQwID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZWxmLmRheXNDb250YWluZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFRhcmdldC4kaSAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0ID09PSBzZWxmLmlucHV0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUYXJnZXQgPT09IHNlbGYuYWx0SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciAtIGRlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkRheShnZXRGaXJzdEF2YWlsYWJsZURheSgxKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1RpbWVPYmopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzT25EYXkodW5kZWZpbmVkLCBkZWx0YSAqIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUYXJnZXQgPT09IHNlbGYuY3VycmVudFllYXJFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlWWVhcihzZWxmLmN1cnJlbnRZZWFyIC0gZGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZi5jb25maWcuZW5hYmxlVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lT2JqICYmIHNlbGYuaG91ckVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUaW1lKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYm91bmNlZENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1RpbWVPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubWludXRlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWNvbmRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFtUE0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYucGx1Z2luRWxlbWVudHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gZWxlbXMuaW5kZXhPZihldmVudFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbGVtc1tpICsgKGUuc2hpZnRLZXkgPyAtMSA6IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0IHx8IHNlbGYuX2lucHV0KS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxmLmNvbmZpZy5ub0NhbGVuZGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5kYXlzQ29udGFpbmVyLmNvbnRhaW5zKGV2ZW50VGFyZ2V0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBldmVudFRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzBdLmNoYXJBdCgwKTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBzZWxmLmwxMG4uYW1QTVswXS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9IHNlbGYubDEwbi5hbVBNWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tSW5wdXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2VsZi5sMTBuLmFtUE1bMV0uY2hhckF0KDApOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIHNlbGYubDEwbi5hbVBNWzFdLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID0gc2VsZi5sMTBuLmFtUE1bMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbnB1dCB8fCBpc0NhbGVuZGFyRWxlbShldmVudFRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbktleURvd25cIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Nb3VzZU92ZXIoZWxlbSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggIT09IDEgfHxcbiAgICAgICAgICAgICAgICAoZWxlbSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRheVwiKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGlzYWJsZWRcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG92ZXJEYXRlID0gZWxlbVxuICAgICAgICAgICAgICAgID8gZWxlbS5kYXRlT2JqLmdldFRpbWUoKVxuICAgICAgICAgICAgICAgIDogc2VsZi5kYXlzLmZpcnN0RWxlbWVudENoaWxkLmRhdGVPYmouZ2V0VGltZSgpLCBpbml0aWFsRGF0ZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgdW5kZWZpbmVkLCB0cnVlKS5nZXRUaW1lKCksIHJhbmdlU3RhcnREYXRlID0gTWF0aC5taW4oaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKSwgcmFuZ2VFbmREYXRlID0gTWF0aC5tYXgoaG92ZXJEYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0uZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHZhciBjb250YWluc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWluUmFuZ2UgPSAwLCBtYXhSYW5nZSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gcmFuZ2VTdGFydERhdGU7IHQgPCByYW5nZUVuZERhdGU7IHQgKz0gZHVyYXRpb24uREFZKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VuYWJsZWQobmV3IERhdGUodCksIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zRGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnNEaXNhYmxlZCB8fCAodCA+IHJhbmdlU3RhcnREYXRlICYmIHQgPCByYW5nZUVuZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodCA8IGluaXRpYWxEYXRlICYmICghbWluUmFuZ2UgfHwgdCA+IG1pblJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblJhbmdlID0gdDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodCA+IGluaXRpYWxEYXRlICYmICghbWF4UmFuZ2UgfHwgdCA8IG1heFJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFJhbmdlID0gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IHNlbGYuY29uZmlnLnNob3dNb250aHM7IG0rKykge1xuICAgICAgICAgICAgICAgIHZhciBtb250aCA9IHNlbGYuZGF5c0NvbnRhaW5lci5jaGlsZHJlblttXTtcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpLCBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXlFbGVtID0gbW9udGguY2hpbGRyZW5baV0sIGRhdGUgPSBkYXlFbGVtLmRhdGVPYmo7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dE9mUmFuZ2UgPSAobWluUmFuZ2UgPiAwICYmIHRpbWVzdGFtcCA8IG1pblJhbmdlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG1heFJhbmdlID4gMCAmJiB0aW1lc3RhbXAgPiBtYXhSYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRPZlJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJub3RBbGxvd2VkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgW1wiaW5SYW5nZVwiLCBcInN0YXJ0UmFuZ2VcIiwgXCJlbmRSYW5nZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zRGlzYWJsZWQgJiYgIW91dE9mUmFuZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICBbXCJzdGFydFJhbmdlXCIsIFwiaW5SYW5nZVwiLCBcImVuZFJhbmdlXCIsIFwibm90QWxsb3dlZFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5yZW1vdmUoYyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoaG92ZXJEYXRlIDw9IHNlbGYuc2VsZWN0ZWREYXRlc1swXS5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwic3RhcnRSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcImVuZFJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluaXRpYWxEYXRlIDwgaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwic3RhcnRSYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluaXRpYWxEYXRlID4gaG92ZXJEYXRlICYmIHRpbWVzdGFtcCA9PT0gaW5pdGlhbERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWxlbS5jbGFzc0xpc3QuYWRkKFwiZW5kUmFuZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXN0YW1wID49IG1pblJhbmdlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1heFJhbmdlID09PSAwIHx8IHRpbWVzdGFtcCA8PSBtYXhSYW5nZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0JldHdlZW4odGltZXN0YW1wLCBpbml0aWFsRGF0ZSwgaG92ZXJEYXRlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXlFbGVtLmNsYXNzTGlzdC5hZGQoXCJpblJhbmdlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1vbnRoLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKGksIGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzT3BlbiAmJiAhc2VsZi5jb25maWcuc3RhdGljICYmICFzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcigpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9wZW4oZSwgcG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25FbGVtZW50ID09PSB2b2lkIDApIHsgcG9zaXRpb25FbGVtZW50ID0gc2VsZi5fcG9zaXRpb25FbGVtZW50OyB9XG4gICAgICAgICAgICBpZiAoc2VsZi5pc01vYmlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0ICYmIGV2ZW50VGFyZ2V0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW9iaWxlSW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25PcGVuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLl9pbnB1dC5kaXNhYmxlZCB8fCBzZWxmLmNvbmZpZy5pbmxpbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHdhc09wZW4gPSBzZWxmLmlzT3BlbjtcbiAgICAgICAgICAgIHNlbGYuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghd2FzT3Blbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm9wZW5cIik7XG4gICAgICAgICAgICAgICAgc2VsZi5faW5wdXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk9wZW5cIik7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25DYWxlbmRhcihwb3NpdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmVuYWJsZVRpbWUgPT09IHRydWUgJiYgc2VsZi5jb25maWcubm9DYWxlbmRhciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5hbGxvd0lucHV0ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAoZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2VsZi50aW1lQ29udGFpbmVyLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5ob3VyRWxlbWVudC5zZWxlY3QoKTsgfSwgNTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW5NYXhEYXRlU2V0dGVyKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlT2JqID0gKHNlbGYuY29uZmlnW1wiX1wiICsgdHlwZSArIFwiRGF0ZVwiXSA9IHNlbGYucGFyc2VEYXRlKGRhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpKTtcbiAgICAgICAgICAgICAgICB2YXIgaW52ZXJzZURhdGVPYmogPSBzZWxmLmNvbmZpZ1tcIl9cIiArICh0eXBlID09PSBcIm1pblwiID8gXCJtYXhcIiA6IFwibWluXCIpICsgXCJEYXRlXCJdO1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZlt0eXBlID09PSBcIm1pblwiID8gXCJtaW5EYXRlSGFzVGltZVwiIDogXCJtYXhEYXRlSGFzVGltZVwiXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlT2JqLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRNaW51dGVzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU9iai5nZXRTZWNvbmRzKCkgPiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IHNlbGYuc2VsZWN0ZWREYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGlzRW5hYmxlZChkKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCAmJiB0eXBlID09PSBcIm1pblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZShkYXRlT2JqKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuZGF5c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZWRyYXcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGVPYmogIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50W3R5cGVdID0gZGF0ZU9iai5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudFllYXJFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhckVsZW1lbnQuZGlzYWJsZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgISFpbnZlcnNlRGF0ZU9iaiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVPYmogIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVyc2VEYXRlT2JqLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVPYmouZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQ29uZmlnKCkge1xuICAgICAgICAgICAgdmFyIGJvb2xPcHRzID0gW1xuICAgICAgICAgICAgICAgIFwid3JhcFwiLFxuICAgICAgICAgICAgICAgIFwid2Vla051bWJlcnNcIixcbiAgICAgICAgICAgICAgICBcImFsbG93SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcImFsbG93SW52YWxpZFByZWxvYWRcIixcbiAgICAgICAgICAgICAgICBcImNsaWNrT3BlbnNcIixcbiAgICAgICAgICAgICAgICBcInRpbWVfMjRoclwiLFxuICAgICAgICAgICAgICAgIFwiZW5hYmxlVGltZVwiLFxuICAgICAgICAgICAgICAgIFwibm9DYWxlbmRhclwiLFxuICAgICAgICAgICAgICAgIFwiYWx0SW5wdXRcIixcbiAgICAgICAgICAgICAgICBcInNob3J0aGFuZEN1cnJlbnRNb250aFwiLFxuICAgICAgICAgICAgICAgIFwiaW5saW5lXCIsXG4gICAgICAgICAgICAgICAgXCJzdGF0aWNcIixcbiAgICAgICAgICAgICAgICBcImVuYWJsZVNlY29uZHNcIixcbiAgICAgICAgICAgICAgICBcImRpc2FibGVNb2JpbGVcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgdXNlckNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnQuZGF0YXNldCB8fCB7fSkpKSwgaW5zdGFuY2VDb25maWcpO1xuICAgICAgICAgICAgdmFyIGZvcm1hdHMgPSB7fTtcbiAgICAgICAgICAgIHNlbGYuY29uZmlnLnBhcnNlRGF0ZSA9IHVzZXJDb25maWcucGFyc2VEYXRlO1xuICAgICAgICAgICAgc2VsZi5jb25maWcuZm9ybWF0RGF0ZSA9IHVzZXJDb25maWcuZm9ybWF0RGF0ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJlbmFibGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX2VuYWJsZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5fZW5hYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJkaXNhYmxlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9kaXNhYmxlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLl9kaXNhYmxlID0gcGFyc2VEYXRlUnVsZXMoZGF0ZXMpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB0aW1lTW9kZSA9IHVzZXJDb25maWcubW9kZSA9PT0gXCJ0aW1lXCI7XG4gICAgICAgICAgICBpZiAoIXVzZXJDb25maWcuZGF0ZUZvcm1hdCAmJiAodXNlckNvbmZpZy5lbmFibGVUaW1lIHx8IHRpbWVNb2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0RGF0ZUZvcm1hdCA9IGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnLmRhdGVGb3JtYXQgfHwgZGVmYXVsdHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzLmRhdGVGb3JtYXQgPVxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLm5vQ2FsZW5kYXIgfHwgdGltZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJIOmlcIiArICh1c2VyQ29uZmlnLmVuYWJsZVNlY29uZHMgPyBcIjpTXCIgOiBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0RGF0ZUZvcm1hdCArIFwiIEg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuYWx0SW5wdXQgJiZcbiAgICAgICAgICAgICAgICAodXNlckNvbmZpZy5lbmFibGVUaW1lIHx8IHRpbWVNb2RlKSAmJlxuICAgICAgICAgICAgICAgICF1c2VyQ29uZmlnLmFsdEZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0QWx0Rm9ybWF0ID0gZmxhdHBpY2tyLmRlZmF1bHRDb25maWcuYWx0Rm9ybWF0IHx8IGRlZmF1bHRzLmFsdEZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzLmFsdEZvcm1hdCA9XG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcubm9DYWxlbmRhciB8fCB0aW1lTW9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcImg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlMgS1wiIDogXCIgS1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0QWx0Rm9ybWF0ICsgKFwiIGg6aVwiICsgKHVzZXJDb25maWcuZW5hYmxlU2Vjb25kcyA/IFwiOlNcIiA6IFwiXCIpICsgXCIgS1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLmNvbmZpZywgXCJtaW5EYXRlXCIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGYuY29uZmlnLl9taW5EYXRlOyB9LFxuICAgICAgICAgICAgICAgIHNldDogbWluTWF4RGF0ZVNldHRlcihcIm1pblwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1heERhdGVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21heERhdGU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhEYXRlU2V0dGVyKFwibWF4XCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWluTWF4VGltZVNldHRlciA9IGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbdHlwZSA9PT0gXCJtaW5cIiA/IFwiX21pblRpbWVcIiA6IFwiX21heFRpbWVcIl0gPSBzZWxmLnBhcnNlRGF0ZSh2YWwsIFwiSDppOlNcIik7XG4gICAgICAgICAgICB9OyB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYuY29uZmlnLCBcIm1pblRpbWVcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VsZi5jb25maWcuX21pblRpbWU7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBtaW5NYXhUaW1lU2V0dGVyKFwibWluXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi5jb25maWcsIFwibWF4VGltZVwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZWxmLmNvbmZpZy5fbWF4VGltZTsgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IG1pbk1heFRpbWVTZXR0ZXIoXCJtYXhcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLm1vZGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubm9DYWxlbmRhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZW5hYmxlVGltZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbGYuY29uZmlnLCBmb3JtYXRzLCB1c2VyQ29uZmlnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9vbE9wdHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTY2M1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2Jvb2xPcHRzW2ldXSA9PT0gdHJ1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWdbYm9vbE9wdHNbaV1dID09PSBcInRydWVcIjtcbiAgICAgICAgICAgIEhPT0tTLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gc2VsZi5jb25maWdbaG9va10gIT09IHVuZGVmaW5lZDsgfSkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2hvb2tdID0gYXJyYXlpZnkoc2VsZi5jb25maWdbaG9va10gfHwgW10pLm1hcChiaW5kVG9JbnN0YW5jZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuaXNNb2JpbGUgPVxuICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5kaXNhYmxlTW9iaWxlICYmXG4gICAgICAgICAgICAgICAgICAgICFzZWxmLmNvbmZpZy5pbmxpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSA9PT0gXCJzaW5nbGVcIiAmJlxuICAgICAgICAgICAgICAgICAgICAhc2VsZi5jb25maWcuZGlzYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLndlZWtOdW1iZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5jb25maWcucGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwbHVnaW5Db25mID0gc2VsZi5jb25maWcucGx1Z2luc1tpXShzZWxmKSB8fCB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGx1Z2luQ29uZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSE9PS1MuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnW2tleV0gPSBhcnJheWlmeShwbHVnaW5Db25mW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChiaW5kVG9JbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHNlbGYuY29uZmlnW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB1c2VyQ29uZmlnW2tleV0gPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1trZXldID0gcGx1Z2luQ29uZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXNlckNvbmZpZy5hbHRJbnB1dENsYXNzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuYWx0SW5wdXRDbGFzcyA9XG4gICAgICAgICAgICAgICAgICAgIGdldElucHV0RWxlbSgpLmNsYXNzTmFtZSArIFwiIFwiICsgc2VsZi5jb25maWcuYWx0SW5wdXRDbGFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUGFyc2VDb25maWdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0SW5wdXRFbGVtKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLndyYXBcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWlucHV0XVwiKVxuICAgICAgICAgICAgICAgIDogZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cExvY2FsZSgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZi5jb25maWcubG9jYWxlICE9PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGZsYXRwaWNrci5sMTBuc1tzZWxmLmNvbmZpZy5sb2NhbGVdID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLmVycm9ySGFuZGxlcihuZXcgRXJyb3IoXCJmbGF0cGlja3I6IGludmFsaWQgbG9jYWxlIFwiICsgc2VsZi5jb25maWcubG9jYWxlKSk7XG4gICAgICAgICAgICBzZWxmLmwxMG4gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZmxhdHBpY2tyLmwxMG5zLmRlZmF1bHQpLCAodHlwZW9mIHNlbGYuY29uZmlnLmxvY2FsZSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubG9jYWxlXG4gICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5sb2NhbGUgIT09IFwiZGVmYXVsdFwiXG4gICAgICAgICAgICAgICAgICAgID8gZmxhdHBpY2tyLmwxMG5zW3NlbGYuY29uZmlnLmxvY2FsZV1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIHRva2VuUmVnZXguSyA9IFwiKFwiICsgc2VsZi5sMTBuLmFtUE1bMF0gKyBcInxcIiArIHNlbGYubDEwbi5hbVBNWzFdICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVswXS50b0xvd2VyQ2FzZSgpICsgXCJ8XCIgKyBzZWxmLmwxMG4uYW1QTVsxXS50b0xvd2VyQ2FzZSgpICsgXCIpXCI7XG4gICAgICAgICAgICB2YXIgdXNlckNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbnN0YW5jZUNvbmZpZyksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZWxlbWVudC5kYXRhc2V0IHx8IHt9KSkpO1xuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcudGltZV8yNGhyID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZy50aW1lXzI0aHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLnRpbWVfMjRociA9IHNlbGYubDEwbi50aW1lXzI0aHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmZvcm1hdERhdGUgPSBjcmVhdGVEYXRlRm9ybWF0dGVyKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5wYXJzZURhdGUgPSBjcmVhdGVEYXRlUGFyc2VyKHsgY29uZmlnOiBzZWxmLmNvbmZpZywgbDEwbjogc2VsZi5sMTBuIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uQ2FsZW5kYXIoY3VzdG9tUG9zaXRpb25FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jYWxlbmRhckNvbnRhaW5lciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uUHJlQ2FsZW5kYXJQb3NpdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkVsZW1lbnQgPSBjdXN0b21Qb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5fcG9zaXRpb25FbGVtZW50O1xuICAgICAgICAgICAgdmFyIGNhbGVuZGFySGVpZ2h0ID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKHNlbGYuY2FsZW5kYXJDb250YWluZXIuY2hpbGRyZW4sIChmdW5jdGlvbiAoYWNjLCBjaGlsZCkgeyByZXR1cm4gYWNjICsgY2hpbGQub2Zmc2V0SGVpZ2h0OyB9KSwgMCksIGNhbGVuZGFyV2lkdGggPSBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLm9mZnNldFdpZHRoLCBjb25maWdQb3MgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbi5zcGxpdChcIiBcIiksIGNvbmZpZ1Bvc1ZlcnRpY2FsID0gY29uZmlnUG9zWzBdLCBjb25maWdQb3NIb3Jpem9udGFsID0gY29uZmlnUG9zLmxlbmd0aCA+IDEgPyBjb25maWdQb3NbMV0gOiBudWxsLCBpbnB1dEJvdW5kcyA9IHBvc2l0aW9uRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZGlzdGFuY2VGcm9tQm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0IC0gaW5wdXRCb3VuZHMuYm90dG9tLCBzaG93T25Ub3AgPSBjb25maWdQb3NWZXJ0aWNhbCA9PT0gXCJhYm92ZVwiIHx8XG4gICAgICAgICAgICAgICAgKGNvbmZpZ1Bvc1ZlcnRpY2FsICE9PSBcImJlbG93XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VGcm9tQm90dG9tIDwgY2FsZW5kYXJIZWlnaHQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wID4gY2FsZW5kYXJIZWlnaHQpO1xuICAgICAgICAgICAgdmFyIHRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCArXG4gICAgICAgICAgICAgICAgaW5wdXRCb3VuZHMudG9wICtcbiAgICAgICAgICAgICAgICAoIXNob3dPblRvcCA/IHBvc2l0aW9uRWxlbWVudC5vZmZzZXRIZWlnaHQgKyAyIDogLWNhbGVuZGFySGVpZ2h0IC0gMik7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImFycm93VG9wXCIsICFzaG93T25Ub3ApO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd0JvdHRvbVwiLCBzaG93T25Ub3ApO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmlubGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHdpbmRvdy5wYWdlWE9mZnNldCArIGlucHV0Qm91bmRzLmxlZnQ7XG4gICAgICAgICAgICB2YXIgaXNDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29uZmlnUG9zSG9yaXpvbnRhbCA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgICAgIGxlZnQgLT0gKGNhbGVuZGFyV2lkdGggLSBpbnB1dEJvdW5kcy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgICAgIGlzQ2VudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZ1Bvc0hvcml6b250YWwgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIGxlZnQgLT0gY2FsZW5kYXJXaWR0aCAtIGlucHV0Qm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIGlzUmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd0xlZnRcIiwgIWlzQ2VudGVyICYmICFpc1JpZ2h0KTtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwiYXJyb3dDZW50ZXJcIiwgaXNDZW50ZXIpO1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3Moc2VsZi5jYWxlbmRhckNvbnRhaW5lciwgXCJhcnJvd1JpZ2h0XCIsIGlzUmlnaHQpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggLVxuICAgICAgICAgICAgICAgICh3aW5kb3cucGFnZVhPZmZzZXQgKyBpbnB1dEJvdW5kcy5yaWdodCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRNb3N0ID0gbGVmdCArIGNhbGVuZGFyV2lkdGggPiB3aW5kb3cuZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBjZW50ZXJNb3N0ID0gcmlnaHQgKyBjYWxlbmRhcldpZHRoID4gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcInJpZ2h0TW9zdFwiLCByaWdodE1vc3QpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLnN0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgICAgIGlmICghcmlnaHRNb3N0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghY2VudGVyTW9zdCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUubGVmdCA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsZW5kYXJDb250YWluZXIuc3R5bGUucmlnaHQgPSByaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkb2MgPSBnZXREb2N1bWVudFN0eWxlU2hlZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBzb21lIHRlc3RpbmcgZW52aXJvbm1lbnRzIGRvbid0IGhhdmUgY3NzIHN1cHBvcnRcbiAgICAgICAgICAgICAgICBpZiAoZG9jID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgYm9keVdpZHRoID0gd2luZG93LmRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlckxlZnQgPSBNYXRoLm1heCgwLCBib2R5V2lkdGggLyAyIC0gY2FsZW5kYXJXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJCZWZvcmUgPSBcIi5mbGF0cGlja3ItY2FsZW5kYXIuY2VudGVyTW9zdDpiZWZvcmVcIjtcbiAgICAgICAgICAgICAgICB2YXIgY2VudGVyQWZ0ZXIgPSBcIi5mbGF0cGlja3ItY2FsZW5kYXIuY2VudGVyTW9zdDphZnRlclwiO1xuICAgICAgICAgICAgICAgIHZhciBjZW50ZXJJbmRleCA9IGRvYy5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGNlbnRlclN0eWxlID0gXCJ7bGVmdDpcIiArIGlucHV0Qm91bmRzLmxlZnQgKyBcInB4O3JpZ2h0OmF1dG87fVwiO1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHNlbGYuY2FsZW5kYXJDb250YWluZXIsIFwicmlnaHRNb3N0XCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhzZWxmLmNhbGVuZGFyQ29udGFpbmVyLCBcImNlbnRlck1vc3RcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZG9jLmluc2VydFJ1bGUoY2VudGVyQmVmb3JlICsgXCIsXCIgKyBjZW50ZXJBZnRlciArIGNlbnRlclN0eWxlLCBjZW50ZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxlbmRhckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gY2VudGVyTGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGVuZGFyQ29udGFpbmVyLnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0RG9jdW1lbnRTdHlsZVNoZWV0KCkge1xuICAgICAgICAgICAgdmFyIGVkaXRhYmxlU2hlZXQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBzaGVldCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNoZWV0LmNzc1J1bGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlZGl0YWJsZVNoZWV0ID0gc2hlZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZWRpdGFibGVTaGVldCAhPSBudWxsID8gZWRpdGFibGVTaGVldCA6IGNyZWF0ZVN0eWxlU2hlZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTdHlsZVNoZWV0KCkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm5vQ2FsZW5kYXIgfHwgc2VsZi5pc01vYmlsZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBidWlsZE1vbnRoU3dpdGNoKCk7XG4gICAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uQ3VycmVudE1vbnRoKCk7XG4gICAgICAgICAgICBidWlsZERheXMoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb2N1c0FuZENsb3NlKCkge1xuICAgICAgICAgICAgc2VsZi5faW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiTVNJRVwiKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFjayAtIGJ1Z3MgaW4gdGhlIHdheSBJRSBoYW5kbGVzIGZvY3VzIGtlZXBzIHRoZSBjYWxlbmRhciBvcGVuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChzZWxmLmNsb3NlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZWxlY3REYXRlKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RhYmxlID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXkuY2xhc3NMaXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGRheS5jbGFzc0xpc3QuY29udGFpbnMoXCJmbGF0cGlja3ItZGF5XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmxhdHBpY2tyLWRpc2FibGVkXCIpICYmXG4gICAgICAgICAgICAgICAgICAgICFkYXkuY2xhc3NMaXN0LmNvbnRhaW5zKFwibm90QWxsb3dlZFwiKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdCA9IGZpbmRQYXJlbnQoZ2V0RXZlbnRUYXJnZXQoZSksIGlzU2VsZWN0YWJsZSk7XG4gICAgICAgICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0ZSA9IChzZWxmLmxhdGVzdFNlbGVjdGVkRGF0ZU9iaiA9IG5ldyBEYXRlKHRhcmdldC5kYXRlT2JqLmdldFRpbWUoKSkpO1xuICAgICAgICAgICAgdmFyIHNob3VsZENoYW5nZU1vbnRoID0gKHNlbGVjdGVkRGF0ZS5nZXRNb250aCgpIDwgc2VsZi5jdXJyZW50TW9udGggfHxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKSA+XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY3VycmVudE1vbnRoICsgc2VsZi5jb25maWcuc2hvd01vbnRocyAtIDEpICYmXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiO1xuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVFbGVtID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIpXG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzID0gW3NlbGVjdGVkRGF0ZV07XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLmNvbmZpZy5tb2RlID09PSBcIm11bHRpcGxlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWRJbmRleCA9IGlzRGF0ZVNlbGVjdGVkKHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5zcGxpY2UocGFyc2VJbnQoc2VsZWN0ZWRJbmRleCksIDEpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2xlYXIoZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxlY3RlZERhdGU7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWxlY3RlZERhdGVzLnB1c2goc2VsZWN0ZWREYXRlKTtcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3Mgc2VsZWN0aW5nIHNhbWUgZGF0ZSB0d2ljZSwgc29ydCBhc2NlbmRpbmdseVxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlRGF0ZXMoc2VsZWN0ZWREYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMF0sIHRydWUpICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRIb3Vyc0Zyb21JbnB1dHMoKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDaGFuZ2VNb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBpc05ld1llYXIgPSBzZWxmLmN1cnJlbnRZZWFyICE9PSBzZWxlY3RlZERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBzZWxmLmN1cnJlbnRZZWFyID0gc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5jdXJyZW50TW9udGggPSBzZWxlY3RlZERhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOZXdZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uWWVhckNoYW5nZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRNb250aFN3aXRjaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvbk1vbnRoQ2hhbmdlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbkN1cnJlbnRNb250aCgpO1xuICAgICAgICAgICAgYnVpbGREYXlzKCk7XG4gICAgICAgICAgICB1cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgLy8gbWFpbnRhaW4gZm9jdXNcbiAgICAgICAgICAgIGlmICghc2hvdWxkQ2hhbmdlTW9udGggJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCIgJiZcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5zaG93TW9udGhzID09PSAxKVxuICAgICAgICAgICAgICAgIGZvY3VzT25EYXlFbGVtKHRhcmdldCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxmLnNlbGVjdGVkRGF0ZUVsZW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHNlbGYuaG91ckVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlRWxlbSAmJiBzZWxmLnNlbGVjdGVkRGF0ZUVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmhvdXJFbGVtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5ob3VyRWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIHNlbGYuaG91ckVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5jbG9zZU9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGYuY29uZmlnLm1vZGUgPT09IFwic2luZ2xlXCIgJiYgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZi5jb25maWcubW9kZSA9PT0gXCJyYW5nZVwiICYmXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgIXNlbGYuY29uZmlnLmVuYWJsZVRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZSB8fCByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0FuZENsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBDQUxMQkFDS1MgPSB7XG4gICAgICAgICAgICBsb2NhbGU6IFtzZXR1cExvY2FsZSwgdXBkYXRlV2Vla2RheXNdLFxuICAgICAgICAgICAgc2hvd01vbnRoczogW2J1aWxkTW9udGhzLCBzZXRDYWxlbmRhcldpZHRoLCBidWlsZFdlZWtkYXlzXSxcbiAgICAgICAgICAgIG1pbkRhdGU6IFtqdW1wVG9EYXRlXSxcbiAgICAgICAgICAgIG1heERhdGU6IFtqdW1wVG9EYXRlXSxcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gc2V0KG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24gIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VsZi5jb25maWcsIG9wdGlvbik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ0FMTEJBQ0tTW2tleV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIENBTExCQUNLU1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgoKTsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWdbb3B0aW9uXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChDQUxMQkFDS1Nbb3B0aW9uXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBDQUxMQkFDS1Nbb3B0aW9uXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4KCk7IH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEhPT0tTLmluZGV4T2Yob3B0aW9uKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZ1tvcHRpb25dID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5yZWRyYXcoKTtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkRGF0ZShpbnB1dERhdGUsIGZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgICAgICBpZiAoaW5wdXREYXRlIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGUubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBzZWxmLnBhcnNlRGF0ZShkLCBmb3JtYXQpOyB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0RGF0ZSBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlucHV0RGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5jb25maWcubW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IFtzZWxmLnBhcnNlRGF0ZShpbnB1dERhdGUsIGZvcm1hdCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZXMgPSBpbnB1dERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3BsaXQoc2VsZi5jb25maWcuY29uanVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJhbmdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlcyA9IGlucHV0RGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gc2VsZi5wYXJzZURhdGUoZGF0ZSwgZm9ybWF0KTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcuZXJyb3JIYW5kbGVyKG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBzdXBwbGllZDogXCIgKyBKU09OLnN0cmluZ2lmeShpbnB1dERhdGUpKSk7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMgPSAoc2VsZi5jb25maWcuYWxsb3dJbnZhbGlkUHJlbG9hZFxuICAgICAgICAgICAgICAgID8gZGF0ZXNcbiAgICAgICAgICAgICAgICA6IGRhdGVzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCBpbnN0YW5jZW9mIERhdGUgJiYgaXNFbmFibGVkKGQsIGZhbHNlKTsgfSkpO1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1vZGUgPT09IFwicmFuZ2VcIilcbiAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5nZXRUaW1lKCkgLSBiLmdldFRpbWUoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0RGF0ZShkYXRlLCB0cmlnZ2VyQ2hhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZSA9IGZhbHNlOyB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSB2b2lkIDApIHsgZm9ybWF0ID0gc2VsZi5jb25maWcuZGF0ZUZvcm1hdDsgfVxuICAgICAgICAgICAgaWYgKChkYXRlICE9PSAwICYmICFkYXRlKSB8fCAoZGF0ZSBpbnN0YW5jZW9mIEFycmF5ICYmIGRhdGUubGVuZ3RoID09PSAwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jbGVhcih0cmlnZ2VyQ2hhbmdlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShkYXRlLCBmb3JtYXQpO1xuICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlc1tzZWxmLnNlbGVjdGVkRGF0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBzZWxmLnJlZHJhdygpO1xuICAgICAgICAgICAganVtcFRvRGF0ZSh1bmRlZmluZWQsIHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgc2V0SG91cnNGcm9tRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNsZWFyKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHRyaWdnZXJDaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KFwib25DaGFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VEYXRlUnVsZXMoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBydWxlID09PSBcIm51bWJlclwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcnNlRGF0ZShydWxlLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydWxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBydWxlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuZnJvbSAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLnRvKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogc2VsZi5wYXJzZURhdGUocnVsZS5mcm9tLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHNlbGYucGFyc2VEYXRlKHJ1bGUudG8sIHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pOyAvLyByZW1vdmUgZmFsc3kgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBEYXRlcygpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcyA9IFtdO1xuICAgICAgICAgICAgc2VsZi5ub3cgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5ub3cpIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIElFMTEgc2V0dGluZyBwbGFjZWhvbGRlciBhcyB0aGUgaW5wdXQncyB2YWx1ZVxuICAgICAgICAgICAgdmFyIHByZWxvYWRlZERhdGUgPSBzZWxmLmNvbmZpZy5kZWZhdWx0RGF0ZSB8fFxuICAgICAgICAgICAgICAgICgoc2VsZi5pbnB1dC5ub2RlTmFtZSA9PT0gXCJJTlBVVFwiIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQubm9kZU5hbWUgPT09IFwiVEVYVEFSRUFcIikgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wbGFjZWhvbGRlciAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnZhbHVlID09PSBzZWxmLmlucHV0LnBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHNlbGYuaW5wdXQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZWxvYWRlZERhdGUpXG4gICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKHByZWxvYWRlZERhdGUsIHNlbGYuY29uZmlnLmRhdGVGb3JtYXQpO1xuICAgICAgICAgICAgc2VsZi5faW5pdGlhbERhdGUgPVxuICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgID8gc2VsZi5zZWxlY3RlZERhdGVzWzBdXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5jb25maWcubWluRGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWluRGF0ZS5nZXRUaW1lKCkgPiBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubWluRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmNvbmZpZy5tYXhEYXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRUaW1lKCkgPCBzZWxmLm5vdy5nZXRUaW1lKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLm1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYubm93O1xuICAgICAgICAgICAgc2VsZi5jdXJyZW50WWVhciA9IHNlbGYuX2luaXRpYWxEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICBzZWxmLmN1cnJlbnRNb250aCA9IHNlbGYuX2luaXRpYWxEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogPSBzZWxmLnNlbGVjdGVkRGF0ZXNbMF07XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubWluVGltZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pblRpbWUgPSBzZWxmLnBhcnNlRGF0ZShzZWxmLmNvbmZpZy5taW5UaW1lLCBcIkg6aVwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhUaW1lICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4VGltZSA9IHNlbGYucGFyc2VEYXRlKHNlbGYuY29uZmlnLm1heFRpbWUsIFwiSDppXCIpO1xuICAgICAgICAgICAgc2VsZi5taW5EYXRlSGFzVGltZSA9XG4gICAgICAgICAgICAgICAgISFzZWxmLmNvbmZpZy5taW5EYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmNvbmZpZy5taW5EYXRlLmdldEhvdXJzKCkgPiAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5taW5EYXRlLmdldE1pbnV0ZXMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0U2Vjb25kcygpID4gMCk7XG4gICAgICAgICAgICBzZWxmLm1heERhdGVIYXNUaW1lID1cbiAgICAgICAgICAgICAgICAhIXNlbGYuY29uZmlnLm1heERhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlbGYuY29uZmlnLm1heERhdGUuZ2V0SG91cnMoKSA+IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1heERhdGUuZ2V0TWludXRlcygpID4gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZS5nZXRTZWNvbmRzKCkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXR1cElucHV0cygpIHtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQgPSBnZXRJbnB1dEVsZW0oKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoIXNlbGYuaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lcnJvckhhbmRsZXIobmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBlbGVtZW50IHNwZWNpZmllZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFjazogc3RvcmUgcHJldmlvdXMgdHlwZSB0byByZXN0b3JlIGl0IGFmdGVyIGRlc3Ryb3koKVxuICAgICAgICAgICAgc2VsZi5pbnB1dC5fdHlwZSA9IHNlbGYuaW5wdXQudHlwZTtcbiAgICAgICAgICAgIHNlbGYuaW5wdXQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC5jbGFzc0xpc3QuYWRkKFwiZmxhdHBpY2tyLWlucHV0XCIpO1xuICAgICAgICAgICAgc2VsZi5faW5wdXQgPSBzZWxmLmlucHV0O1xuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLmFsdElucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGljYXRlIHNlbGYuZWxlbWVudFxuICAgICAgICAgICAgICAgIHNlbGYuYWx0SW5wdXQgPSBjcmVhdGVFbGVtZW50KHNlbGYuaW5wdXQubm9kZU5hbWUsIHNlbGYuY29uZmlnLmFsdElucHV0Q2xhc3MpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0ID0gc2VsZi5hbHRJbnB1dDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnBsYWNlaG9sZGVyID0gc2VsZi5pbnB1dC5wbGFjZWhvbGRlcjtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnJlcXVpcmVkID0gc2VsZi5pbnB1dC5yZXF1aXJlZDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnRhYkluZGV4ID0gc2VsZi5pbnB1dC50YWJJbmRleDtcbiAgICAgICAgICAgICAgICBzZWxmLmFsdElucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5zdGF0aWMgJiYgc2VsZi5pbnB1dC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuYWx0SW5wdXQsIHNlbGYuaW5wdXQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxmLmNvbmZpZy5hbGxvd0lucHV0KVxuICAgICAgICAgICAgICAgIHNlbGYuX2lucHV0LnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICBzZWxmLl9wb3NpdGlvbkVsZW1lbnQgPSBzZWxmLmNvbmZpZy5wb3NpdGlvbkVsZW1lbnQgfHwgc2VsZi5faW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0dXBNb2JpbGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRUeXBlID0gc2VsZi5jb25maWcuZW5hYmxlVGltZVxuICAgICAgICAgICAgICAgID8gc2VsZi5jb25maWcubm9DYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICA/IFwidGltZVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJkYXRldGltZS1sb2NhbFwiXG4gICAgICAgICAgICAgICAgOiBcImRhdGVcIjtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQgPSBjcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgc2VsZi5pbnB1dC5jbGFzc05hbWUgKyBcIiBmbGF0cGlja3ItbW9iaWxlXCIpO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC50YWJJbmRleCA9IDE7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnR5cGUgPSBpbnB1dFR5cGU7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LmRpc2FibGVkID0gc2VsZi5pbnB1dC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQucmVxdWlyZWQgPSBzZWxmLmlucHV0LnJlcXVpcmVkO1xuICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5wbGFjZWhvbGRlciA9IHNlbGYuaW5wdXQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgICBzZWxmLm1vYmlsZUZvcm1hdFN0ciA9XG4gICAgICAgICAgICAgICAgaW5wdXRUeXBlID09PSBcImRhdGV0aW1lLWxvY2FsXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXFxcXFRIOmk6U1wiXG4gICAgICAgICAgICAgICAgICAgIDogaW5wdXRUeXBlID09PSBcImRhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlktbS1kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJIOmk6U1wiO1xuICAgICAgICAgICAgaWYgKHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5kZWZhdWx0VmFsdWUgPSBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuc2VsZWN0ZWREYXRlc1swXSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnLm1pbkRhdGUpXG4gICAgICAgICAgICAgICAgc2VsZi5tb2JpbGVJbnB1dC5taW4gPSBzZWxmLmZvcm1hdERhdGUoc2VsZi5jb25maWcubWluRGF0ZSwgXCJZLW0tZFwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5tYXhEYXRlKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQubWF4ID0gc2VsZi5mb3JtYXREYXRlKHNlbGYuY29uZmlnLm1heERhdGUsIFwiWS1tLWRcIik7XG4gICAgICAgICAgICBpZiAoc2VsZi5pbnB1dC5nZXRBdHRyaWJ1dGUoXCJzdGVwXCIpKVxuICAgICAgICAgICAgICAgIHNlbGYubW9iaWxlSW5wdXQuc3RlcCA9IFN0cmluZyhzZWxmLmlucHV0LmdldEF0dHJpYnV0ZShcInN0ZXBcIikpO1xuICAgICAgICAgICAgc2VsZi5pbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdElucHV0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5wdXQucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbnB1dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLm1vYmlsZUlucHV0LCBzZWxmLmlucHV0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICBiaW5kKHNlbGYubW9iaWxlSW5wdXQsIFwiY2hhbmdlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXREYXRlKGdldEV2ZW50VGFyZ2V0KGUpLnZhbHVlLCBmYWxzZSwgc2VsZi5tb2JpbGVGb3JtYXRTdHIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2hhbmdlXCIpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudChcIm9uQ2xvc2VcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNPcGVuID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICBzZWxmLm9wZW4oZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHksIGFsbCBob29rcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZmlnID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gc2VsZi5jb25maWdbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGhvb2tzICE9PSB1bmRlZmluZWQgJiYgaG9va3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBob29rc1tpXSAmJiBpIDwgaG9va3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzW2ldKHNlbGYuc2VsZWN0ZWREYXRlcywgc2VsZi5pbnB1dC52YWx1ZSwgc2VsZiwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IFwib25DaGFuZ2VcIikge1xuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImNoYW5nZVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gbWFueSBmcm9udC1lbmQgZnJhbWV3b3JrcyBiaW5kIHRvIHRoZSBpbnB1dCBldmVudFxuICAgICAgICAgICAgICAgIHNlbGYuaW5wdXQuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChcImlucHV0XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVFdmVudChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgICAgICAgICBlLmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGVkKGRhdGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5zZWxlY3RlZERhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVEYXRlcyhzZWxmLnNlbGVjdGVkRGF0ZXNbaV0sIGRhdGUpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIiArIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNEYXRlSW5SYW5nZShkYXRlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubW9kZSAhPT0gXCJyYW5nZVwiIHx8IHNlbGYuc2VsZWN0ZWREYXRlcy5sZW5ndGggPCAyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAoY29tcGFyZURhdGVzKGRhdGUsIHNlbGYuc2VsZWN0ZWREYXRlc1swXSkgPj0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVEYXRlcyhkYXRlLCBzZWxmLnNlbGVjdGVkRGF0ZXNbMV0pIDw9IDApO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb25DdXJyZW50TW9udGgoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25maWcubm9DYWxlbmRhciB8fCBzZWxmLmlzTW9iaWxlIHx8ICFzZWxmLm1vbnRoTmF2KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbGYueWVhckVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHllYXJFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZShzZWxmLmN1cnJlbnRZZWFyLCBzZWxmLmN1cnJlbnRNb250aCwgMSk7XG4gICAgICAgICAgICAgICAgZC5zZXRNb250aChzZWxmLmN1cnJlbnRNb250aCArIGkpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbmZpZy5zaG93TW9udGhzID4gMSB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5tb250aFNlbGVjdG9yVHlwZSA9PT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm1vbnRoRWxlbWVudHNbaV0udGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbW9udGhUb1N0cihkLmdldE1vbnRoKCksIHNlbGYuY29uZmlnLnNob3J0aGFuZEN1cnJlbnRNb250aCwgc2VsZi5sMTBuKSArIFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb250aHNEcm9wZG93bkNvbnRhaW5lci52YWx1ZSA9IGQuZ2V0TW9udGgoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ZWFyRWxlbWVudC52YWx1ZSA9IGQuZ2V0RnVsbFllYXIoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLl9oaWRlUHJldk1vbnRoQXJyb3cgPVxuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnLm1pbkRhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VsZi5jdXJyZW50WWVhciA9PT0gc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNlbGYuY3VycmVudE1vbnRoIDw9IHNlbGYuY29uZmlnLm1pbkRhdGUuZ2V0TW9udGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZWxmLmN1cnJlbnRZZWFyIDwgc2VsZi5jb25maWcubWluRGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgICAgICAgICAgIHNlbGYuX2hpZGVOZXh0TW9udGhBcnJvdyA9XG4gICAgICAgICAgICAgICAgc2VsZi5jb25maWcubWF4RGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxmLmN1cnJlbnRZZWFyID09PSBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2VsZi5jdXJyZW50TW9udGggKyAxID4gc2VsZi5jb25maWcubWF4RGF0ZS5nZXRNb250aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNlbGYuY3VycmVudFllYXIgPiBzZWxmLmNvbmZpZy5tYXhEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldERhdGVTdHIoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5zZWxlY3RlZERhdGVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZE9iaikgeyByZXR1cm4gc2VsZi5mb3JtYXREYXRlKGRPYmosIGZvcm1hdCk7IH0pXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZCwgaSwgYXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuY29uZmlnLm1vZGUgIT09IFwicmFuZ2VcIiB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZy5lbmFibGVUaW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIGFyci5pbmRleE9mKGQpID09PSBpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihzZWxmLmNvbmZpZy5tb2RlICE9PSBcInJhbmdlXCJcbiAgICAgICAgICAgICAgICA/IHNlbGYuY29uZmlnLmNvbmp1bmN0aW9uXG4gICAgICAgICAgICAgICAgOiBzZWxmLmwxMG4ucmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZXMgb2YgaW5wdXRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsZW5kYXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlID09PSB2b2lkIDApIHsgdHJpZ2dlckNoYW5nZSA9IHRydWU7IH1cbiAgICAgICAgICAgIGlmIChzZWxmLm1vYmlsZUlucHV0ICE9PSB1bmRlZmluZWQgJiYgc2VsZi5tb2JpbGVGb3JtYXRTdHIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1vYmlsZUlucHV0LnZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmogIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxmLmZvcm1hdERhdGUoc2VsZi5sYXRlc3RTZWxlY3RlZERhdGVPYmosIHNlbGYubW9iaWxlRm9ybWF0U3RyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuZGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRJbnB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbHRJbnB1dC52YWx1ZSA9IGdldERhdGVTdHIoc2VsZi5jb25maWcuYWx0Rm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoXCJvblZhbHVlVXBkYXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uTW9udGhOYXZDbGljayhlKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChlKTtcbiAgICAgICAgICAgIHZhciBpc1ByZXZNb250aCA9IHNlbGYucHJldk1vbnRoTmF2LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIHZhciBpc05leHRNb250aCA9IHNlbGYubmV4dE1vbnRoTmF2LmNvbnRhaW5zKGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXZNb250aCB8fCBpc05leHRNb250aCkge1xuICAgICAgICAgICAgICAgIGNoYW5nZU1vbnRoKGlzUHJldk1vbnRoID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlbGYueWVhckVsZW1lbnRzLmluZGV4T2YoZXZlbnRUYXJnZXQpID49IDApIHtcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcImFycm93VXBcIikpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNoYW5nZVllYXIoc2VsZi5jdXJyZW50WWVhciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYXJyb3dEb3duXCIpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaGFuZ2VZZWFyKHNlbGYuY3VycmVudFllYXIgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lV3JhcHBlcihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgaXNLZXlEb3duID0gZS50eXBlID09PSBcImtleWRvd25cIiwgZXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChlKSwgaW5wdXQgPSBldmVudFRhcmdldDtcbiAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gIT09IHVuZGVmaW5lZCAmJiBldmVudFRhcmdldCA9PT0gc2VsZi5hbVBNKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hbVBNLnRleHRDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5sMTBuLmFtUE1baW50KHNlbGYuYW1QTS50ZXh0Q29udGVudCA9PT0gc2VsZi5sMTBuLmFtUE1bMF0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW4gPSBwYXJzZUZsb2F0KGlucHV0LmdldEF0dHJpYnV0ZShcIm1pblwiKSksIG1heCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwibWF4XCIpKSwgc3RlcCA9IHBhcnNlRmxvYXQoaW5wdXQuZ2V0QXR0cmlidXRlKFwic3RlcFwiKSksIGN1clZhbHVlID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKSwgZGVsdGEgPSBlLmRlbHRhIHx8XG4gICAgICAgICAgICAgICAgKGlzS2V5RG93biA/IChlLndoaWNoID09PSAzOCA/IDEgOiAtMSkgOiAwKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1clZhbHVlICsgc3RlcCAqIGRlbHRhO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dC52YWx1ZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNIb3VyRWxlbSA9IGlucHV0ID09PSBzZWxmLmhvdXJFbGVtZW50LCBpc01pbnV0ZUVsZW0gPSBpbnB1dCA9PT0gc2VsZi5taW51dGVFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQoIWlzSG91ckVsZW0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW50KGlzSG91ckVsZW0pICYmIGludCghc2VsZi5hbVBNKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01pbnV0ZUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnROdW1JbnB1dCh1bmRlZmluZWQsIC0xLCBzZWxmLmhvdXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQgPT09IHNlbGYuaG91ckVsZW1lbnQgPyBuZXdWYWx1ZSAtIG1heCAtIGludCghc2VsZi5hbVBNKSA6IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWludXRlRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlbWVudE51bUlucHV0KHVuZGVmaW5lZCwgMSwgc2VsZi5ob3VyRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmFtUE0gJiZcbiAgICAgICAgICAgICAgICAgICAgaXNIb3VyRWxlbSAmJlxuICAgICAgICAgICAgICAgICAgICAoc3RlcCA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZSArIGN1clZhbHVlID09PSAyM1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLmFicyhuZXdWYWx1ZSAtIGN1clZhbHVlKSA+IHN0ZXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYW1QTS50ZXh0Q29udGVudCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmwxMG4uYW1QTVtpbnQoc2VsZi5hbVBNLnRleHRDb250ZW50ID09PSBzZWxmLmwxMG4uYW1QTVswXSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHBhZChuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdCgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBfZmxhdHBpY2tyKG5vZGVMaXN0LCBjb25maWcpIHtcbiAgICAgICAgLy8gc3RhdGljIGxpc3RcbiAgICAgICAgdmFyIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAgICAgICAuY2FsbChub2RlTGlzdClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudDsgfSk7XG4gICAgICAgIHZhciBpbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKFwiZGF0YS1mcC1vbWl0XCIpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fZmxhdHBpY2tyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fZmxhdHBpY2tyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLl9mbGF0cGlja3IgPSBGbGF0cGlja3JJbnN0YW5jZShub2RlLCBjb25maWcgfHwge30pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlcy5wdXNoKG5vZGUuX2ZsYXRwaWNrcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcy5sZW5ndGggPT09IDEgPyBpbnN0YW5jZXNbMF0gOiBpbnN0YW5jZXM7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgSFRNTENvbGxlY3Rpb24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIE5vZGVMaXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIGJyb3dzZXIgZW52XG4gICAgICAgIEhUTUxDb2xsZWN0aW9uLnByb3RvdHlwZS5mbGF0cGlja3IgPSBOb2RlTGlzdC5wcm90b3R5cGUuZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmZsYXRwaWNrciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKFt0aGlzXSwgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB2YXIgZmxhdHBpY2tyID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBjb25maWcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3Iod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IoW3NlbGVjdG9yXSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfZmxhdHBpY2tyKHNlbGVjdG9yLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZsYXRwaWNrci5kZWZhdWx0Q29uZmlnID0ge307XG4gICAgZmxhdHBpY2tyLmwxMG5zID0ge1xuICAgICAgICBlbjogX19hc3NpZ24oe30sIGVuZ2xpc2gpLFxuICAgICAgICBkZWZhdWx0OiBfX2Fzc2lnbih7fSwgZW5nbGlzaCksXG4gICAgfTtcbiAgICBmbGF0cGlja3IubG9jYWxpemUgPSBmdW5jdGlvbiAobDEwbikge1xuICAgICAgICBmbGF0cGlja3IubDEwbnMuZGVmYXVsdCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbGF0cGlja3IubDEwbnMuZGVmYXVsdCksIGwxMG4pO1xuICAgIH07XG4gICAgZmxhdHBpY2tyLnNldERlZmF1bHRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBmbGF0cGlja3IuZGVmYXVsdENvbmZpZyksIGNvbmZpZyk7XG4gICAgfTtcbiAgICBmbGF0cGlja3IucGFyc2VEYXRlID0gY3JlYXRlRGF0ZVBhcnNlcih7fSk7XG4gICAgZmxhdHBpY2tyLmZvcm1hdERhdGUgPSBjcmVhdGVEYXRlRm9ybWF0dGVyKHt9KTtcbiAgICBmbGF0cGlja3IuY29tcGFyZURhdGVzID0gY29tcGFyZURhdGVzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGpRdWVyeS5mbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBqUXVlcnkuZm4uZmxhdHBpY2tyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF9mbGF0cGlja3IodGhpcywgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9jYW1lbGNhc2VcbiAgICBEYXRlLnByb3RvdHlwZS5mcF9pbmNyID0gZnVuY3Rpb24gKGRheXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMuZ2V0RnVsbFllYXIoKSwgdGhpcy5nZXRNb250aCgpLCB0aGlzLmdldERhdGUoKSArICh0eXBlb2YgZGF5cyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSW50KGRheXMsIDEwKSA6IGRheXMpKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHdpbmRvdy5mbGF0cGlja3IgPSBmbGF0cGlja3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZsYXRwaWNrcjtcblxufSkpKTtcbiIsIi8qXHJcbiAqIEpTUyB2MC42IC0gSmF2YVNjcmlwdCBTdHlsZXNoZWV0c1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQm94OS9qc3NcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDExLCBEYXZpZCBUYW5nXHJcbiAqIE1JVCBMaWNlbnNlZCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXHJcbiAqL1xyXG52YXIganNzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGFkalNlbEF0dHJSZWdleCA9IC8oKD86XFwufCMpW15cXC5cXHMjXSspKCg/OlxcLnwjKVteXFwuXFxzI10rKS9nO1xyXG4gICAgdmFyIGRvdWJsZUNvbG9uUHNldWRvRWxSZWdleCA9IC8oOjopKGJlZm9yZXxhZnRlcnxmaXJzdC1saW5lfGZpcnN0LWxldHRlcnxzZWxlY3Rpb24pLztcclxuICAgIHZhciBzaW5nbGVDb2xvblBzZXVkb0VsUmVnZXggPSAvKFteOl0pKDopKGJlZm9yZXxhZnRlcnxmaXJzdC1saW5lfGZpcnN0LWxldHRlcnxzZWxlY3Rpb24pLztcclxuICAgIHZhciBzaW5nbGVDb2xvbkZvclBzZXVkb0VsZW1lbnRzOyAvLyBmbGFnIGZvciBvbGRlciBicm93c2Vyc1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNlbGVjdG9yc0FuZFJ1bGVzKHNoZWV0KSB7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gc2hlZXQuY3NzUnVsZXMgfHwgc2hlZXQucnVsZXMgfHwgW107XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIGFuZCBGRiByZXBvcnQgcHNldWRvIGVsZW1lbnQgc2VsZWN0b3JzIGluIGFuIG91dGRhdGVkIGZvcm1hdFxyXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3JUZXh0ID0gdG9Eb3VibGVDb2xvblBzZXVkb0VsZW1lbnRzKHJ1bGVzW2ldLnNlbGVjdG9yVGV4dCk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0c1tzZWxlY3RvclRleHRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzW3NlbGVjdG9yVGV4dF0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRzW3NlbGVjdG9yVGV4dF0ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzaGVldDogc2hlZXQsXHJcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiBydWxlc1tpXS5zdHlsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UnVsZXMoc2hlZXQsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gc2hlZXQuY3NzUnVsZXMgfHwgc2hlZXQucnVsZXMgfHwgW107XHJcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgICAgICAvLyBCcm93c2VycyByZXBvcnQgc2VsZWN0b3JzIGluIGxvd2VyY2FzZVxyXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWxlY3RvclRleHQgPSBydWxlc1tpXS5zZWxlY3RvclRleHQ7XHJcbiAgICAgICAgICAgIC8vIE5vdGUgLSBjZXJ0YWluIHJ1bGVzIChlLmcuIEBydWxlcykgZG9uJ3QgaGF2ZSBzZWxlY3RvclRleHRcclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yVGV4dCAmJiAoc2VsZWN0b3JUZXh0ID09IHNlbGVjdG9yIHx8IHNlbGVjdG9yVGV4dCA9PSBzd2FwQWRqU2VsQXR0cihzZWxlY3RvcikgfHwgc2VsZWN0b3JUZXh0ID09IHN3YXBQc2V1ZG9FbFN5bnRheChzZWxlY3RvcikpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0OiBzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogcnVsZXNbaV0uc3R5bGVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFJ1bGUoc2hlZXQsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgdmFyIHJ1bGVzID0gc2hlZXQuY3NzUnVsZXMgfHwgc2hlZXQucnVsZXMgfHwgW107XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcnVsZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwc2V1ZG9FbGVtZW50UnVsZSA9IGFkZFBzZXVkb0VsZW1lbnRSdWxlKHNoZWV0LCBzZWxlY3RvciwgcnVsZXMsIGluZGV4KTtcclxuXHJcbiAgICAgICAgaWYgKCFwc2V1ZG9FbGVtZW50UnVsZSkge1xyXG4gICAgICAgICAgICBhZGRSdWxlVG9TaGVldChzaGVldCwgc2VsZWN0b3IsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2hlZXQ6IHNoZWV0LFxyXG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgIHN0eWxlOiBydWxlc1tpbmRleF0uc3R5bGVcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGRSdWxlVG9TaGVldChzaGVldCwgc2VsZWN0b3IsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKHNoZWV0Lmluc2VydFJ1bGUpIHtcclxuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzZWxlY3RvciArICcgeyB9JywgaW5kZXgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIG51bGwsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlcyBzaW5nbGUgY29sb24gc3ludGF4IGZvciBvbGRlciBicm93c2VycyBhbmQgYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTk0OTY1MVxyXG4gICAgZnVuY3Rpb24gYWRkUHNldWRvRWxlbWVudFJ1bGUoc2hlZXQsIHNlbGVjdG9yLCBydWxlcywgaW5kZXgpIHtcclxuICAgICAgICB2YXIgZG91YmxlQ29sb25TZWxlY3RvcjtcclxuICAgICAgICB2YXIgc2luZ2xlQ29sb25TZWxlY3RvcjtcclxuXHJcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uUHNldWRvRWxSZWdleC5leGVjKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICBkb3VibGVDb2xvblNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgICAgIHNpbmdsZUNvbG9uU2VsZWN0b3IgPSB0b1NpbmdsZUNvbG9uUHNldWRvRWxlbWVudHMoc2VsZWN0b3IpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2luZ2xlQ29sb25Qc2V1ZG9FbFJlZ2V4LmV4ZWMoc2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIGRvdWJsZUNvbG9uU2VsZWN0b3IgPSB0b0RvdWJsZUNvbG9uUHNldWRvRWxlbWVudHMoc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBzaW5nbGVDb2xvblNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBOb3QgZGVhbGluZyB3aXRoIGEgcHNldWRvIGVsZW1lbnRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghc2luZ2xlQ29sb25Gb3JQc2V1ZG9FbGVtZW50cykge1xyXG4gICAgICAgICAgICAvLyBBc3N1bWUgbW9kZXJuIGJyb3dzZXIgYW5kIHRoZW4gY2hlY2sgaWYgc3VjY2Vzc2Z1bFxyXG4gICAgICAgICAgICBhZGRSdWxlVG9TaGVldChzaGVldCwgZG91YmxlQ29sb25TZWxlY3RvciwgaW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAocnVsZXMubGVuZ3RoIDw9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzaW5nbGVDb2xvbkZvclBzZXVkb0VsZW1lbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2luZ2xlQ29sb25Gb3JQc2V1ZG9FbGVtZW50cykge1xyXG4gICAgICAgICAgICBhZGRSdWxlVG9TaGVldChzaGVldCwgc2luZ2xlQ29sb25TZWxlY3RvciwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9Eb3VibGVDb2xvblBzZXVkb0VsZW1lbnRzKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2Uoc2luZ2xlQ29sb25Qc2V1ZG9FbFJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIHN1Ym1hdGNoMSwgc3VibWF0Y2gyLCBzdWJtYXRjaDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN1Ym1hdGNoMSArICc6OicgKyBzdWJtYXRjaDM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9TaW5nbGVDb2xvblBzZXVkb0VsZW1lbnRzKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLnJlcGxhY2UoZG91YmxlQ29sb25Qc2V1ZG9FbFJlZ2V4LCBmdW5jdGlvbihtYXRjaCwgc3VibWF0Y2gxLCBzdWJtYXRjaDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICc6JyArIHN1Ym1hdGNoMjtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZVJ1bGUocnVsZSkge1xyXG4gICAgICAgIHZhciBzaGVldCA9IHJ1bGUuc2hlZXQ7XHJcbiAgICAgICAgaWYgKHNoZWV0LmRlbGV0ZVJ1bGUpIHtcclxuICAgICAgICAgICAgc2hlZXQuZGVsZXRlUnVsZShydWxlLmluZGV4KTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNoZWV0LnJlbW92ZVJ1bGUpIHtcclxuICAgICAgICAgICAgc2hlZXQucmVtb3ZlUnVsZShydWxlLmluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzcmMpIHtcclxuICAgICAgICAgICAgaWYgKCFzcmMuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWdncmVnYXRlU3R5bGVzKHJ1bGVzKSB7XHJcbiAgICAgICAgdmFyIGFnZ3JlZ2F0ZSA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXh0ZW5kKGFnZ3JlZ2F0ZSwgZGVjbGFyZWRQcm9wZXJ0aWVzKHJ1bGVzW2ldLnN0eWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVjbGFyZWRQcm9wZXJ0aWVzKHN0eWxlKSB7XHJcbiAgICAgICAgdmFyIGRlY2xhcmVkID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZWNsYXJlZFtzdHlsZVtpXV0gPSBzdHlsZVt0b0NhbWVsQ2FzZShzdHlsZVtpXSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjbGFyZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSUU5IHN0b3JlcyBydWxlcyB3aXRoIGF0dHJpYnV0ZXMgKGNsYXNzZXMgb3IgSUQncykgYWRqYWNlbnQgaW4gdGhlIG9wcG9zaXRlIG9yZGVyIGFzIGRlZmluZWRcclxuICAgIC8vIGNhdXNpbmcgdGhlbSB0byBub3QgYmUgZm91bmQsIHNvIHRoaXMgbWV0aG9kIHN3YXBzIFsjfC5dc2VsMVsjfC5dc2VsMiB0byBiZWNvbWUgWyN8Ll1zZWwyWyN8Ll1zZWwxXHJcbiAgICBmdW5jdGlvbiBzd2FwQWRqU2VsQXR0cihzZWxlY3Rvcikge1xyXG4gICAgICAgIHZhciBzd2FwID0gJyc7XHJcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBhZGpTZWxBdHRyUmVnZXguZXhlYyhzZWxlY3RvcikpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzBdID09PSAnJylcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBzd2FwICs9IHNlbGVjdG9yLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KTtcclxuICAgICAgICAgICAgc3dhcCArPSBzZWxlY3Rvci5zdWJzdHIobWF0Y2guaW5kZXggKyBtYXRjaFsxXS5sZW5ndGgsIG1hdGNoWzJdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHN3YXAgKz0gc2VsZWN0b3Iuc3Vic3RyKG1hdGNoLmluZGV4LCBtYXRjaFsxXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dhcCArPSBzZWxlY3Rvci5zdWJzdHIobGFzdEluZGV4KTtcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc3dhcDtcclxuICAgIH07XHJcblxyXG4gICAgLy8gRkYgYW5kIG9sZGVyIGJyb3dzZXJzIHN0b3JlIHJ1bGVzIHdpdGggcHNldWRvIGVsZW1lbnRzIHVzaW5nIHNpbmdsZS1jb2xvbiBzeW50YXhcclxuICAgIGZ1bmN0aW9uIHN3YXBQc2V1ZG9FbFN5bnRheChzZWxlY3Rvcikge1xyXG4gICAgICAgIGlmIChkb3VibGVDb2xvblBzZXVkb0VsUmVnZXguZXhlYyhzZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvU2luZ2xlQ29sb25Qc2V1ZG9FbGVtZW50cyhzZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTdHlsZVByb3BlcnRpZXMocnVsZSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNba2V5XTtcclxuICAgICAgICAgICAgdmFyIGltcG9ydGFudEluZGV4ID0gdmFsdWUuaW5kZXhPZignICFpbXBvcnRhbnQnKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1vZGVybiBicm93c2VycyBzZWVtIHRvIGhhbmRsZSBvdmVycmlkZXMgZmluZSwgYnV0IElFOSBkb2Vzbid0XHJcbiAgICAgICAgICAgIHJ1bGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTsgXHJcbiAgICAgICAgICAgIGlmIChpbXBvcnRhbnRJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJ1bGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZS5zdWJzdHIoMCwgaW1wb3J0YW50SW5kZXgpLCAnaW1wb3J0YW50Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBydWxlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvQ2FtZWxDYXNlKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24gKG1hdGNoLCBzdWJtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VibWF0Y2gudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1DYW1lbENhc2VkUHJvcGVydHlOYW1lcyhvbGRQcm9wcykge1xyXG4gICAgICAgIHZhciBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBuZXdQcm9wc1t1bkNhbWVsQ2FzZShrZXkpXSA9IG9sZFByb3BzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdQcm9wcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bkNhbWVsQ2FzZShzdHIpIHtcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24obWF0Y2gsIHN1Ym1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyBzdWJtYXRjaC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBKc3MgPSBmdW5jdGlvbihkb2MpIHtcclxuICAgICAgICB0aGlzLmRvYyA9IGRvYztcclxuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmRvYy5oZWFkIHx8IHRoaXMuZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XHJcbiAgICAgICAgdGhpcy5zaGVldHMgPSB0aGlzLmRvYy5zdHlsZVNoZWV0cyB8fCBbXTtcclxuICAgIH07XHJcblxyXG4gICAgSnNzLnByb3RvdHlwZSA9IHtcclxuICAgICAgICAvLyBSZXR1cm5zIEpTUyBydWxlcyAoc2VsZWN0b3IgaXMgb3B0aW9uYWwpXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWdncmVnYXRlU3R5bGVzKGdldFJ1bGVzKHRoaXMuZGVmYXVsdFNoZWV0LCBzZWxlY3RvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBydWxlcyA9IGdldFNlbGVjdG9yc0FuZFJ1bGVzKHRoaXMuZGVmYXVsdFNoZWV0KTtcclxuICAgICAgICAgICAgZm9yIChzZWxlY3RvciBpbiBydWxlcykge1xyXG4gICAgICAgICAgICAgICAgcnVsZXNbc2VsZWN0b3JdID0gYWdncmVnYXRlU3R5bGVzKHJ1bGVzW3NlbGVjdG9yXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gUmV0dXJucyBhbGwgcnVsZXMgKHNlbGVjdG9yIGlzIHJlcXVpcmVkKVxyXG4gICAgICAgIGdldEFsbDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoZWV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKHByb3BlcnRpZXMsIGFnZ3JlZ2F0ZVN0eWxlcyhnZXRSdWxlcyh0aGlzLnNoZWV0c1tpXSwgc2VsZWN0b3IpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBBZGRzIEpTUyBydWxlcyBmb3IgdGhlIHNlbGVjdG9yIGJhc2VkIG9uIHRoZSBnaXZlbiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihzZWxlY3RvciwgcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFNoZWV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRTaGVldCA9IHRoaXMuX2NyZWF0ZVNoZWV0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHRyYW5zZm9ybUNhbWVsQ2FzZWRQcm9wZXJ0eU5hbWVzKHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBnZXRSdWxlcyh0aGlzLmRlZmF1bHRTaGVldCwgc2VsZWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcnVsZXMgPSBbYWRkUnVsZSh0aGlzLmRlZmF1bHRTaGVldCwgc2VsZWN0b3IpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTdHlsZVByb3BlcnRpZXMocnVsZXNbaV0sIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBSZW1vdmVzIEpTUyBydWxlcyAoc2VsZWN0b3IgaXMgb3B0aW9uYWwpXHJcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdFNoZWV0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTaGVldCh0aGlzLmRlZmF1bHRTaGVldCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kZWZhdWx0U2hlZXQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gZ2V0UnVsZXModGhpcy5kZWZhdWx0U2hlZXQsIHNlbGVjdG9yKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUnVsZShydWxlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzLmxlbmd0aDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIF9jcmVhdGVTaGVldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZU5vZGUgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICBzdHlsZU5vZGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICAgIHN0eWxlTm9kZS5yZWwgPSAnc3R5bGVzaGVldCc7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZC5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGVOb2RlLnNoZWV0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgX3JlbW92ZVNoZWV0OiBmdW5jdGlvbihzaGVldCkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHNoZWV0Lm93bmVyTm9kZTtcclxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIGV4cG9ydHMgPSBuZXcgSnNzKGRvY3VtZW50KTtcclxuICAgIGV4cG9ydHMuZm9yRG9jdW1lbnQgPSBmdW5jdGlvbihkb2MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEpzcyhkb2MpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59KSgpO1xyXG5cclxudHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgJiYgKG1vZHVsZS5leHBvcnRzID0ganNzKTsgLy8gQ29tbW9uSlMgc3VwcG9ydCIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE51bWJlck1hc2tcclxuICpcclxuICogQSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIGZvciBCQmogbnVtYmVycyBtYXNraW5nXHJcbiAqXHJcbiAqIEBhdXRob3IgSHl5YW4gQWJvIEZha2hlciA8aGFib2Zha2hlckBiYXNpcy5jb20+XHJcbiAqL1xyXG5jbGFzcyBOdW1iZXJNYXNrIHtcclxuICAvKipcclxuICAgKiBNYXNrIHRoZSBnaXZlbiBudW1iZXIgd2l0aCB0aGUgZ2l2ZW4gbWFzayBhY2NvcmRpbmcgdG8gQkJqIHJ1bGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIHRoZSBudW1iZXIgdG8gZm9ybWF0XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgdGhlIG1hc2sgdG8gdXNlIGZvciBmb3JtYXR0aW5nXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtncm91cGluZ1NlcGFyYXRvcj0sXSAtIGEgY2hhciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYSBncm91cGluZyBzZXBhcmF0b3JcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2RlY2ltYWxTZXBhcmF0b3I9Ll0gIC0gYSBjaGFyIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhIGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2VUcmFpbGluZ1plcm9zPWZhbHNlXSAtIEFmZmVjdHMgdGhlIG91dHB1dCBieSBzd2l0Y2hpbmcgdGhlIHdheSBhIG1hc2sgd2l0aCBcIiNcIiBjaGFyYWN0ZXJzIGluIHRoZSB0cmFpbGluZyBwb3NpdGlvbnMgaXMgZmlsbGVkLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlLCB0aGUgZnVuY3Rpb24gYE51bWJlck1hc2subWFzayguMTA6XCIjLiMjXCIpYCByZXR1cm5zIGAgLjEwYCBpbnN0ZWFkIG9mIGAgLjEgYFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3NlPXRydWVdIHdoZW4gdHJ1ZSAsIGVycm9ycyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSBtZXRob2Qgd2lsbCB0cnkgYXQgYXBwbHkgdGhlIG1hc2tcclxuICAgKiAgICAgICAgICAgICAgICBhbnl3YXkgLCBvdGhlcndpc2UgaXQgd2lsbCBzdG9wIGF0IGZpcnN0IGVycm9yIGFuZCB0aHJvdyBpdC5cclxuICAgKiBcclxuICAgKiBAdGhyb3dzIHtNYXNrRXJyb3J9IG9ubHkgaWYgbG9vc2UgaXMgZGlzYWJsZWRcclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgbWFza2VkIG51bWJlclxyXG4gICAqL1xyXG4gIHN0YXRpYyBtYXNrKFxyXG4gICAgbnVtYmVyLFxyXG4gICAgbWFzayxcclxuICAgIGdyb3VwaW5nU2VwYXJhdG9yID0gJywnLFxyXG4gICAgZGVjaW1hbFNlcGFyYXRvciA9ICcuJyxcclxuICAgIGZvcmNlVHJhaWxpbmdaZXJvcyA9IGZhbHNlLFxyXG4gICAgbG9vc2UgPSB0cnVlXHJcbiAgKSB7XHJcbiAgICBjb25zdCBtYXNrTGVuID0gbWFzay5sZW5ndGhcclxuICAgIGlmICgwID09PSBtYXNrTGVuKSB7XHJcbiAgICAgIGlmIChsb29zZSkgcmV0dXJuIHN0clxyXG4gICAgICAvLyBmcmllbmRseSBzaWxlbnQgZmFpbFxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgbmFtZTogJ01hc2tFcnJvcicsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgTWFza0Vycm9yOiBNYXNrIGlzIGVtcHR5YFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTUFTS1xyXG4gICAgbGV0IG1hc2tCZWZvcmVEZWNpbWFsID0gMFxyXG4gICAgbGV0IG1hc2tBZnRlckRlY2ltYWwgPSAwXHJcbiAgICBsZXQgZm91bmREZWNpbWFsID0gZmFsc2VcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0xlbjsgKytpKSB7XHJcbiAgICAgIGNvbnN0IG0gPSBtYXNrLmNoYXJBdChpKVxyXG4gICAgICBpZiAobSA9PSAnMCcgfHwgbSA9PSAnIycpIHtcclxuICAgICAgICBpZiAoZm91bmREZWNpbWFsKSArK21hc2tBZnRlckRlY2ltYWxcclxuICAgICAgICBlbHNlICsrbWFza0JlZm9yZURlY2ltYWxcclxuICAgICAgfSBlbHNlIGlmIChtID09ICcuJykgZm91bmREZWNpbWFsID0gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIGxldCBudW0gPSBOdW1iZXJNYXNrLl9yb3VuZChudW1iZXIsIG1hc2tBZnRlckRlY2ltYWwpXHJcbiAgICBsZXQgYnl0ZXMgPSBOdW1iZXJNYXNrLl90b0NoYXJBcnJheShudW0pXHJcblxyXG4gICAgLy8gR2V0IG1hZ25pdHVkZSBhbmQgcHJlY2lzaW9uIG9mIE5VTUJFUlxyXG4gICAgbGV0IGluTGVuID0gYnl0ZXMubGVuZ3RoXHJcbiAgICBsZXQgbnVtQmVmb3JlRGVjaW1hbCA9IDBcclxuICAgIGxldCBudW1BZnRlckRlY2ltYWwgPSAwXHJcbiAgICBmb3VuZERlY2ltYWwgPSBmYWxzZVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbkxlbjsgKytpKSB7XHJcbiAgICAgIGlmIChieXRlc1tpXSA9PSAnLicpIGZvdW5kRGVjaW1hbCA9IHRydWVcclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZvdW5kRGVjaW1hbCkgKytudW1BZnRlckRlY2ltYWxcclxuICAgICAgICBlbHNlICsrbnVtQmVmb3JlRGVjaW1hbFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWx3YXlzIGlnbm9yZSBtYXNrIG92ZXJmbG93XHJcbiAgICBpZiAobnVtQmVmb3JlRGVjaW1hbCA+IG1hc2tCZWZvcmVEZWNpbWFsKSB7XHJcbiAgICAgIGlmIChsb29zZSkgcmV0dXJuIG51bWJlci50b1N0cmluZygpXHJcbiAgICAgIC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICBuYW1lOiAnTWFza0Vycm9yJyxcclxuICAgICAgICAgIG1lc3NhZ2U6IGBNYXNrRXJyb3I6IE51bWJlciBpcyB0b28gbGFyZ2UgZm9yIG1hc2tgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHJvdW5kIGlmIG1hc2sgaXMgZm9yIGEgbG93ZXIgcHJlY2lzaW9uIG51bWJlclxyXG4gICAgaWYgKG51bUFmdGVyRGVjaW1hbCA+IG1hc2tBZnRlckRlY2ltYWwpIHtcclxuICAgICAgbnVtID0gTnVtYmVyTWFzay5fcm91bmQobnVtLCBtYXNrQWZ0ZXJEZWNpbWFsKVxyXG4gICAgICBieXRlcyA9IE51bWJlck1hc2suX3RvQ2hhckFycmF5KG51bSlcclxuICAgICAgaW5MZW4gPSBieXRlcy5sZW5ndGhcclxuXHJcbiAgICAgIC8vIEdldCBuZXcgbWFnbml0dWRlIGFuZCBwcmVjaXNpb24gb2YgTlVNQkVSXHJcbiAgICAgIG51bUJlZm9yZURlY2ltYWwgPSAwXHJcbiAgICAgIG51bUFmdGVyRGVjaW1hbCA9IDBcclxuICAgICAgZm91bmREZWNpbWFsID0gZmFsc2VcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbkxlbjsgKytpKSB7XHJcbiAgICAgICAgaWYgKGJ5dGVzW2ldID09ICcuJykgZm91bmREZWNpbWFsID0gdHJ1ZVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGZvdW5kRGVjaW1hbCkgKytudW1BZnRlckRlY2ltYWxcclxuICAgICAgICAgIGVsc2UgKytudW1CZWZvcmVEZWNpbWFsXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhbHdheXMgaWdub3JlIG1hc2sgb3ZlcmZsb3dcclxuICAgICAgaWYgKG51bUJlZm9yZURlY2ltYWwgPiBtYXNrQmVmb3JlRGVjaW1hbCkge1xyXG4gICAgICAgIGlmIChsb29zZSkgcmV0dXJuIG51bWJlci50b1N0cmluZygpXHJcbiAgICAgICAgLy8gZnJpZW5kbHkgc2lsZW50IGZhaWxcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgIG5hbWU6ICdNYXNrRXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBgTWFza0Vycm9yOiBOdW1iZXIgaXMgdG9vIGxhcmdlIGZvciBtYXNrYFxyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGZpbGxCeXRlID0gJyAnLFxyXG4gICAgICBmbG9hdEJ5dGUgPSAnICdcclxuICAgIGxldCBpblBvcyA9IDAsXHJcbiAgICAgIG91dFBvcyA9IDAsXHJcbiAgICAgIGZsb2F0UG9zID0gMFxyXG4gICAgaWYgKG1hc2suY2hhckF0KDApID09ICcqJykgZmlsbEJ5dGUgPSAnKidcclxuXHJcbiAgICBjb25zdCBmaWxsSW5pdCA9IGZpbGxCeXRlXHJcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gTnVtYmVyTWFzay5fZ2V0U2lnbihudW0pIDwgMFxyXG4gICAgbGV0IGVtaXREZWNpbWFsID0gaW5MZW4gPiAwIHx8IG1hc2suaW5kZXhPZignMCcpID49IDBcclxuICAgIGxldCBmb3VuZFplcm8gPSBmYWxzZVxyXG4gICAgbGV0IGZvdW5kRGlnaXQgPSBmYWxzZVxyXG4gICAgbGV0IGN1cnJlbmN5ID0gZmFsc2VcclxuICAgIGZvdW5kRGVjaW1hbCA9IGZhbHNlXHJcblxyXG4gICAgbGV0IHJldCA9IG5ldyBBcnJheShtYXNrTGVuKVxyXG5cclxuICAgIGZvciAobGV0IG1hc2tQb3MgPSAwOyBtYXNrUG9zIDwgbWFza0xlbjsgKyttYXNrUG9zKSB7XHJcbiAgICAgIGxldCBtID0gbWFzay5jaGFyQXQobWFza1BvcylcclxuICAgICAgc3dpdGNoIChtKSB7XHJcbiAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICAtLW1hc2tCZWZvcmVEZWNpbWFsXHJcbiAgICAgICAgICBpZiAobWFza0JlZm9yZURlY2ltYWwgPCBudW1CZWZvcmVEZWNpbWFsICYmIGluUG9zIDwgaW5MZW4pIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBieXRlc1tpblBvc11cclxuICAgICAgICAgICAgKytpblBvc1xyXG4gICAgICAgICAgICBmb3VuZERpZ2l0ID0gdHJ1ZVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSAnMCdcclxuICAgICAgICAgICAgZm91bmRaZXJvID0gdHJ1ZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJyMnOlxyXG4gICAgICAgICAgLS1tYXNrQmVmb3JlRGVjaW1hbFxyXG4gICAgICAgICAgaWYgKG1hc2tCZWZvcmVEZWNpbWFsIDwgbnVtQmVmb3JlRGVjaW1hbCAmJiBpblBvcyA8IGluTGVuKSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gYnl0ZXNbaW5Qb3NdXHJcbiAgICAgICAgICAgICsraW5Qb3NcclxuICAgICAgICAgICAgZm91bmREaWdpdCA9IHRydWVcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID1cclxuICAgICAgICAgICAgICBmb3VuZERlY2ltYWwgJiZcclxuICAgICAgICAgICAgICBmb3JjZVRyYWlsaW5nWmVyb3MgJiZcclxuICAgICAgICAgICAgICBOdW1iZXJNYXNrLl9nZXRTaWduKG51bSkgIT0gMFxyXG4gICAgICAgICAgICAgICAgPyAnMCdcclxuICAgICAgICAgICAgICAgIDogZmlsbEJ5dGVcclxuICAgICAgICAgICAgaWYgKCFmb3VuZERlY2ltYWwpIGZsb2F0UG9zID0gbWFza1Bvc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgICAgaWYgKGZvdW5kWmVybyB8fCBpblBvcyA+IDApIHJldFtvdXRQb3NdID0gZ3JvdXBpbmdTZXBhcmF0b3JcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlXHJcbiAgICAgICAgICAgIGlmICghZm91bmREZWNpbWFsKSBmbG9hdFBvcyA9IG1hc2tQb3NcclxuICAgICAgICAgIH1cclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSBmbG9hdEJ5dGUgPSAnLSdcclxuICAgICAgICAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgICAgfSBlbHNlIHJldFtvdXRQb3NdID0gaXNOZWdhdGl2ZSA/ICctJyA6IGZpbGxCeXRlXHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgICBmbG9hdEJ5dGUgPSBpc05lZ2F0aXZlID8gJy0nIDogJysnXHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3NcclxuICAgICAgICAgIH0gZWxzZSByZXRbb3V0UG9zXSA9IGlzTmVnYXRpdmUgPyAnLScgOiAnKydcclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICckJzpcclxuICAgICAgICAgIGlmICghZm91bmREaWdpdCAmJiBmbG9hdEJ5dGUgPT0gJyAnKSB7XHJcbiAgICAgICAgICAgIGZsb2F0Qnl0ZSA9ICckJ1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZpbGxCeXRlXHJcbiAgICAgICAgICAgIGZsb2F0UG9zID0gZm91bmREZWNpbWFsID8gLTEgOiBtYXNrUG9zXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9ICckJ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIC8vIGNhc2UgJyYnOlxyXG4gICAgICAgIC8vICAgY3VycmVuY3kgPSB0cnVlXHJcbiAgICAgICAgLy8gICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgIC8vICAgICBmbG9hdEJ5dGUgPSAnJidcclxuICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSBmaWxsQnl0ZVxyXG4gICAgICAgIC8vICAgICBmbG9hdFBvcyA9IGZvdW5kRGVjaW1hbCA/IC0xIDogbWFza1Bvc1xyXG4gICAgICAgIC8vICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgcmV0W291dFBvc10gPSAnJidcclxuICAgICAgICAvLyAgIH1cclxuICAgICAgICAvLyAgICsrb3V0UG9zXHJcbiAgICAgICAgLy8gICBicmVha1xyXG5cclxuICAgICAgICAvLyBjYXNlICdAJzpcclxuICAgICAgICAvLyAgIGN1cnJlbmN5ID0gdHJ1ZVxyXG4gICAgICAgIC8vICAgaWYgKCFmb3VuZERpZ2l0ICYmIGZsb2F0Qnl0ZSA9PSAnICcpIHtcclxuICAgICAgICAvLyAgICAgZmxvYXRCeXRlID0gJ0AnXHJcbiAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAvLyAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3NcclxuICAgICAgICAvLyAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIHJldFtvdXRQb3NdID0gJ0AnXHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gICArK291dFBvc1xyXG4gICAgICAgIC8vICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnKCc6XHJcbiAgICAgICAgICBpZiAoIWZvdW5kRGlnaXQgJiYgZmxvYXRCeXRlID09ICcgJykge1xyXG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkgZmxvYXRCeXRlID0gJygnXHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gZmlsbEJ5dGVcclxuICAgICAgICAgICAgZmxvYXRQb3MgPSBmb3VuZERlY2ltYWwgPyAtMSA6IG1hc2tQb3NcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnKCdcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZvdW5kRGVjaW1hbCA/ICcgJyA6IGZpbGxCeXRlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICcpJzpcclxuICAgICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyknXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9IGZvdW5kRGVjaW1hbCA/ICcgJyA6IGZpbGxCeXRlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnQyc6XHJcbiAgICAgICAgICBpZiAobWFza1BvcyA8IG1hc2tMZW4gLSAxICYmIG1hc2suY2hhckF0KG1hc2tQb3MgKyAxKSA9PSAnUicpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdDJ1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3MgKyAxXSA9ICdSJ1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJyAnXHJcbiAgICAgICAgICAgICAgcmV0W291dFBvcyArIDFdID0gJyAnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0UG9zICs9IDJcclxuICAgICAgICAgICAgKyttYXNrUG9zXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXRbb3V0UG9zXSA9ICdDJ1xyXG4gICAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICdEJzpcclxuICAgICAgICAgIGlmIChtYXNrUG9zIDwgbWFza0xlbiAtIDEgJiYgbWFzay5jaGFyQXQobWFza1BvcyArIDEpID09ICdSJykge1xyXG4gICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0MnXHJcbiAgICAgICAgICAgICAgcmV0W291dFBvcyArIDFdID0gJ1InXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0W291dFBvc10gPSAnRCdcclxuICAgICAgICAgICAgICByZXRbb3V0UG9zICsgMV0gPSAnUidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRQb3MgKz0gMlxyXG4gICAgICAgICAgICArK21hc2tQb3NcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldFtvdXRQb3NdID0gJ0QnXHJcbiAgICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICcqJzpcclxuICAgICAgICAgIHJldFtvdXRQb3NdID0gJyonXHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICByZXRbb3V0UG9zXSA9IGVtaXREZWNpbWFsID8gZGVjaW1hbFNlcGFyYXRvciA6IGZpbGxCeXRlXHJcbiAgICAgICAgICBmaWxsQnl0ZSA9ICcgJ1xyXG4gICAgICAgICAgZm91bmREZWNpbWFsID0gdHJ1ZVxyXG4gICAgICAgICAgKytpblBvc1xyXG4gICAgICAgICAgKytvdXRQb3NcclxuICAgICAgICAgIGJyZWFrXHJcblxyXG4gICAgICAgIGNhc2UgJ0InOlxyXG4gICAgICAgICAgcmV0W291dFBvc10gPSAnICdcclxuICAgICAgICAgICsrb3V0UG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0W291dFBvc10gPSBtXHJcbiAgICAgICAgICArK291dFBvc1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChmbG9hdEJ5dGUgIT0gJyAnKSB7XHJcbiAgICAgIGlmIChmbG9hdFBvcyA8IDApIGZsb2F0UG9zID0gb3V0UG9zXHJcbiAgICAgIHdoaWxlIChmbG9hdFBvcyA+PSBtYXNrTGVuKSAtLWZsb2F0UG9zXHJcbiAgICAgIGlmIChyZXRbZmxvYXRQb3NdID09IGZpbGxJbml0KSByZXRbZmxvYXRQb3NdID0gZmxvYXRCeXRlXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldC5qb2luKCcnKVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIF9zaGlmdChudW1iZXIsIHByZWNpc2lvbiwgcmV2ZXJzZVNoaWZ0KSB7XHJcbiAgICBpZiAocmV2ZXJzZVNoaWZ0KSBwcmVjaXNpb24gPSAtcHJlY2lzaW9uXHJcbiAgICB2YXIgbnVtQXJyYXkgPSAoJycgKyBudW1iZXIpLnNwbGl0KCdlJylcclxuICAgIHJldHVybiArKFxyXG4gICAgICBudW1BcnJheVswXSArXHJcbiAgICAgICdlJyArXHJcbiAgICAgIChudW1BcnJheVsxXSA/ICtudW1BcnJheVsxXSArIHByZWNpc2lvbiA6IHByZWNpc2lvbilcclxuICAgIClcclxuICB9XHJcblxyXG4gIHN0YXRpYyBfcm91bmQobnVtYmVyLCBwcmVjaXNpb24pIHtcclxuICAgIHJldHVybiBOdW1iZXJNYXNrLl9zaGlmdChcclxuICAgICAgTWF0aC5yb3VuZChOdW1iZXJNYXNrLl9zaGlmdChudW1iZXIsIHByZWNpc2lvbiwgZmFsc2UpKSxcclxuICAgICAgcHJlY2lzaW9uLFxyXG4gICAgICB0cnVlXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBzdGF0aWMgX3RvQ2hhckFycmF5KG51bWJlcikge1xyXG4gICAgY29uc3Qgc2lnbnVtID0gTnVtYmVyTWFzay5fZ2V0U2lnbihudW1iZXIpXHJcbiAgICBsZXQgY2hhcnMgPSBbXVxyXG5cclxuICAgIGlmIChzaWdudW0gIT09IDApIHtcclxuICAgICAgbGV0IHN0cmluZyA9IHNpZ251bSA8IDAgPyBgJHstMSAqIG51bWJlci50b1N0cmluZygpfWAgOiBudW1iZXIudG9TdHJpbmcoKVxyXG5cclxuICAgICAgaWYgKHN0cmluZy5sZW5ndGggPiAxICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJzAnKVxyXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoMSlcclxuXHJcbiAgICAgIC8vIFRoZSBzdHJpbmcgY29udGFpbnMgb25seSBbMC05XSBhbmQgJy4nXHJcbiAgICAgIGNoYXJzID0gc3RyaW5nLnNwbGl0KCcnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjaGFyc1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgc2lnbiBvZiBhIG51bWJlclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHggbnVtYmVyXHJcbiAgICogQHJldHVybnMge051bWJlcn0gQSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaWduIG9mIHRoZSBnaXZlbiBhcmd1bWVudC5cclxuICAgKiAgICAgICAgICAgICAgICAgICBJZiB0aGUgYXJndW1lbnQgaXMgYSBwb3NpdGl2ZSBudW1iZXIsIG5lZ2F0aXZlIG51bWJlciwgcG9zaXRpdmUgemVyb1xyXG4gICAqICAgICAgICAgICAgICAgICAgIG9yIG5lZ2F0aXZlIHplcm8sIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiAxLCAtMSwgMCBvciAtMCByZXNwZWN0aXZlbHkuXHJcbiAgICogICAgICAgICAgICAgICAgICAgT3RoZXJ3aXNlLCBOYU4gaXMgcmV0dXJuZWQuXHJcbiAgICovXHJcbiAgc3RhdGljIF9nZXRTaWduKHgpIHtcclxuICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTnVtYmVyTWFza1xyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBiYmotbWFza3MgbGliLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBOdW1iZXJNYXNrIGZyb20gJy4vTnVtYmVyTWFzaydcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE51bWJlck1hc2tcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgYmJqLW1hc2tzIGxpYi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5jb25zdCBpc051bWJlclJlZ2V4ID0gL15cXGQrJC9cclxuY29uc3QgaXNXaGl0ZXNwYWNlUmVnZXggPSAvXFxzL1xyXG5jb25zdCBwdW5jdHVhdGlvbkxpc3QgPSAnIVwiIyQlJlxcJygpKissLS4vOjs8PT4/QFtdXl9ge3x9fidcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGluIGxvd2VyIGNhc2VcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKi9cclxuY29uc3QgaXNMb3dlckNhc2UgPSBzdHIgPT4ge1xyXG4gIHJldHVybiBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgc3RyICE9IHN0ci50b1VwcGVyQ2FzZSgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGluIHVwcGVyIGNhc2VcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKi9cclxuY29uc3QgaXNVcHBlckNhc2UgPSBzdHIgPT4ge1xyXG4gIHJldHVybiBzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgc3RyICE9IHN0ci50b0xvd2VyQ2FzZSgpXHJcbn1cclxuXHJcbmNvbnN0IHBhc3NPclRocm93RXJyb3IgPSAobG9vc2UsIHJldCwgaSwgc3RyKSA9PiB7XHJcbiAgaWYgKCFsb29zZSkge1xyXG4gICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoaSlcclxuICAgIGNvbnN0IHBvcyA9IGkgKyAxXHJcbiAgICB0aHJvdyB7XHJcbiAgICAgIG5hbWU6ICdTdHJpbmdNYXNrRXJyb3InLFxyXG4gICAgICBtZXNzYWdlOiBgU3RyaW5nTWFza0Vycm9yOiBlcnJvciBhcHBseWluZyBtYXNrIGF0IHBvc2l0aW9uIFwiJHtwb3N9XCIgLCBjaGFyIFwiJHtjaGFyfVwiYCxcclxuICAgICAgcG9zLFxyXG4gICAgICBjaGFyXHJcbiAgICB9XHJcbiAgfSBlbHNlIHJldFtpXSA9ICcgJ1xyXG59XHJcblxyXG4vKipcclxuICogTnVtYmVyTWFza1xyXG4gKlxyXG4gKiBBIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gZm9yIEJCaiBudW1iZXJzIG1hc2tpbmdcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyIDxoYWJvZmFraGVyQGJhc2lzLmNvbT5cclxuICovXHJcbmNsYXNzIFN0cmluZ01hc2sge1xyXG4gIC8qKlxyXG4gICAqIE1hc2sgdGhlIGdpdmVuIHN0cmluZyB3aXRoIHRoZSBnaXZlbiBtYXNrIGFjY29yZGluZyB0byBCQmogcnVsZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBtYXNrXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hc2sgdGhlIG1hc2sgdG8gdXNlIGZvciBmb3JtYXR0aW5nXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbG9vc2U9dHJ1ZV0gd2hlbiB0cnVlICwgZXJyb3JzIHdpbGwgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCB3aWxsIHRyeSBhdCBhcHBseSB0aGUgbWFza1xyXG4gICAqICAgICAgICAgICAgICAgIGFueXdheSAsIG90aGVyd2lzZSBpdCB3aWxsIHN0b3AgYXQgZmlyc3QgZXJyb3IgYW5kIHRocm93IGl0LlxyXG4gICAqIFxyXG4gICAqIEB0aHJvd3Mge01hc2tJc1Rvb1Nob3J0RXJyb3J9XHJcbiAgICogQHRocm93cyB7U3RyaW5nTWFza0Vycm9yfVxyXG4gICAqIEB0aHJvd3Mge01hc2tFcnJvcn1cclxuICAgKiBcclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgbWFza2VkIHN0cmluZ1xyXG4gICAqL1xyXG4gIHN0YXRpYyBtYXNrKHN0ciwgbWFzaywgbG9vc2UgPSB0cnVlKSB7XHJcbiAgICBzdHIgPSBTdHJpbmcoc3RyKVxyXG4gICAgbWFzayA9IFN0cmluZyhtYXNrKVxyXG4gICAgY29uc3QgbWFza0xlbiA9IG1hc2subGVuZ3RoXHJcbiAgICBjb25zdCBzdHJMZW4gPSBzdHIubGVuZ3RoXHJcblxyXG4gICAgaWYgKHN0ckxlbiA+IG1hc2tMZW4pIHtcclxuICAgICAgaWYgKGxvb3NlKSByZXR1cm4gc3RyXHJcbiAgICAgIC8vIGZyaWVuZGx5IHNpbGVudCBmYWlsXHJcbiAgICAgIGVsc2VcclxuICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICBuYW1lOiAnTWFza0lzVG9vU2hvcnRFcnJvcicsXHJcbiAgICAgICAgICBtZXNzYWdlOiBgTWFza0lzVG9vU2hvcnRFcnJvcjogTWFzayBpcyBzaG9ydGVyIHRoYW4gdGhlIHBhc3NlZCBzdHJpbmdgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheShtYXNrTGVuKVxyXG4gICAgbGV0IHBvcyA9IDAgLy8gdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgc3RyXHJcbiAgICBsZXQgbWFza0J5dGUgPSAnJ1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFza0xlbjsgaSsrKSB7XHJcbiAgICAgIG1hc2tCeXRlID0gbWFzay5jaGFyQXQoaSlcclxuICAgICAgc3dpdGNoIChtYXNrQnl0ZSkge1xyXG4gICAgICAgIGNhc2UgJ1gnOiAvLyBtYXRjaCBhbnkgY2hhcmFjdGVyXHJcbiAgICAgICAgICByZXRbaV0gPSBwb3MgPCBzdHJMZW4gPyBzdHIuY2hhckF0KHBvcykgOiAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICdBJzogLy8gbWF0Y2ggbGV0dGVyOyBmb3JjZSB1cHBlciBjYXNlXHJcbiAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBzdHIuY2hhckF0KHBvcylcclxuICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKGJ5dGUpKSByZXRbaV0gPSBieXRlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTG93ZXJDYXNlKGJ5dGUpKSByZXRbaV0gPSBieXRlLnRvVXBwZXJDYXNlKClcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICBjYXNlICdhJzogLy8gbWF0Y2ggbGV0dGVyXHJcbiAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBzdHIuY2hhckF0KHBvcylcclxuICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKGJ5dGUpIHx8IGlzTG93ZXJDYXNlKGJ5dGUpKSByZXRbaV0gPSBieXRlXHJcbiAgICAgICAgICAgIGVsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpXHJcbiAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnXHJcbiAgICAgICAgICArK3Bvc1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICcwJzogLy8gbWF0Y2ggZGlnaXRcclxuICAgICAgICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZSA9IHN0ci5jaGFyQXQocG9zKVxyXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXJSZWdleC50ZXN0KGJ5dGUpKSByZXRbaV0gPSBieXRlXHJcbiAgICAgICAgICAgIGVsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpXHJcbiAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnXHJcbiAgICAgICAgICArK3Bvc1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICdaJzogLy8gbWF0Y2ggbGV0dGVyIG9yIGRpZ2l0OyBmb3JjZSB1cHBlciBjYXNlXHJcbiAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBzdHIuY2hhckF0KHBvcylcclxuICAgICAgICAgICAgaWYgKGlzVXBwZXJDYXNlKGJ5dGUpIHx8IGlzTnVtYmVyUmVnZXgudGVzdChieXRlKSkgcmV0W2ldID0gYnl0ZVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0xvd2VyQ2FzZShieXRlKSkgcmV0W2ldID0gYnl0ZS50b1VwcGVyQ2FzZSgpXHJcbiAgICAgICAgICAgIGVsc2UgcGFzc09yVGhyb3dFcnJvcihsb29zZSwgcmV0LCBpLCBzdHIpXHJcbiAgICAgICAgICB9IGVsc2UgcmV0W2ldID0gJyAnXHJcbiAgICAgICAgICArK3Bvc1xyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlICd6JzogLy8gbWF0Y2ggbGV0dGVyIG9yIGRpZ2l0XHJcbiAgICAgICAgICBpZiAocG9zIDwgc3RyTGVuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBzdHIuY2hhckF0KHBvcylcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgIGlzVXBwZXJDYXNlKGJ5dGUpIHx8XHJcbiAgICAgICAgICAgICAgaXNMb3dlckNhc2UoYnl0ZSkgfHxcclxuICAgICAgICAgICAgICBpc051bWJlclJlZ2V4LnRlc3QoYnl0ZSlcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgIHJldFtpXSA9IGJ5dGVcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAnVSc6IC8vIG1hdGNoIGxldHRlciAoZm9yY2UgdXBwZXIgY2FzZSksIGRpZ2l0LCB3aGl0ZXNwYWNlIG9yIHB1bmN0dWF0aW9uLlxyXG4gICAgICAgICAgaWYgKHBvcyA8IHN0ckxlbikge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlID0gc3RyLmNoYXJBdChwb3MpXHJcbiAgICAgICAgICAgIGlmIChpc0xvd2VyQ2FzZShieXRlKSkgcmV0W2ldID0gYnl0ZS50b1VwcGVyQ2FzZSgpXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgIGlzVXBwZXJDYXNlKGJ5dGUpIHx8XHJcbiAgICAgICAgICAgICAgaXNOdW1iZXJSZWdleC50ZXN0KGJ5dGUpIHx8XHJcbiAgICAgICAgICAgICAgaXNXaGl0ZXNwYWNlUmVnZXgudGVzdChieXRlKSB8fFxyXG4gICAgICAgICAgICAgIHB1bmN0dWF0aW9uTGlzdC5pbmRleE9mKGJ5dGUpID4gLTFcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgIHJldFtpXSA9IGJ5dGVcclxuICAgICAgICAgICAgZWxzZSBwYXNzT3JUaHJvd0Vycm9yKGxvb3NlLCByZXQsIGksIHN0cilcclxuICAgICAgICAgIH0gZWxzZSByZXRbaV0gPSAnICdcclxuICAgICAgICAgICsrcG9zXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXRbaV0gPSBtYXNrQnl0ZVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChwb3MgPCBzdHJMZW4pIHtcclxuICAgICAgaWYgKCFsb29zZSkge1xyXG4gICAgICAgIHRocm93IHsgbmFtZTogJ01hc2tFcnJvcicsIG1lc3NhZ2U6ICdNYXNrIGNhbm5vdCBiZSBhcHBsaWVkJyB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0LmpvaW4oJycpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHJpbmdNYXNrXHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIGJiai1tYXNrcyBsaWIuXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFN0cmluZ01hc2sgZnJvbSAnLi9TdHJpbmdNYXNrJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3RyaW5nTWFza1xyXG4iLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFtSZWN1cnNpdmVseSBwYXJzZXMgYSBzdHJpbmdpZmllZCBKU09OXVxuICogQHBhcmFtICB7W3R5cGVdfSBqc29uU3RyaW5nIFtzdHJpbmdpZmllZCBqc29uIHRvIHBhcnNlXVxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgIFtub3JtYWxpemVkIEphdmFzY3JpcHQgb2JqZWN0XVxuICovXG5mdW5jdGlvbiBkZWVwUGFyc2VKc29uKGpzb25TdHJpbmcpIHtcbiAgLy8gaWYgbm90IHN0cmluZ2lmaWVkIGpzb24gcmF0aGVyIGEgc2ltcGxlIHN0cmluZyB2YWx1ZSB0aGVuIEpTT04ucGFyc2Ugd2lsbCB0aHJvdyBlcnJvclxuICAvLyBvdGhlcndpc2UgY29udGludWUgcmVjdXJzaW9uXG4gIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRlZXBQYXJzZUpzb24oSlNPTi5wYXJzZShqc29uU3RyaW5nKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ganNvblN0cmluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShqc29uU3RyaW5nKSkge1xuICAgIC8vIGlmIGFuIGFycmF5IGlzIHJlY2VpdmVkLCBtYXAgb3ZlciB0aGUgYXJyYXkgYW5kIGRlZXBQYXJzZSBlYWNoIHZhbHVlXG4gICAgcmV0dXJuIGpzb25TdHJpbmcubWFwKHZhbCA9PiBkZWVwUGFyc2VKc29uKHZhbCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnb2JqZWN0JyAmJiBqc29uU3RyaW5nICE9PSBudWxsKSB7XG4gICAgLy8gaWYgYW4gb2JqZWN0IGlzIHJlY2VpdmVkIHRoZW4gZGVlcFBhcnNlIGVhY2ggZWxlbWVudCBpbiB0aGUgb2JqZWN0XG4gICAgLy8gdHlwZW9mIG51bGwgcmV0dXJucyAnb2JqZWN0JyB0b28sIHNvIHdlIGhhdmUgdG8gZWxpbWluYXRlIHRoYXRcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoanNvblN0cmluZykucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgb2JqW2tleV0gPSBkZWVwUGFyc2VKc29uKGpzb25TdHJpbmdba2V5XSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHdoYXRldmVyIHdhcyByZWNlaXZlZFxuICAgIHJldHVybiBqc29uU3RyaW5nO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWVwUGFyc2VKc29uIH07XG4iLCJpZighZ2xvYmFsW1wiQkJqXCJdKSBnbG9iYWxbXCJCQmpcIl0gPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiQkJqXCJdW1wiTWFza3NcIl0gPSByZXF1aXJlKFwiLSFEOlxcXFxHaXRodWJcXFxcQkJqR3JpZEV4V2lkZ2V0XFxcXGNsaWVudFxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz8/cmVmLS00IS5cXFxcYmJqLW1hc2tzLmpzXCIpOyIsImlmKCFnbG9iYWxbXCJCYXNpc1wiXSkgZ2xvYmFsW1wiQmFzaXNcIl0gPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiQmFzaXNcIl1bXCJBZ0dyaWRDb21wb25lbnRzXCJdID0gcmVxdWlyZShcIi0hRDpcXFxcR2l0aHViXFxcXEJCakdyaWRFeFdpZGdldFxcXFxjbGllbnRcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/P3JlZi0tNCEuXFxcXGJhc2lzLWFnZ3JpZC1jb21wb25lbnRzLmpzXCIpOyIsImlmKCFnbG9iYWxbXCJCYXNpc1wiXSkgZ2xvYmFsW1wiQmFzaXNcIl0gPSB7fTtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsW1wiQmFzaXNcIl1bXCJJbnB1dE1hc2tpbmdcIl0gPSByZXF1aXJlKFwiLSFEOlxcXFxHaXRodWJcXFxcQkJqR3JpZEV4V2lkZ2V0XFxcXGNsaWVudFxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz8/cmVmLS00IS5cXFxcYmFzaXMtaW5wdXQtbWFza2luZy5qc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFtcImZsYXRwaWNrclwiXSA9IHJlcXVpcmUoXCItIUQ6XFxcXEdpdGh1YlxcXFxCQmpHcmlkRXhXaWRnZXRcXFxcY2xpZW50XFxcXG5vZGVfbW9kdWxlc1xcXFxiYWJlbC1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzPz9yZWYtLTQhLlxcXFxmbGF0cGlja3IuanNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSBnbG9iYWxbXCJqc3NcIl0gPSByZXF1aXJlKFwiLSFEOlxcXFxHaXRodWJcXFxcQkJqR3JpZEV4V2lkZ2V0XFxcXGNsaWVudFxcXFxub2RlX21vZHVsZXNcXFxcYmFiZWwtbG9hZGVyXFxcXGxpYlxcXFxpbmRleC5qcz8/cmVmLS00IS5cXFxcanNzLmpzXCIpOyIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9mbGF0cGlja3IuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LnBhcmVudC5kb2N1bWVudC5oZWFkXHJcbiAgICAgICAgICAgICAgfTtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9mbGF0cGlja3IuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vZmxhdHBpY2tyLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcHBseTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgZGVmaW5lUHJvcGVydHkgZnJvbSAnLi9fZGVmaW5lUHJvcGVydHkuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQXNzaWduVmFsdWU7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNNYXNrZWQgZnJvbSAnLi9faXNNYXNrZWQuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IHRvU291cmNlIGZyb20gJy4vX3RvU291cmNlLmpzJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzTmF0aXZlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzSW4gZnJvbSAnLi9fbmF0aXZlS2V5c0luLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXNJbjtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlPZmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5T2Yob2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVByb3BlcnR5T2Y7XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSAnLi9pZGVudGl0eS5qcyc7XG5pbXBvcnQgb3ZlclJlc3QgZnJvbSAnLi9fb3ZlclJlc3QuanMnO1xuaW1wb3J0IHNldFRvU3RyaW5nIGZyb20gJy4vX3NldFRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSZXN0O1xuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gJy4vY29uc3RhbnQuanMnO1xuaW1wb3J0IGRlZmluZVByb3BlcnR5IGZyb20gJy4vX2RlZmluZVByb3BlcnR5LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlPYmplY3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuZXhwb3J0IGRlZmF1bHQgY29yZUpzRGF0YTtcbiIsImltcG9ydCBiYXNlUmVzdCBmcm9tICcuL19iYXNlUmVzdC5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVBc3NpZ25lcjtcbiIsImltcG9ydCBlcSBmcm9tICcuL2VxLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UgdG8gYXNzaWduIHByb3BlcnRpZXNcbiAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGN1c3RvbURlZmF1bHRzQXNzaWduSW47XG4iLCJpbXBvcnQgZ2V0TmF0aXZlIGZyb20gJy4vX2dldE5hdGl2ZS5qcyc7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVQcm9wZXJ0eTtcbiIsImltcG9ydCBiYXNlUHJvcGVydHlPZiBmcm9tICcuL19iYXNlUHJvcGVydHlPZi5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG52YXIgaHRtbEVzY2FwZXMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5Oydcbn07XG5cbi8qKlxuICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xudmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGVIdG1sQ2hhcjtcbiIsIi8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xudmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICdcXFxcJzogJ1xcXFwnLFxuICBcIidcIjogXCInXCIsXG4gICdcXG4nOiAnbicsXG4gICdcXHInOiAncicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udGVtcGxhdGVgIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nQ2hhcihjaHIpIHtcbiAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXNjYXBlU3RyaW5nQ2hhcjtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgYmFzZUlzTmF0aXZlIGZyb20gJy4vX2Jhc2VJc05hdGl2ZS5qcyc7XG5pbXBvcnQgZ2V0VmFsdWUgZnJvbSAnLi9fZ2V0VmFsdWUuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXROYXRpdmU7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFByb3RvdHlwZTtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0VmFsdWU7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCJpbXBvcnQgZXEgZnJvbSAnLi9lcS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0l0ZXJhdGVlQ2FsbDtcbiIsImltcG9ydCBjb3JlSnNEYXRhIGZyb20gJy4vX2NvcmVKc0RhdGEuanMnO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXNJbjtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IGFwcGx5IGZyb20gJy4vX2FwcGx5LmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlclJlc3Q7XG4iLCIvKiogVXNlZCB0byBtYXRjaCB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xudmFyIHJlRXNjYXBlID0gLzwlLShbXFxzXFxTXSs/KSU+L2c7XG5cbmV4cG9ydCBkZWZhdWx0IHJlRXNjYXBlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy4gKi9cbnZhciByZUV2YWx1YXRlID0gLzwlKFtcXHNcXFNdKz8pJT4vZztcblxuZXhwb3J0IGRlZmF1bHQgcmVFdmFsdWF0ZTtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVJbnRlcnBvbGF0ZSA9IC88JT0oW1xcc1xcU10rPyklPi9nO1xuXG5leHBvcnQgZGVmYXVsdCByZUludGVycG9sYXRlO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCBiYXNlU2V0VG9TdHJpbmcgZnJvbSAnLi9fYmFzZVNldFRvU3RyaW5nLmpzJztcbmltcG9ydCBzaG9ydE91dCBmcm9tICcuL19zaG9ydE91dC5qcyc7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbmV4cG9ydCBkZWZhdWx0IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaG9ydE91dDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Tb3VyY2U7XG4iLCJpbXBvcnQgY29weU9iamVjdCBmcm9tICcuL19jb3B5T2JqZWN0LmpzJztcbmltcG9ydCBjcmVhdGVBc3NpZ25lciBmcm9tICcuL19jcmVhdGVBc3NpZ25lci5qcyc7XG5pbXBvcnQga2V5c0luIGZyb20gJy4va2V5c0luLmpzJztcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbkluV2l0aDtcbiIsImltcG9ydCBhcHBseSBmcm9tICcuL19hcHBseS5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzRXJyb3IgZnJvbSAnLi9pc0Vycm9yLmpzJztcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAqIH0sICc+Xz4nKTtcbiAqXG4gKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICogICBlbGVtZW50cyA9IFtdO1xuICogfVxuICovXG52YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGF0dGVtcHQ7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29uc3RhbnQ7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXE7XG4iLCJpbXBvcnQgZXNjYXBlSHRtbENoYXIgZnJvbSAnLi9fZXNjYXBlSHRtbENoYXIuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuICovXG52YXIgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csXG4gICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICpcbiAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gKlxuICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gKiBYU1MgdmVjdG9ycy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBlc2NhcGU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpZGVudGl0eTtcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgRXJyb3JgLCBgRXZhbEVycm9yYCwgYFJhbmdlRXJyb3JgLCBgUmVmZXJlbmNlRXJyb3JgLFxuICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRXJyb3IoRXJyb3IpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNFcnJvcjtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBnZXRQcm90b3R5cGUgZnJvbSAnLi9fZ2V0UHJvdG90eXBlLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG52YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdCk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC44LjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgQ3RvciA9IGhhc093blByb3BlcnR5LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3ltYm9sO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzSW4gZnJvbSAnLi9fYmFzZUtleXNJbi5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCBhc3NpZ25JbldpdGggZnJvbSAnLi9hc3NpZ25JbldpdGguanMnO1xuaW1wb3J0IGF0dGVtcHQgZnJvbSAnLi9hdHRlbXB0LmpzJztcbmltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGN1c3RvbURlZmF1bHRzQXNzaWduSW4gZnJvbSAnLi9fY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbi5qcyc7XG5pbXBvcnQgZXNjYXBlU3RyaW5nQ2hhciBmcm9tICcuL19lc2NhcGVTdHJpbmdDaGFyLmpzJztcbmltcG9ydCBpc0Vycm9yIGZyb20gJy4vaXNFcnJvci5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcbmltcG9ydCByZUludGVycG9sYXRlIGZyb20gJy4vX3JlSW50ZXJwb2xhdGUuanMnO1xuaW1wb3J0IHRlbXBsYXRlU2V0dGluZ3MgZnJvbSAnLi90ZW1wbGF0ZVNldHRpbmdzLmpzJztcbmltcG9ydCB0b1N0cmluZyBmcm9tICcuL3RvU3RyaW5nLmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggZW1wdHkgc3RyaW5nIGxpdGVyYWxzIGluIGNvbXBpbGVkIHRlbXBsYXRlIHNvdXJjZS4gKi9cbnZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgcmVFbXB0eVN0cmluZ1RyYWlsaW5nID0gLyhfX2VcXCguKj9cXCl8XFxiX190XFwpKSBcXCtcXG4nJzsvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoXG4gKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICovXG52YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4vKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG52YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4vKiogVXNlZCB0byBtYXRjaCB1bmVzY2FwZWQgY2hhcmFjdGVycyBpbiBjb21waWxlZCBzdHJpbmcgbGl0ZXJhbHMuICovXG52YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAqXG4gKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICpcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0ndGVtcGxhdGVTb3VyY2VzW25dJ11cbiAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gKlxuICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gKlxuICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICpcbiAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAqXG4gKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAqXG4gKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICpcbiAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAqXG4gKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICogY29tcGlsZWQoZGF0YSk7XG4gKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICpcbiAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICogY29tcGlsZWQuc291cmNlO1xuICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICogLy8gICByZXR1cm4gX19wO1xuICogLy8gfVxuICpcbiAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICpcbiAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICogICB2YXIgSlNUID0ge1xcXG4gKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAqICAgfTtcXFxuICogJyk7XG4gKi9cbmZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICB2YXIgc2V0dGluZ3MgPSB0ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHMuXy50ZW1wbGF0ZVNldHRpbmdzIHx8IHRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAsICdnJyk7XG5cbiAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAvLyBUaGUgc291cmNlVVJMIGdldHMgaW5qZWN0ZWQgaW50byB0aGUgc291cmNlIHRoYXQncyBldmFsLWVkLCBzbyBiZSBjYXJlZnVsXG4gIC8vIHdpdGggbG9va3VwIChpbiBjYXNlIG9mIGUuZy4gcHJvdG90eXBlIHBvbGx1dGlvbiksIGFuZCBzdHJpcCBuZXdsaW5lcyBpZiBhbnkuXG4gIC8vIEEgbmV3bGluZSB3b3VsZG4ndCBiZSBhIHZhbGlkIHNvdXJjZVVSTCBhbnl3YXksIGFuZCBpdCdkIGVuYWJsZSBjb2RlIGluamVjdGlvbi5cbiAgdmFyIHNvdXJjZVVSTCA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgPyAoJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykgK1xuICAgICAgICdcXG4nKVxuICAgIDogJyc7XG5cbiAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgfVxuICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgIH1cbiAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuXG4gIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gIC8vIExpa2Ugd2l0aCBzb3VyY2VVUkwsIHdlIHRha2UgY2FyZSB0byBub3QgY2hlY2sgdGhlIG9wdGlvbidzIHByb3RvdHlwZSxcbiAgLy8gYXMgdGhpcyBjb25maWd1cmF0aW9uIGlzIGEgY29kZSBpbmplY3Rpb24gdmVjdG9yLlxuICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICd2YXJpYWJsZScpICYmIG9wdGlvbnMudmFyaWFibGU7XG4gIGlmICghdmFyaWFibGUpIHtcbiAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgfVxuICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgIC5yZXBsYWNlKHJlRW1wdHlTdHJpbmdNaWRkbGUsICckMScpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAodmFyaWFibGUgfHwgJ29iaicpICsgJykge1xcbicgK1xuICAgICh2YXJpYWJsZVxuICAgICAgPyAnJ1xuICAgICAgOiAnb2JqIHx8IChvYmogPSB7fSk7XFxuJ1xuICAgICkgK1xuICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgKGlzRXNjYXBpbmdcbiAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgIDogJydcbiAgICApICtcbiAgICAoaXNFdmFsdWF0aW5nXG4gICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICBcImZ1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCAnJykgfVxcblwiXG4gICAgICA6ICc7XFxuJ1xuICAgICkgK1xuICAgIHNvdXJjZSArXG4gICAgJ3JldHVybiBfX3BcXG59JztcblxuICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24oaW1wb3J0c0tleXMsIHNvdXJjZVVSTCArICdyZXR1cm4gJyArIHNvdXJjZSlcbiAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICB9KTtcblxuICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBmdW5jdGlvbidzIHNvdXJjZSBieSBpdHMgYHRvU3RyaW5nYCBtZXRob2Qgb3JcbiAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgaWYgKGlzRXJyb3IocmVzdWx0KSkge1xuICAgIHRocm93IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZTtcbiIsImltcG9ydCBlc2NhcGUgZnJvbSAnLi9lc2NhcGUuanMnO1xuaW1wb3J0IHJlRXNjYXBlIGZyb20gJy4vX3JlRXNjYXBlLmpzJztcbmltcG9ydCByZUV2YWx1YXRlIGZyb20gJy4vX3JlRXZhbHVhdGUuanMnO1xuaW1wb3J0IHJlSW50ZXJwb2xhdGUgZnJvbSAnLi9fcmVJbnRlcnBvbGF0ZS5qcyc7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgdGhlIHRlbXBsYXRlIGRlbGltaXRlcnMgdXNlZCBieSBsb2Rhc2ggYXJlIGxpa2UgdGhvc2UgaW5cbiAqIGVtYmVkZGVkIFJ1YnkgKEVSQikgYXMgd2VsbCBhcyBFUzIwMTUgdGVtcGxhdGUgc3RyaW5ncy4gQ2hhbmdlIHRoZVxuICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgdGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgYGRhdGFgIHByb3BlcnR5IHZhbHVlcyB0byBiZSBIVE1MLWVzY2FwZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdlc2NhcGUnOiByZUVzY2FwZSxcblxuICAvKipcbiAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICovXG4gICdldmFsdWF0ZSc6IHJlRXZhbHVhdGUsXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqL1xuICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlZmVyZW5jZSB0aGUgZGF0YSBvYmplY3QgaW4gdGhlIHRlbXBsYXRlIHRleHQuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gICd2YXJpYWJsZSc6ICcnLFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gICdpbXBvcnRzJzoge1xuXG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuICAgICdfJzogeyAnZXNjYXBlJzogZXNjYXBlIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVTZXR0aW5ncztcbiIsImltcG9ydCBiYXNlVG9TdHJpbmcgZnJvbSAnLi9fYmFzZVRvU3RyaW5nLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b1N0cmluZztcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIuZmxhdHBpY2tyLWNhbGVuZGFyIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgb3BhY2l0eTogMDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICBwYWRkaW5nOiAwO1xcbiAgLXdlYmtpdC1hbmltYXRpb246IG5vbmU7XFxuICAgICAgICAgIGFuaW1hdGlvbjogbm9uZTtcXG4gIGRpcmVjdGlvbjogbHRyO1xcbiAgYm9yZGVyOiAwO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgbGluZS1oZWlnaHQ6IDI0cHg7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogMzA3Ljg3NXB4O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLW1zLXRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xcbiAgICAgIHRvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMXB4IDAgMCAjZTZlNmU2LCAtMXB4IDAgMCAjZTZlNmU2LCAwIDFweCAwICNlNmU2ZTYsIDAgLTFweCAwICNlNmU2ZTYsIDAgM3B4IDEzcHggcmdiYSgwLDAsMCwwLjA4KTtcXG4gICAgICAgICAgYm94LXNoYWRvdzogMXB4IDAgMCAjZTZlNmU2LCAtMXB4IDAgMCAjZTZlNmU2LCAwIDFweCAwICNlNmU2ZTYsIDAgLTFweCAwICNlNmU2ZTYsIDAgM3B4IDEzcHggcmdiYSgwLDAsMCwwLjA4KTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5vcGVuLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuaW5saW5lIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBtYXgtaGVpZ2h0OiA2NDBweDtcXG4gIHZpc2liaWxpdHk6IHZpc2libGU7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIub3BlbiB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB6LWluZGV4OiA5OTk5OTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hbmltYXRlLm9wZW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGZwRmFkZUluRG93biAzMDBtcyBjdWJpYy1iZXppZXIoMC4yMywgMSwgMC4zMiwgMSk7XFxuICAgICAgICAgIGFuaW1hdGlvbjogZnBGYWRlSW5Eb3duIDMwMG1zIGN1YmljLWJlemllcigwLjIzLCAxLCAwLjMyLCAxKTtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5pbmxpbmUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB0b3A6IDJweDtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5zdGF0aWMge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiBjYWxjKDEwMCUgKyAycHgpO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLnN0YXRpYy5vcGVuIHtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLm11bHRpTW9udGggLmZsYXRwaWNrci1kYXlzIC5kYXlDb250YWluZXI6bnRoLWNoaWxkKG4rMSkgLmZsYXRwaWNrci1kYXkuaW5SYW5nZTpudGgtY2hpbGQoN24rNykge1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IG5vbmUgIWltcG9ydGFudDtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5tdWx0aU1vbnRoIC5mbGF0cGlja3ItZGF5cyAuZGF5Q29udGFpbmVyOm50aC1jaGlsZChuKzIpIC5mbGF0cGlja3ItZGF5LmluUmFuZ2U6bnRoLWNoaWxkKDduKzEpIHtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogLTJweCAwIDAgI2U2ZTZlNiwgNXB4IDAgMCAjZTZlNmU2O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAtMnB4IDAgMCAjZTZlNmU2LCA1cHggMCAwICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIgLmhhc1dlZWtzIC5kYXlDb250YWluZXIsXFxuLmZsYXRwaWNrci1jYWxlbmRhciAuaGFzVGltZSAuZGF5Q29udGFpbmVyIHtcXG4gIGJvcmRlci1ib3R0b206IDA7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogMDtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIgLmhhc1dlZWtzIC5kYXlDb250YWluZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDA7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuaGFzVGltZSAuZmxhdHBpY2tyLXRpbWUge1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIubm9DYWxlbmRhci5oYXNUaW1lIC5mbGF0cGlja3ItdGltZSB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXI6YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXI6YWZ0ZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gIGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuICBjb250ZW50OiAnJztcXG4gIGhlaWdodDogMDtcXG4gIHdpZHRoOiAwO1xcbiAgbGVmdDogMjJweDtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5yaWdodE1vc3Q6YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dSaWdodDpiZWZvcmUsXFxuLmZsYXRwaWNrci1jYWxlbmRhci5yaWdodE1vc3Q6YWZ0ZXIsXFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd1JpZ2h0OmFmdGVyIHtcXG4gIGxlZnQ6IGF1dG87XFxuICByaWdodDogMjJweDtcXG59XFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd0NlbnRlcjpiZWZvcmUsXFxuLmZsYXRwaWNrci1jYWxlbmRhci5hcnJvd0NlbnRlcjphZnRlciB7XFxuICBsZWZ0OiA1MCU7XFxuICByaWdodDogNTAlO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyOmJlZm9yZSB7XFxuICBib3JkZXItd2lkdGg6IDVweDtcXG4gIG1hcmdpbjogMCAtNXB4O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyOmFmdGVyIHtcXG4gIGJvcmRlci13aWR0aDogNHB4O1xcbiAgbWFyZ2luOiAwIC00cHg7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dUb3A6YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dUb3A6YWZ0ZXIge1xcbiAgYm90dG9tOiAxMDAlO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93VG9wOmJlZm9yZSB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93VG9wOmFmdGVyIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICNmZmY7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dCb3R0b206YmVmb3JlLFxcbi5mbGF0cGlja3ItY2FsZW5kYXIuYXJyb3dCb3R0b206YWZ0ZXIge1xcbiAgdG9wOiAxMDAlO1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93Qm90dG9tOmJlZm9yZSB7XFxuICBib3JkZXItdG9wLWNvbG9yOiAjZTZlNmU2O1xcbn1cXG4uZmxhdHBpY2tyLWNhbGVuZGFyLmFycm93Qm90dG9tOmFmdGVyIHtcXG4gIGJvcmRlci10b3AtY29sb3I6ICNmZmY7XFxufVxcbi5mbGF0cGlja3ItY2FsZW5kYXI6Zm9jdXMge1xcbiAgb3V0bGluZTogMDtcXG59XFxuLmZsYXRwaWNrci13cmFwcGVyIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLmZsYXRwaWNrci1tb250aHMge1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbW9udGgge1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogcmdiYSgwLDAsMCwwLjkpO1xcbiAgZmlsbDogcmdiYSgwLDAsMCwwLjkpO1xcbiAgaGVpZ2h0OiAzNHB4O1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxuICAtd2Via2l0LWZsZXg6IDE7XFxuICAgICAgLW1zLWZsZXg6IDE7XFxuICAgICAgICAgIGZsZXg6IDE7XFxufVxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItcHJldi1tb250aCxcXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW5leHQtbW9udGgge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAwO1xcbiAgaGVpZ2h0OiAzNHB4O1xcbiAgcGFkZGluZzogMTBweDtcXG4gIHotaW5kZXg6IDM7XFxuICBjb2xvcjogcmdiYSgwLDAsMCwwLjkpO1xcbiAgZmlsbDogcmdiYSgwLDAsMCwwLjkpO1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGguZmxhdHBpY2tyLWRpc2FibGVkLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aC5mbGF0cGlja3ItZGlzYWJsZWQge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoIGksXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoIGkge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGguZmxhdHBpY2tyLXByZXYtbW9udGgsXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoLmZsYXRwaWNrci1wcmV2LW1vbnRoIHtcXG4vKlxcbiAgICAgIC8qcnRsOmJlZ2luOmlnbm9yZSovXFxuLypcXG4gICAgICAqL1xcbiAgbGVmdDogMDtcXG4vKlxcbiAgICAgIC8qcnRsOmVuZDppZ25vcmUqL1xcbi8qXFxuICAgICAgKi9cXG59XFxuLypcXG4gICAgICAvKnJ0bDpiZWdpbjppZ25vcmUqL1xcbi8qXFxuICAgICAgLypydGw6ZW5kOmlnbm9yZSovXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoLmZsYXRwaWNrci1uZXh0LW1vbnRoLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aC5mbGF0cGlja3ItbmV4dC1tb250aCB7XFxuLypcXG4gICAgICAvKnJ0bDpiZWdpbjppZ25vcmUqL1xcbi8qXFxuICAgICAgKi9cXG4gIHJpZ2h0OiAwO1xcbi8qXFxuICAgICAgLypydGw6ZW5kOmlnbm9yZSovXFxuLypcXG4gICAgICAqL1xcbn1cXG4vKlxcbiAgICAgIC8qcnRsOmJlZ2luOmlnbm9yZSovXFxuLypcXG4gICAgICAvKnJ0bDplbmQ6aWdub3JlKi9cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGg6aG92ZXIsXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoOmhvdmVyIHtcXG4gIGNvbG9yOiAjOTU5ZWE5O1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGg6aG92ZXIgc3ZnLFxcbi5mbGF0cGlja3ItbW9udGhzIC5mbGF0cGlja3ItbmV4dC1tb250aDpob3ZlciBzdmcge1xcbiAgZmlsbDogI2Y2NDc0NztcXG59XFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1wcmV2LW1vbnRoIHN2ZyxcXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLW5leHQtbW9udGggc3ZnIHtcXG4gIHdpZHRoOiAxNHB4O1xcbiAgaGVpZ2h0OiAxNHB4O1xcbn1cXG4uZmxhdHBpY2tyLW1vbnRocyAuZmxhdHBpY2tyLXByZXYtbW9udGggc3ZnIHBhdGgsXFxuLmZsYXRwaWNrci1tb250aHMgLmZsYXRwaWNrci1uZXh0LW1vbnRoIHN2ZyBwYXRoIHtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogZmlsbCAwLjFzO1xcbiAgdHJhbnNpdGlvbjogZmlsbCAwLjFzO1xcbiAgZmlsbDogaW5oZXJpdDtcXG59XFxuLm51bUlucHV0V3JhcHBlciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgaW5wdXQsXFxuLm51bUlucHV0V3JhcHBlciBzcGFuIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuLm51bUlucHV0V3JhcHBlciBpbnB1dCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLm51bUlucHV0V3JhcHBlciBpbnB1dDo6LW1zLWNsZWFyIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgaW5wdXQ6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24sXFxuLm51bUlucHV0V3JhcHBlciBpbnB1dDo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XFxuICBtYXJnaW46IDA7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3BhbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHdpZHRoOiAxNHB4O1xcbiAgcGFkZGluZzogMCA0cHggMCAycHg7XFxuICBoZWlnaHQ6IDUwJTtcXG4gIGxpbmUtaGVpZ2h0OiA1MCU7XFxuICBvcGFjaXR5OiAwO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSg1Nyw1Nyw1NywwLjE1KTtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4xKTtcXG59XFxuLm51bUlucHV0V3JhcHBlciBzcGFuOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuMik7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3BhbjphZnRlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dVcCB7XFxuICB0b3A6IDA7XFxuICBib3JkZXItYm90dG9tOiAwO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dVcDphZnRlciB7XFxuICBib3JkZXItbGVmdDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXJpZ2h0OiA0cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItYm90dG9tOiA0cHggc29saWQgcmdiYSg1Nyw1Nyw1NywwLjYpO1xcbiAgdG9wOiAyNiU7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3Bhbi5hcnJvd0Rvd24ge1xcbiAgdG9wOiA1MCU7XFxufVxcbi5udW1JbnB1dFdyYXBwZXIgc3Bhbi5hcnJvd0Rvd246YWZ0ZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDRweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yaWdodDogNHB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXRvcDogNHB4IHNvbGlkIHJnYmEoNTcsNTcsNTcsMC42KTtcXG4gIHRvcDogNDAlO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4gc3ZnIHtcXG4gIHdpZHRoOiBpbmhlcml0O1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyIHNwYW4gc3ZnIHBhdGgge1xcbiAgZmlsbDogcmdiYSgwLDAsMCwwLjUpO1xcbn1cXG4ubnVtSW5wdXRXcmFwcGVyOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4wNSk7XFxufVxcbi5udW1JbnB1dFdyYXBwZXI6aG92ZXIgc3BhbiB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG4uZmxhdHBpY2tyLWN1cnJlbnQtbW9udGgge1xcbiAgZm9udC1zaXplOiAxMzUlO1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogMzAwO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB3aWR0aDogNzUlO1xcbiAgbGVmdDogMTIuNSU7XFxuICBwYWRkaW5nOiA3LjQ4cHggMCAwIDA7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIGhlaWdodDogMzRweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KTtcXG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KTtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIHNwYW4uY3VyLW1vbnRoIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgbWFyZ2luLWxlZnQ6IDAuNWNoO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIHNwYW4uY3VyLW1vbnRoOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4wNSk7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAubnVtSW5wdXRXcmFwcGVyIHtcXG4gIHdpZHRoOiA2Y2g7XFxuICB3aWR0aDogN2NoXFxcXDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dVcDphZnRlciB7XFxuICBib3JkZXItYm90dG9tLWNvbG9yOiByZ2JhKDAsMCwwLDAuOSk7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dEb3duOmFmdGVyIHtcXG4gIGJvcmRlci10b3AtY29sb3I6IHJnYmEoMCwwLDAsMC45KTtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIGlucHV0LmN1ci15ZWFyIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBjdXJzb3I6IHRleHQ7XFxuICBwYWRkaW5nOiAwIDAgMCAwLjVjaDtcXG4gIG1hcmdpbjogMDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgYm9yZGVyOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIHZlcnRpY2FsLWFsaWduOiBpbml0aWFsO1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxuICAtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG4gIGFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIGlucHV0LmN1ci15ZWFyOmZvY3VzIHtcXG4gIG91dGxpbmU6IDA7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCBpbnB1dC5jdXIteWVhcltkaXNhYmxlZF0sXFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIGlucHV0LmN1ci15ZWFyW2Rpc2FibGVkXTpob3ZlciB7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICBjb2xvcjogcmdiYSgwLDAsMCwwLjUpO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIC5mbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aHMge1xcbiAgYXBwZWFyYW5jZTogbWVudWxpc3Q7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XFxuICBoZWlnaHQ6IGF1dG87XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIG1hcmdpbjogLTFweCAwIDAgMDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBwYWRkaW5nOiAwIDAgMCAwLjVjaDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBpbml0aWFsO1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBtZW51bGlzdDtcXG4gIC1tb3otYXBwZWFyYW5jZTogbWVudWxpc3Q7XFxuICB3aWR0aDogYXV0bztcXG59XFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIC5mbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aHM6Zm9jdXMsXFxuLmZsYXRwaWNrci1jdXJyZW50LW1vbnRoIC5mbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aHM6YWN0aXZlIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwwLDAsMC4wNSk7XFxufVxcbi5mbGF0cGlja3ItY3VycmVudC1tb250aCAuZmxhdHBpY2tyLW1vbnRoRHJvcGRvd24tbW9udGhzIC5mbGF0cGlja3ItbW9udGhEcm9wZG93bi1tb250aCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4uZmxhdHBpY2tyLXdlZWtkYXlzIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBoZWlnaHQ6IDI4cHg7XFxufVxcbi5mbGF0cGlja3Itd2Vla2RheXMgLmZsYXRwaWNrci13ZWVrZGF5Y29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG59XFxuc3Bhbi5mbGF0cGlja3Itd2Vla2RheSB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICBmb250LXNpemU6IDkwJTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHJnYmEoMCwwLDAsMC41NCk7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIG1hcmdpbjogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcbi5kYXlDb250YWluZXIsXFxuLmZsYXRwaWNrci13ZWVrcyB7XFxuICBwYWRkaW5nOiAxcHggMCAwIDA7XFxufVxcbi5mbGF0cGlja3ItZGF5cyB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1hbGlnbjogc3RhcnQ7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICAgIC1tcy1mbGV4LWFsaWduOiBzdGFydDtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxuICB3aWR0aDogMzA3Ljg3NXB4O1xcbn1cXG4uZmxhdHBpY2tyLWRheXM6Zm9jdXMge1xcbiAgb3V0bGluZTogMDtcXG59XFxuLmRheUNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAwO1xcbiAgb3V0bGluZTogMDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICB3aWR0aDogMzA3Ljg3NXB4O1xcbiAgbWluLXdpZHRoOiAzMDcuODc1cHg7XFxuICBtYXgtd2lkdGg6IDMwNy44NzVweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1mbGV4LXdyYXA6IHdyYXA7XFxuICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gIC1tcy1mbGV4LXdyYXA6IHdyYXA7XFxuICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCk7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG4uZGF5Q29udGFpbmVyICsgLmRheUNvbnRhaW5lciB7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IC0xcHggMCAwICNlNmU2ZTY7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IC0xcHggMCAwICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3ItZGF5IHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1yYWRpdXM6IDE1MHB4O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgY29sb3I6ICMzOTM5Mzk7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgd2lkdGg6IDE0LjI4NTcxNDMlO1xcbiAgLXdlYmtpdC1mbGV4LWJhc2lzOiAxNC4yODU3MTQzJTtcXG4gICAgICAtbXMtZmxleC1wcmVmZXJyZWQtc2l6ZTogMTQuMjg1NzE0MyU7XFxuICAgICAgICAgIGZsZXgtYmFzaXM6IDE0LjI4NTcxNDMlO1xcbiAgbWF4LXdpZHRoOiAzOXB4O1xcbiAgaGVpZ2h0OiAzOXB4O1xcbiAgbGluZS1oZWlnaHQ6IDM5cHg7XFxuICBtYXJnaW46IDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxuICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5mbGF0cGlja3ItZGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkucHJldk1vbnRoRGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkubmV4dE1vbnRoRGF5LmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkudG9kYXkuaW5SYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5wcmV2TW9udGhEYXkudG9kYXkuaW5SYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5uZXh0TW9udGhEYXkudG9kYXkuaW5SYW5nZSxcXG4uZmxhdHBpY2tyLWRheTpob3ZlcixcXG4uZmxhdHBpY2tyLWRheS5wcmV2TW9udGhEYXk6aG92ZXIsXFxuLmZsYXRwaWNrci1kYXkubmV4dE1vbnRoRGF5OmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5OmZvY3VzLFxcbi5mbGF0cGlja3ItZGF5LnByZXZNb250aERheTpmb2N1cyxcXG4uZmxhdHBpY2tyLWRheS5uZXh0TW9udGhEYXk6Zm9jdXMge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgb3V0bGluZTogMDtcXG4gIGJhY2tncm91bmQ6ICNlNmU2ZTY7XFxuICBib3JkZXItY29sb3I6ICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3ItZGF5LnRvZGF5IHtcXG4gIGJvcmRlci1jb2xvcjogIzk1OWVhOTtcXG59XFxuLmZsYXRwaWNrci1kYXkudG9kYXk6aG92ZXIsXFxuLmZsYXRwaWNrci1kYXkudG9kYXk6Zm9jdXMge1xcbiAgYm9yZGVyLWNvbG9yOiAjOTU5ZWE5O1xcbiAgYmFja2dyb3VuZDogIzk1OWVhOTtcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZCxcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkLmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZS5pblJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlLmluUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQ6Zm9jdXMsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZTpmb2N1cyxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZTpmb2N1cyxcXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZDpob3ZlcixcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlOmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlOmhvdmVyLFxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkLnByZXZNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlLnByZXZNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5wcmV2TW9udGhEYXksXFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQubmV4dE1vbnRoRGF5LFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2UubmV4dE1vbnRoRGF5LFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlLm5leHRNb250aERheSB7XFxuICBiYWNrZ3JvdW5kOiAjNTY5ZmY3O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgY29sb3I6ICNmZmY7XFxuICBib3JkZXItY29sb3I6ICM1NjlmZjc7XFxufVxcbi5mbGF0cGlja3ItZGF5LnNlbGVjdGVkLnN0YXJ0UmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZS5zdGFydFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlLnN0YXJ0UmFuZ2Uge1xcbiAgYm9yZGVyLXJhZGl1czogNTBweCAwIDAgNTBweDtcXG59XFxuLmZsYXRwaWNrci1kYXkuc2VsZWN0ZWQuZW5kUmFuZ2UsXFxuLmZsYXRwaWNrci1kYXkuc3RhcnRSYW5nZS5lbmRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5lbmRSYW5nZSB7XFxuICBib3JkZXItcmFkaXVzOiAwIDUwcHggNTBweCAwO1xcbn1cXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZC5zdGFydFJhbmdlICsgLmVuZFJhbmdlOm5vdCg6bnRoLWNoaWxkKDduKzEpKSxcXG4uZmxhdHBpY2tyLWRheS5zdGFydFJhbmdlLnN0YXJ0UmFuZ2UgKyAuZW5kUmFuZ2U6bm90KDpudGgtY2hpbGQoN24rMSkpLFxcbi5mbGF0cGlja3ItZGF5LmVuZFJhbmdlLnN0YXJ0UmFuZ2UgKyAuZW5kUmFuZ2U6bm90KDpudGgtY2hpbGQoN24rMSkpIHtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogLTEwcHggMCAwICM1NjlmZjc7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IC0xMHB4IDAgMCAjNTY5ZmY3O1xcbn1cXG4uZmxhdHBpY2tyLWRheS5zZWxlY3RlZC5zdGFydFJhbmdlLmVuZFJhbmdlLFxcbi5mbGF0cGlja3ItZGF5LnN0YXJ0UmFuZ2Uuc3RhcnRSYW5nZS5lbmRSYW5nZSxcXG4uZmxhdHBpY2tyLWRheS5lbmRSYW5nZS5zdGFydFJhbmdlLmVuZFJhbmdlIHtcXG4gIGJvcmRlci1yYWRpdXM6IDUwcHg7XFxufVxcbi5mbGF0cGlja3ItZGF5LmluUmFuZ2Uge1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogLTVweCAwIDAgI2U2ZTZlNiwgNXB4IDAgMCAjZTZlNmU2O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAtNXB4IDAgMCAjZTZlNmU2LCA1cHggMCAwICNlNmU2ZTY7XFxufVxcbi5mbGF0cGlja3ItZGF5LmZsYXRwaWNrci1kaXNhYmxlZCxcXG4uZmxhdHBpY2tyLWRheS5mbGF0cGlja3ItZGlzYWJsZWQ6aG92ZXIsXFxuLmZsYXRwaWNrci1kYXkucHJldk1vbnRoRGF5LFxcbi5mbGF0cGlja3ItZGF5Lm5leHRNb250aERheSxcXG4uZmxhdHBpY2tyLWRheS5ub3RBbGxvd2VkLFxcbi5mbGF0cGlja3ItZGF5Lm5vdEFsbG93ZWQucHJldk1vbnRoRGF5LFxcbi5mbGF0cGlja3ItZGF5Lm5vdEFsbG93ZWQubmV4dE1vbnRoRGF5IHtcXG4gIGNvbG9yOiByZ2JhKDU3LDU3LDU3LDAuMyk7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5mbGF0cGlja3ItZGF5LmZsYXRwaWNrci1kaXNhYmxlZCxcXG4uZmxhdHBpY2tyLWRheS5mbGF0cGlja3ItZGlzYWJsZWQ6aG92ZXIge1xcbiAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIGNvbG9yOiByZ2JhKDU3LDU3LDU3LDAuMSk7XFxufVxcbi5mbGF0cGlja3ItZGF5LndlZWsuc2VsZWN0ZWQge1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogLTVweCAwIDAgIzU2OWZmNywgNXB4IDAgMCAjNTY5ZmY3O1xcbiAgICAgICAgICBib3gtc2hhZG93OiAtNXB4IDAgMCAjNTY5ZmY3LCA1cHggMCAwICM1NjlmZjc7XFxufVxcbi5mbGF0cGlja3ItZGF5LmhpZGRlbiB7XFxuICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcbi5yYW5nZU1vZGUgLmZsYXRwaWNrci1kYXkge1xcbiAgbWFyZ2luLXRvcDogMXB4O1xcbn1cXG4uZmxhdHBpY2tyLXdlZWt3cmFwcGVyIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbn1cXG4uZmxhdHBpY2tyLXdlZWt3cmFwcGVyIC5mbGF0cGlja3Itd2Vla3Mge1xcbiAgcGFkZGluZzogMCAxMnB4O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAxcHggMCAwICNlNmU2ZTY7XFxuICAgICAgICAgIGJveC1zaGFkb3c6IDFweCAwIDAgI2U2ZTZlNjtcXG59XFxuLmZsYXRwaWNrci13ZWVrd3JhcHBlciAuZmxhdHBpY2tyLXdlZWtkYXkge1xcbiAgZmxvYXQ6IG5vbmU7XFxuICB3aWR0aDogMTAwJTtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbn1cXG4uZmxhdHBpY2tyLXdlZWt3cmFwcGVyIHNwYW4uZmxhdHBpY2tyLWRheSxcXG4uZmxhdHBpY2tyLXdlZWt3cmFwcGVyIHNwYW4uZmxhdHBpY2tyLWRheTpob3ZlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiBub25lO1xcbiAgY29sb3I6IHJnYmEoNTcsNTcsNTcsMC4zKTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG4uZmxhdHBpY2tyLWlubmVyQ29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG4uZmxhdHBpY2tyLXJDb250YWluZXIge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgcGFkZGluZzogMDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLmZsYXRwaWNrci10aW1lIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG91dGxpbmU6IDA7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGhlaWdodDogMDtcXG4gIGxpbmUtaGVpZ2h0OiA0MHB4O1xcbiAgbWF4LWhlaWdodDogNDBweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcXG4gIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLmZsYXRwaWNrci10aW1lOmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgZGlzcGxheTogdGFibGU7XFxuICBjbGVhcjogYm90aDtcXG59XFxuLmZsYXRwaWNrci10aW1lIC5udW1JbnB1dFdyYXBwZXIge1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIHdpZHRoOiA0MCU7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBmbG9hdDogbGVmdDtcXG59XFxuLmZsYXRwaWNrci10aW1lIC5udW1JbnB1dFdyYXBwZXIgc3Bhbi5hcnJvd1VwOmFmdGVyIHtcXG4gIGJvcmRlci1ib3R0b20tY29sb3I6ICMzOTM5Mzk7XFxufVxcbi5mbGF0cGlja3ItdGltZSAubnVtSW5wdXRXcmFwcGVyIHNwYW4uYXJyb3dEb3duOmFmdGVyIHtcXG4gIGJvcmRlci10b3AtY29sb3I6ICMzOTM5Mzk7XFxufVxcbi5mbGF0cGlja3ItdGltZS5oYXNTZWNvbmRzIC5udW1JbnB1dFdyYXBwZXIge1xcbiAgd2lkdGg6IDI2JTtcXG59XFxuLmZsYXRwaWNrci10aW1lLnRpbWUyNGhyIC5udW1JbnB1dFdyYXBwZXIge1xcbiAgd2lkdGg6IDQ5JTtcXG59XFxuLmZsYXRwaWNrci10aW1lIGlucHV0IHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xcbiAgYm9yZGVyOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBoZWlnaHQ6IGluaGVyaXQ7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIGNvbG9yOiAjMzkzOTM5O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiB0ZXh0ZmllbGQ7XFxuICAtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG4gIGFwcGVhcmFuY2U6IHRleHRmaWVsZDtcXG59XFxuLmZsYXRwaWNrci10aW1lIGlucHV0LmZsYXRwaWNrci1ob3VyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uZmxhdHBpY2tyLXRpbWUgaW5wdXQuZmxhdHBpY2tyLW1pbnV0ZSxcXG4uZmxhdHBpY2tyLXRpbWUgaW5wdXQuZmxhdHBpY2tyLXNlY29uZCB7XFxuICBmb250LXdlaWdodDogNDAwO1xcbn1cXG4uZmxhdHBpY2tyLXRpbWUgaW5wdXQ6Zm9jdXMge1xcbiAgb3V0bGluZTogMDtcXG4gIGJvcmRlcjogMDtcXG59XFxuLmZsYXRwaWNrci10aW1lIC5mbGF0cGlja3ItdGltZS1zZXBhcmF0b3IsXFxuLmZsYXRwaWNrci10aW1lIC5mbGF0cGlja3ItYW0tcG0ge1xcbiAgaGVpZ2h0OiBpbmhlcml0O1xcbiAgZmxvYXQ6IGxlZnQ7XFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gIGNvbG9yOiAjMzkzOTM5O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICB3aWR0aDogMiU7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xcbiAgLXdlYmtpdC1hbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgICAgLW1zLWZsZXgtaXRlbS1hbGlnbjogY2VudGVyO1xcbiAgICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxufVxcbi5mbGF0cGlja3ItdGltZSAuZmxhdHBpY2tyLWFtLXBtIHtcXG4gIG91dGxpbmU6IDA7XFxuICB3aWR0aDogMTglO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuLmZsYXRwaWNrci10aW1lIGlucHV0OmhvdmVyLFxcbi5mbGF0cGlja3ItdGltZSAuZmxhdHBpY2tyLWFtLXBtOmhvdmVyLFxcbi5mbGF0cGlja3ItdGltZSBpbnB1dDpmb2N1cyxcXG4uZmxhdHBpY2tyLXRpbWUgLmZsYXRwaWNrci1hbS1wbTpmb2N1cyB7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbn1cXG4uZmxhdHBpY2tyLWlucHV0W3JlYWRvbmx5XSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBmcEZhZGVJbkRvd24ge1xcbiAgZnJvbSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMjBweCwgMCk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAtMjBweCwgMCk7XFxuICB9XFxuICB0byB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbiAgfVxcbn1cXG5Aa2V5ZnJhbWVzIGZwRmFkZUluRG93biB7XFxuICBmcm9tIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0yMHB4LCAwKTtcXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIC0yMHB4LCAwKTtcXG4gIH1cXG4gIHRvIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxuICB9XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qXFxyXFxuKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cXHJcXG4qIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cXHJcXG4qXFxyXFxuKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxcclxcbiogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXFxyXFxuKi9cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtcmlnaHQsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLXJpZ2h0IC5hZy1jZWxsLXZhbHVlLFxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1yaWdodCAudGVtcGxhdGVSZW5kZXJlciB7XFxyXFxuICB0ZXh0LWFsaWduOiByaWdodDtcXHJcXG4gIC13ZWJraXQtYm94LXBhY2s6IGVuZDtcXHJcXG4gICAgICAtbXMtZmxleC1wYWNrOiBlbmQ7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxyXFxuICAtd2Via2l0LWJveC1mbGV4OiAxO1xcclxcbiAgICAgIC1tcy1mbGV4OiAxO1xcclxcbiAgICAgICAgICBmbGV4OiAxO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyLFxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1jZW50ZXIgLmFnLWNlbGwtdmFsdWUsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLWNlbnRlciAudGVtcGxhdGVSZW5kZXJlciB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAtd2Via2l0LWJveC1wYWNrOiBjZW50ZXI7XFxyXFxuICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xcclxcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIC13ZWJraXQtYm94LWZsZXg6IDE7XFxyXFxuICAgICAgLW1zLWZsZXg6IDE7XFxyXFxuICAgICAgICAgIGZsZXg6IDE7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1yaWdodCAuYm9vbFN3aXRjaCxcXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyIC5ib29sU3dpdGNoIHtcXHJcXG4gIHRleHQtYWxpZ246IGluaXRpYWw7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtY2VsbC1jZW50ZXIgLmJvb2xTd2l0Y2hfX3dyYXBwZXIsXFxyXFxuLmd3LWFsaWdubWVudC1jZWxsLXJpZ2h0IC5ib29sU3dpdGNoX193cmFwcGVyIHtcXHJcXG4gIHdpZHRoOiBhdXRvO1xcclxcbiAgaGVpZ2h0OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtY2VudGVyIC5ib29sU3dpdGNoX193cmFwcGVyIHtcXHJcXG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXHJcXG4gICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWNlbGwtcmlnaHQgLmJvb2xTd2l0Y2hfX3dyYXBwZXIge1xcclxcbiAgLXdlYmtpdC1ib3gtcGFjazogcmlnaHQ7XFxyXFxuICAgICAgLW1zLWZsZXgtcGFjazogcmlnaHQ7XFxyXFxuICAgICAgICAgIGp1c3RpZnktY29udGVudDogcmlnaHQ7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLXJpZ2h0IC5hZy1oZWFkZXItY2VsbC1sYWJlbCB7XFxyXFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxyXFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IHJldmVyc2U7XFxyXFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcXHJcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctYWxpZ25tZW50LWhlYWRlci1jZW50ZXIgLmFnLWhlYWRlci1jZWxsLWxhYmVsIHtcXHJcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcclxcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgLXdlYmtpdC1ib3gtcGFjazogY2VudGVyO1xcclxcbiAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcXHJcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLWNlbnRlciAuYWctaGVhZGVyLWNlbGwtdGV4dCB7XFxyXFxuICBtYXJnaW4tbGVmdDogLTE2cHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmd3LWFsaWdubWVudC1oZWFkZXItcmlnaHQgLmFnLWNlbGwtbGFiZWwtY29udGFpbmVyLFxcclxcbi5ndy1hbGlnbm1lbnQtaGVhZGVyLWNlbnRlciAuYWctY2VsbC1sYWJlbC1jb250YWluZXIge1xcclxcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcclxcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxyXFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxyXFxufVxcclxcblxcclxcbi5ndy10b29sdGlwIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXHJcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAxcztcXHJcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XFxyXFxuICBib3JkZXItcmFkaXVzOiAzLjFweDtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG9wYWNpdHkgMjYwbXM7XFxyXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDI2MG1zO1xcclxcbn1cXHJcXG5cXHJcXG4uZ3ctdG9vbHRpcC1saWdodCB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDZweCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNnB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxyXFxufVxcclxcblxcclxcbi5ndy10b29sdGlwLWRhcmsge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFjMWYyMDtcXHJcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAwIDZweCAjNWM1YzVjO1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgNnB4ICM1YzVjNWM7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxufVxcclxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi5hdXRvY29tcGxldGVJbnB1dFdyYXBwZXJfX2lucHV0IHtcXHJcXG4gIHBhZGRpbmctbGVmdDogNnB4O1xcclxcbiAgYm9yZGVyOiB0aGluIHNvbGlkIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywgMTUwLCAyNDMsIDAuNCkpO1xcclxcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvcik7XFxyXFxuICBjb2xvcjogaW5oZXJpdDtcXHJcXG4gIG91dGxpbmU6IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi5hZy10aGVtZS1hbHBpbmUgLmF1dG9jb21wbGV0ZUlucHV0V3JhcHBlcl9faW5wdXQsXFxyXFxuLmFnLXRoZW1lLWJhbGhhbSAuYXV0b2NvbXBsZXRlSW5wdXRXcmFwcGVyX19pbnB1dCxcXHJcXG4uYWctdGhlbWUtbWF0ZXJpYWwgLmF1dG9jb21wbGV0ZUlucHV0V3JhcHBlcl9faW5wdXQge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7XFxyXFxufVxcclxcblxcclxcbi5hZy10aGVtZS1hbHBpbmUtZGFyayAuYXV0b2NvbXBsZXRlSW5wdXRXcmFwcGVyX19pbnB1dCxcXHJcXG4uYWctdGhlbWUtYmFsaGFtLWRhcmsgLmF1dG9jb21wbGV0ZUlucHV0V3JhcHBlcl9faW5wdXQge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzJkMzQzNik7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgI2ZmZik7XFxyXFxuICB6LWluZGV4OiAxMDAwO1xcclxcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcbiAgYm9yZGVyOiB0aGluIHNvbGlkIHZhcigtLWFnLWlucHV0LWZvY3VzLWJvcmRlci1jb2xvciwgcmdiYSgzMywgMTUwLCAyNDMsIDAuNCkpO1xcclxcbiAgYm9yZGVyLXRvcDogMDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDNweDtcXHJcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDA7XFxyXFxuICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMDtcXHJcXG4gIG92ZXJmbG93OiBhdXRvO1xcclxcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwcHggM3B4IDE1cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwcHggM3B4IDE1cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlLmRhcmsge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgIzJkMzQzNik7XFxyXFxuICBjb2xvcjogdmFyKC0tYWctZGF0YS1jb2xvciwgdmFyKC0tYWctZm9yZWdyb3VuZC1jb2xvciwgI2ZmZikpO1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlIC5zdWdnZXN0aW9uLWdyb3VwIHtcXHJcXG4gIGJhY2tncm91bmQ6ICNlZWU7XFxyXFxuICBwYWRkaW5nOiA1cHggNnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUuZGFyayAuc3VnZ2VzdGlvbi1ncm91cCB7XFxyXFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1hZy1iYWNrZ3JvdW5kLWNvbG9yLCAjMTgxZDFmKTtcXHJcXG59XFxyXFxuXFxyXFxuLmF1dG9jb21wbGV0ZSAuc3VnZ2VzdGlvbi1pdGVtIHtcXHJcXG4gIHBhZGRpbmc6IDEwcHg7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUgLnN1Z2dlc3Rpb24taXRlbTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1yb3ctaG92ZXItY29sb3IsIHJnYmEoMzMsIDE1MCwgMjQ0LCAwLjEpKTtcXHJcXG59XFxyXFxuXFxyXFxuLmF1dG9jb21wbGV0ZSAuc3VnZ2VzdGlvbi1pdGVtLnNlbGVjdGVkIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcihcXHJcXG4gICAgLS1hZy1zZWxlY3RlZC1yb3ctYmFja2dyb3VuZC1jb2xvcixcXHJcXG4gICAgcmdiYSgzMywgMTUwLCAyNDMsIDAuMylcXHJcXG4gICk7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUgLmVtcHR5IHtcXHJcXG4gIHBhZGRpbmc6IDhweCA2cHg7XFxyXFxufVxcclxcblxcclxcbi5hdXRvY29tcGxldGUtaW5wdXQtZXJyb3Ige1xcclxcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIC0ycHggMCAjZTkxZTYzIGluc2V0O1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIC0ycHggMCAjZTkxZTYzIGluc2V0O1xcclxcbn1cXHJcXG5cXHJcXG4uYXV0b2NvbXBsZXRlLWlucHV0LXN1Y2Nlc3Mge1xcclxcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIC0ycHggMCAjNGNhZjUwIGluc2V0O1xcclxcbiAgICAgICAgICBib3gtc2hhZG93OiAwIC0ycHggMCAjNGNhZjUwIGluc2V0O1xcclxcbn1cXHJcXG5cIiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcGFzc2luZyBmdW5jdGlvbiBpbiBvcHRpb25zLCB0aGVuIHVzZSBpdCBmb3IgcmVzb2x2ZSBcImhlYWRcIiBlbGVtZW50LlxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBmb3IgU2hhZG93IFJvb3Qgc3R5bGUgaS5lXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gKCkgeyByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb29cIikuc2hhZG93Um9vdCB9XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHR2YXIgc3R5bGVUYXJnZXQgPSBnZXRUYXJnZXQuY2FsbCh0aGlzLCB0YXJnZXQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8gKyBcIiBcIiArIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cbiIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvfFxccyokKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19wYXJzZU5vZGUgfSBmcm9tICdldmVudHMvdXRpbGl0aWVzJ1xyXG5cclxuY29uc3QgeyBkZWVwUGFyc2VKc29uIH0gPSByZXF1aXJlKCdkZWVwLXBhcnNlLWpzb24nKVxyXG5cclxuLyoqXHJcbiAqIFN0YXJ0IGNlbGwgZWRpdGluZ1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xudW1iZXJ9IHJvdyBUaGUgcm93IGluZGV4IG9yIGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sS2V5IFRoZSBjb2x1bW4ncyBrZXlcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBrZXlQcmVzcyAgS2V5IHByZXNzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjaGFyUHJlc3NcclxuICogQHBhcmFtIHtTdHJpbmd9IHJvd1Bpbm5lZCBTZXQgdG8gJ3RvcCcgb3IgJ2JvdHRvbScgdG8gc3RhcnRlZCBlZGl0aW5nIGEgcGlubmVkIHJvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3N0YXJ0RWRpdGluZ0NlbGwoXHJcbiAgaWQsXHJcbiAgcm93LFxyXG4gIGNvbEtleSxcclxuICBrZXlQcmVzcyxcclxuICBjaGFyUHJlc3MsXHJcbiAgcm93UGlubmVkXHJcbikge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgYXBpID0gb3B0aW9ucy5hcGlcclxuICBjb25zdCBub2RlID0gYXBpLmdldFJvd05vZGUocm93KSB8fCBhcGkuZ2V0RGlzcGxheWVkUm93QXRJbmRleChyb3cpXHJcblxyXG4gIG9wdGlvbnMuYXBpLnN0YXJ0RWRpdGluZ0NlbGwoe1xyXG4gICAgcm93SW5kZXg6IG5vZGUucm93SW5kZXgsXHJcbiAgICBrZXlQcmVzczogTnVtYmVyKGtleVByZXNzKSxcclxuICAgIGNvbEtleSxcclxuICAgIGNoYXJQcmVzcyxcclxuICAgIHJvd1Bpbm5lZCxcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogU3RvcCBjZWxsIGVkaXRpbmdcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtCb29sZWFufSBjYW5jZWwgd2hlbiB0cnVlIGNhbmNlbCBlZGl0cyAsIHNhdmUgZWRpdHMgb3RoZXJ3aXNlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc3RvcEVkaXRpbmcoaWQsIGNhbmNlbCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnN0b3BFZGl0aW5nKGNhbmNlbClcclxufVxyXG5cclxuLyoqXHJcbiAqIE5hdmlnYXRlcyB0aGUgZ3JpZCBmb2N1cyB0byB0aGUgbmV4dCBjZWxsLCBhcyBpZiB0YWJiaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfdGFiVG9OZXh0Q2VsbChpZCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnRhYlRvTmV4dENlbGwoKVxyXG59XHJcblxyXG4vKipcclxuICogTmF2aWdhdGVzIHRoZSBncmlkIGZvY3VzIHRvIHRoZSBwcmV2aW91cyBjZWxsLCBhcyBpZiBzaGlmdC10YWJiaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfdGFiVG9QcmV2aW91c0NlbGwoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS50YWJUb1ByZXZpb3VzQ2VsbCgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgRm9jdXMgb24gdGhlIGdpdmVuIHJvdyBhbmQgY29sdW1uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcm93IFRoZSByb3cncyBpbmRleC9pZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uIFRoZSBjb2x1bW4gaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGZsb2F0aW5nIG51bGwsICd0b3AnLCBvciAnYm90dG9tJy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRGb2N1c2VkQ2VsbChpZCwgcm93LCBjb2x1bW4sIGZsb2F0aW5nID0gbnVsbCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIC8vIGlnbm9yZSBmb2N1cyBjYWxscyBpZiBlZGl0aW5nXHJcbiAgaWYgKG9wdGlvbnMuYXBpLmdldEVkaXRpbmdDZWxscygpLmxlbmd0aCA+IDApIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgbGV0IHIsIGMsIGZcclxuICBpZiAocm93ID09IC0xKSB7XHJcbiAgICAvLyB0cnkgdG8gcmV0YWluIHRoZSBmb2N1c1xyXG4gICAgY29uc3QgbGFzdEZvY3VzZWRDZWxsID0gb3B0aW9ucy5hcGkuZ2V0Rm9jdXNlZENlbGwoKVxyXG5cclxuICAgIGlmIChsYXN0Rm9jdXNlZENlbGwpIHtcclxuICAgICAgciA9IGxhc3RGb2N1c2VkQ2VsbC5yb3dJbmRleFxyXG4gICAgICBjID0gbGFzdEZvY3VzZWRDZWxsLmNvbHVtbi5jb2xJZFxyXG4gICAgICBmID0gbGFzdEZvY3VzZWRDZWxsLnJvd1Bpbm5lZFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IDBcclxuICAgICAgYyA9IG9wdGlvbnMuY29sdW1uQXBpLmdldEFsbEdyaWRDb2x1bW5zKClbMF0uY29sSWRcclxuICAgICAgZiA9IGZsb2F0aW5nXHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHIgPSAhcm93XHJcbiAgICAgID8gMFxyXG4gICAgICA6IE51bWJlci5pc0ludGVnZXIoK3JvdylcclxuICAgICAgPyArcm93XHJcbiAgICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShyb3cpLnJvd0luZGV4XHJcbiAgICBjID0gY29sdW1uID8gY29sdW1uIDogb3B0aW9ucy5jb2x1bW5BcGkuZ2V0QWxsR3JpZENvbHVtbnMoKVswXS5jb2xJZFxyXG4gICAgZiA9IGZsb2F0aW5nXHJcbiAgfVxyXG5cclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zZXRGb2N1c2VkQ2VsbChyLCBjLCBmKVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IFJhbmdlIFNlbGVjdGlvbnNcclxuICpcclxuICogVGhlIG1ldGhvZCB3aWxsIGNyZWF0ZSBhIHJhbmdlIGpzb24gbW9kZWwgZm9yIGVhY2ggcmFuZ2Ugd2hpY2ggY2FuIGJlIHBhcnNlZCBpbiBCQmogc2lkZS5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzZWxlY3RlZCByYW5nZXMgYXMgSlNPTlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFJhbmdlU2VsZWN0aW9ucyhpZCkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dFxyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcbiAgY29uc3QgcmFuZ2VzID0gYXBpLmdldENlbGxSYW5nZXMoKVxyXG4gIGNvbnN0IG1vZGVsID0gYXBpLmdldE1vZGVsKClcclxuICBsZXQgcmVzdWx0ID0gW11cclxuXHJcbiAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xyXG4gICAgLy8gY29uc3Qgc3RhcnQgPSBnd19wYXJzZU5vZGUobW9kZWwuZ2V0Um93KHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4KSwgb3B0aW9ucy5jb250ZXh0KTtcclxuICAgIC8vIGNvbnN0IGVuZCA9IGd3X3BhcnNlTm9kZShtb2RlbC5nZXRSb3cocmFuZ2UuZW5kUm93LnJvd0luZGV4KSwgb3B0aW9ucy5jb250ZXh0KTtcclxuXHJcbiAgICAvL2lmIChzdGFydCAhPT0gZmFsc2UgJiYgZW5kICE9PSBmYWxzZSkge1xyXG4gICAgY29uc3QgY29sdW1ucyA9IHJhbmdlLmNvbHVtbnNcclxuICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICBpZiAoJ2FnLUdyaWQtQXV0b0NvbHVtbicgIT09IGN1cnJlbnQuY29sSWQpIHtcclxuICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY3VycmVudC5jb2xJZClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvclxyXG4gICAgICB9LCBbXSlcclxuICAgICAgLmZpbHRlcihCb29sZWFuKVxyXG5cclxuICAgIGNvbnN0IHN0YXJJbmRleCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4LCByYW5nZS5lbmRSb3cucm93SW5kZXgpXHJcbiAgICBjb25zdCBlbmRJbmRleCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0Um93LnJvd0luZGV4LCByYW5nZS5lbmRSb3cucm93SW5kZXgpXHJcbiAgICBjb25zdCByb3dzID0gW11cclxuXHJcbiAgICBmb3IgKGxldCByb3dJbmRleCA9IHN0YXJJbmRleDsgcm93SW5kZXggPD0gZW5kSW5kZXg7IHJvd0luZGV4KyspIHtcclxuICAgICAgY29uc3Qgbm9kZSA9IG1vZGVsLmdldFJvdyhyb3dJbmRleClcclxuICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBwYXJzZWROb2RlID0gZ3dfcGFyc2VOb2RlKG5vZGUsIGNvbnRleHQpXHJcbiAgICAgICAgaWYgKHBhcnNlZE5vZGUpIHtcclxuICAgICAgICAgIHJvd3MucHVzaChwYXJzZWROb2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChyb3dzLmxlbmd0aCAmJiBjb2x1bW5zLmxlbmd0aCkge1xyXG4gICAgICByZXN1bHQucHVzaCh7IHI6IHJvd3MsIGM6IGNvbHVtbnMgfSlcclxuICAgIH1cclxuICAgIC8vfVxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSB0aGUgY2VsbHMgcmFuZ2UgaW4gYSBmb3JtYXQgdGhlIGdyaWQgY2FuIHVuZGVyc3RhbmQgd2hlbiBpdCBpcyBwYXNzZWRcclxuICogdG8gYGFwaS5hZGRDZWxsUmFuZ2VgXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBncmlkJ3Mgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgIGJvdW5kZWQgb3IgdW5ib3VuZGVkIHJhbmdlIG1vZGVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcGFyc2VBZGRDZWxsUmFuZ2Uob3B0aW9ucywgcmFuZ2UpIHtcclxuICBjb25zdCBwciA9IGRlZXBQYXJzZUpzb24oSlNPTi5zdHJpbmdpZnkocmFuZ2UpKVxyXG4gIGNvbnN0IHN0YXJ0ID0gIShwci5zdGFydCB8fCBudWxsKVxyXG4gICAgPyAwXHJcbiAgICA6IE51bWJlci5pc0ludGVnZXIoK3ByLnN0YXJ0KVxyXG4gICAgPyArcHIuc3RhcnRcclxuICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShwci5zdGFydCkucm93SW5kZXhcclxuICBjb25zdCBlbmQgPSAhKHByLmVuZCB8fCBudWxsKVxyXG4gICAgPyBvcHRpb25zLnJvd0RhdGEubGVuZ3RoIC0gMVxyXG4gICAgOiBOdW1iZXIuaXNJbnRlZ2VyKCtwci5lbmQpXHJcbiAgICA/ICtwci5lbmRcclxuICAgIDogb3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShwci5lbmQpLnJvd0luZGV4XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByb3dTdGFydEluZGV4OiBNYXRoLmFicyhzdGFydCksXHJcbiAgICByb3dFbmRJbmRleDogTWF0aC5hYnMoZW5kKSxcclxuICAgIGNvbHVtbnM6IHByLmNvbHVtbnMsXHJcbiAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgbmV3IGNlbGwgcmFuZ2VcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgIGJvdW5kZWQgb3IgdW5ib3VuZGVkIHJhbmdlIG1vZGVsXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYWRkQ2VsbFJhbmdlKGlkLCByYW5nZSkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgb3B0aW9ucy5hcGkuYWRkQ2VsbFJhbmdlKGd3X3BhcnNlQWRkQ2VsbFJhbmdlKG9wdGlvbnMsIHJhbmdlKSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENsZWFycyB0aGUgc2VsZWN0ZWQgcmFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBncmlkJ3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19jbGVhclJhbmdlU2VsZWN0aW9uKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuY2xlYXJSYW5nZVNlbGVjdGlvbigpXHJcbn1cclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXHJcbi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2dldEdyaWQsIGd3X3V1aWQgfSBmcm9tICdhcGkvdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19wYXJzZUFkZENlbGxSYW5nZSB9IGZyb20gJ2FwaS9jZWxscydcclxuXHJcbmNvbnN0IHsgZGVlcFBhcnNlSnNvbiB9ID0gcmVxdWlyZSgnZGVlcC1wYXJzZS1qc29uJylcclxuXHJcbi8qKlxyXG4gKiBUaGUgYXJyYXkgY29udGFpbnMgcmVmZXJlbmNlcyB0byBjcmVhdGVkIGNoYXJ0cyBmcm9tIEJCai5cclxuICogRXZlcnkgcmVmZXJlbmNlIGlzIGEgQ2hhcnRSZWYgb2JqZWN0IHdoaWNoIHByb3ZpZGVzIHRoZSBhcHBsaWNhdGlvbiB3aXRoIHRoZVxyXG4gKiBkZXN0cm95Q2hhcnQoKSBtZXRob2QgdGhhdCBpcyByZXF1aXJlZCB3aGVuIHRoZSBhcHBsaWNhdGlvbiB3YW50cyB0byBkaXNwb3NlIHRoZSBjaGFydC5cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBjaGFydCB0b29sYmFyIGl0ZW1zIGRlZmluZWQgaW4gdGhlIGdyaWQncyBjb250ZXh0XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcclxuICogQHJldHVybnMge0FycmF5fSBhcnJheSBvZiBzdXBwb3J0ZWQgY2hhcnQgaXRlbXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRDaGFydFRvb2xiYXJJdGVtcyhwYXJhbXMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgcGFyYW1zLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dC5jaGFydFRvb2xiYXJJdGVtcyB8fCBbXVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZCBuZXcgY2hhcnQgcmFuZ2VcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgIGJvdW5kZWQgb3IgdW5ib3VuZGVkIHJhbmdlIG1vZGVsXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gYSB1bmlxdWUgaWQgZm9yIHRoZSBnZW5lcmF0ZSBjaGFydFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZENoYXJ0UmFuZ2UoaWQsIHJhbmdlKSB7XHJcbiAgY29uc3QgZ3JpZCA9IGd3X2dldEdyaWQoaWQpXHJcbiAgY29uc3Qgb3B0aW9ucyA9IGdyaWQub3B0aW9uc1xyXG4gIGNvbnN0IHByID0gZGVlcFBhcnNlSnNvbihKU09OLnN0cmluZ2lmeShyYW5nZSkpXHJcblxyXG4gIHByLmNlbGxSYW5nZSA9IGd3X3BhcnNlQWRkQ2VsbFJhbmdlKG9wdGlvbnMsIHByLmNlbGxSYW5nZSlcclxuXHJcbiAgY29uc3QgcmVmID0gb3B0aW9ucy5hcGkuY3JlYXRlUmFuZ2VDaGFydChwcilcclxuICBjb25zdCB1dWlkID0gZ3dfdXVpZCgpXHJcblxyXG4gIGdyaWQuY3JlYXRlZF9jaGFydHMgPSBncmlkLmNyZWF0ZWRfY2hhcnRzIHx8IHt9XHJcbiAgZ3JpZC5jcmVhdGVkX2NoYXJ0c1t1dWlkXSA9IHJlZlxyXG5cclxuICByZXR1cm4gdXVpZFxyXG59XHJcblxyXG4vKipcclxuICogRGVzdHJveSBjcmVhdGVkIGNoYXJ0c1xyXG4gKlxyXG4gKiBEZXN0cm95IGFscmVhZHkgY3JlYXRlZCBjaGFydCBieSBpZCBvciBhbGwgY3JlYXRlZCBjaGFydHNcclxuICogd2hlbiB0aGUgYHV1aWRgIGlzIG9taXR0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHV1aWQgVGhlIGNoYXJ0J3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19kZXN0cm95Q2hhcnQoaWQsIHV1aWQpIHtcclxuICBjb25zdCBncmlkID0gZ3dfZ2V0R3JpZChpZClcclxuXHJcbiAgaWYgKHV1aWQpIHtcclxuICAgIGlmIChcclxuICAgICAgZ3JpZC5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlZF9jaGFydHMnKSAmJlxyXG4gICAgICBncmlkLmNyZWF0ZWRfY2hhcnRzLmhhc093blByb3BlcnR5KHV1aWQpXHJcbiAgICApIHtcclxuICAgICAgZ3JpZC5jcmVhdGVkX2NoYXJ0c1t1dWlkXS5kZXN0cm95Q2hhcnQoKVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoZ3JpZC5oYXNPd25Qcm9wZXJ0eSgnY3JlYXRlZF9jaGFydHMnKSkge1xyXG4gICAgICBmb3IgKGNvbnN0IGkgaW4gZ3JpZC5jcmVhdGVkX2NoYXJ0cykge1xyXG4gICAgICAgIGlmIChncmlkLmNyZWF0ZWRfY2hhcnRzLmhhc093blByb3BlcnR5KGkpKSB7XHJcbiAgICAgICAgICBjb25zdCBjaGFydCA9IGdyaWQuY3JlYXRlZF9jaGFydHNbaV1cclxuICAgICAgICAgIGNoYXJ0LmRlc3Ryb3lDaGFydCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19leGVjdXRlRXhwcmVzc2lvbiB9IGZyb20gJy4uL2V4cHJlc3Npb24nXHJcbmNvbnN0IHsgZGVlcFBhcnNlSnNvbiB9ID0gcmVxdWlyZSgnZGVlcC1wYXJzZS1qc29uJylcclxuXHJcbi8qKlxyXG4gKiBFeHRlbmQgdGhlIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKlxyXG4gKiBFeHRlbmQgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyB3aXRoIG9wdGlvbnMgd2hpY2ggY2FuIG5vdCBiZSBoYW5kbGVkIGluIEJCalxyXG4gKiAoZXg6IGF0dGFjaGluZyBjYWxsYmFja3MpXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmluaXRpb25zIGFycmF5IG9mIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2V4dGVuZENvbHVtbkRlZmluaXRpb25zKGRlZmluaXRpb25zKSB7XHJcbiAgZm9yIChsZXQgaSBpbiBkZWZpbml0aW9ucykge1xyXG4gICAgY29uc3QgZGVmID0gZGVmaW5pdGlvbnNbaV1cclxuXHJcbiAgICBkZWYuY2hlY2tib3hTZWxlY3Rpb24gPSBkZWYuY2hlY2tib3hTZWxlY3Rpb24gfHwgZ3dfaXNTaG93U2VsZWN0aW9uQ2hlY2tib3hcclxuICAgIGRlZi5oZWFkZXJDaGVja2JveFNlbGVjdGlvbiA9XHJcbiAgICAgIGRlZi5oZWFkZXJDaGVja2JveFNlbGVjdGlvbiB8fCBnd19pc0hlYWRlckNoZWNrYm94U2VsZWN0aW9uXHJcblxyXG4gICAgY29uc3QgdG9vbHRpcFZhbHVlR2V0dGVyRXhwcmVzc2lvbiA9IGRlZi50b29sdGlwVmFsdWVHZXR0ZXJcclxuICAgIGlmICh0b29sdGlwVmFsdWVHZXR0ZXJFeHByZXNzaW9uKSB7XHJcbiAgICAgIGRlZi50b29sdGlwVmFsdWVHZXR0ZXIgPSBwYXJhbXMgPT5cclxuICAgICAgICBnd19leGVjdXRlRXhwcmVzc2lvbih0b29sdGlwVmFsdWVHZXR0ZXJFeHByZXNzaW9uLCBwYXJhbXMpXHJcbiAgICB9XHJcblxyXG4gICAgZGVmLnRvb2x0aXBDb21wb25lbnQgPSAnSFRNTFRvb2x0aXAnXHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eSgnZWRpdGFibGUnKSAmJiB0eXBlb2YgZGVmLmVkaXRhYmxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCBlZGl0YWJsZSA9IGRlZi5lZGl0YWJsZVxyXG4gICAgICBkZWYuZWRpdGFibGUgPSBwYXJhbXMgPT4gZ3dfZXhlY3V0ZUV4cHJlc3Npb24oZWRpdGFibGUsIHBhcmFtcylcclxuICAgIH1cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICBpZiAoZGVmLmhhc093blByb3BlcnR5KCdyb3dTcGFuJykgJiYgdHlwZW9mIGRlZi5yb3dTcGFuID09PSAnc3RyaW5nJykge1xyXG4gICAgICBjb25zdCByb3dTcGFuID0gZGVmLnJvd1NwYW5cclxuICAgICAgZGVmLnJvd1NwYW4gPSBwYXJhbXMgPT4gZ3dfZXhlY3V0ZUV4cHJlc3Npb24ocm93U3BhbiwgcGFyYW1zKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcclxuICAgIGlmIChkZWYuaGFzT3duUHJvcGVydHkoJ2NvbFNwYW4nKSAmJiB0eXBlb2YgZGVmLmNvbFNwYW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGNvbnN0IGNvbFNwYW4gPSBkZWYuY29sU3BhblxyXG4gICAgICBkZWYuY29sU3BhbiA9IHBhcmFtcyA9PiBnd19leGVjdXRlRXhwcmVzc2lvbihjb2xTcGFuLCBwYXJhbXMpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgaWYgKGRlZi5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRyZW4nKSkge1xyXG4gICAgICBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyhkZWYuY2hpbGRyZW4pXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVXBkYXRlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRlZmluaXRpb25zIGFycmF5IG9mIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldENvbHVtbkRlZmluaXRpb25zKGlkLCBkZWZpbml0aW9ucykge1xyXG4gIGNvbnN0IGdyaWQgPSBnd19nZXRHcmlkKGlkKVxyXG4gIGNvbnN0IGRlZXBQYXJzZWREZWZpbml0aW9ucyA9IGRlZXBQYXJzZUpzb24oSlNPTi5zdHJpbmdpZnkoZGVmaW5pdGlvbnMpKVxyXG5cclxuICBnd19leHRlbmRDb2x1bW5EZWZpbml0aW9ucyhkZWVwUGFyc2VkRGVmaW5pdGlvbnMpXHJcblxyXG4gIGdyaWQub3B0aW9ucy5hcGkuc2V0Q29sdW1uRGVmcyhkZWVwUGFyc2VkRGVmaW5pdGlvbnMpXHJcbiAgZ3JpZC5vcHRpb25zLmNvbHVtbkRlZnMgPSBkZWVwUGFyc2VkRGVmaW5pdGlvbnNcclxufVxyXG5cclxuLyoqXHJcbiAqIE1ha2UgdGhlIGN1cnJlbnRseSB2aXNpYmxlIGNvbHVtbnMgZml0IHRoZSBzY3JlZW5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRoZSB3aWR0aCB0byB1c2UgdG8gZml0IGFsbCBjb2x1bW5zIGluXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2l6ZUNvbHVtbnNUb0ZpdChpZCwgd2lkdGgpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcbiAgY29uc3QgY29sdW1uc0FQSSA9IG9wdGlvbnMuY29sdW1uQXBpXHJcbiAgaWYgKHdpZHRoKSB7XHJcbiAgICBjb2x1bW5zQVBJLnNpemVDb2x1bW5zVG9GaXQoTnVtYmVyKHdpZHRoKSlcclxuICB9IGVsc2Uge1xyXG4gICAgYXBpLnNpemVDb2x1bW5zVG9GaXQoKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFdvcmsgb3V0IHRoZSBiZXN0IHdpZHRoIHRvIGZpdCB0aGUgY29udGVudHMgb2YgdGhlIGNlbGxzIGluIHRoZSBjb2x1bW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NraXBIZWFkZXI9ZmFsc2VdIHdoZW4gdHJ1ZSBpbmRpY2F0ZSB0aGF0IHRoZSBoZWFkZXIgY29udGVudCAoaGVhZGVyTmFtZSkgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHdoZW5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0aW5nIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uXHJcbiAqIEBwYXJhbSB7QXJyYXl8bnVsbH0gW2NvbHVtbnM9bnVsbF0gYW4gYXJyYXkgb2YgY29sdW1ucyBpZHMgdG8gYXV0byBzaXplIG9yIG51bGwgdG8gYXV0byBzaXplIGFsbCBjb2x1bW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYXV0b1NpemVDb2x1bW5zKGlkLCBza2lwSGVhZGVyID0gZmFsc2UsIGNvbHVtbnMgPSBudWxsKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBjb2x1bW5zQVBJID0gb3B0aW9ucy5jb2x1bW5BcGlcclxuXHJcbiAgaWYgKCEoY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCkpIHtcclxuICAgIGNvbnN0IGFsbENvbHVtbklkcyA9IFtdXHJcblxyXG4gICAgY29sdW1uc0FQSS5nZXRBbGxDb2x1bW5zKCkuZm9yRWFjaChjb2x1bW4gPT4ge1xyXG4gICAgICBhbGxDb2x1bW5JZHMucHVzaChjb2x1bW4uY29sSWQpXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbHVtbnNBUEkuYXV0b1NpemVDb2x1bW5zKGFsbENvbHVtbklkcywgQm9vbGVhbihza2lwSGVhZGVyKSlcclxuICB9IGVsc2Uge1xyXG4gICAgY29sdW1uc0FQSS5hdXRvU2l6ZUNvbHVtbnMoY29sdW1ucywgQm9vbGVhbihza2lwSGVhZGVyKSlcclxuICB9XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZXMgdGhlIGNvbHVtbiBpcyB2aXNpYmxlLCBzY3JvbGxpbmcgdGhlIHRhYmxlIGlmIG5lZWRlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5JZCAgdGhlIGNvbHVtbiBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Vuc3VyZUNvbHVtblZpc2libGUoaWQsIGNvbHVtbklkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuZW5zdXJlQ29sdW1uVmlzaWJsZShjb2x1bW5JZClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCBDb2x1bW4gV2lkdGhcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5JZCBUaGUgY29sdW1uIGlkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gd2lkdGggVGhlIG5ldyBjb2x1bW4gd2lkdGhcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRDb2x1bW5XaWR0aChpZCwgY29sdW1uSWQsIHdpZHRoKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb2x1bW5BcGkuc2V0Q29sdW1uV2lkdGgoY29sdW1uSWQsIE51bWJlcih3aWR0aCkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQaW4gQ29sdW1uXHJcbiAqXHJcbiAqIFBpbiBhIGNvbHVtbiB0byBhIHNwZWNpZmljIGRpcmVjdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbklkIFRoZSBjb2x1bW4gaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHBpbiBUaGUgcGluIGRpcmVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3BpbkNvbHVtbihpZCwgY29sdW1uSWQsIHBpbikge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnNldENvbHVtblBpbm5lZChjb2x1bW5JZCwgcGluKVxyXG59XHJcblxyXG4vKipcclxuICogTW92ZSBDb2x1bW5cclxuICpcclxuICogTW92ZSBjb2x1bW4gdG8gYSBzcGVjaWZpYyBpbmRleFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbklkIFRoZSBjb2x1bW4gaWRcclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSB0b0luZGV4IFRoZSBuZXcgY29sdW1uIGluZGV4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfbW92ZUNvbHVtbihpZCwgY29sdW1uSWQsIHRvSW5kZXgpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5tb3ZlQ29sdW1uKGNvbHVtbklkLCB0b0luZGV4KVxyXG59XHJcblxyXG4vKipcclxuICogU2hvdyAvIEhpZGUgc2VsZWN0aW9uIGNoZWNrYm94IGJhc2VkIG9uIHRoZSBmaXJzdCBjb2x1bW5cclxuICpcclxuICogVGhlIGZ1bmN0aW9uIG1ha2Ugc3VyZSB0aGF0IHRoZSBzZWxlY3Rpb24gY2hlY2tib3ggaXMgYWx3YXlzIHNob3duIG9uIHRoZVxyXG4gKiBmaXJzdCBjb2x1bW5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBmaXJzdCBjb2x1bW4gLCBmYWxzZSBpZiBub3QgdGhlIGZpcnN0IGNvbHVtbiBvciBpZiB0aGVcclxuICogICAgICAgICAgICAgICAgICAgZ3JpZCdzIGBDb250ZXh0LnNob3dTZWxlY3Rpb25DaGVja2JveGAgaXMgZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19pc1Nob3dTZWxlY3Rpb25DaGVja2JveChwYXJhbSkge1xyXG4gIGlmICghcGFyYW0uY29udGV4dC5zaG93U2VsZWN0aW9uQ2hlY2tib3gpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgY29sdW1ucyA9IHBhcmFtLmNvbHVtbkFwaS5nZXRBbGxEaXNwbGF5ZWRDb2x1bW5zKClcclxuXHJcbiAgcmV0dXJuIGNvbHVtbnNbMF0gPT09IHBhcmFtLmNvbHVtbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3cgLyBIaWRlIGhlYWRlciBzZWxlY3Rpb24gY2hlY2tib3ggYmFzZWQgb24gdGhlIGZpcnN0IGNvbHVtblxyXG4gKlxyXG4gKiBUaGUgZnVuY3Rpb24gbWFrZSBzdXJlIHRoYXQgdGhlIGhlYWRlciBzZWxlY3Rpb24gY2hlY2tib3ggaXMgYWx3YXlzIHNob3duIG9uIHRoZVxyXG4gKiBmaXJzdCBjb2x1bW5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiBmaXJzdCBjb2x1bW4gLCBmYWxzZSBpZiBub3QgdGhlIGZpcnN0IGNvbHVtbiBvciBpZiB0aGVcclxuICogICAgICAgICAgICAgICAgICAgZ3JpZCdzIGBDb250ZXh0LnNob3dIZWFkZXJTZWxlY3Rpb25DaGVja2JveGAgaXMgZmFsc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19pc0hlYWRlckNoZWNrYm94U2VsZWN0aW9uKHBhcmFtKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IHBhcmFtLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dFxyXG5cclxuICBpZiAoIWNvbnRleHQuc2hvd0hlYWRlclNlbGVjdGlvbkNoZWNrYm94KSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbHVtbnMgPSBwYXJhbS5jb2x1bW5BcGkuZ2V0QWxsRGlzcGxheWVkQ29sdW1ucygpXHJcblxyXG4gIHJldHVybiBjb2x1bW5zWzBdID09PSBwYXJhbS5jb2x1bW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgcm93IGdyb3VwaW5nIGZvciBjb2x1bW5zXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1ucyAgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGNvbHVtbnNcclxuICogQHBhcmFtIHtCb29sZWFufSBzZXQgIFdoZW4gdHJ1ZSAsIGBzZXRSb3dHcm91cENvbHVtbnNgIHdpbGwgYmUgdXNlZCAsIGBhZGRSb3dHcm91cENvbHVtbnNgIG90aGVyd2lzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZFJvd0dyb3VwQ29sdW1uKGlkLCBjb2x1bW5zLCBzZXQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaVtcclxuICAgIHNldCA/ICdzZXRSb3dHcm91cENvbHVtbnMnIDogJ2FkZFJvd0dyb3VwQ29sdW1ucydcclxuICBdKGNvbHVtbnMuc3BsaXQoJywnKS5tYXAoaSA9PiBpLnRyaW0oKSkpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlIHJvdyBncm91cGluZyBmb3IgY29sdW1uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBjb2x1bW5zXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVtb3ZlUm93R3JvdXBDb2x1bW4oaWQsIGNvbHVtbnMpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5yZW1vdmVSb3dHcm91cENvbHVtbnMoXHJcbiAgICBjb2x1bW5zLnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0UGl2b3RNb2RlKGlkKSB7XHJcbiAgcmV0dXJuIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLmlzUGl2b3RNb2RlKClcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSAvIGRpc2JhbGUgcGl2b3QgbW9kZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtCb29sZWFufSBtb2RlIHdoZW4gdHJ1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFBpdm90TW9kZShpZCwgbW9kZSkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnNldFBpdm90TW9kZSghIU51bWJlcihtb2RlKSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSBwaXZvdCBmb3IgY29sdW1uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvZiBjb2x1bW5zXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc2V0ICBXaGVuIHRydWUgLCBgYWRkUGl2b3RDb2x1bW5zYCB3aWxsIGJlIHVzZWQgLCBgc2V0UGl2b3RDb2x1bW5zYCBvdGhlcndpc2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19hZGRQaXZvdENvbHVtbnMoaWQsIGNvbHVtbnMsIHNldCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpW3NldCA/ICdzZXRQaXZvdENvbHVtbnMnIDogJ2FkZFBpdm90Q29sdW1ucyddKFxyXG4gICAgY29sdW1ucy5zcGxpdCgnLCcpLm1hcChpID0+IGkudHJpbSgpKVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIERpc2FibGUgcGl2b3QgZm9yIGNvbHVtbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5zICBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgY29sdW1uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3JlbW92ZVBpdm90Q29sdW1ucyhpZCwgY29sdW1ucykge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnJlbW92ZVBpdm90Q29sdW1ucyhcclxuICAgIGNvbHVtbnMuc3BsaXQoJywnKS5tYXAoaSA9PiBpLnRyaW0oKSlcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFbmFibGUgdmFsdWUgZm9yIGNvbHVtbnNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5zICBhIGNvbW1hIHNlcGFyYXRlZCBzdHJpbmcgb2YgY29sdW1uc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZFZhbHVlQ29sdW1ucyhpZCwgY29sdW1ucykge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLmFkZFZhbHVlQ29sdW1ucyhcclxuICAgIGNvbHVtbnMuc3BsaXQoJywnKS5tYXAoaSA9PiBpLnRyaW0oKSlcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlIHZhbHVlIGZvciBjb2x1bW5zXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1ucyAgYSBjb21tYSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGNvbHVtbnNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19yZW1vdmVWYWx1ZUNvbHVtbnMoaWQsIGNvbHVtbnMpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbHVtbkFwaS5yZW1vdmVWYWx1ZUNvbHVtbnMoXHJcbiAgICBjb2x1bW5zLnNwbGl0KCcsJykubWFwKGkgPT4gaS50cmltKCkpXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBjb2x1bW4gc29ydGluZyBtb2RlbFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGVsIG1vZGVsIGFzIGpzb24gYXJyYXlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRTb3J0TW9kZWwoaWQsIG1vZGVsKSB7XHJcbiAgY29uc3QgYXNBcnJheSA9IEpTT04ucGFyc2UobW9kZWwpXHJcbiAgY29uc3QgcGFyc2VkTW9kZWwgPSBbXVxyXG4gIGFzQXJyYXkuZm9yRWFjaChpID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGkpIHtcclxuICAgICAgcGFyc2VkTW9kZWwucHVzaCh7XHJcbiAgICAgICAgY29sSWQ6IGtleSxcclxuICAgICAgICBzb3J0OiBpW2tleV0sXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0U29ydE1vZGVsKHBhcnNlZE1vZGVsKVxyXG59XHJcblxyXG4vKipcclxuICogUmVkcmF3cyB0aGUgaGVhZGVyLiBVc2VmdWwgaWYgYSBjb2x1bW4gbmFtZSBjaGFuZ2VzLFxyXG4gKiBvciBzb21ldGhpbmcgZWxzZSB0aGF0IGNoYW5nZXMgaG93IHRoZSBjb2x1bW4gaGVhZGVyIGlzIGRpc3BsYXllZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3JlZnJlc2hIZWFkZXIoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5yZWRyYXdSb3dzKClcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBjb2x1bW4gdmlhYmlsaXR5XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtbnMgIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgY29sdW1uIGlkc1xyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgdHJ1ZSB0byBtYWtlIHRoZSBjb2x1bW5zIHZpc2libGUgLCBmYWxzZSB0byBoaWRlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0Q29sdW1uVmlzaWJsZShpZCwgY29sdW1ucywgdmlzaWJsZSkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29sdW1uQXBpLnNldENvbHVtbnNWaXNpYmxlKFxyXG4gICAgY29sdW1ucy5zcGxpdCgnLCcpLFxyXG4gICAgQm9vbGVhbih2aXNpYmxlKVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsaWduIHR3byBncmlkIHRvZ2V0aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgY3VycmVudCBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGdyaWRJZCBUaGUgdGFyZ2V0IGdyaWQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2FkZEFsaWduZWRHcmlkKGlkLCBncmlkSWQpIHtcclxuICBjb25zdCBjdXJyZW50R3JpZE9wdGlvbiA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCByZWdpc3RlciA9ICgpID0+IHtcclxuICAgIGNvbnN0IHRhcmdldEdyaWRPcHRpb24gPSBnd19nZXRHcmlkKGdyaWRJZCkub3B0aW9uc1xyXG4gICAgY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLnB1c2godGFyZ2V0R3JpZE9wdGlvbilcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZWdpc3RlcigpXHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBjdXJyZW50R3JpZE9wdGlvbi5hbGlnbmVkR3JpZHMucHVzaChncmlkSWQpXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgJHtncmlkSWR9LXJlYWR5YCwgKCkgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleE9mID0gY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLmluZGV4T2YoZ3JpZElkKVxyXG4gICAgICBpZiAoaW5kZXhPZiA+IC0xKSB7XHJcbiAgICAgICAgY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzLnNwbGljZShpbmRleE9mLCAxKVxyXG4gICAgICAgIHJlZ2lzdGVyKClcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgYWxpZ25lZCBncmlkc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGN1cnJlbnQgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBncmlkSWQgVGhlIHRhcmdldCBncmlkJ3MgaWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19yZW1vdmVBbGlnbmVkR3JpZChpZCwgZ3JpZElkKSB7XHJcbiAgY29uc3QgY3VycmVudEdyaWRPcHRpb24gPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgYWxpZ25lZEdyaWRzID0gY3VycmVudEdyaWRPcHRpb24uYWxpZ25lZEdyaWRzXHJcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBhbGlnbmVkR3JpZHMubGVuZ3RoOyB4KyspIHtcclxuICAgIGNvbnN0IGdyaWQgPSBhbGlnbmVkR3JpZHNbeF1cclxuICAgIGlmIChcclxuICAgICAgKHR5cGVvZiBncmlkID09PSAnc3RyaW5nJyAmJiBncmlkID09PSBncmlkSWQpIHx8XHJcbiAgICAgIGdyaWQuY29udGV4dC5pZCA9PT0gZ3JpZElkXHJcbiAgICApIHtcclxuICAgICAgYWxpZ25lZEdyaWRzLnNwbGljZSh4LCAxKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogVXBkYXRlIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgY29udGV4dCdzIGtleSB0byB1cGRhdGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlICBUaGUgbmV3IGNvbnRleHQncyB2YWx1ZVxyXG4gKi9cclxuLy8gZXhwb3J0IGZ1bmN0aW9uIGd3X2xlZ2FjeVVwZGF0ZUNvbnRleHQoaWQsIGtleSwgdmFsdWUpIHtcclxuLy8gXHRnd19nZXRHcmlkKGlkKVxyXG4vLyBcdFx0Lm9wdGlvbnNcclxuLy8gXHRcdC5jb250ZXh0W2tleV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcclxuLy8gfVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBjb250ZXh0XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IFRoZSBuZXcgY29udGV4dCBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd191cGRhdGVDb250ZXh0KGlkLCBjb250ZXh0KSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb250ZXh0ID0gY29udGV4dFxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuZXhwb3J0ICogZnJvbSAnLi9pbml0LmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2NvbHVtbnMuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vcm93cy5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9jZWxscy5qcydcclxuZXhwb3J0ICogZnJvbSAnLi9zdGF0ZS5qcydcclxuZXhwb3J0ICogZnJvbSAnLi90b29scGFuZWwuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vc3RhdHVzYmFyLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL292ZXJsYXlzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2NvbnRleHQuanMnXHJcbmV4cG9ydCAqIGZyb20gJy4vY2hhcnRzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2pzcy5qcydcclxuZXhwb3J0ICogZnJvbSAnLi91dGlsaXRpZXMuanMnXHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZXh0ZW5kQ29sdW1uRGVmaW5pdGlvbnMgfSBmcm9tICcuL2NvbHVtbnMnXHJcbmltcG9ydCB7IGd3X25hdmlnYXRlVG9OZXh0Um93LCBnd19nZXRSb3dOb2RlSWQgfSBmcm9tICcuL3Jvd3MnXHJcbmltcG9ydCB7IGd3X2dldENvbnRleHRNZW51IH0gZnJvbSAnLi9tZW51cydcclxuaW1wb3J0IHsgZ3dfZ2V0Q2hhcnRUb29sYmFySXRlbXMgfSBmcm9tICcuL2NoYXJ0cydcclxuaW1wb3J0IHsgZ3dfZ2V0RG9jdW1lbnQsIGd3X2dldFdpbmRvdywgZ3dfYWRkR3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQge1xyXG4gIGd3X29uUm93Q2xpY2tlZCxcclxuICBnd19vblJvd0RvdWJsZUNsaWNrZWQsXHJcbiAgZ3dfb25TZWxlY3Rpb25DaGFuZ2VkLFxyXG4gIGd3X29uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkLFxyXG4gIGd3X29uQ2VsbENsaWNrRXZlbnQsXHJcbiAgZ3dfb25DZWxsRWRpdGluZ0V2ZW50LFxyXG4gIGd3X29uUm93RWRpdGluZ0V2ZW50LFxyXG4gIGd3X29uUmVhZHlFdmVudCxcclxuICBnd19vbkZpbHRlckNoYW5nZWQsXHJcbiAgZ3dfZGVib3VuY2UsXHJcbn0gZnJvbSAnZXZlbnRzJ1xyXG5pbXBvcnQgdGVtcGxhdGUgZnJvbSAnbG9kYXNoLWVzL3RlbXBsYXRlJ1xyXG5pbXBvcnQgSFRNTFRvb2x0aXAgZnJvbSAnLi4vY29tcG9uZW50cy9IVE1MVG9vbHRpcC5qcydcclxuaW1wb3J0IFN1Z2dlc3Rpb25FZGl0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9TdWdnZXN0aW9uRWRpdG9yLmpzJ1xyXG5cclxuY29uc3QgeyBkZWVwUGFyc2VKc29uIH0gPSByZXF1aXJlKCdkZWVwLXBhcnNlLWpzb24nKVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2luaXQob3B0aW9ucywgbGljZW5zZSwgZGF0YSkge1xyXG4gIGlmIChhZ0dyaWQuTGljZW5zZU1hbmFnZXIgJiYgbGljZW5zZSkge1xyXG4gICAgYWdHcmlkLkxpY2Vuc2VNYW5hZ2VyLnNldExpY2Vuc2VLZXkobGljZW5zZSlcclxuICB9XHJcblxyXG4gIGNvbnN0IGlkID0gb3B0aW9ucy5jb250ZXh0LmlkXHJcbiAgbGV0IGNvbnRhaW5lciA9IGd3X2dldERvY3VtZW50KCkuZ2V0RWxlbWVudEJ5SWQoaWQpXHJcbiAgY29uc3QgY29udGFpbmVyQ2xvbmUgPSBjb250YWluZXIuY2xvbmVOb2RlKHRydWUpXHJcblxyXG4gIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb250YWluZXJDbG9uZSwgY29udGFpbmVyKVxyXG4gIGNvbnRhaW5lciA9IGNvbnRhaW5lckNsb25lXHJcbiAgLy8gd2UgbWFrZSB0aGUgZ3JpZCBvcHRpb25zIGF2YWlsYWJsZSBhcyBzb29uIGFzIHBvc3NpYmxlXHJcbiAgY29uc3QgZ3JpZCA9IGd3X2FkZEdyaWQoaWQsIHtcclxuICAgIGNvbnRhaW5lcixcclxuICAgIG9wdGlvbnMsXHJcbiAgfSlcclxuXHJcbiAgLy8gVE9ETzogdXNlIGFnIGdyaWQgZGVzdHJveVxyXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJ1xyXG5cclxuICBjb25zdCBwYXJzZWRPcHRpb25zID0gZ3dfcGFyc2VPcHRpb25zKG9wdGlvbnMpXHJcbiAgcGFyc2VkT3B0aW9ucy5yb3dEYXRhID0gZGF0YVxyXG5cclxuICBjb25zdCBpbnN0YW5jZSA9IG5ldyBhZ0dyaWQuR3JpZChjb250YWluZXIsIHBhcnNlZE9wdGlvbnMpXHJcbiAgZ3JpZC5pbnN0YW5jZSA9IGluc3RhbmNlXHJcbiAgZ3JpZC5vcHRpb25zID0gcGFyc2VkT3B0aW9uc1xyXG5cclxuICBjb25zb2xlLmxvZyhcclxuICAgIGAlYyBHcmlkIFske2lkfV0gc2V0dGluZ3MgOiBgLFxyXG4gICAgJ2JhY2tncm91bmQ6ICMyMjI7IGNvbG9yOiAjYmFkYTU1JyxcclxuICAgIHBhcnNlZE9wdGlvbnNcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBPcHRpb25zXHJcbiAqXHJcbiAqIFBhcnNlIHRoZSBncmlkIG9wdGlvbnMgYW5kIHJldHVyblxyXG4gKiBhbiBvYmplY3Qgd2hpY2ggY2FuIGJlIHBhc3NlZCB0byB0aGUgZ3JpZFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBHcmlkIG9wdGlvbnMgYXMgSnNvbiBPYmplY3RcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSBvcHRpb25zIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gZ3dfcGFyc2VPcHRpb25zKG9wdGlvbnMpIHtcclxuICBjb25zdCBkZWVwUGFyc2VkT3B0aW9ucyA9IGRlZXBQYXJzZUpzb24oSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpXHJcbiAgY29uc3QgaWQgPSBkZWVwUGFyc2VkT3B0aW9ucy5jb250ZXh0LmlkXHJcbiAgY29uc3QgZ2V0RGF0YVBhdGhUZW1wbGF0ZSA9IGRlZXBQYXJzZWRPcHRpb25zLmNvbnRleHQuZ2V0RGF0YVBhdGggfHwgJydcclxuICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIGNvbnRyb2wgdGhpcyBzZXR0aW5nIGZyb20gQkJqID9cclxuICBjb25zdCBkZWJvdW5jZUR1cmF0aW9uID0gMjUwXHJcbiAgY29uc3QgZmluYWxPcHRpb25zID0ge1xyXG4gICAgLi4uZGVlcFBhcnNlZE9wdGlvbnMsXHJcbiAgICAuLi57XHJcbiAgICAgIGdldERvY3VtZW50OiAoKSA9PiBnd19nZXREb2N1bWVudCgpLFxyXG4gICAgICBvbkNlbGxFZGl0aW5nU3RhcnRlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25DZWxsRWRpdGluZ0V2ZW50KGlkLCBlKVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNlbGxFZGl0aW5nU3RvcHBlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25DZWxsRWRpdGluZ0V2ZW50KGlkLCBlKVxyXG4gICAgICB9LFxyXG4gICAgICBvbkNlbGxWYWx1ZUNoYW5nZWQ6IGUgPT4ge1xyXG4gICAgICAgIGd3X29uQ2VsbEVkaXRpbmdFdmVudChpZCwgZSlcclxuICAgICAgfSxcclxuICAgICAgb25Sb3dFZGl0aW5nU3RhcnRlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25Sb3dFZGl0aW5nRXZlbnQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uUm93VmFsdWVDaGFuZ2VkOiBlID0+IHtcclxuICAgICAgICBnd19vblJvd0VkaXRpbmdFdmVudChpZCwgZSlcclxuICAgICAgfSxcclxuICAgICAgb25Sb3dFZGl0aW5nU3RvcHBlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25Sb3dFZGl0aW5nRXZlbnQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uR3JpZFJlYWR5OiBlID0+IHtcclxuICAgICAgICBnd19vblJlYWR5RXZlbnQoaWQsIGUpXHJcbiAgICAgIH0sXHJcbiAgICAgIG9uRmlsdGVyQ2hhbmdlZDogZSA9PiB7XHJcbiAgICAgICAgZ3dfb25GaWx0ZXJDaGFuZ2VkKGlkLCBlKVxyXG4gICAgICB9LFxyXG4gICAgICBnZXRSb3dOb2RlSWQ6IGRhdGEgPT4gZ3dfZ2V0Um93Tm9kZUlkKGlkLCBkYXRhKSxcclxuICAgICAgZ2V0Q29udGV4dE1lbnVJdGVtczogcGFyYW1zID0+IGd3X2dldENvbnRleHRNZW51KGlkLCBwYXJhbXMpLFxyXG4gICAgICBnZXRDaGFydFRvb2xiYXJJdGVtczogZ3dfZ2V0Q2hhcnRUb29sYmFySXRlbXMsXHJcbiAgICAgIHBvcHVwUGFyZW50OiBnd19nZXREb2N1bWVudCgpLmJvZHksXHJcbiAgICAgIG9uUm93RG91YmxlQ2xpY2tlZDogZ3dfZGVib3VuY2UoZ3dfb25Sb3dEb3VibGVDbGlja2VkLCBkZWJvdW5jZUR1cmF0aW9uKSxcclxuICAgICAgb25Sb3dDbGlja2VkOiBnd19kZWJvdW5jZShnd19vblJvd0NsaWNrZWQsIGRlYm91bmNlRHVyYXRpb24pLFxyXG4gICAgICBvbkNlbGxDbGlja2VkOiBnd19kZWJvdW5jZShnd19vbkNlbGxDbGlja0V2ZW50LCBkZWJvdW5jZUR1cmF0aW9uKSxcclxuICAgICAgb25DZWxsRG91YmxlQ2xpY2tlZDogZ3dfZGVib3VuY2UoZ3dfb25DZWxsQ2xpY2tFdmVudCwgZGVib3VuY2VEdXJhdGlvbiksXHJcbiAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlZDogZ3dfZGVib3VuY2UoZ3dfb25TZWxlY3Rpb25DaGFuZ2VkLCBkZWJvdW5jZUR1cmF0aW9uKSxcclxuICAgICAgb25SYW5nZVNlbGVjdGlvbkNoYW5nZWQ6IGd3X2RlYm91bmNlKFxyXG4gICAgICAgIGd3X29uUmFuZ2VTZWxlY3Rpb25DaGFuZ2VkLFxyXG4gICAgICAgIGRlYm91bmNlRHVyYXRpb25cclxuICAgICAgKSxcclxuICAgICAgY29tcG9uZW50czoge1xyXG4gICAgICAgIEJvb2xlYW5GaWx0ZXI6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuQm9vbGVhbkZpbHRlcixcclxuICAgICAgICBCb29sZWFuUmVuZGVyZXI6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuQm9vbGVhblJlbmRlcmVyLFxyXG4gICAgICAgIEJvb2xlYW5FZGl0b3I6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuQm9vbGVhbkVkaXRvcixcclxuICAgICAgICBOdW1iZXJFZGl0b3I6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuTnVtYmVyRWRpdG9yLFxyXG4gICAgICAgIFRleHRFZGl0b3I6IEJhc2lzLkFnR3JpZENvbXBvbmVudHMuVGV4dEVkaXRvcixcclxuICAgICAgICBEYXRlVGltZUVkaXRvcjogQmFzaXMuQWdHcmlkQ29tcG9uZW50cy5EYXRlVGltZUVkaXRvcixcclxuICAgICAgICBEYXRlVGltZUZpbHRlcjogQmFzaXMuQWdHcmlkQ29tcG9uZW50cy5EYXRlVGltZUZpbHRlcixcclxuICAgICAgICBJbWFnZVJlbmRlcmVyOiBCYXNpcy5BZ0dyaWRDb21wb25lbnRzLkltYWdlUmVuZGVyZXIsXHJcbiAgICAgICAgVGVtcGxhdGVSZW5kZXJlcjogQmFzaXMuQWdHcmlkQ29tcG9uZW50cy5UZW1wbGF0ZVJlbmRlcmVyLFxyXG4gICAgICAgIEhUTUxUb29sdGlwOiBIVE1MVG9vbHRpcCxcclxuICAgICAgICBTdWdnZXN0aW9uRWRpdG9yOiBTdWdnZXN0aW9uRWRpdG9yLFxyXG4gICAgICB9LFxyXG4gICAgICBjb250ZXh0OiB7XHJcbiAgICAgICAgLi4uZGVlcFBhcnNlZE9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICAuLi57XHJcbiAgICAgICAgICBkb2N1bWVudDogZ3dfZ2V0RG9jdW1lbnQoKSxcclxuICAgICAgICAgIHdpbmRvdzogZ3dfZ2V0V2luZG93KCksXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgYWxpZ25lZEdyaWRzOiBbXSxcclxuICAgIH0sXHJcbiAgfVxyXG5cclxuICBpZiAoXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICBmaW5hbE9wdGlvbnMuY29udGV4dC5oYXNPd25Qcm9wZXJ0eSgnbmF2aWdhdGVUb05leHRDZWxsJykgJiZcclxuICAgIGZpbmFsT3B0aW9ucy5jb250ZXh0Lm5hdmlnYXRlVG9OZXh0Q2VsbFxyXG4gICkge1xyXG4gICAgZmluYWxPcHRpb25zLm5hdmlnYXRlVG9OZXh0Q2VsbCA9IHBhcmFtcyA9PiB7XHJcbiAgICAgIHJldHVybiBnd19uYXZpZ2F0ZVRvTmV4dFJvdyhpZCwgcGFyYW1zKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKGdldERhdGFQYXRoVGVtcGxhdGUgJiYgZmluYWxPcHRpb25zLnRyZWVEYXRhKSB7XHJcbiAgICBjb25zdCBnZXREYXRhUGF0aFRlbXBsYXRlQ29tcGxpZWQgPSB0ZW1wbGF0ZShnZXREYXRhUGF0aFRlbXBsYXRlKVxyXG4gICAgZmluYWxPcHRpb25zLmdldERhdGFQYXRoID0gZGF0YSA9PlxyXG4gICAgICBnZXREYXRhUGF0aFRlbXBsYXRlQ29tcGxpZWQoeyBkYXRhOiBkYXRhIH0pXHJcbiAgfVxyXG5cclxuICAvLyBleHRlbmQgdGhlIGNvbHVtbiBkZWZpbml0aW9uc1xyXG4gIGd3X2V4dGVuZENvbHVtbkRlZmluaXRpb25zKGZpbmFsT3B0aW9ucy5jb2x1bW5EZWZzKVxyXG5cclxuICByZXR1cm4gZmluYWxPcHRpb25zXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0ICdleHBvc2UtbG9hZGVyP2pzcyFqc3MvanNzLmpzJ1xyXG5pbXBvcnQgeyBnd19nZXREb2N1bWVudCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5cclxuLyoqXHJcbiAqIEFkZCBuZXcgc3R5bGVcclxuICpcclxuICogQWRkIG5ldyBzdHlsZSB0byB0aGUgZG9jdW1lbnRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIGNzcyBzZWxlY3RvclxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcnVsZXMgSnNvbiBzdHJpbmcgZm9yIGFuIGFycmF5IG9mIHJ1bGVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0U3R5bGUoc2VsZWN0b3IsIHJ1bGVzKSB7XHJcbiAganNzLmZvckRvY3VtZW50KGd3X2dldERvY3VtZW50KCkpLnNldChzZWxlY3RvciwgSlNPTi5wYXJzZShydWxlcykpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgc3R5bGVcclxuICpcclxuICogUmVtb3ZlIGFkZGVkIHN0eWxlIGZyb20gdGhlcyBkb2N1bWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgY3NzIHNlbGVjdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfcmVtb3ZlU3R5bGUoc2VsZWN0b3IpIHtcclxuICBqc3MuZm9yRG9jdW1lbnQoZ3dfZ2V0RG9jdW1lbnQoKSkucmVtb3ZlKHNlbGVjdG9yKVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2dldEdyaWQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfcGFyc2VOb2RlRnJvbUV2ZW50LCBnd19zZW5kRXZlbnQgfSBmcm9tICdldmVudHMvdXRpbGl0aWVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldENvbnRleHRNZW51KGdyaWRJZCwgcGFyYW1zKSB7XHJcbiAgY29uc3QgYnVpbGRDb250ZXh0TWVudUFjdGlvbiA9IChwYXJhbXMsIGlkKSA9PiB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjb25zdCBub2RlID0gZ3dfcGFyc2VOb2RlRnJvbUV2ZW50KHBhcmFtcylcclxuICAgICAgY29uc3QgY29sSWQgPSBwYXJhbXMuY29sdW1uLmNvbElkXHJcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zLnZhbHVlXHJcblxyXG4gICAgICBnd19zZW5kRXZlbnQoXHJcbiAgICAgICAgZ3dfZ2V0R3JpZChncmlkSWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgICAgICB7XHJcbiAgICAgICAgICB0eXBlOiAnZ3cuY29udGV4dG1lbnUnLFxyXG4gICAgICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7IHI6IG5vZGUsIGM6IGNvbElkLCB2OiB2YWx1ZSwgaTogaWQgfSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpZFxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBwYXJzZU1lbnUgPSBtZW51ID0+IHtcclxuICAgIG1lbnUuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpdGVtWydhY3Rpb24nXSA9IGJ1aWxkQ29udGV4dE1lbnVBY3Rpb24ocGFyYW1zLCBpdGVtLmlkKVxyXG5cclxuICAgICAgaWYgKGl0ZW1bJ2Nzc0NsYXNzZXMnXSAmJiAhQXJyYXkuaXNBcnJheShpdGVtWydjc3NDbGFzc2VzJ10pKSB7XHJcbiAgICAgICAgaXRlbVsnY3NzQ2xhc3NlcyddID0gaXRlbVsnY3NzQ2xhc3NlcyddLnNwbGl0KCcgJylcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGl0ZW1bJ3N1Yk1lbnUnXSkge1xyXG4gICAgICAgIGl0ZW1bJ3N1Yk1lbnUnXSA9IHBhcnNlTWVudShpdGVtWydzdWJNZW51J10pXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgcmV0dXJuIG1lbnVcclxuICB9XHJcblxyXG4gIHJldHVybiBwYXJzZU1lbnUoZ3dfZ2V0R3JpZChncmlkSWQpLm9wdGlvbnMuY29udGV4dC5jb250ZXh0TWVudSlcclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogU2hvdyBsb2FkaW5nIG92ZXJsYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2hvd0xvYWRpbmdPdmVybGF5KGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2hvd0xvYWRpbmdPdmVybGF5KClcclxufVxyXG5cclxuLyoqXHJcbiAqIFNob3cgJ25vIHJvd3MnIG92ZXJsYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2hvd05vUm93c092ZXJsYXkoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zaG93Tm9Sb3dzT3ZlcmxheSgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGVhciBhbGwgb3ZlcmxheXNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfaGlkZU92ZXJsYXkoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5oaWRlT3ZlcmxheSgpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QEJhc2lzLkFnR3JpZENvbXBvbmVudHMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X3BhcnNlTm9kZSB9IGZyb20gJ2V2ZW50cy91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X2V4ZWN1dGVFeHByZXNzaW9uIH0gZnJvbSAnLi4vZXhwcmVzc2lvbidcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRRdWlja0ZpbHRlcihpZCwgZmlsdGVyKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0UXVpY2tGaWx0ZXIoZmlsdGVyKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZXhwYW5kQWxsKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuZXhwYW5kQWxsKClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2NvbGxhcHNlQWxsKGlkKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuY29sbGFwc2VBbGwoKVxyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIHRoZSByb3cgaW5kZXggaXMgdmlzaWJsZSBieSB2ZXJ0aWNhbGx5IHNjcm9sbGluZyB0aGUgZ3JpZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbmRleCB0aGUgcm93IGluZGV4IG9yIGtleVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24geyd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbScsIHVuZGVmaW5lZC9udWxsfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2Vuc3VyZUluZGV4VmlzaWJsZShpZCwgaW5kZXgsIHBvc2l0aW9uKSB7XHJcbiAgY29uc3QgYXBpID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGlcclxuICBjb25zdCBub2RlID0gYXBpLmdldFJvd05vZGUoaW5kZXgpXHJcblxyXG4gIGlmIChub2RlKSB7XHJcbiAgICBhcGkuZW5zdXJlTm9kZVZpc2libGUobm9kZSwgcG9zaXRpb24pXHJcbiAgfSBlbHNlIHtcclxuICAgIGFwaS5lbnN1cmVJbmRleFZpc2libGUoTnVtYmVyKGluZGV4KSwgcG9zaXRpb24pXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfbmF2aWdhdGVUb05leHRSb3coaWQsIHBhcmFtcykge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgbGV0IHByZXZpb3VzQ2VsbCA9IHBhcmFtcy5wcmV2aW91c0NlbGxQb3NpdGlvblxyXG4gIGxldCBzdWdnZXN0ZWROZXh0Q2VsbCA9IHBhcmFtcy5uZXh0Q2VsbFBvc2l0aW9uXHJcblxyXG4gIGNvbnN0IEtFWV9VUCA9IDM4XHJcbiAgY29uc3QgS0VZX0RPV04gPSA0MFxyXG4gIGNvbnN0IEtFWV9MRUZUID0gMzdcclxuICBjb25zdCBLRVlfUklHSFQgPSAzOVxyXG5cclxuICBzd2l0Y2ggKHBhcmFtcy5rZXkpIHtcclxuICAgIGNhc2UgS0VZX0RPV046XHJcbiAgICAgIC8vIHNldCBzZWxlY3RlZCBjZWxsIG9uIGN1cnJlbnQgY2VsbCArIDFcclxuICAgICAgaWYgKHN1Z2dlc3RlZE5leHRDZWxsICYmICFzdWdnZXN0ZWROZXh0Q2VsbC5yb3dQaW5uZWQpIHtcclxuICAgICAgICBpZiAocHJldmlvdXNDZWxsLnJvd1Bpbm5lZCkge1xyXG4gICAgICAgICAgY29uc3Qgcm93ID0gb3B0aW9ucy5hcGkuZ2V0RGlzcGxheWVkUm93QXRJbmRleChcclxuICAgICAgICAgICAgb3B0aW9ucy5hcGkuZ2V0Rmlyc3REaXNwbGF5ZWRSb3coKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICAgaWYgKHJvdykge1xyXG4gICAgICAgICAgICByb3cuc2V0U2VsZWN0ZWQodHJ1ZSlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgb3B0aW9ucy5hcGkuZm9yRWFjaE5vZGUobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0NlbGwucm93SW5kZXggKyAxID09PSBub2RlLnJvd0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgbm9kZS5zZXRTZWxlY3RlZCh0cnVlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN1Z2dlc3RlZE5leHRDZWxsXHJcbiAgICBjYXNlIEtFWV9VUDpcclxuICAgICAgLy8gc2V0IHNlbGVjdGVkIGNlbGwgb24gY3VycmVudCBjZWxsIC0gMVxyXG4gICAgICBpZiAoc3VnZ2VzdGVkTmV4dENlbGwgJiYgIXN1Z2dlc3RlZE5leHRDZWxsLnJvd1Bpbm5lZCkge1xyXG4gICAgICAgIGlmIChwcmV2aW91c0NlbGwucm93UGlubmVkKSB7XHJcbiAgICAgICAgICBjb25zdCByb3cgPSBvcHRpb25zLmFwaS5nZXREaXNwbGF5ZWRSb3dBdEluZGV4KFxyXG4gICAgICAgICAgICBvcHRpb25zLmFwaS5nZXRMYXN0RGlzcGxheWVkUm93KClcclxuICAgICAgICAgIClcclxuICAgICAgICAgIGlmIChyb3cpIHtcclxuICAgICAgICAgICAgcm93LnNldFNlbGVjdGVkKHRydWUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG9wdGlvbnMuYXBpLmZvckVhY2hOb2RlKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJldmlvdXNDZWxsLnJvd0luZGV4IC0gMSA9PT0gbm9kZS5yb3dJbmRleCkge1xyXG4gICAgICAgICAgICAgIG5vZGUuc2V0U2VsZWN0ZWQodHJ1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHN1Z2dlc3RlZE5leHRDZWxsXHJcbiAgICBjYXNlIEtFWV9MRUZUOlxyXG4gICAgY2FzZSBLRVlfUklHSFQ6XHJcbiAgICAgIHJldHVybiBzdWdnZXN0ZWROZXh0Q2VsbFxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSBzdXBlciBzdHJhbmdlIGtleWJvYXJkJylcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcm93IGJhc2VkIG9uIGBnZXRSb3dOb2RlSWRgIGNvbmZpZyBkZWZpbmVkIGluIHRoZSBncmlkIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgIHRoZSBkYXRhIHJvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFJvd05vZGVJZChpZCwgZGF0YSkge1xyXG4gIHJldHVybiBkYXRhW2d3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dC5nZXRSb3dOb2RlSWRdXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIGdyaWQncyBkYXRhIHNldFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbiBqc29uIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbmV3IGRhdGFzZXQgdG8gdXBkYXRlIHRoZSBncmlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0Um93RGF0YShpZCwganNvbikge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIG9wdGlvbnMuYXBpLnNldFJvd0RhdGEoanNvbilcclxuICBvcHRpb25zLnJvd0RhdGEgPSBqc29uXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgdGhlIGdyaWQgd2l0aCBhIHRyYW5zYWN0aW9uIG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2FjdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3VwZGF0ZVJvd0RhdGEoaWQsIHRyYW5zYWN0aW9uLCBiYXRjaFVwZGF0ZSkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIGlmICh0cmFuc2FjdGlvbi5yZW1vdmUubGVuZ3RoKSB7XHJcbiAgICBsZXQgaXRlbXMgPSBbXVxyXG5cclxuICAgIHRyYW5zYWN0aW9uLnJlbW92ZS5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgaXRlbXMucHVzaChvcHRpb25zLmFwaS5nZXRSb3dOb2RlKGluZGV4KS5kYXRhKVxyXG4gICAgfSlcclxuXHJcbiAgICB0cmFuc2FjdGlvbi5yZW1vdmUgPSBpdGVtc1xyXG4gIH1cclxuXHJcbiAgaWYgKCFiYXRjaFVwZGF0ZSkge1xyXG4gICAgb3B0aW9ucy5hcGkuYXBwbHlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcclxuICB9IGVsc2Uge1xyXG4gICAgb3B0aW9ucy5hcGkuYXBwbHlUcmFuc2FjdGlvbkFzeW5jKHRyYW5zYWN0aW9uKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgaGVpZ2h0IG9mIGFsbCByb3dzXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IHRoZSByb3cgaGVpZ2h0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0Um93c0hlaWdodChpZCwgaGVpZ2h0KSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBhcGkgPSBvcHRpb25zLmFwaVxyXG5cclxuICBhcGkuZm9yRWFjaE5vZGUocm93ID0+IHtcclxuICAgIHJvdy5zZXRSb3dIZWlnaHQoaGVpZ2h0KVxyXG4gIH0pXHJcblxyXG4gIGFwaS5vblJvd0hlaWdodENoYW5nZWQoKVxyXG59XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBnaXZlbiByb3cgaGVpZ2h0XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCBpZFxyXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGluZGV4IHRoZSByb3cgaW5kZXggb3Iga2V5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgdGhlIG5ldyBoZWlnaHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRSb3dIZWlnaHQoaWQsIGluZGV4LCBoZWlnaHQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IGFwaSA9IG9wdGlvbnMuYXBpXHJcbiAgY29uc3Qgcm93ID0gYXBpLmdldFJvd05vZGUoaW5kZXgpIHx8IGFwaS5nZXREaXNwbGF5ZWRSb3dBdEluZGV4KGluZGV4KVxyXG5cclxuICBpZiAocm93KSB7XHJcbiAgICByb3cuc2V0Um93SGVpZ2h0KGhlaWdodClcclxuICAgIG9wdGlvbnMuYXBpLm9uUm93SGVpZ2h0Q2hhbmdlZCgpXHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHNldCBoZWlnaHQgZm9yIHJvdyAke2luZGV4fS4gUm93IGNhbm5vdCBiZSBmb3VuZGApXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmVzZXQgdGhlIHJvdyBoZWlnaHRcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgZ3JpZCBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3Jlc2V0Um93SGVpZ2h0cyhpZCkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnJlc2V0Um93SGVpZ2h0cygpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZWxlY3Qgcm93IG9yIG1vcmUgYmFzZWQgb24gdGhlIHJvdyBpZCBvciBpbmRleFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge0FycmF5fSByb3dzIGFuIGFycmF5IG9mIHJvdyBrZXlzIGFuZCBpbmRleGVzIHRvIHNlbGVjdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFNlbGVjdGVkUm93cyhpZCwgcm93cykge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcbiAgY29uc3QgYXBpID0gb3B0aW9ucy5hcGlcclxuXHJcbiAgYXBpLmZvckVhY2hOb2RlQWZ0ZXJGaWx0ZXJBbmRTb3J0KG5vZGUgPT4ge1xyXG4gICAgaWYgKFxyXG4gICAgICByb3dzLmluZGV4T2YoU3RyaW5nKG5vZGUucm93SW5kZXgpKSA+IC0xIHx8XHJcbiAgICAgIHJvd3MuaW5kZXhPZihTdHJpbmcobm9kZS5pZCkpID4gLTFcclxuICAgICkge1xyXG4gICAgICBub2RlLnNldFNlbGVjdGVkKHRydWUpXHJcbiAgICAgIG5vZGUuZXhwYW5kZWQgPSB0cnVlXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgYXBpLm9uR3JvdXBFeHBhbmRlZE9yQ29sbGFwc2VkKClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NlbGVjdEFsbChpZCwgZmlsdGVyZWQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG5cclxuICBpZiAoMSA9PT0gZmlsdGVyZWQpIHtcclxuICAgIG9wdGlvbnMuYXBpLnNlbGVjdEFsbEZpbHRlcmVkKClcclxuICB9IGVsc2Uge1xyXG4gICAgb3B0aW9ucy5hcGkuc2VsZWN0QWxsKClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19kZXNlbGVjdEFsbChpZCwgZmlsdGVyZWQpIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG5cclxuICBpZiAoMSA9PT0gZmlsdGVyZWQpIHtcclxuICAgIG9wdGlvbnMuYXBpLmRlc2VsZWN0QWxsRmlsdGVyZWQoKVxyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHRpb25zLmFwaS5kZXNlbGVjdEFsbCgpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IHNlbGVjdGVkIHJvd3NcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSAgc2VsZWN0ZWQgcm93cyBhcyBKU09OXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0U2VsZWN0ZWRSb3dzKGlkKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBub2RlcyA9IG9wdGlvbnMuYXBpLmdldFNlbGVjdGVkTm9kZXMoKVxyXG4gIGxldCBwYXJzZWQgPSBbXVxyXG5cclxuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgcGFyc2VkLnB1c2goZ3dfcGFyc2VOb2RlKG5vZGUsIG9wdGlvbnMuY29udGV4dCkpXHJcbiAgfSlcclxuXHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcnNlZClcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbGFzdCBzZWxlY3RlZCByb3dcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIGdyaWQncyBpZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzZWxlY3RlZCByb3cgYXMgSlNPTlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFNlbGVjdGVkUm93KGlkKSB7XHJcbiAgY29uc3Qgcm93cyA9IEpTT04ucGFyc2UoZ3dfZ2V0U2VsZWN0ZWRSb3dzKGlkKSlcclxuXHJcbiAgaWYgKHJvd3MubGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocm93c1tyb3dzLmxlbmd0aCAtIDFdKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuICcnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJvdyBieSBpdHMgaWQgb3IgaW5kZXhcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGluZGV4XHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gcm93IGFzIEpTT05cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRSb3coaWQsIGluZGV4KSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoXHJcbiAgICBnd19wYXJzZU5vZGUob3B0aW9ucy5hcGkuZ2V0Um93Tm9kZShpbmRleCksIG9wdGlvbnMuY29udGV4dClcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcm93cyBmcm9tIHRoZSBncmlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwaGFzZSBUaGUgcm93cyBwaGFzZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsdGVyRXhwcmVzc2lvbiBBIGZpbHRlciBleHByZXNzaW9uXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gSnNvbiBzdHJpbmdpZmllZCBhcnJheSBvZiByb3dzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfZ2V0Um93cyhpZCwgcGhhc2UsIGZpbHRlckV4cHJlc3Npb24pIHtcclxuICBjb25zdCBvcHRpb25zID0gZ3dfZ2V0R3JpZChpZCkub3B0aW9uc1xyXG4gIGNvbnN0IHBhcnNlZCA9IFtdXHJcblxyXG4gIG9wdGlvbnMuYXBpW3BoYXNlXShub2RlID0+IHtcclxuICAgIGlmICghbm9kZS5ncm91cCkge1xyXG4gICAgICBpZiAoZmlsdGVyRXhwcmVzc2lvbikge1xyXG4gICAgICAgIGNvbnN0IGNhblByb2Nlc3MgPSBnd19leGVjdXRlRXhwcmVzc2lvbihmaWx0ZXJFeHByZXNzaW9uLCB7XHJcbiAgICAgICAgICB2YWx1ZTogbm9kZS5kYXRhLFxyXG4gICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxyXG4gICAgICAgICAgb2xkVmFsdWU6IG51bGwsXHJcbiAgICAgICAgICBuZXdWYWx1ZTogbnVsbCxcclxuICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICBkYXRhOiBub2RlLmRhdGEsXHJcbiAgICAgICAgICBjb2xEZWY6IG51bGwsXHJcbiAgICAgICAgICByb3dJbmRleDogbm9kZS5yb3dJbmRleCxcclxuICAgICAgICAgIGFwaTogbm9kZS5ncmlkQXBpLFxyXG4gICAgICAgICAgY29sdW1uQXBpOiBub2RlLmNvbHVtbkFwaSxcclxuICAgICAgICAgIGdldFZhbHVlOiAoKSA9PiBub2RlLmRhdGEsXHJcbiAgICAgICAgICBjb2x1bW46IG51bGwsXHJcbiAgICAgICAgICBjb2x1bW5Hcm91cDpcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgICAgICAgICBub2RlLmhhc093blByb3BlcnR5KCdwYXJlbnQnKSAmJiBub2RlLnBhcmVudC5oYXNPd25Qcm9wZXJ0eSgna2V5JylcclxuICAgICAgICAgICAgICA/IG5vZGUucGFyZW50LmtleVxyXG4gICAgICAgICAgICAgIDogJycsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaWYgKGNhblByb2Nlc3MpIHtcclxuICAgICAgICAgIHBhcnNlZC5wdXNoKGd3X3BhcnNlTm9kZShub2RlLCBvcHRpb25zLmNvbnRleHQpKVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwYXJzZWQucHVzaChnd19wYXJzZU5vZGUobm9kZSwgb3B0aW9ucy5jb250ZXh0KSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBncmlkIHRvIHJlbW92ZSBhIHJvdyBmcm9tIHRoZSBET00gYW5kIHJlY3JlYXRlIGl0IGFnYWluIGZyb20gc2NyYXRjaC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIGdyaWQncyBpZFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3JlZHJhd1Jvd3MoaWQpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5yZWRyYXdSb3dzKClcclxufVxyXG5cclxuLyoqXHJcbiAqIFBpbiBhbiBhcnJheSBvZiB0b3cgdG8gdGhlIHRvcCBvZiB0aGUgZ3JpZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgdGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIGFycmF5IG9mIHJvd3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRQaW5uZWRUb3BSb3dEYXRhKGlkLCBkYXRhKSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0UGlubmVkVG9wUm93RGF0YShkYXRhKVxyXG59XHJcblxyXG4vKipcclxuICogUGluIGFuIGFycmF5IG9mIHRvdyB0byB0aGUgYm90dG9tIG9mIHRoZSBncmlkXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgb2Ygcm93c1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFBpbm5lZEJvdHRvbVJvd0RhdGEoaWQsIGRhdGEpIHtcclxuICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmFwaS5zZXRQaW5uZWRCb3R0b21Sb3dEYXRhKGRhdGEpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFN0YXRlKGlkLCBzdGF0ZSkge1xyXG4gIGNvbnN0IG9wdGlvbnMgPSBnd19nZXRHcmlkKGlkKS5vcHRpb25zXHJcblxyXG4gIHRyeSB7XHJcbiAgICBvcHRpb25zLmNvbHVtbkFwaS5zZXRDb2x1bW5TdGF0ZShzdGF0ZS5jb2x1bW5zKVxyXG4gICAgb3B0aW9ucy5jb2x1bW5BcGkuc2V0Q29sdW1uR3JvdXBTdGF0ZShzdGF0ZS5ncm91cHMpXHJcbiAgICBvcHRpb25zLmFwaS5zZXRTb3J0TW9kZWwoc3RhdGUuc29ydClcclxuICAgIG9wdGlvbnMuYXBpLnNldEZpbHRlck1vZGVsKHN0YXRlLmZpbHRlcnMpXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgZ3JpZCBzdGF0ZSBmcm9tIEpTT04nLCBlKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldFN0YXRlKGlkKSB7XHJcbiAgY29uc3Qgb3B0aW9ucyA9IGd3X2dldEdyaWQoaWQpLm9wdGlvbnNcclxuICBjb25zdCBjb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5BcGkuZ2V0Q29sdW1uU3RhdGUoKVxyXG4gIGNvbnN0IGdyb3VwcyA9IG9wdGlvbnMuY29sdW1uQXBpLmdldENvbHVtbkdyb3VwU3RhdGUoKVxyXG4gIGNvbnN0IHNvcnQgPSBvcHRpb25zLmFwaS5nZXRTb3J0TW9kZWwoKVxyXG4gIGNvbnN0IGZpbHRlcnMgPSBvcHRpb25zLmFwaS5nZXRGaWx0ZXJNb2RlbCgpXHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBjb2x1bW5zLFxyXG4gICAgICBncm91cHMsXHJcbiAgICAgIHNvcnQsXHJcbiAgICAgIGZpbHRlcnMsXHJcbiAgICB9KVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNvbnZlcnQgdGhlIGdyaWQgc3RhdGUgdG8ganNvbicsIGUpXHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2dldEdyaWQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19zZXRTdGF0dXNiYXJDb21wb25lbnRWaXNpYmlsaXR5KGlkLCBrZXksIHZpc2liaWxpdHkpIHtcclxuICBnd19nZXRHcmlkKGlkKVxyXG4gICAgLm9wdGlvbnMuYXBpLmdldFN0YXR1c1BhbmVsKGtleSlcclxuICAgIC5zZXRWaXNpYmxlKEJvb2xlYW4odmlzaWJpbGl0eSkpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3NldFNpZGVCYXJWaXNpYmxlKGlkLCB2YWx1ZSkge1xyXG4gIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuYXBpLnNldFNpZGVCYXJWaXNpYmxlKEJvb2xlYW4odmFsdWUpKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb3BlblRvb2xwYW5lbChncmlkSWQsIHRvb2xwYW5lbElkKSB7XHJcbiAgZ3dfZ2V0R3JpZChncmlkSWQpLm9wdGlvbnMuYXBpLm9wZW5Ub29sUGFuZWwodG9vbHBhbmVsSWQpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19jbG9zZVRvb2xwYW5lbChncmlkSWQsIHRvb2xwYW5lbElkKSB7XHJcbiAgZ3dfZ2V0R3JpZChncmlkSWQpLm9wdGlvbnMuYXBpLmNsb3NlVG9vbFBhbmVsKHRvb2xwYW5lbElkKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2V0RnVuY3Rpb25zUmVhZE9ubHkoaWQsIHJlYWRvbmx5KSB7XHJcbiAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5hcGkuc2V0RnVuY3Rpb25zUmVhZE9ubHkoQm9vbGVhbihyZWFkb25seSkpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QEJhc2lzLkFnR3JpZENvbXBvbmVudHMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vKipcclxuICogR2V0IGRvY3VtZW50XHJcbiAqXHJcbiAqIEdldCB0aGUgZG9jdW1lbnQgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IEJCaiBlbnZcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSBEb2N1bWVudCBpbnN0YW5jZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2dldERvY3VtZW50KCkge1xyXG4gIHJldHVybiB0eXBlb2YgJGRvYyAhPT0gJ3VuZGVmaW5lZCcgPyAkZG9jIDogZG9jdW1lbnRcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB3aW5kb3dcclxuICpcclxuICogR2V0IHRoZSB3aW5kb3cgaW5zdGFuY2UgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IEJCaiBlbnZcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSBXaW5kb3cgaW5zdGFuY2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRXaW5kb3coKSB7XHJcbiAgcmV0dXJuIHR5cGVvZiAkd25kICE9PSAndW5kZWZpbmVkJyA/ICR3bmQgOiB3aW5kb3dcclxufVxyXG5cclxuLyoqXHJcbiAqIEVzY2FwZSBWYWx1ZVxyXG4gKlxyXG4gKiBDaGFuZ2UgbnVsbCBhbmQgdW5kZWZpbmVkIHRvIGVtcHR5IHN0cmluZ1xyXG4gKlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAqXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gZXNjYXBlZCB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2VzY2FwZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAnJ1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGUgYSB1bmlxdWUgdXVpZFxyXG4gKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9jcmVhdGUtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd191dWlkKCkge1xyXG4gIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcclxuICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxyXG4gICAgICB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4XHJcbiAgICByZXR1cm4gdi50b1N0cmluZygxNilcclxuICB9KVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IEdyaWRcclxuICpcclxuICogUmV0cmlldmUgdGhlIGdyaWQgaW5zdGFuY2UgZnJvbSBgd2luZG93LkJCakdyaWRFeFdpZGdldGAgYXJyYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBncmlkJ3MgaW5zdGFuY2Ugb2ZyIG51bGxcclxuICogQHRocm93cyBUeXBlRXJyb3Igd2hlbiB0aGUgZ3JpZCBpbnN0YW5jZSBpcyBub3QgZm91bmRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19nZXRHcmlkKGlkKSB7XHJcbiAgd2luZG93LkJCakdyaWRFeFdpZGdldCA9IHdpbmRvdy5CQmpHcmlkRXhXaWRnZXQgfHwge31cclxuICBjb25zdCBncmlkID0gd2luZG93LkJCakdyaWRFeFdpZGdldFtpZF0gfHwgbnVsbFxyXG5cclxuICBpZiAoIWdyaWQpIHtcclxuICAgIGNvbnN0IHJlZ2lzdGVyZWRHcmlkcyA9IEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHdpbmRvdy5CQmpHcmlkRXhXaWRnZXQpKVxyXG4gICAgLy9nZXRGdW5jQXJncyhmdW5jKS5mb3JFYWNoKChrZXksIGkpID0+IGFyZ3NPYmpba2V5XSA9IGFyZ3NbaV0pO1xyXG5cclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgIGBcXG5cXG5bR3JpZCBOb3QgRm91bmRdIFRoZSBtZXRob2QgYXNrZWQgZm9yIG5vbi1leGlzdGVudCBncmlkIGluc3RhbmNlLlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblJlcXVpcmVkIEdyaWQgSWQgOiAke2lkfSAgIFxyXG5SZWdpc3RlcmVkIEdyaWRzIDogJHtyZWdpc3RlcmVkR3JpZHN9XHJcbmBcclxuICAgIClcclxuICB9XHJcblxyXG4gIHJldHVybiBncmlkXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgR3JpZFxyXG4gKlxyXG4gKiBTdG9yZSBhIG5ldyBncmlkIGluc3RhbmNlIGJ5IGluIHRoZSBgd2luZG93LkJCakdyaWRFeFdpZGdldGAgYXJyYXlcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgIFRoZSBncmlkJ3Mgb3B0aW9uc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IFN0b3JlZCBncmlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfYWRkR3JpZChpZCwgb3B0aW9ucykge1xyXG4gIHdpbmRvdy5CQmpHcmlkRXhXaWRnZXQgPSB3aW5kb3cuQkJqR3JpZEV4V2lkZ2V0IHx8IHt9XHJcbiAgd2luZG93LkJCakdyaWRFeFdpZGdldFtpZF0gPSBvcHRpb25zXHJcblxyXG4gIHJldHVybiBnd19nZXRHcmlkKGlkKVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBpbXByb3ZlZCB0b29sdGlwIGNvbXBvbmVudCB3aGljaCBzdXBwb3J0cyBIVE1MIGFuZCBiZWhhdmVzIHRoZSBzYW1lIGluIGJvdGggR1VJIGFuZCBCVUlcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyXHJcbiAqL1xyXG5jbGFzcyBIVE1MVG9vbHRpcCB7XHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IHRoZSBjb21wb25lbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgdGhlIHRvb2x0aXAgY29tcG9uZW50IHBhcmFtc1xyXG4gICAqL1xyXG4gIGluaXQocGFyYW1zKSB7XHJcbiAgICBjb25zdCBlR3VpID0gKHRoaXMuZUd1aSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxyXG4gICAgY29uc3QgdG9vbHRpcFZhbHVlR2V0dGVyID0gcGFyYW1zLmNvbERlZi50b29sdGlwVmFsdWVHZXR0ZXJcclxuICAgIGNvbnN0IGlzSGVhZGVyID0gcGFyYW1zLnJvd0luZGV4ID09PSB1bmRlZmluZWRcclxuICAgIGNvbnN0IGlzR3JvdXBlZEhlYWRlciA9IGlzSGVhZGVyICYmICEhcGFyYW1zLmNvbERlZi5jaGlsZHJlblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgY29uc3QgZGF0YSA9XHJcbiAgICAgICFpc0hlYWRlciAmJiAhaXNHcm91cGVkSGVhZGVyXHJcbiAgICAgICAgPyBwYXJhbXMuYXBpLmdldERpc3BsYXllZFJvd0F0SW5kZXgocGFyYW1zLnJvd0luZGV4KS5kYXRhXHJcbiAgICAgICAgOiBudWxsXHJcbiAgICBjb25zdCB0aGVtZSA9IHBhcmFtcy5hcGkuZ3JpZENvcmUuZUdyaWREaXYuY2xhc3NOYW1lLmVuZHNXaXRoKCdkYXJrJylcclxuICAgICAgPyAnZ3ctdG9vbHRpcC1kYXJrJ1xyXG4gICAgICA6ICdndy10b29sdGlwLWxpZ2h0J1xyXG4gICAgY29uc3QgdG9vbHRpcEZpZWxkID0gcGFyYW1zLmNvbERlZi50b29sdGlwRmllbGRcclxuICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXHJcbiAgICAgICAgZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KHBhcmFtcy5jb2xEZWYudG9vbHRpcEZpZWxkKVxyXG4gICAgICAgID8gZGF0YVtwYXJhbXMuY29sRGVmLnRvb2x0aXBGaWVsZF1cclxuICAgICAgICA6IG51bGxcclxuICAgICAgOiBudWxsXHJcblxyXG4gICAgY29uc3QgcGFzc2VkUGFyYW1zID0ge1xyXG4gICAgICAuLi5wYXJhbXMsXHJcbiAgICAgIC4uLnsgZGF0YSB9LFxyXG4gICAgICAuLi57IGlzSGVhZGVyLCBpc0dyb3VwZWRIZWFkZXIsIHRvb2x0aXBGaWVsZCB9LFxyXG4gICAgfVxyXG5cclxuICAgIGVHdWkuY2xhc3NMaXN0LmFkZCgnZ3ctdG9vbHRpcCcsIHRoZW1lKVxyXG4gICAgZUd1aS5pbm5lckhUTUwgPVxyXG4gICAgICBpc0hlYWRlciB8fCBpc0dyb3VwZWRIZWFkZXJcclxuICAgICAgICA/IHBhcmFtcy52YWx1ZVxyXG4gICAgICAgIDogdG9vbHRpcEZpZWxkXHJcbiAgICAgICAgPyB0b29sdGlwRmllbGRcclxuICAgICAgICA6IHRvb2x0aXBWYWx1ZUdldHRlclxyXG4gICAgICAgID8gdG9vbHRpcFZhbHVlR2V0dGVyKHBhc3NlZFBhcmFtcylcclxuICAgICAgICA6IHBhcmFtcy52YWx1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBndWkgSW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldEd1aSgpIHtcclxuICAgIHJldHVybiB0aGlzLmVHdWlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhUTUxUb29sdGlwXHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCBhdXRvY29tcGxldGUgZnJvbSAnYXV0b2NvbXBsZXRlcidcclxuaW1wb3J0IHRlbXBsYXRlIGZyb20gJ2xvZGFzaC1lcy90ZW1wbGF0ZSdcclxuaW1wb3J0IHsgZ3dfcGFyc2VOb2RlIH0gZnJvbSAnZXZlbnRzL3V0aWxpdGllcydcclxuLyoqXHJcbiAqIEFuIGF1dG9jb21wbGV0ZSBjZWxsIGVkaXRvciB3cml0dGVuIHNwZWNpZmljYWxseSB0byBCQmpHcmlkRXhXaWRnZXRcclxuICpcclxuICogQGF1dGhvciBIeXlhbiBBYm8gRmFraGVyXHJcbiAqL1xyXG5jbGFzcyBTdWdnZXN0aW9uRWRpdG9yIHtcclxuICAvKipcclxuICAgKiBJbml0aWFsaXplIHRoZSBjb21wb25lbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4gdm9pZFxyXG4gICAqL1xyXG4gIGluaXQocGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXR0ZXJuID0gcGFyYW1zLnRleHRQYXR0ZXJuIHx8IG51bGxcclxuICAgIGNvbnN0IHJlcXVpcmVkID0gcGFyYW1zLnRleHRSZXF1aXJlZCB8fCBmYWxzZVxyXG4gICAgY29uc3QgdGl0bGUgPSBwYXJhbXMudGV4dFRpdGxlIHx8IG51bGxcclxuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gcGFyYW1zLmRlYm91bmNlV2FpdE1zIHx8IDI1MFxyXG5cclxuICAgIGxldCBzdGFydFZhbHVlXHJcblxyXG4gICAgdGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkID0gcGFyYW1zLmNlbGxTdGFydGVkRWRpdFxyXG4gICAgaWYgKHRoaXMuX2ZvY3VzQWZ0ZXJBdHRhY2hlZCkge1xyXG4gICAgICBjb25zdCBrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlID1cclxuICAgICAgICBwYXJhbXMua2V5UHJlc3MgPT0gMzIgfHwgcGFyYW1zLmtleVByZXNzID09IDQ2IC8vIHNwYWNlIC8vIGRlbGV0ZVxyXG5cclxuICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcclxuICAgICAgICBzdGFydFZhbHVlID0gJydcclxuICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XHJcbiAgICAgICAgc3RhcnRWYWx1ZSA9IHBhcmFtcy5jaGFyUHJlc3NcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGFydFZhbHVlID0gcGFyYW1zLnZhbHVlXHJcbiAgICAgICAgaWYgKHBhcmFtcy5rZXlQcmVzcyAhPSAxMTMpIHtcclxuICAgICAgICAgIC8vRjJcclxuICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodEFsbE9uRm9jdXMgPSB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdGFydFZhbHVlID0gcGFyYW1zLnZhbHVlXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zXHJcblxyXG4gICAgdGhpcy5fZ3VpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIHRoaXMuX2d1aS5jbGFzc05hbWUgPSAnYXV0b2NvbXBsZXRlSW5wdXRXcmFwcGVyIGFnLWNlbGwtZWRpdC13cmFwcGVyJ1xyXG4gICAgdGhpcy5fZ3VpLnRhYkluZGV4ID0gJzAnXHJcbiAgICB0aGlzLl9ndWkuaW5uZXJIVE1MID0gLyogaHRtbCAqLyBgXHJcbiAgICA8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0b3IgYWctbGFiZWxlZCBhZy1sYWJlbC1hbGlnbi1sZWZ0IGFnLXRleHQtZmllbGQgYWctaW5wdXQtZmllbGRcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImFnLXdyYXBwZXIgYWctaW5wdXQtd3JhcHBlciBhZy10ZXh0LWZpZWxkLWlucHV0LXdyYXBwZXJcIj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIGBcclxuXHJcbiAgICAvLyBpbnB1dFxyXG4gICAgdGhpcy5faW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXHJcbiAgICB0aGlzLl9pbnB1dC5jbGFzc05hbWUgPVxyXG4gICAgICAnYXV0b2NvbXBsZXRlSW5wdXRXcmFwcGVyX19pbnB1dCBhZy1jZWxsLWVkaXQtaW5wdXQgYWctaW5wdXQtZmllbGQtaW5wdXQgYWctdGV4dC1maWVsZC1pbnB1dCdcclxuICAgIHRoaXMuX2lucHV0LnR5cGUgPSAndGV4dCdcclxuICAgIHRoaXMuX2lucHV0LnZhbHVlID0gc3RhcnRWYWx1ZVxyXG4gICAgdGhpcy5faW5wdXQudGFiSW5kZXggPSAwXHJcblxyXG4gICAgdGhpcy5fZ3VpLnF1ZXJ5U2VsZWN0b3IoJy5hZy1pbnB1dC13cmFwcGVyJykuYXBwZW5kQ2hpbGQodGhpcy5faW5wdXQpXHJcblxyXG4gICAgaWYgKHBhdHRlcm4gIT09IG51bGwpIHtcclxuICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKCdwYXR0ZXJuJywgcGF0dGVybilcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKCdyZXF1aXJlZCcsICdyZXF1aXJlZCcpXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRpdGxlICE9PSBudWxsICYmIHRpdGxlICE9PSAnZGVmYXVsdCcpIHtcclxuICAgICAgdGhpcy5faW5wdXQudGl0bGUgPSB0aXRsZVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKVxyXG5cclxuICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25DaGFuZ2UpXHJcbiAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSlcclxuXHJcbiAgICAvLyBzZXR1cCB0aGUgYXV0b2NvbXBsZXRlIGNvbXBvbmVudFxyXG4gICAgdGhpcy5fcmVuZGVySXRlbVRlbXBsYXRlID0gdGhpcy5fcGFyYW1zLml0ZW1UZW1wbGF0ZVxyXG4gICAgICA/IHRlbXBsYXRlKHRoaXMuX3BhcmFtcy5pdGVtVGVtcGxhdGUpXHJcbiAgICAgIDogJydcclxuICAgIHRoaXMuX3JlbmRlckdyb3VwVGVtcGxhdGUgPSB0aGlzLl9wYXJhbXMuZ3JvdXBUZW1wbGF0ZVxyXG4gICAgICA/IHRlbXBsYXRlKHRoaXMuX3BhcmFtcy5ncm91cFRlbXBsYXRlKVxyXG4gICAgICA6ICcnXHJcbiAgICB0aGlzLl9hdXRvY29tcGxldGUgPSBhdXRvY29tcGxldGUoe1xyXG4gICAgICBpbnB1dDogdGhpcy5faW5wdXQsXHJcbiAgICAgIGRlYm91bmNlV2FpdE1zOiBkZWJvdW5jZVdhaXRNcyxcclxuICAgICAgLy8gd2l0aG91dCB0aGlzIG9wdGlvbiBlbmFibGVkICwgdGhlIGxpc3Qgd29udCBiZSBjbG9zZWQgaW4gR1VJXHJcbiAgICAgIHByZXZlbnRTdWJtaXQ6IHRydWUsXHJcbiAgICAgIGZldGNoOiB0aGlzLl9vbkF1dG9jb21wbGV0ZUZldGNoLmJpbmQodGhpcyksXHJcbiAgICAgIG9uU2VsZWN0OiB0aGlzLl9vbkF1dG9jb21wbGV0ZVNlbGVjdC5iaW5kKHRoaXMpLFxyXG4gICAgICByZW5kZXJHcm91cDogdGhpcy5fb25BdXRvY29tcGxldGVSZW5kZXJHcm91cC5iaW5kKHRoaXMpLFxyXG4gICAgICByZW5kZXI6IHRoaXMuX29uQXV0b2NvbXBsZXRlUmVuZGVySXRlbS5iaW5kKHRoaXMpLFxyXG4gICAgICBjdXN0b21pemU6IHRoaXMuX29uQXV0b2NvbXBsZXRlQ3VzdG9taXplLmJpbmQodGhpcyksXHJcbiAgICAgIGVtcHR5TXNnOiB0aGlzLl9wYXJhbXMuZW1wdHlNZXNzYWdlIHx8IG51bGwsXHJcbiAgICAgIG1pbkxlbmd0aDogdGhpcy5fcGFyYW1zLm1pbkxlbmd0aCB8fCAyLFxyXG4gICAgICBzaG93T25Gb2N1czogdGhpcy5fcGFyYW1zLnNob3dPbkZvY3VzIHx8IGZhbHNlLFxyXG4gICAgICBjbGFzc05hbWU6IHBhcmFtcy5hcGkuZ3JpZENvcmUuZUdyaWREaXYuY2xhc3NOYW1lLmVuZHNXaXRoKCdkYXJrJylcclxuICAgICAgICA/ICdkYXJrJ1xyXG4gICAgICAgIDogJ2xpZ2h0JyxcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIERPTSBlbGVtZW50IG9mIHRoZSBjb21wb25lbnQsIHRoaXMgaXMgd2hhdCB0aGUgZ3JpZCBwdXRzIGludG8gdGhlIGNlbGxcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIGdldEd1aSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ndWlcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgY2FsbGVkIG9uY2UgYWZ0ZXIgR1VJIGlzIGF0dGFjaGVkIHRvIERPTS5cclxuICAgKlxyXG4gICAqIE1ha2Ugc3VyZSBjb250YWluZXIgaXMgYWx3YXlzIGZvY3VzZWQgdG8gbGlzdGVuIHRvIGtleSBjaGFuZ2VzXHJcbiAgICovXHJcbiAgYWZ0ZXJHdWlBdHRhY2hlZCgpIHtcclxuICAgIGlmICh0aGlzLl9oaWdobGlnaHRBbGxPbkZvY3VzKSB7XHJcbiAgICAgIHRoaXMuX2lucHV0LnNlbGVjdCgpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5fZm9jdXNBZnRlckF0dGFjaGVkKSB7XHJcbiAgICAgICAgdGhpcy5mb2N1c0luKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IFRoZSBjb21wb25lbnQgdmFsdWVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgKi9cclxuICBnZXRWYWx1ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9pbnB1dC52YWx1ZVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgZG9pbmcgZnVsbCByb3cgZWRpdCwgdGhlbiBnZXRzIGNhbGxlZCB3aGVuIHRhYmJpbmcgaW50byB0aGUgY2VsbC5cclxuICAgKi9cclxuICBmb2N1c0luKCkge1xyXG4gICAgdGhpcy5faW5wdXQuZm9jdXMoKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBjYWxsZWQgb25jZSB3aGVuIGVkaXRpbmcgaXMgZmluaXNoZWQgKGVnIGlmIGVudGVyIGlzIHByZXNzZWQpLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgd2hlbiB0aGUgcmVzdWx0IG9mIHRoZSBlZGl0IHdpbGwgYmUgaWdub3JlZC4gZmFsc2Ugb3RoZXJ3aXNlXHJcbiAgICovXHJcbiAgaXNDYW5jZWxBZnRlckVuZCgpIHtcclxuICAgIGNvbnN0IGFsbG93Q3VzdG9tVmFsdWVzID0gdGhpcy5fcGFyYW1zLmFsbG93Q3VzdG9tVmFsdWVzIHx8IGZhbHNlXHJcbiAgICBsZXQgaXNWYWxpZCA9IHRoaXMuX3ZhbGlkYXRlSW5wdXQodGhpcy5faW5wdXQpXHJcblxyXG4gICAgaWYgKGlzVmFsaWQgJiYgYWxsb3dDdXN0b21WYWx1ZXMgPT09IGZhbHNlICYmIHRoaXMuX2xhc3RGZXRjaGVkRGF0YSkge1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZEl0ZW1zID0gdGhpcy5fbGFzdEZldGNoZWREYXRhLmZpbHRlcihcclxuICAgICAgICB4ID0+IHgudmFsdWUgPT09IHRoaXMuX2lucHV0LnZhbHVlXHJcbiAgICAgIClcclxuICAgICAgaXNWYWxpZCA9IGZpbHRlcmVkSXRlbXMubGVuZ3RoID09PSAxXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICFpc1ZhbGlkXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxyXG4gICAqXHJcbiAgICogQ2xlYXIgdGhlIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIGFuZCBkZXN0cm95IHRoZSBhdXRvY29tcGxldGVcclxuICAgKi9cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbkNoYW5nZSlcclxuICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKVxyXG4gICAgdGhpcy5fYXV0b2NvbXBsZXRlLmRlc3Ryb3koKVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgdG8gcHJlcGFyZSBzdWdnZXN0aW9ucyBhbmQgdGhlbiBwYXNzIHRoZW0gdG8gYXV0b2NvbXBsZXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgaW4gdGhlIGlucHV0IGZpZWxkXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBtdXN0IGJlIGNhbGxlZCBhZnRlciBzdWdnZXN0aW9ucyBhcmUgcHJlcGFyZWRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBmYWxzZSB3aGVuIHRoZSByZXF1ZXN0IGlzIGlnbm9yZWQgLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBfb25BdXRvY29tcGxldGVGZXRjaCh0ZXh0LCB1cGRhdGUpIHtcclxuICAgIGNvbnN0IHN1cHByZXNzU3VnZ2VzdGlvbk9uSW52YWxpZElucHV0ID1cclxuICAgICAgdGhpcy5fcGFyYW1zLnN1cHByZXNzU3VnZ2VzdGlvbk9uSW52YWxpZElucHV0IHx8IGZhbHNlXHJcbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5fdmFsaWRhdGVJbnB1dCh0aGlzLl9pbnB1dClcclxuXHJcbiAgICBpZiAoc3VwcHJlc3NTdWdnZXN0aW9uT25JbnZhbGlkSW5wdXQgJiYgIWlzVmFsaWQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaWQgPSB0aGlzLl9wYXJhbXMuZXZlbnRJZFxyXG5cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoaWQsIGV2ZW50ID0+IHtcclxuICAgICAgdGhpcy5fbGFzdEZldGNoZWREYXRhID0gZXZlbnQuZGV0YWlsXHJcbiAgICAgIHVwZGF0ZShldmVudC5kZXRhaWwpXHJcbiAgICB9KVxyXG5cclxuICAgIHdpbmRvdy5iYXNpc0Rpc3BhdGNoQ3VzdG9tRXZlbnQodGhpcy5fcGFyYW1zLmVHcmlkQ2VsbCwge1xyXG4gICAgICB0eXBlOiAnZ3cuc3VnZ2VzdGlvbicsXHJcbiAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGlkLFxyXG4gICAgICAgIHRleHQsXHJcbiAgICAgICAgY29sdW1uOiB0aGlzLl9wYXJhbXMuY29sRGVmLmZpZWxkLFxyXG4gICAgICAgIHJvdzogZ3dfcGFyc2VOb2RlKFxyXG4gICAgICAgICAgdGhpcy5fcGFyYW1zLm5vZGUsXHJcbiAgICAgICAgICB0aGlzLl9wYXJhbXMuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcbiAgICAgICAgKSxcclxuICAgICAgfSksXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aGVuIHVzZXIgY2hvb3NlIGFuIGl0ZW0gaW4gYXV0b2NvbXBsZXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZW0gVGhlIHNlbGVjdGVkIGl0ZW1cclxuICAgKi9cclxuICBfb25BdXRvY29tcGxldGVTZWxlY3QoaXRlbSkge1xyXG4gICAgdGhpcy5faW5wdXQudmFsdWUgPSBpdGVtLnZhbHVlXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG92ZXJyaWRlcyB0aGUgcmVuZGVyaW5nIGZ1bmN0aW9uIG9mIGF1dG9jb21wbGV0ZSBpdGVtcy5cclxuICAgKlxyXG4gICAqIEl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIHN1Z2dlc3Rpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIHN1Z2dlc3Rpb24gb2JqZWN0XHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRWYWx1ZSBUaGUgY3VycmVudCBpbnB1dCBmaWVsZCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxyXG4gICAqL1xyXG4gIF9vbkF1dG9jb21wbGV0ZVJlbmRlckl0ZW0oaXRlbSwgY3VycmVudFZhbHVlKSB7XHJcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxyXG4gICAgZGl2LmNsYXNzTmFtZSA9ICdzdWdnZXN0aW9uLWl0ZW0nXHJcblxyXG4gICAgaWYgKHRoaXMuX3JlbmRlckl0ZW1UZW1wbGF0ZSkge1xyXG4gICAgICBkaXYuaW5uZXJIVE1MID0gdGhpcy5fcmVuZGVySXRlbVRlbXBsYXRlKHtcclxuICAgICAgICBpdGVtLFxyXG4gICAgICAgIGN1cnJlbnRWYWx1ZSxcclxuICAgICAgfSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGRpdi5pbm5lckhUTUwgPSBpdGVtLmxhYmVsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRpdlxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBvdmVycmlkZXMgdGhlIHJlbmRlcmluZyBmdW5jdGlvbiBvZiBhdXRvY29tcGxldGUgZ3JvdXBzLlxyXG4gICAqXHJcbiAgICogSXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggZ3JvdXBcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgVGhlIGdyb3VwIG5hbWVcclxuICAgKiBAcGFyYW0ge1N0cmluZ30gY3VycmVudFZhbHVlIFRoZSBjdXJyZW50IGlucHV0IGZpZWxkIHZhbHVlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XHJcbiAgICovXHJcbiAgX29uQXV0b2NvbXBsZXRlUmVuZGVyR3JvdXAoZ3JvdXBOYW1lLCBjdXJyZW50VmFsdWUpIHtcclxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICBkaXYuY2xhc3NOYW1lID0gJ3N1Z2dlc3Rpb24tZ3JvdXAnXHJcblxyXG4gICAgaWYgKHRoaXMuX3JlbmRlckdyb3VwVGVtcGxhdGUpIHtcclxuICAgICAgZGl2LmlubmVySFRNTCA9IHRoaXMuX3JlbmRlckdyb3VwVGVtcGxhdGUoeyBncm91cE5hbWUsIGN1cnJlbnRWYWx1ZSB9KVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGl2LmlubmVySFRNTCA9IGdyb3VwTmFtZVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkaXZcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhvb2sgb24gdGhlIGF1dG9jb21wbGV0ZSBjb250YWluZXIgcmVuZGVyIGFuZCBjaGFuZ2UgdGhlIHdpZHRoIGFuZCB0aGVcclxuICAgKiBoZWlnaHQgYWNjb3JkaW5nIHRvIHRoZSBvcHRpb25zXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpbnB1dFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0UmVjdFxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXhIZWlnaHRcclxuICAgKi9cclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuICBfb25BdXRvY29tcGxldGVDdXN0b21pemUoaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpIHtcclxuICAgIGlmICh0aGlzLl9wYXJhbXMud2lkdGgpIHtcclxuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fcGFyYW1zLndpZHRofXB4YFxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9wYXJhbXMuaGVpZ2h0KSB7XHJcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9wYXJhbXMuaGVpZ2h0fXB4YFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdCB0byB0aGUgaW5wdXQgY2hhbmdlcyBhbmQgdmFsaWRhdGUgaXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RXZlbnR9IFRoZSBldmVudCBvYmplY3RcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIHdoZW4gdmFsaWQgLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKi9cclxuICBfb25DaGFuZ2UoZXZlbnQpIHtcclxuICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZUlucHV0KGV2ZW50LnRhcmdldClcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERvIHZhbGlkYXRlIHRoZSBnaXZlbiBpbnB1dCBlbGVtZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0IGlucHV0IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgd2hlbiB2YWxpZCAsIGZhbHNlIG90aGVyd2lzZVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUlucHV0KGlucHV0KSB7XHJcbiAgICBjb25zdCBpc1ZhbGlkID0gaW5wdXQuY2hlY2tWYWxpZGl0eSgpXHJcblxyXG4gICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2F1dG9jb21wbGV0ZS1pbnB1dC1lcnJvcicpXHJcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2F1dG9jb21wbGV0ZS1pbnB1dC1zdWNjZXNzJylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5yZW1vdmUoJ2F1dG9jb21wbGV0ZS1pbnB1dC1lcnJvcicpXHJcbiAgICAgIGlucHV0LmNsYXNzTGlzdC5hZGQoJ2F1dG9jb21wbGV0ZS1pbnB1dC1zdWNjZXNzJylcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaXNWYWxpZFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3VnZ2VzdGlvbkVkaXRvclxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG4vLyBzZWxlY3Rpb24gY29uc3RhbnRzXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9ST1dfU0VMRUNUID0gNjlcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX1JPV19DTElDSyA9IDUwMTFcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX1JPV19ET1VCTEVfQ0xJQ0sgPSA1MlxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfQ0VMTF9DTElDSyA9IDUwMDFcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX0NFTExfRE9VQkxFX0NMSUNLID0gNTAwMlxyXG5cclxuLy8gZWRpdGluZyBjb25zdGFudHNcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX0NFTExfRURJVElOR19TVEFSVEVEID0gNTAwM1xyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUT1BQRUQgPSA1MDA0XHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9DRUxMX1ZBTFVFX0NIQU5HRUQgPSA1MDA1XHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9ST1dfRURJVElOR19TVEFSVEVEID0gNTAwNlxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUk9XX0VESVRJTkdfU1RPUFBFRCA9IDUwMDdcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX1JPV19WQUxVRV9DSEFOR0VEID0gNTAxMlxyXG5cclxuLy8gc3RhdGUgY29uc3RhbnRzXHJcbmV4cG9ydCBjb25zdCBHV19FVkVOVF9HUklEX1NUQVRFX0NIQU5HRSA9IDUwMDhcclxuXHJcbi8vIHJhbmdlIHNlbGVjdGlvblxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRUQgPSA1MDA5XHJcblxyXG4vLyBrZXlib2FyZCBldmVudHNcclxuZXhwb3J0IGNvbnN0IEdXX0VWRU5UX0tFWVBSRVNTID0gNTAxMFxyXG5cclxuLy8gZmlsdGVyc1xyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfRklMVEVSX0NIQU5HRUQgPSA1MDEzXHJcblxyXG4vLyByZWFkeVxyXG5leHBvcnQgY29uc3QgR1dfRVZFTlRfUkVBRFkgPSA1MDE0XHJcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xyXG4vKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19zZW5kRXZlbnQsIGd3X3BhcnNlTm9kZUZyb21FdmVudCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19lc2NhcGUsIGd3X2dldEdyaWQgfSBmcm9tICdhcGkvdXRpbGl0aWVzJ1xyXG5pbXBvcnQge1xyXG4gIEdXX0VWRU5UX0NFTExfRURJVElOR19TVEFSVEVELFxyXG4gIEdXX0VWRU5UX0NFTExfRURJVElOR19TVE9QUEVELFxyXG4gIEdXX0VWRU5UX0NFTExfVkFMVUVfQ0hBTkdFRCxcclxuICBHV19FVkVOVF9ST1dfRURJVElOR19TVEFSVEVELFxyXG4gIEdXX0VWRU5UX1JPV19FRElUSU5HX1NUT1BQRUQsXHJcbiAgR1dfRVZFTlRfUk9XX1ZBTFVFX0NIQU5HRUQsXHJcbn0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG5jb25zdCBDRUxMX0VESVRJTkdfRVZFTlRTX01BUCA9IHtcclxuICBjZWxsRWRpdGluZ1N0YXJ0ZWQ6IEdXX0VWRU5UX0NFTExfRURJVElOR19TVEFSVEVELFxyXG4gIGNlbGxFZGl0aW5nU3RvcHBlZDogR1dfRVZFTlRfQ0VMTF9FRElUSU5HX1NUT1BQRUQsXHJcbiAgY2VsbFZhbHVlQ2hhbmdlZDogR1dfRVZFTlRfQ0VMTF9WQUxVRV9DSEFOR0VELFxyXG59XHJcblxyXG5jb25zdCBST1dfRURJVElOR19FVkVOVFNfTUFQID0ge1xyXG4gIHJvd0VkaXRpbmdTdGFydGVkOiBHV19FVkVOVF9ST1dfRURJVElOR19TVEFSVEVELFxyXG4gIHJvd0VkaXRpbmdTdG9wcGVkOiBHV19FVkVOVF9ST1dfRURJVElOR19TVE9QUEVELFxyXG4gIHJvd1ZhbHVlQ2hhbmdlZDogR1dfRVZFTlRfUk9XX1ZBTFVFX0NIQU5HRUQsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgY2VsbEVkaXRpbmdTdGFydGVkYCAsIGBjZWxsRWRpdGluZ1N0b3BwZWRgIGFuZFxyXG4gKiBgY2VsbFZhbHVlQ2hhbmdlZGAgZXZlbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlICBUaGUgZXZlbnQgcGF5bG9hZFxyXG4gKlxyXG4gKiBAbGlzdGVucyBhZ0dyaWQuY2VsbEVkaXRpbmdTdGFydGVkXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5jZWxsRWRpdGluZ1N0b3BwZWRcclxuICogQGxpc3RlbnMgYWdHcmlkLmNlbGxWYWx1ZUNoYW5nZWRcclxuICpcclxuICogQGZpcmVzIGd3LmNlbGxFZGl0aW5nU3RhcnRlZFxyXG4gKiBAZmlyZXMgZ3cuY2VsbEVkaXRpbmdTdG9wcGVkXHJcbiAqIEBmaXJlcyBndy5jZWxsVmFsdWVDaGFuZ2VkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25DZWxsRWRpdGluZ0V2ZW50KGlkLCBlKSB7XHJcbiAgY29uc3QgdmFsdWUgPSBlLmhhc093blByb3BlcnR5KCduZXdWYWx1ZScpXHJcbiAgICA/IGd3X2VzY2FwZShlLm5ld1ZhbHVlKVxyXG4gICAgOiBnd19lc2NhcGUoZS52YWx1ZSlcclxuICBjb25zdCBvbGRWYWx1ZSA9IGUuaGFzT3duUHJvcGVydHkoJ29sZFZhbHVlJylcclxuICAgID8gZ3dfZXNjYXBlKGUub2xkVmFsdWUpXHJcbiAgICA6IGUuaGFzT3duUHJvcGVydHkoJ25ld1ZhbHVlJylcclxuICAgID8gZ3dfZXNjYXBlKGUubmV3VmFsdWUpXHJcbiAgICA6IGd3X2VzY2FwZShlLnZhbHVlKVxyXG5cclxuICBpZiAodmFsdWUgPT0gb2xkVmFsdWUgJiYgZS50eXBlID09PSAnY2VsbFZhbHVlQ2hhbmdlZCcpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuXHJcbiAgY29uc3QgcGFyc2VkID0gZ3dfcGFyc2VOb2RlRnJvbUV2ZW50KGUpXHJcbiAgY29uc3QgdHlwZSA9IGUudHlwZVxyXG4gIGNvbnN0IGNvbElkID0gZS5jb2x1bW4uY29sSWRcclxuXHJcbiAgaWYgKHBhcnNlZCkge1xyXG4gICAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgICBnd19nZXRHcmlkKGlkKS5vcHRpb25zLmNvbnRleHQsXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiBgZ3cuJHt0eXBlfWAsXHJcbiAgICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICByOiB7IC4uLnBhcnNlZCwgLi4ueyBjcjogZS5kYXRhIH0gfSwgLy8gcm93ICh3ZSBhbHdheXMgaW5jbHVkZSB0aGUgY2xpZW50IHJvdyBkYXRhKVxyXG4gICAgICAgICAgdjogdmFsdWUsIC8vIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgbzogb2xkVmFsdWUsIC8vIG9sZCB2YWx1ZVxyXG4gICAgICAgICAgYzogY29sSWQsIC8vIGNvbHVtblxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9LFxyXG4gICAgICBDRUxMX0VESVRJTkdfRVZFTlRTX01BUFt0eXBlXVxyXG4gICAgKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGhhbmRsZXIgZm9yIHRoZSBncmlkIGByb3dFZGl0aW5nU3RhcnRlZGAgLCBgcm93RWRpdGluZ1N0b3BwZWRgIGFuZCBgcm93VmFsdWVDaGFuZ2VkYCBldmVudHNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dFZGl0aW5nU3RhcnRlZFxyXG4gKiBAbGlzdGVucyBhZ0dyaWQucm93RWRpdGluZ1N0b3BwZWRcclxuICogQGxpc3RlbnMgYWdHcmlkLnJvd1ZhbHVlQ2hhbmdlZFxyXG4gKlxyXG4gKiBAZmlyZXMgZ3cucm93RWRpdGluZ1N0YXJ0ZWRcclxuICogQGZpcmVzIGd3LnJvd0VkaXRpbmdTdG9wcGVkXHJcbiAqIEBmaXJlcyBndy5yb3dWYWx1ZUNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vblJvd0VkaXRpbmdFdmVudChpZCwgZSkge1xyXG4gIGNvbnN0IHBhcnNlZCA9IGd3X3BhcnNlTm9kZUZyb21FdmVudChlKVxyXG5cclxuICBpZiAocGFyc2VkKSB7XHJcbiAgICBjb25zdCB0eXBlID0gZS50eXBlXHJcbiAgICBnd19zZW5kRXZlbnQoXHJcbiAgICAgIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6IGBndy4ke2UudHlwZX1gLFxyXG4gICAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoeyAuLi5wYXJzZWQsIC4uLnsgY3I6IGUuZGF0YSB9IH0pLCAvLyByb3cgKHdlIGFsd2F5cyBpbmNsdWRlIHRoZSBjbGllbnQgcm93IGRhdGEpXHJcbiAgICAgIH0sXHJcbiAgICAgIFJPV19FRElUSU5HX0VWRU5UU19NQVBbdHlwZV1cclxuICAgIClcclxuICB9XHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfc2VuZEV2ZW50IH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IEdXX0VWRU5UX0ZJTFRFUl9DSEFOR0VEIH0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYGZpbHRlckNoYW5nZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlIFRoZSBldmVudCdzIHBheWxvYWRcclxuICpcclxuICogQGxpc3RlbnMgYWdHcmlkLmZpbHRlckNoYW5nZWRcclxuICogQGZpcmVzIGd3LmZpbHRlckNoYW5nZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbkZpbHRlckNoYW5nZWQoaWQsIGUpIHtcclxuICBjb25zdCBjb250ZXh0ID0gZS5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdyaWRPcHRpb25zLmNvbnRleHRcclxuXHJcbiAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2d3LmZpbHRlckNoYW5nZWQnLFxyXG4gICAgICBkZXRhaWw6IHt9LFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX0ZJTFRFUl9DSEFOR0VEXHJcbiAgKVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7XHJcbiAgZ3dfb25Sb3dDbGlja2VkLFxyXG4gIGd3X29uUm93RG91YmxlQ2xpY2tlZCxcclxuICBnd19vblNlbGVjdGlvbkNoYW5nZWQsXHJcbiAgZ3dfb25DZWxsQ2xpY2tFdmVudCxcclxuICBnd19vblJhbmdlU2VsZWN0aW9uQ2hhbmdlZCxcclxufSBmcm9tICcuL3NlbGVjdGlvbnMnXHJcbmltcG9ydCB7IGd3X29uQ2VsbEVkaXRpbmdFdmVudCwgZ3dfb25Sb3dFZGl0aW5nRXZlbnQgfSBmcm9tICcuL2VkaXRpbmcnXHJcbmltcG9ydCB7IGd3X29uUmVhZHlFdmVudCB9IGZyb20gJy4vcmVhZHknXHJcbmltcG9ydCB7IGd3X2RlYm91bmNlIH0gZnJvbSAnLi91dGlsaXRpZXMnXHJcbmltcG9ydCB7IGd3X29uRmlsdGVyQ2hhbmdlZCB9IGZyb20gJy4vZmlsdGVycydcclxuXHJcbmV4cG9ydCB7XHJcbiAgZ3dfb25Sb3dDbGlja2VkLFxyXG4gIGd3X29uUm93RG91YmxlQ2xpY2tlZCxcclxuICBnd19vblNlbGVjdGlvbkNoYW5nZWQsXHJcbiAgZ3dfb25SYW5nZVNlbGVjdGlvbkNoYW5nZWQsXHJcbiAgZ3dfb25DZWxsQ2xpY2tFdmVudCxcclxuICBnd19vbkNlbGxFZGl0aW5nRXZlbnQsXHJcbiAgZ3dfb25Sb3dFZGl0aW5nRXZlbnQsXHJcbiAgZ3dfb25SZWFkeUV2ZW50LFxyXG4gIGd3X2RlYm91bmNlLFxyXG4gIGd3X29uRmlsdGVyQ2hhbmdlZCxcclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBnd19zZW5kRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgR1dfRVZFTlRfS0VZUFJFU1MgfSBmcm9tICcuL2NvbnN0YW50cydcclxuaW1wb3J0IHsgZ3dfZ2V0R3JpZCB9IGZyb20gJ2FwaS91dGlsaXRpZXMnXHJcblxyXG4vKipcclxuICogQ29tcG9zZSBhIG1vZGVsIG9mIHRoZSBrZXlkb3duIGV2ZW50IGFuZCBzZW5kIGl0IHRvIEJCalxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtFdmVudH0ga2V5ZG93bkV2ZW50IGtleWRvd24gZXZlbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbktleWRvd24oaWQsIGtleWRvd25FdmVudCkge1xyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGd3X2dldEdyaWQoaWQpLm9wdGlvbnMuY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogYGd3LmtleXByZXNzYCxcclxuICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgYzoga2V5ZG93bkV2ZW50LmtleSxcclxuICAgICAgICBrYzoga2V5ZG93bkV2ZW50LndoaWNoIHx8IE51bWJlcihrZXlkb3duRXZlbnQua2V5Q29kZSksXHJcbiAgICAgICAgYWs6IGtleWRvd25FdmVudC5hbHRLZXksXHJcbiAgICAgICAgc2s6IGtleWRvd25FdmVudC5zaGlmdEtleSxcclxuICAgICAgICBjazoga2V5ZG93bkV2ZW50LmN0cmxLZXksXHJcbiAgICAgIH0pLFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX0tFWVBSRVNTXHJcbiAgKVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X2RlYm91bmNlLCBnd19zZW5kRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfb25TdGF0ZUNoYW5nZWQgfSBmcm9tICcuL3N0YXRlJ1xyXG5pbXBvcnQgeyBnd19vbktleWRvd24gfSBmcm9tICcuL2tleWJvYXJkJ1xyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnYXBpL3V0aWxpdGllcydcclxuaW1wb3J0IHsgR1dfRVZFTlRfUkVBRFkgfSBmcm9tICcuL2NvbnN0YW50cydcclxuXHJcbi8qKlxyXG4gKiBPbiBSZWFkeSBFdmVudFxyXG4gKlxyXG4gKiBUaGUgbWV0aG9kIHdpbGwgaWdub3JlIGZpcnN0IHJlYWR5IGV2ZW50IGFuZCB0aGVuIHJlZ2lzdGVyIGEgZGVib3VuY2VkIHN0YXRlXHJcbiAqIGNhbGxiYWNrIHRvIHNlbmQgc3RhdGUgZXZlbnRzIHRvIEJCalxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIGdyaWQncyBpZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gZSAgVGhlIGV2ZW50IHBheWxvYWRcclxuICpcclxuICogQGxpc3RlbnMgYWdHcmlkLmdyaWRSZWFkeVxyXG4gKiBAZmlyZXMgZ3cucmVhZHlcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25SZWFkeUV2ZW50KGlkLCBfZSkge1xyXG4gIGNvbnN0IGdyaWQgPSBnd19nZXRHcmlkKGlkKVxyXG5cclxuICBnd19zZW5kRXZlbnQoXHJcbiAgICBncmlkLm9wdGlvbnMuY29udGV4dCxcclxuICAgIHtcclxuICAgICAgdHlwZTogJ2d3LmdyaWRSZWFkeScsXHJcbiAgICAgIGRldGFpbDoge30sXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUkVBRFlcclxuICApXHJcblxyXG4gIC8vIHJlZ2lzdGVyIHN0YXRlIGRlYm91bmNlIG1vbml0b3JcclxuICBjb25zdCBzdGF0ZURlYm91bmNlID0gZ3dfZGVib3VuY2UoY2hhbmdlRXZlbnQgPT4ge1xyXG4gICAgZ3dfb25TdGF0ZUNoYW5nZWQoaWQsIGNoYW5nZUV2ZW50KVxyXG4gIH0sIDUwMClcclxuXHJcbiAgO1tcclxuICAgICdzb3J0Q2hhbmdlZCcsXHJcbiAgICAnZmlsdGVyQ2hhbmdlZCcsXHJcbiAgICAnY29sdW1uVmlzaWJsZScsXHJcbiAgICAnY29sdW1uUGlubmVkJyxcclxuICAgICdjb2x1bW5SZXNpemVkJyxcclxuICAgICdjb2x1bW5Nb3ZlZCcsXHJcbiAgICAnbmV3Q29sdW1uc0xvYWRlZCcsXHJcbiAgICAnZ3JpZENvbHVtbnNDaGFuZ2VkJyxcclxuICAgICdkaXNwbGF5ZWRDb2x1bW5zQ2hhbmdlZCcsXHJcbiAgICAndmlydHVhbENvbHVtbnNDaGFuZ2VkJyxcclxuICAgICdjb2x1bW5FdmVyeXRoaW5nQ2hhbmdlZCcsXHJcbiAgICAvLydncmlkU2l6ZUNoYW5nZWQnLFxyXG4gICAgJ2V4cGFuZE9yQ29sbGFwc2VBbGwnLFxyXG4gICAgLy8ndG9vbFBhbmVsVmlzaWJsZUNoYW5nZWQnXHJcbiAgXS5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgIGdyaWQub3B0aW9ucy5hcGkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgc3RhdGVEZWJvdW5jZSlcclxuICB9KVxyXG5cclxuICAvLyBjb2xsZWN0IGtleSBkb3ducyBpbmZvcm1hdGlvbiB0byBiZSByZXBvcnRlZCB3aXRoIG90aGVyIGV2ZW50c1xyXG4gIGdyaWQuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlkb3duRXZlbnQgPT4ge1xyXG4gICAgZ3JpZC5rZXlzID0ge1xyXG4gICAgICBjOiBrZXlkb3duRXZlbnQua2V5LFxyXG4gICAgICBrYzoga2V5ZG93bkV2ZW50LndoaWNoIHx8IE51bWJlcihrZXlkb3duRXZlbnQua2V5Q29kZSksXHJcbiAgICAgIGFrOiBrZXlkb3duRXZlbnQuYWx0S2V5LFxyXG4gICAgICBzazoga2V5ZG93bkV2ZW50LnNoaWZ0S2V5LFxyXG4gICAgICBjazoga2V5ZG93bkV2ZW50LmN0cmxLZXksXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgLy8gY2xlYXIgY29sbGVjdCBrZXlkb3duIGluZm9ybWF0aW9uXHJcbiAgZ3JpZC5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICdrZXl1cCcsXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcclxuICAgIGd3X2RlYm91bmNlKF9lID0+IHtcclxuICAgICAgZ3JpZC5rZXlzID0gbnVsbFxyXG4gICAgfSwgMjUwKVxyXG4gIClcclxuXHJcbiAgLy8gcmVnaXN0ZXIga2V5Ym9hcmQgZGVib3VuY2UgbW9uaXRvclxyXG5cclxuICBncmlkLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFxyXG4gICAgJ2tleWRvd24nLFxyXG4gICAgZ3dfZGVib3VuY2Uoa2V5ZG93bkV2ZW50ID0+IHtcclxuICAgICAgZ3dfb25LZXlkb3duKGlkLCBrZXlkb3duRXZlbnQpXHJcbiAgICB9LCA1MDApXHJcbiAgKVxyXG5cclxuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYCR7aWR9LXJlYWR5YCwgeyBkZXRhaWw6IGdyaWQgfSkpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfc2VuZEV2ZW50LCBnd19wYXJzZU5vZGVGcm9tRXZlbnQgfSBmcm9tICcuL3V0aWxpdGllcydcclxuaW1wb3J0IHsgZ3dfZXNjYXBlLCBnd19nZXRHcmlkIH0gZnJvbSAnYXBpL3V0aWxpdGllcydcclxuaW1wb3J0IHtcclxuICBHV19FVkVOVF9ST1dfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfUk9XX0RPVUJMRV9DTElDSyxcclxuICBHV19FVkVOVF9ST1dfU0VMRUNULFxyXG4gIEdXX0VWRU5UX0NFTExfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfQ0VMTF9ET1VCTEVfQ0xJQ0ssXHJcbiAgR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRUQsXHJcbn0gZnJvbSAnLi9jb25zdGFudHMnXHJcblxyXG5jb25zdCBDRUxMX0NMSUNLSU5HX0VWRU5UU19NQVAgPSB7XHJcbiAgY2VsbENsaWNrZWQ6IEdXX0VWRU5UX0NFTExfQ0xJQ0ssXHJcbiAgY2VsbERvdWJsZUNsaWNrZWQ6IEdXX0VWRU5UX0NFTExfRE9VQkxFX0NMSUNLLFxyXG59XHJcblxyXG4vKipcclxuICogQW4gaGFuZGxlciBmb3IgdGhlIGdyaWQgYHJvd0RvdWJsZUNsaWNrZWRgIGV2ZW50XHJcbiAqXHJcbiAqIFRoZSBmdW5jdGlvbiB3aWxsIHNlbmQgYSBiYmogZXZlbnQgd2l0aCBgR1dfTk9ERWAgYXMgcGF5bG9hZFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZSBUaGUgZXZlbnQncyBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dEb3VibGVDbGlja2VkXHJcbiAqIEBmaXJlcyBndy5yb3dEb3VibGVDbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uUm93RG91YmxlQ2xpY2tlZChlKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IGUuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcblxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dEb3VibGVDbGljaycsXHJcbiAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGs6IGd3X2dldEdyaWQoY29udGV4dC5pZCkua2V5cyxcclxuICAgICAgfSksXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUk9XX0RPVUJMRV9DTElDS1xyXG4gIClcclxufVxyXG4vKipcclxuICogQSBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgcm93Q2xpY2tlZGAgZXZlbnRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yb3dDbGlja2VkXHJcbiAqIEBmaXJlcyBndy5yb3dDbGlja1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X29uUm93Q2xpY2tlZChlKSB7XHJcbiAgY29uc3QgY29udGV4dCA9IGUuYXBpLmdyaWRPcHRpb25zV3JhcHBlci5ncmlkT3B0aW9ucy5jb250ZXh0XHJcblxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dDbGljaycsXHJcbiAgICAgIGRldGFpbDogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGs6IGd3X2dldEdyaWQoY29udGV4dC5pZCkua2V5cyxcclxuICAgICAgfSksXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUk9XX0NMSUNLXHJcbiAgKVxyXG59XHJcblxyXG4vKipcclxuICogQSBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgc2VsZWN0aW9uQ2hhbmdlZGAgZXZlbnRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5zZWxlY3Rpb25DaGFuZ2VkXHJcbiAqIEBmaXJlcyBndy5yb3dTZWxlY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vblNlbGVjdGlvbkNoYW5nZWQoZSkge1xyXG4gIGNvbnN0IGNvbnRleHQgPSBlLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dFxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yb3dTZWxlY3QnLFxyXG4gICAgICBkZXRhaWw6ICcnLFxyXG4gICAgfSxcclxuICAgIEdXX0VWRU5UX1JPV19TRUxFQ1RcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGhhbmRsZXIgZm9yIHRoZSBncmlkIGByYW5nZVNlbGVjdGlvbkNoYW5nZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5yYW5nZVNlbGVjdGlvbkNoYW5nZWRcclxuICogQGZpcmVzIGd3LnJhbmdlU2VsZWN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25SYW5nZVNlbGVjdGlvbkNoYW5nZWQoZSkge1xyXG4gIGNvbnN0IGNvbnRleHQgPSBlLmFwaS5ncmlkT3B0aW9uc1dyYXBwZXIuZ3JpZE9wdGlvbnMuY29udGV4dFxyXG4gIGd3X3NlbmRFdmVudChcclxuICAgIGNvbnRleHQsXHJcbiAgICB7XHJcbiAgICAgIHR5cGU6ICdndy5yYW5nZVNlbGVjdGlvbicsXHJcbiAgICAgIGRldGFpbDogJycsXHJcbiAgICB9LFxyXG4gICAgR1dfRVZFTlRfUkFOR0VfU0VMRUNUSU9OX0NIQU5HRURcclxuICApXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGhhbmRsZXIgZm9yIHRoZSBncmlkIGBjZWxsQ2xpY2tFdmVudGAgJiBgY2VsbERvdWJsZUNsaWNrZWRgIGV2ZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBUaGUgZ3JpZCdzIGlkXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlICBUaGUgZXZlbnQgcGF5bG9hZFxyXG4gKlxyXG4gKiBAbGlzdGVucyBhZ0dyaWQuY2VsbENsaWNrRXZlbnRcclxuICogQGxpc3RlbnMgYWdHcmlkLmNlbGxEb3VibGVDbGlja2VkXHJcbiAqXHJcbiAqIEBmaXJlcyBndy5jZWxsQ2xpY2tlZFxyXG4gKiBAZmlyZXMgZ3cuY2VsbERvdWJsZUNsaWNrZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19vbkNlbGxDbGlja0V2ZW50KGUpIHtcclxuICBjb25zdCBjb250ZXh0ID0gZS5hcGkuZ3JpZE9wdGlvbnNXcmFwcGVyLmdyaWRPcHRpb25zLmNvbnRleHRcclxuICBjb25zdCBpZCA9IGNvbnRleHQuaWRcclxuICBjb25zdCBwYXJzZWQgPSBnd19wYXJzZU5vZGVGcm9tRXZlbnQoZSlcclxuXHJcbiAgaWYgKHBhcnNlZCkge1xyXG4gICAgY29uc3QgdHlwZSA9IGUudHlwZVxyXG4gICAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgICBjb250ZXh0LFxyXG4gICAgICB7XHJcbiAgICAgICAgdHlwZTogYGd3LiR7ZS50eXBlfWAsXHJcbiAgICAgICAgZGV0YWlsOiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICByOiBwYXJzZWQsIC8vIHJvd1xyXG4gICAgICAgICAgdjogZ3dfZXNjYXBlKGUudmFsdWUpLCAvLyBuZXcgdmFsdWVcclxuICAgICAgICAgIG86IGd3X2VzY2FwZShlLnZhbHVlKSwgLy8gb2RsIHZhbHVlXHJcbiAgICAgICAgICBjOiBlLmNvbHVtbi5jb2xJZCwgLy8gY29sdW1uc1xyXG4gICAgICAgICAgazogZ3dfZ2V0R3JpZChpZCkua2V5cyxcclxuICAgICAgICB9KSxcclxuICAgICAgfSxcclxuICAgICAgQ0VMTF9DTElDS0lOR19FVkVOVFNfTUFQW3R5cGVdXHJcbiAgICApXHJcbiAgfVxyXG59XHJcbiIsIi8qXHJcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHRoZSBCQmpHcmlkRXhXaWRnZXQgcGx1Z2luLlxyXG4gKiAoYykgQmFzaXMgRXVyb3BlIDxldUBiYXNpcy5jb20+XHJcbiAqXHJcbiAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXHJcbiAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGd3X3NlbmRFdmVudCB9IGZyb20gJy4vdXRpbGl0aWVzJ1xyXG5pbXBvcnQgeyBnd19nZXRHcmlkIH0gZnJvbSAnYXBpL3V0aWxpdGllcydcclxuaW1wb3J0IHsgR1dfRVZFTlRfR1JJRF9TVEFURV9DSEFOR0UgfSBmcm9tICcuL2NvbnN0YW50cydcclxuXHJcbi8qKlxyXG4gKiBBbiBoYW5kbGVyIGZvciB0aGUgZ3JpZCBgc3RhdGVDaGFuZ2VkYCBldmVudHNcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBncmlkJ3MgaWRcclxuICogQHBhcmFtIHtPYmplY3R9IGUgIFRoZSBldmVudCBwYXlsb2FkXHJcbiAqXHJcbiAqIEBsaXN0ZW5zIGFnR3JpZC5zdGF0ZUNoYW5nZWRcclxuICogQGxpc3RlbnMgYWdHcmlkLnJvd0VkaXRpbmdTdG9wcGVkXHJcbiAqXHJcbiAqIEBmaXJlcyBndy5zdGF0ZUNoYW5nZWRcclxuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfb25TdGF0ZUNoYW5nZWQoaWQsIF9lKSB7XHJcbiAgZ3dfc2VuZEV2ZW50KFxyXG4gICAgZ3dfZ2V0R3JpZChpZCkub3B0aW9ucy5jb250ZXh0LFxyXG4gICAge1xyXG4gICAgICB0eXBlOiAnZ3cuc3RhdGVDaGFuZ2VkJyxcclxuICAgICAgZGV0YWlsOiBbXSxcclxuICAgIH0sXHJcbiAgICBHV19FVkVOVF9HUklEX1NUQVRFX0NIQU5HRVxyXG4gIClcclxufVxyXG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cclxuLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3dfZ2V0RG9jdW1lbnQgfSBmcm9tICdhcGkvdXRpbGl0aWVzJ1xyXG5cclxuLyoqIGh0dHBzOi8vZGF2aWR3YWxzaC5uYW1lL2phdmFzY3JpcHQtZGVib3VuY2UtZnVuY3Rpb24gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X2RlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xyXG4gIHZhciB0aW1lb3V0XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLFxyXG4gICAgICBhcmdzID0gYXJndW1lbnRzXHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdGltZW91dCA9IG51bGxcclxuICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcclxuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0XHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dClcclxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KVxyXG4gICAgaWYgKGNhbGxOb3cpIHtcclxuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFNlbmQgYW4gZXZlbnQgdG8gQkJqIHNpZGVcclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gY29udGV4dCB0aGUgZ3JpZCdzIGNvbnRleHRcclxuICogQHBhcmFtIHsqfSBwYXlsb2FkIHRoZSBldmVudCBwYXlsb2FkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudElkIHRoZSBldmVudCdzIGlkXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ3dfc2VuZEV2ZW50KGNvbnRleHQsIHBheWxvYWQgPSB7fSwgZXZlbnRJZCA9IFtdKSB7XHJcbiAgY29uc3QgcmVnaXN0ZXJlZEludGVyZXN0cyA9IGNvbnRleHQuaW50ZXJlc3RzIHx8IFtdXHJcblxyXG4gIGlmIChyZWdpc3RlcmVkSW50ZXJlc3RzLmluY2x1ZGVzKGV2ZW50SWQpKSB7XHJcbiAgICBjb25zdCBkaXYgPSBnd19nZXREb2N1bWVudCgpLmdldEVsZW1lbnRCeUlkKGAke2NvbnRleHQuaWR9YClcclxuXHJcbiAgICAvLyBidWkgb3Igd2ViYXBwXHJcbiAgICBpZiAoWzUsIDZdLmluZGV4T2YoY29udGV4dC5wbGF0Zm9ybSkgPiAtMSkge1xyXG4gICAgICBjb25zdCBodG1sdmlld0lkID0gYGh0bWx2aWV3LSR7Y29udGV4dC5pZH1gXHJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGd3X2dldERvY3VtZW50KCkuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShodG1sdmlld0lkKVswXVxyXG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lci5iYXNpc0Rpc3BhdGNoQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjb250YWluZXIuYmFzaXNEaXNwYXRjaEN1c3RvbUV2ZW50KGRpdiwgcGF5bG9hZClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3aW5kb3cuYmFzaXNEaXNwYXRjaEN1c3RvbUV2ZW50KGRpdiwgcGF5bG9hZClcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd2luZG93LmJhc2lzRGlzcGF0Y2hDdXN0b21FdmVudChkaXYsIHBheWxvYWQpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gQkJqR3JpZEV4V2lkZ2V0Um93XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZFxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhcmVudEtleVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hpbGRJbmRleFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNlbGVjdGVkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFBhcnNlIGEgbm9kZSBhcyBCQmpHcmlkRXhXaWRnZXRSb3dcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgYWcgZ3JpZCBub2RlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0ICBhZyBncmlkIGNvbnRleHRcclxuICpcclxuICogQHJldHVybnMge0JCakdyaWRFeFdpZGdldFJvd3xCb29sZWFufSBvYmplY3QgZm9ybWF0dGVkIGFzIEJCakdyaWRFeFdpZGdldFJvdy5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSBpZiB0aGUgbm9kZSBpcyBmb3IgZ3JvdXAgbm9kZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGd3X3BhcnNlTm9kZShub2RlLCBjb250ZXh0KSB7XHJcbiAgaWYgKHRydWUgPT09IG5vZGUuZ3JvdXApIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH0gLy8gd2UgZG8gbm90IG1hbmFnZSBncm91cHNcclxuXHJcbiAgY29uc3QgZ2V0Um93Tm9kZUlkID0gbm9kZS5yb3dQaW5uZWQgPyAnX19ST1dfSU5ERVgnIDogY29udGV4dC5nZXRSb3dOb2RlSWRcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGk6XHJcbiAgICAgIGNvbnRleHQuaGFzT3duUHJvcGVydHkoJ2dldFJvd05vZGVJZCcpICYmIG5vZGUuZGF0YVtnZXRSb3dOb2RlSWRdXHJcbiAgICAgICAgPyBub2RlLmRhdGFbZ2V0Um93Tm9kZUlkXVxyXG4gICAgICAgIDogbm9kZS5pZCwgLy8gaWRcclxuICAgIHg6IG5vZGUucm93SW5kZXgsIC8vIGluZGV4XHJcbiAgICBwOlxyXG4gICAgICBub2RlLmhhc093blByb3BlcnR5KCdwYXJlbnQnKSAmJiBub2RlLnBhcmVudC5oYXNPd25Qcm9wZXJ0eSgna2V5JylcclxuICAgICAgICA/IG5vZGUucGFyZW50LmtleVxyXG4gICAgICAgIDogJycsIC8vIHBhcmVudCBrZXlcclxuICAgIGM6IG5vZGUucm93UGlubmVkID8gLTEgOiBub2RlLmNoaWxkSW5kZXgsIC8vY2hpbGRJbmRleFxyXG4gICAgczogQm9vbGVhbihub2RlLnNlbGVjdGVkKSwgLy8gc2VsZWN0ZWRcclxuICAgIC8vIGNsaWVudCByb3dcclxuICAgIGNyOlxyXG4gICAgICBjb250ZXh0Lmhhc093blByb3BlcnR5KCdpbmNsdWRlQ2xpZW50Um93RGF0YScpICYmXHJcbiAgICAgIGNvbnRleHRbJ2luY2x1ZGVDbGllbnRSb3dEYXRhJ10gPT09IHRydWVcclxuICAgICAgICA/IG5vZGUuZGF0YVxyXG4gICAgICAgIDogbnVsbCxcclxuICAgIHBwOiBub2RlLnJvd1Bpbm5lZCwgLy8gcGluIHBvc2l0aW9uXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2Ugbm9kZSBmcm9tIGV2ZW50XHJcbiAqXHJcbiAqIFBhcnNlIG5vZGUgaW4gdGhlIHBhU3NlZCBldmVudCBhcyBCQmpHcmlkRXhXaWRnZXRSb3dcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGVcclxuICpcclxuICogQHJldHVybnMge0JCakdyaWRFeFdpZGdldFJvd31cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19wYXJzZU5vZGVGcm9tRXZlbnQoZSkge1xyXG4gIHJldHVybiBnd19wYXJzZU5vZGUoZS5ub2RlLCBlLmNvbnRleHQpXHJcbn1cclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkIGEganMgZnVuY3Rpb24gZnJvbSB0aGUgZ2l2ZW4gZXhwcmVzc2lvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxyXG4gKlxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19jb21waWxlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBleHByZXNzaW9uIGNhY2hlIGhhcyBiZWVuIGluaXRpYWxpemVkXHJcbiAgaWYgKHR5cGVvZiBnd19jb21waWxlRXhwcmVzc2lvbi5leHByZXNzaW9uQ2FjaGUgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIGd3X2NvbXBpbGVFeHByZXNzaW9uLmV4cHJlc3Npb25DYWNoZSA9IFtdXHJcbiAgfVxyXG5cclxuICAvLyBjaGVjayBjYWNoZSBmaXJzdFxyXG4gIGlmIChnd19jb21waWxlRXhwcmVzc2lvbi5leHByZXNzaW9uQ2FjaGVbZXhwcmVzc2lvbl0pIHtcclxuICAgIHJldHVybiBnd19jb21waWxlRXhwcmVzc2lvbi5leHByZXNzaW9uQ2FjaGVbZXhwcmVzc2lvbl1cclxuICB9XHJcblxyXG4gIC8vIGlmIG5vdCBmb3VuZCBpbiBjYWNoZSwgcmV0dXJuIHRoZSBmdW5jdGlvblxyXG4gIGxldCBmdW5jdGlvbkJvZHkgPSBudWxsXHJcbiAgLy8gaWYgdGhlIGV4cHJlc3Npb24gaGFzIHRoZSAncmV0dXJuJyB3b3JkIGluIGl0LCB0aGVuIHVzZSBhcyBpcyxcclxuICAvLyBpZiBub3QsIHRoZW4gd3JhcCBpdCB3aXRoIHJldHVybiBhbmQgJzsnIHRvIG1ha2UgYSBmdW5jdGlvblxyXG4gIGlmIChleHByZXNzaW9uLmluZGV4T2YoJ3JldHVybicpID49IDApIHtcclxuICAgIGZ1bmN0aW9uQm9keSA9IGV4cHJlc3Npb25cclxuICB9IGVsc2Uge1xyXG4gICAgZnVuY3Rpb25Cb2R5ID0gJ3JldHVybiAnICsgZXhwcmVzc2lvbiArICc7J1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdGhlRnVuY3Rpb24gPSBuZXcgRnVuY3Rpb24oXHJcbiAgICAneCwgY3R4LCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHZhbHVlLCBub2RlLCBkYXRhLCBjb2xEZWYsIHJvd0luZGV4LCBhcGksIGNvbHVtbkFwaSwgZ2V0VmFsdWUsIGNvbHVtbiwgY29sdW1uR3JvdXAnLFxyXG4gICAgZnVuY3Rpb25Cb2R5XHJcbiAgKVxyXG5cclxuICAvLyBzdG9yZSBpbiBjYWNoZVxyXG4gIGd3X2NvbXBpbGVFeHByZXNzaW9uLmV4cHJlc3Npb25DYWNoZVtleHByZXNzaW9uXSA9IHRoZUZ1bmN0aW9uXHJcblxyXG4gIHJldHVybiB0aGVGdW5jdGlvblxyXG59XHJcblxyXG4vKipcclxuICogQnVpbGQgYW5kIGV4ZWN1dGVkIGFuIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIHBhcmFtc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXHJcbiAqXHJcbiAqIEByZXR1cm4gbWl4ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnd19leGVjdXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwYXJhbXMpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgamF2YVNjcmlwdEZ1bmN0aW9uID0gZ3dfY29tcGlsZUV4cHJlc3Npb24oZXhwcmVzc2lvbilcclxuICAgIC8vIHRoZSBwYXJhbXMgZG9uJ3QgaGF2ZSBhbGwgdGhlc2UgdmFsdWVzLCByYXRoZXIgd2UgYWRkIGV2ZXJ5IHBvc3NpYmxlXHJcbiAgICAvLyB2YWx1ZSBhIHBhcmFtcyBjYW4gaGF2ZSwgd2hpY2ggbWFrZXMgd2hhdGV2ZXIgaXMgaW4gdGhlIHBhcmFtcyBhdmFpbGFibGUuXHJcbiAgICBjb25zdCByZXN1bHQgPSBqYXZhU2NyaXB0RnVuY3Rpb24oXHJcbiAgICAgIHBhcmFtcy52YWx1ZSxcclxuICAgICAgcGFyYW1zLmNvbnRleHQsXHJcbiAgICAgIHBhcmFtcy5vbGRWYWx1ZSxcclxuICAgICAgcGFyYW1zLm5ld1ZhbHVlLFxyXG4gICAgICBwYXJhbXMudmFsdWUsXHJcbiAgICAgIHBhcmFtcy5ub2RlLFxyXG4gICAgICBwYXJhbXMuZGF0YSxcclxuICAgICAgcGFyYW1zLmNvbERlZixcclxuICAgICAgcGFyYW1zLnJvd0luZGV4LFxyXG4gICAgICBwYXJhbXMuYXBpLFxyXG4gICAgICBwYXJhbXMuY29sdW1uQXBpLFxyXG4gICAgICBwYXJhbXMuZ2V0VmFsdWUsXHJcbiAgICAgIHBhcmFtcy5jb2x1bW4sXHJcbiAgICAgIHBhcmFtcy5jb2x1bW5Hcm91cFxyXG4gICAgKVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIC8vIHRoZSBleHByZXNzaW9uIGZhaWxlZCwgd2hpY2ggY2FuIGhhcHBlbiwgYXMgaXQncyB0aGUgY2xpZW50IHRoYXRcclxuICAgIC8vIHByb3ZpZGVzIHRoZSBleHByZXNzaW9uLiBzbyBwcmludCBhIG5pY2UgbWVzc2FnZVxyXG4gICAgY29uc29sZS5sb2coJ1Byb2Nlc3Npbmcgb2YgdGhlIGV4cHJlc3Npb24gZmFpbGVkJylcclxuICAgIGNvbnNvbGUubG9nKCdFeHByZXNzaW9uID0gJyArIGV4cHJlc3Npb24pXHJcbiAgICBjb25zb2xlLmxvZygnUGFyYW1zID0nLCBwYXJhbXMpXHJcbiAgICBjb25zb2xlLmxvZygnRXhjZXB0aW9uID0gJyArIGUpXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxufVxyXG4iLCIvKlxyXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiB0aGUgQkJqR3JpZEV4V2lkZ2V0IHBsdWdpbi5cclxuICogKGMpIEJhc2lzIEV1cm9wZSA8ZXVAYmFzaXMuY29tPlxyXG4gKlxyXG4gKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxyXG4gKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cclxuICovXHJcblxyXG5pbXBvcnQgJ2V4cG9zZS1sb2FkZXI/QkJqLk1hc2tzIWJiai1tYXNrcy9kaXN0L2Jiai1tYXNrcy5qcydcclxuaW1wb3J0ICdleHBvc2UtbG9hZGVyP0Jhc2lzLklucHV0TWFza2luZyFiYXNpcy1pbnB1dC1tYXNraW5nL2Rpc3QvYmFzaXMtaW5wdXQtbWFza2luZy5qcydcclxuaW1wb3J0ICdleHBvc2UtbG9hZGVyP2ZsYXRwaWNrciFmbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuanMnXHJcbmltcG9ydCAnZXhwb3NlLWxvYWRlcj9CYXNpcy5BZ0dyaWRDb21wb25lbnRzIWJhc2lzLWFnZ3JpZC1jb21wb25lbnRzL2Rpc3QvYmFzaXMtYWdncmlkLWNvbXBvbmVudHMuanMnXHJcblxyXG5yZXF1aXJlKCdmbGF0cGlja3IvZGlzdC9mbGF0cGlja3IuY3NzJylcclxucmVxdWlyZSgnLi9zdHlsZS9jbGFzc2VzLmNzcycpXHJcbnJlcXVpcmUoJy4vc3R5bGUvc3VnZ2VzdGlvbi1lZGl0b3IuY3NzJylcclxuXHJcbmV4cG9ydCAqIGZyb20gJy4vcG9seWZpbGxzLmpzJ1xyXG5leHBvcnQgKiBmcm9tICcuL2FwaSdcclxuIiwiLypcclxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgdGhlIEJCakdyaWRFeFdpZGdldCBwbHVnaW4uXHJcbiAqIChjKSBCYXNpcyBFdXJvcGUgPGV1QGJhc2lzLmNvbT5cclxuICpcclxuICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0VcclxuICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXHJcbiAqL1xyXG5cclxuLyoqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCAgKi9cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dHJhLXNlbWlcclxuOyhmdW5jdGlvbigpIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIGZhbHNlXHJcbiAgfSAvL0lmIG5vdCBJRVxyXG5cclxuICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XHJcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkIH1cclxuICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKVxyXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKVxyXG4gICAgcmV0dXJuIGV2dFxyXG4gIH1cclxuXHJcbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZVxyXG5cclxuICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudFxyXG59KSgpXHJcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vY2xhc3Nlcy5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmhlYWRcclxuICAgICAgICAgICAgICB9O1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vY2xhc3Nlcy5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vY2xhc3Nlcy5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iLCJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcyEuL3N1Z2dlc3Rpb24tZWRpdG9yLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQuaGVhZFxyXG4gICAgICAgICAgICAgIH07XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanMhLi9zdWdnZXN0aW9uLWVkaXRvci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzIS4vc3VnZ2VzdGlvbi1lZGl0b3IuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==