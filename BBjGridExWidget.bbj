rem /**
rem  *  The package exports a few helper classes along with the BBjGridExWidget class which is the entry point of the plugin. Most of the time you only need to use the BBjGridExWidget class from it
rem  */
rem package BBjGridExWidget
rem /**
rem  * This file is part of the BBjGridExWidget plugin.
rem  * (c) Basis Europe <eu@basis.cloud>
rem  *
rem  * For the full copyright and license information, please view the LICENSE
rem  * file that was distributed with this source code.
rem  */
use java.util.Arrays
use java.util.ArrayList
use java.util.HashSet
use java.util.LinkedHashMap
use java.util.UUID
use java.lang.StringBuilder
use java.sql.Types
use com.google.gson.Gson
use com.google.gson.JsonParser
use com.google.gson.JsonObject
use com.google.gson.JsonArray
use com.google.gson.JsonPrimitive
rem Basis Components
rem ==========================
use com.basiscomponents.db.ResultSet
use com.basiscomponents.db.DataRow
rem BBjWidget
rem ==========================
use ::BBjWidget/BBjWidget.bbj::BBjWidget
rem BBjGridExWidget Package
rem ==========================
use ::BBjGridExWidget/GxOptions.bbj::GxOptions
use ::BBjGridExWidget/util/LicenseManager.bbj::LicenseManager
use ::BBjGridExWidget/GxExecutor.bbj::GxExecutor
use ::BBjGridExWidget/GxState.bbj::GxState
use ::BBjGridExWidget/GxLanguageManager.bbj::GxLanguageManager
use ::BBjGridExWidget/GxClientJsonFactory.bbj::GxClientJsonFactory
use ::BBjGridExWidget/GxLogger.bbj::GxLogger
rem Client Events
rem ==========================
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRowSelection
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsContextMenu
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsCell
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRowEditing
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRangeSelection
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsKeypress
rem Sidebars
rem ==========================
use ::BBjGridExWidget/GxSidebar.bbj::GxSidebar
use ::BBjGridExWidget/GxSidebar.bbj::GxDefaultSidebar
use ::BBjGridExWidget/GxSidebar.bbj::GxFiltersToolpanel
rem Statusbar
rem ==========================
use ::BBjGridExWidget/GxStatusBar.bbj::GxStatusBar
rem Context Menu
rem ==========================
use ::BBjGridExWidget/GxContextMenu.bbj::GxContextMenu
use ::BBjGridExWidget/GxContextMenu.bbj::GxDefaultContextMenu
rem Expressions
rem ==========================
use ::BBjGridExWidget/GxExpressions.bbj::GxExpressionInterface
use ::BBjGridExWidget/GxExpressions.bbj::GxExpression
rem Columns
rem ==========================
use ::BBjGridExWidget/GxColumns.bbj::GxDefaultColumnDefinition
use ::BBjGridExWidget/GxColumns.bbj::GxAutoGroupColumn
use ::BBjGridExWidget/GxColumns.bbj::GxColumn
use ::BBjGridExWidget/GxColumns.bbj::GxDefaultColumnGroup
use ::BBjGridExWidget/GxColumns.bbj::GxColumnGroup
use ::BBjGridExWidget/GxColumns.bbj::GxColumnsManagerInterface
use ::BBjGridExWidget/GxColumns.bbj::GxColumnsManager
rem Renderers
rem ==========================
use ::BBjGridExWidget/GxRenderers.bbj::GxRendererImageRenderer
rem Client Models
rem ==========================
use ::BBjGridExWidget/GxClientModels.bbj::GxClientRowModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientAddRangeSelectionModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientAddRangeChartModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientSortModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientTransactionModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterNumberModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterTextModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterDateTimeModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterBooleanModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterCombinedModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterSetFilterModel
rem Filter Components
rem ==========================
use ::BBjGridExWidget/GxFilters.bbj::GxFilterText
use ::BBjGridExWidget/GxFilters.bbj::GxFilterNumber
use ::BBjGridExWidget/GxFilters.bbj::GxFilterBasicBoolean
use ::BBjGridExWidget/GxFilters.bbj::GxFilterBasicTimestamp
use ::BBjGridExWidget/GxFilters.bbj::GxFilterSetFilter
rem /**
rem  * The Grid Core Class.This class works as a columns manager and api provider.
rem  * It contains a big number of methods and properties to configure the column from A..Z.
rem  * Every property and method has one or more tag attached.
rem  *
rem  * The following is the meaning for each tag :<br><br>
rem  *
rem  *
rem  * <table border="1" cellpadding="10">
rem  *  <tbody>
rem  *      <tr>
rem  *          <td><strong>&nbsp;Enterprise</strong></td>
rem  *          <td>The property/method is used only with the enterprise version. using it without having a valid license will<br />be ignored.</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td>&nbsp;<strong>Configuration</strong></td>
rem  *          <td>Properties and methods which are tagged with&nbsp;this tag are used to configure the grid before it is rendered on the client.<br />Changing these properties or calling these methods won't affect&nbsp;the grid which is displayed on the client.<br />In order to reflect your changes on the client, you need to re-render the whole grid <br />or re-render the column definition once again.</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td>&nbsp;<strong>API</strong></td>
rem  *          <td>Methods/properties tagged with this tag can be called before or after the grid is rendered on the client and they don't require a refresh.</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td><strong>&nbsp;ColumnsRenderer</strong></td>
rem  *          <td>Changing this property or calling this method after the first render require columns re-render using <i>updateColumns()</i> method</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td><strong>&nbsp;GridRenderer</strong></td>
rem  *          <td>Changing this property or calling this method after the first render require full re-render using <i>render()</i> method</td>
rem  *      </tr>
rem  *  </tbody>
rem  * </table>
rem  *
rem  * @author Stephan Wald
rem  * @author Hyyan Abo Fakher
rem  */
class public BBjGridExWidget extends BBjWidget implements GxColumnsManagerInterface
  rem /**
  rem  * The Grid enterprise key
  rem  */
  field public static BBjString LicenseKey$
  rem /**
  rem  * When true, the grid will force using the community version of the grid whether there
  rem  * is a license key or not.
  rem  */
  field public static BBjNumber ForceCommunityBuild! = 0
  rem /**
  rem  * When true the grid will use the unmingled version of the Javascript code then open the debugger
  rem  * in a new window.
  rem  */
  field public static BBjNumber Debug! = 0
  rem /**
  rem  * The unique string to use as row index. default is __ROW_INDEX
  rem  */
  field public BBjString RowNodeId$ = "__ROW_INDEX"
  rem /**
  rem  * The ResultSet instance
  rem  */
  field public ResultSet RS! = new ResultSet()
  rem /**
  rem  * Columns Manager instance
  rem  */
  field public GxColumnsManager ColumnsManager! = new GxColumnsManager()
  rem /**
  rem  * Instance of the grid options class
  rem  */
  field public GxOptions Options! = new GxOptions(#this!)
  rem /**
  rem  * Instance of he scripts executor
  rem  */
  field public GxExecutor Executor! = new GxExecutor(#this!, 250)
  rem /**
  rem  * Instance of the created HTMLView
  rem  */
  field public BBjHtmlView HTMLView!
  rem /**
  rem  * A flag which defines when the grid is ready and the process events started
  rem  */
  field public Boolean IsReady! = BBjAPI.FALSE
  rem /**
  rem  * Instance of GxClientJsonFactory to convert client JSON strings to Client Models
  rem  */
  field protected GxClientJsonFactory ClientJsonFactory! = new GxClientJsonFactory(#this!)
  rem /**
  rem  * The vector holds the registered events
  rem  */
  field protected JsonArray Interests! = new JsonArray()
  rem /**
  rem  * An array which contains the supported toolbar items
  rem  */
  field protected JsonArray ChartToolbarItems! = new JsonArray()
  rem /**
  rem  * The client's HTML template to use in order to build the grid.
  rem  */
  field protected BBjString Template$ = ""
  rem /**
  rem  * Instance of the grid's license manager
  rem  */
  field protected static LicenseManager LicenseManager! = new LicenseManager()
  rem /**
  rem  * A boolean which indicates whether the grid has its first renderer
  rem  */
  field protected Boolean IsFirstRender! = BBjAPI.TRUE
  rem /**
  rem  * Unique auto-generated id for the grid instance.
  rem  * This id is used in the client to distinguish instances
  rem  */
  field protected BBjString RootId!
  rem /**
  rem  * Number of initiated instances per session
  rem  */
  field protected static BBjNumber InstanceCount! = 0
  field protected BBjNumber newW!
  field protected BBjNumber newH!
  rem /**
  rem  * A Constant value to define row selection (selected/deselected) change events
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_SELECT_ROW()
    methodret BBjAPI.ON_GRID_SELECT_ROW
  methodend
  rem /**
  rem  * Alias for ON_GRID_SELECT_ROW
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_SELECT()
    methodret #ON_GRID_SELECT_ROW()
  methodend
  rem /**
  rem  * Constant value to define row double-click event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_DOUBLE_CLICK()
    methodret BBjAPI.ON_GRID_DOUBLE_CLICK
  methodend
  rem /**
  rem  * Alias to <i>ON_GRID_ROW_DOUBLE_CLICK()</i>
  rem  *
  rem  * @see ON_GRID_ROW_DOUBLE_CLICK()
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_DOUBLE_CLICK()
    methodret #ON_GRID_ROW_DOUBLE_CLICK()
  methodend
  rem /**
  rem  * Constant value to define cell click event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_CELL_CLICK()
    methodret 5001
  methodend
  rem /**
  rem  * Constant value to define cell double-click event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_CELL_DOUBLE_CLICK()
    methodret 5002
  methodend
  rem /**
  rem  * Constant value to define cell editing start event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_CELL_EDITING_STARTED()
    methodret 5003
  methodend
  rem /**
  rem  * Constant value to define cell editing stop event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_CELL_EDITING_STOPPED()
    methodret 5004
  methodend
  rem /**
  rem  * Constant value to define cell value changed event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_CELL_VALUE_CHANGED()
    methodret 5005
  methodend
  rem /**
  rem  * Constant value to define row editing start event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_EDITING_STARTED()
    methodret 5006
  methodend
  rem /**
  rem  * Constant value to define row editing stop event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_EDITING_STOPPED()
    methodret 5007
  methodend
  rem /**
  rem  * Constant value to define grid state changes
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_STATE_CHANGE()
    methodret 5008
  methodend
  rem /**
  rem  * Constant value to define range selection event
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_RANGE_SELECTION_CHANGED()
    methodret 5009
  methodend
  rem /**
  rem  * Constant value to define keyboard keypress
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_KEYPRESS()
    methodret 5010
  methodend
  rem /**
  rem  * Constant value to define row click events
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_CLICK()
    methodret 5011
  methodend
  rem /**
  rem  * Constant value to define A row has changed.
  rem  * This event corresponds to Full Row Editing only.
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_ROW_VALUE_CHANGED()
    methodret 5012
  methodend
  rem /**
  rem  * Constant value to define A filter changed event.
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_FILTER_CHANGED()
    methodret 5013
  methodend
  rem /**
  rem  * Constant value to define the grid ready event.
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_READY()
    methodret 5014
  methodend
  rem /**
  rem  * Alias for <i>ON_GRID_STATE_CHANGE()</i>
  rem  *
  rem  * @see ON_GRID_STATE_CHANGE()
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber ON_GRID_COLUMN_STATE_CHANGE()
    methodret #ON_GRID_STATE_CHANGE()
  methodend
  rem /**
  rem  * Constant value to define left aligned column
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber GRID_ALIGN_LEFT()
    methodret BBjGrid.GRID_ALIGN_LEFT
  methodend
  rem /**
  rem  * Constant value to define right aligned column
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber GRID_ALIGN_RIGHT()
    methodret BBjGrid.GRID_ALIGN_RIGHT
  methodend
  rem /**
  rem  * Constant value to define centered column
  rem  *
  rem  * @return BBjNumber
  rem  */
  method public static BBjNumber GRID_ALIGN_CENTER()
    methodret BBjGrid.GRID_ALIGN_CENTER
  methodend
  rem /**
  rem  * Constant value to define row position
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWPOS_TOP()
    methodret "top"
  methodend
  rem /**
  rem  * Constant value to define row position
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWPOS_MIDDLE()
    methodret "middle"
  methodend
  rem /**
  rem  * Constant value to define row position
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWPOS_BOTTOM()
    methodret "bottom"
  methodend
  rem /**
  rem  * Constant value to define editing mode "row"
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_EDITTYPE_ROW()
    methodret "fullRow"
  methodend
  rem /**
  rem  * Constant value to define editing mode "cell"
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_EDITTYPE_CELL()
    methodret ""
  methodend
  rem /**
  rem  * Constant value to define enter key behavior (Move to next cell)
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ENTER_NEXT_CELL()
    methodret "next"
  methodend
  rem /**
  rem  * Constant value to define navigation behavior (Move to next cell)
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_CELL()
    methodret "navigate_next_cell"
  methodend
  rem /**
  rem  * Constant value to define navigation behavior (Move to next row)
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW()
    methodret "navigate_next_row"
  methodend
  rem /**
  rem  * Constant value to define enter key behavior (Stop editing)
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ENTER_STOP_EDITING()
    methodret "stop"
  methodend
  rem /**
  rem  * Constant value which defines that group panel must always be shown
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_GROUPPANEL_SHOW_VISIBLE()
    methodret "always"
  methodend
  rem /**
  rem  * Constant value which defines that group panel must be shown only when grouping
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_GROUPPANEL_SHOW_ONGROUPING()
    methodret "onlyWhenGrouping"
  methodend
  rem /**
  rem  * Constant value which defines that group panel must always be hidden
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_GROUPPANEL_SHOW_HIDDEN()
    methodret "never"
  methodend
  rem /**
  rem  * Constant value which describes the rows in before sorting and
  rem  * filtering phase.
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWS_PHASE_ALL()
    methodret "forEachNode"
  methodend
  rem /**
  rem  * Constant value which describes the rows in after filtering phase.
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWS_PHASE_AFTER_FILTER()
    methodret "forEachNodeAfterFilter"
  methodend
  rem /**
  rem  * Constant value which describes the rows in after filtering and sorting
  rem  * phase.
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_ROWS_PHASE_AFTER_FILTER_SORT()
    methodret "forEachNodeAfterFilterAndSort"
  methodend
  rem /**
  rem  * Constant value which defines that chart toolbar settings item
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString CHART_TOOLBAR_SETTINGS()
    methodret "chartSettings"
  methodend
  rem /**
  rem  * Constant value which defines that chart toolbar data item
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString CHART_TOOLBAR_DATA()
    methodret "chartData"
  methodend
  rem /**
  rem  * Constant value which defines that chart toolbar format item
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString CHART_TOOLBAR_FORMAT()
    methodret "chartFormat"
  methodend
  rem /**
  rem  * Constant value which defines that chart toolbar download item
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString CHART_TOOLBAR_DOWNLOAD()
    methodret "chartDownload"
  methodend
  rem /**
  rem  * Constant value which defines that balham theme
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_THEME_BALHAM()
    methodret "balham"
  methodend
  rem /**
  rem  * Constant value which defines that balham dark theme
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_THEME_BALHAM_DARK()
    methodret "balham-dark"
  methodend
  rem /**
  rem  * Constant value which defines the material theme
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_THEME_MATERIAL()
    methodret "material"
  methodend
  rem /**
  rem  * Constant value which defines the alpine theme
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_THEME_ALPINE()
    methodret "alpine"
  methodend
  rem /**
  rem  * Constant value which defines the alpine dark theme
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_THEME_ALPINE_DARK()
    methodret "alpine-dark"
  methodend
  rem /**
  rem  * Constant value which defines the rows floating on top
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_FLOATING_TOP()
    methodret "top"
  methodend
  rem /**
  rem  * Constant value which defines the rows floating on bottom
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_FLOATING_BOTTOM()
    methodret "bottom"
  methodend
  rem /**
  rem  * Constant value which defines the rows with no floating
  rem  *
  rem  * @return BBjString
  rem  */
  method public static BBjString GRID_FLOATING_NONE()
    methodret ""
  methodend
  rem /**
  rem  * Make Hex Color
  rem  *
  rem  * Convert the given BBjColor to a hex color string
  rem  *
  rem  * @param BBjColor color! BBj color
  rem  *
  rem  * @return BBjString hex color
  rem  */
  method public static BBjString makeHexColor(BBjColor color!)
    methodret "#"+hta(chr(color!.getRed()))+hta(chr(color!.getGreen()))+hta(chr(color!.getBlue()))
  methodend
  rem /**
  rem  * Convert the image at the given path to base64 string
  rem  *
  rem  * @param BBjString filename! The image's path
  rem  *
  rem  * @return BBjString Image as base64 string
  rem  */
  method public static BBjString imageToBase64(BBjString filename!)
    imageSlice!=BBjAPI().getSysGui().getImageManager().loadImageFromFile(filename!)
    bytes$ = str(imageSlice!.getBytes("png"))
    b64$ = java.util.Base64.getEncoder().encode(bytes$)
    methodret "data:image/png;base64, "+b64$
  methodend
  rem /**
  rem  * Alias for <i>imageToBase64()</i>
  rem  *
  rem  * @see imageToBase64()
  rem  */
  method public static BBjString getImageData(BBjString filename!)
    methodret BBjGridExWidget.imageToBase64(filename!)
  methodend
  rem /**
  rem  * The method will check whether the grid has license key or not.
  rem  *
  rem  * @return BBjNumber true when a license key is found, false otherwise
  rem  */
  method public static BBjNumber isLicensed()
    #getLicenseManager().setLicenseKey(#getLicenseKey())
    methodret #getLicenseManager().isLicensed()
  methodend
  rem /**
  rem  * disabled default constructor
  rem  */
  method public BBjGridExWidget()
  methodend
  rem /**
  rem  * The constructor that creates the widget on wnd!
  rem  *
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem */
  method public BBjGridExWidget(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
    #this!(null(), wnd!, id!, x!, y!, w!, h!, "")
  methodend
  rem /**
  rem  * The constructor that creates the widget on wnd!
  rem  *
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem  *                           By default you will never need  to change the default Template.
  rem  *                           Unless you want to do something really unusual
  rem */
  method public BBjGridExWidget(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h! , BBjString template$)
    #this!(null(), wnd!, id!, x!, y!, w!, h!, template$)
  methodend
  rem /**
  rem * The constructor that creates the widget on wnd!
  rem *
  rem * @param BBjString rootId! The root ID of the grid. This is used to identify the grid in the client side.
  rem  *                         This is useful when you have multiple grids in the same window.
  rem  *                         By default the root ID is  a random string.
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem */
  method public BBjGridExWidget(BBjString rootId!, BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
    #this!(rootId!, wnd!, id!, x!, y!, w!, h!, "")
  methodend
  rem /**
  rem * The constructor that creates the widget on wnd!
  rem *
  rem * @param BBjString rootId! The root ID of the grid. This is used to identify the grid in the client side.
  rem  *                         This is useful when you have multiple grids in the same window.
  rem  *                         By default the root ID is  a random string.
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem *                           By default you will never need  to change the default Template.
  rem *                           Unless you want to do something really unusual
  rem */
  method public BBjGridExWidget(BBjString rootId!, BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h! , BBjString template$)
    #RootId! = rootId!
    #create(wnd!, id!, x!, y!, w!, h!, template$)
  methodend
  rem /**
  rem  * The constructor that creates the widget in the ChildWindow
  rem  *
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem  */
  method public BBjGridExWidget(BBjChildWindow wnd!)
    #this!(null(), wnd!, "")
  methodend
  rem /**
  rem  * The constructor that creates the widget in the ChildWindow
  rem  *
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem  * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem  *                           By default you will never need  to change the default Template.
  rem  *                           Unless you want to do something really unusual
  rem  */
  method public BBjGridExWidget(BBjChildWindow wnd!, BBjString template$)
    #this!(null(), wnd!, template$)
  methodend
  rem /**
  rem  * The constructor that creates the widget in the ChildWindow
  rem  *
  rem  * @param BBjString rootId! The root ID of the grid. This is used to identify the grid in the client side.
  rem  *                          This is useful when you have multiple grids in the same window.
  rem  *                          By default the root ID is  a random string.
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem  */
  method public BBjGridExWidget(BBjString rootId!, BBjChildWindow wnd!)
    #this!(RootId!, wnd!, "")
  methodend
  rem /**
  rem  * The constructor that creates the widget in the ChildWindow
  rem  *
  rem  * @param BBjString rootId! The root ID of the grid. This is used to identify the grid in the client side.
  rem  *                          This is useful when you have multiple grids in the same window.
  rem  *                          By default the root ID is  a random string.
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem  * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem  *                           By default you will never need  to change the default Template.
  rem  *                           Unless you want to do something really unusual
  rem  */
  method public BBjGridExWidget(BBjString rootId!, BBjChildWindow wnd!, BBjString template$)
    #RootId! = rootId!
    #create(wnd!, template$)
  methodend
  rem /**
  rem  * Create the widget
  rem  *
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem  *                           By default you will never need  to change the default Template.
  rem  *                           Unless you want to do something really unusual
  rem  *
  rem  * @Override
  rem  */
  method protected void create(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!, BBjString template$)
    #super!.setCanvas(wnd!.addChildWindow(id!,x!,y!,w!,h!,"",$00000800$,BBjAPI().getSysGui().getAvailableContext()))
    #super!.setX(x!)
    #super!.setY(y!)
    #super!.setW(w!)
    #super!.setH(h!)
    #RS!.createIndex()
    #fillChartToolbarItems()
    #setTemplate(template$)
    #redraw(BBjAPI.TRUE)
  methodend
  rem /**
  rem  * Create the widget
  rem  *
  rem * @param BBjWindow wnd!! parent window
  rem * @param BBjNumber id! the control ID
  rem * @param BBjNumber x! x-location
  rem * @param BBjNumber y! y-location
  rem * @param BBjNumber w! width
  rem * @param BBjNumber h! height
  rem  *
  rem  * @Override
  rem  */
  method protected void create(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
    #create(wnd!,id!,x!,y!,w!,h!,"")
  methodend
  rem /**
  rem  * Create the widget
  rem  *
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
  rem  *                           By default you will never need  to change the default Template.
  rem  *                           Unless you want to do something really unusual
  rem  *
  rem  * @Override
  rem  */
  method protected void create(BBjChildWindow wnd!,BBjString template$)
    #super!.setCanvas(wnd!)
    #super!.setX(wnd!.getX())
    #super!.setY(wnd!.getY())
    #super!.setW(wnd!.getWidth())
    #super!.setH(wnd!.getHeight())
    #RS!.createIndex()
    #fillChartToolbarItems()
    #setTemplate(template$)
    #redraw(BBjAPI.TRUE)
  methodend
  rem /**
  rem  * Create the widget
  rem  *
  rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
  rem  * @param BBjString template$ the html template to use for the grid initialization
  rem  *
  rem  * @Override
  rem  */
  method protected void create(BBjChildWindow wnd!)
    #create(wnd!,"")
  methodend
  REM /**
  REM  * Get the unique control type
  REM  *
  REM  * @returns int controlType = 65001
  REM  */
  method public int getControlType()
    methodret 65001
  methodend
  rem /**
  rem  * Register an event handler
  rem  *
  rem  * @param Int type! The event's type
  rem  * @param String callback! The event's callback
  rem  *
  rem  * @Override
  rem  */
  method public void setCallback(int type!, String callback!)
    #super!.setCallback(type!,callback!)
    #getInterests().add(type!)
    #updateClientWithInterests()
  methodend
  rem /**
  rem  * Register an event handler
  rem  *
  rem  * @param Int type! The event's type
  rem  * @param CustomObject instance! class instance
  rem  * @param String method! method name
  rem  *
  rem  * @Override
  rem  */
  method public void setCallback(int type!, CustomObject instance!, String method!)
    #super!.setCallback(type!, instance!, method!)
    #getInterests().add(type!)
    #updateClientWithInterests()
  methodend
  rem /**
  rem  * Remove callback
  rem  *
  rem  * @param Int type! The event's type
  rem  *
  rem  * @Override
  rem  */
  method public void clearCallback(int type!)
    #super!.clearCallback(type!)
    interests! = #getInterests()
    el! = new JsonPrimitive(type!)

    if(interests!.contains(el!)) then
      interests!.remove(el!)
      #updateClientWithInterests()
    FI
  methodend
  rem /**
  rem  * Enable remote debugging on the given port
  rem  *
  rem  * @param BBjNumber debug! true to enable debug , false otherwise
  rem  * @param BBjNumber port! the debugging port
  rem  *
  rem  * @return void
  rem  */
  method public static void setDebug(BBjNumber debug! , BBjNumber port!)
    if(debug!.booleanValue())
      chromiumSwitches$ = stbl("!CHROMIUM_SWITCHES","--remote-debugging-port=" + str(port!))
    FI

    #Debug! = debug!
  methodend
  rem /**
  rem  * Enable remote debugging on the 9222 port
  rem  *
  rem  * @param BBjNumber debug! true to enable debug , false otherwise
  rem  *
  rem  * @return void
  rem  */
  method public static void setDebug(BBjNumber debug!)
    #setDebug(Debug! , 9222)
  methodend
  rem /**
  rem  * Get the root id of the grid
  rem  *
  rem  * The root id is a unique & auto-generated id for the grid instance.
  rem  * This id is used in the client to distinguish the grid instances
  rem  *
  rem  * @return BBjString the root id
  rem  */
  method public BBjString getRootId()
    if(null() = #RootId!)
      rem not used anymore. We keep it for the getInstancesCount() method
      #InstanceCount! = #InstanceCount! + 1
      uuid! = UUID.randomUUID().toString().replace("-","").substring(0,8)
      #RootId! = "gx-grid-" + uuid!
    FI

    methodret #RootId!
  methodend
  rem /**
  rem  * Return the number of initiated instances of the grid
  rem  *
  rem  * @return BBjNumber The number of instances
  rem  * @deprecated this method is deprecated and will be removed in the next release.
  rem  *             The method will return a wrong value if the BBj session is different from the one
  rem  *             in which the grid was initiated.
  rem  * @see <a href="https://github.com/BBj-Plugins/BBjGridExWidget/issues/251">Issue 251</a>
  rem  */
  method public static BBjNumber getInstanceCount()
    msg$ = "Since version 1.11.1, BBjGridExWidget.getInstanceCount is deprecated and will be removed in the next release. The method will return a wrong value if the BBj session is different from the one in which the grid was initiated."
    GxLogger.warn(msg$)
    methodret #InstanceCount!
  methodend
  rem /**
  rem  * @Override
  rem  *
  rem  * This method is called whenever the widget needs to be rendered
  rem  *
  rem  * @param Boolean f_init! if TRUE then the control is rendered for the first time so this method
  rem  *                         has to perform initial rendering
  rem  */
  method public void redraw(Boolean f_init!)
    declare BBjHtmlView htmlview!

    if (f_init!) then
      rem @see https://bugzilla.basis.cloud/show_bug.cgi?id=33048
      enableInternalSpecialKeysHandling! = stbl("!OPTIONS","HTMLVIEW_INTERNAL_TABS=TRUE")

      if (info(3,6)="6")
        rem force components to load in DWC
        #getCanvas().addButton(32765,0,0,0,0,"",$0010$)
        #getCanvas().setStyle("@element","{""width"":""100%"",""height"":""100%""}")
      fi

      html$ = #getTemplate()
      htmlview! = #getCanvas().addHtmlView(101,0,0,#getCanvas().getWidth(),#getCanvas().getHeight(),"",$0000$)
      htmlview!.setOpaque(0)
      htmlview!.setNoEdge(1)
      htmlview!.setTabTraversable(1)
      htmlview!.setFocusable(1)
      htmlview!.addStyle("htmlview-" + #getRootId())

      if (info(3,6)="6" AND AND(#getCanvas().getWindowFlags(),$00100000$) = $00100000$) then
        rem in DWC, if parent window is client-side sized, make the htmlview same size as surrunding canvas
        htmlview!.setStyle("width","100%")
        htmlview!.setStyle("height","100%")
      fi

      if (info(3,6)<"5" and #getDebug() > 0) then
        url$ = htmlview!.getAttribute("remoteDebuggingURL")

        if url$>"" then
          a = scall("bbj BBjGridExWidget/util/DebugWindow.bbj - "+url$+" &")
        FI
      FI

      htmlview!.setCallback(BBjAPI.ON_PAGE_LOADED,#this!,"onInit")
      htmlview!.setCallback(BBjAPI.ON_NATIVE_JAVASCRIPT,#this!,"onNativeEvent")
      htmlview!.setCallback(BBjAPI.ON_GAINED_FOCUS,#this!,"onGainedFocus")
      htmlview!.setText(html$)
      #HTMLView!=htmlview!
    else
      #HTMLView!.setSize(#getCanvas().getWidth(),#getCanvas().getHeight())
    FI
  methodend
  rem /**
  rem  * Inject a js Script.
  rem  *
  rem  * @param BBjString script! The javascript code to inject
  rem  * @param BBjNumber top! If true, the script will be injected at iframe's parent
  rem  */
  method public void injectScript(BBjString script!, BBjNumber top!)
    #HTMLView!.injectScript(new String(script!.getBytes(),"UTF-8") , top!)
  methodend
  rem /**
  rem  * Inject a js Script at the top window (iframe's parent window if any).
  rem  *
  rem  * @param BBjString script! The javascript code to inject
  rem  */
  method public void injectScript(BBjString script!)
    #injectScript(script!, 1)
  methodend
  rem /**
  rem  * Execute a javascript code on the client.
  rem  *
  rem  * Note that if the grid is not ready yet , then script will queued until the grid is ready then send
  rem  * to the client.
  rem  * If some reason you do not want this behavior , then use the executeScript method from the created internal
  rem  * HTML View
  rem  *
  rem  * @see <a href="https://documentation.basis.cloud/BASISHelp/WebHelp/index.htm">BBjHtmlView::executeScript</a>
  rem  *
  rem  * @param BBjString script$ The javascript code
  rem  *
  rem  * @return Object returned value, if any
  rem  */
  method public Object executeScript(BBjString script$)
    methodret #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * When true then the executor will limit the rate at
  rem  * which executeScript gets invoked on the HTMLView.
  rem  *
  rem  * Setting this to "0" will help to boost up the communication
  rem  * performance between BBj and the grid which lives inside
  rem  * the HTMLView in BUI context
  rem  *
  rem  * By default this options is set to "0"
  rem  *
  rem  * @param BBjNumber suppress! true to suppress , false to enable
  rem  *
  rem  * @deprecated Use `setSuppressWebDebouncing` instead
  rem  */
  method public void suppressBuiDebouncing(BBjNumber suppress!)
    #getExecutor().setSuppressBuiDebouncing(suppress!)
  methodend
  rem /**
  rem  * When true then the executor will limit the rate at
  rem  * which executeScript gets invoked on the HTMLView.
  rem  *
  rem  * Setting this to "0" will help to boost up the communication
  rem  * performance between BBj and the grid which lives inside
  rem  * the HTMLView in BUI & DWC context
  rem  *
  rem  * By default this options is set to "0"
  rem  *
  rem  * @param BBjNumber suppress! true to suppress , false to enable
  rem  */
  method public void suppressWebDebouncing(BBjNumber suppress!)
    #getExecutor().setSuppressWebDebouncing(suppress!)
  methodend
  rem /**
  rem  * When true then the executor will limit the rate at
  rem  * which executeScript gets invoked on the HTMLView.
  rem  *
  rem  * Setting this to "0" will help to boost up the communication
  rem  * performance between BBj and the grid which lives inside
  rem  * the HTMLView in GUI context
  rem  *
  rem  * By default this options is set to "1"
  rem  *
  rem  * @param BBjNumber suppress! true to suppress , false to enable
  rem  */
  method public void suppressGuiDebouncing(BBjNumber suppress!)
    #getExecutor().setSuppressGuiDebouncing(suppress!)
  methodend
  rem /**
  rem  * Suppress scripts debouncing for GUI and BUI
  rem  *
  rem  * @see #suppressWebDebouncing()
  rem  * @see #suppressGuiDebouncing()
  rem  *
  rem  * @param BBjNumber suppress! true to suppress , false to enable
  rem  */
  method public void suppressDebouncing(BBjNumber suppress!)
    #suppressWebDebouncing(suppress!)
    #suppressGuiDebouncing(suppress!)
  methodend
  rem /**
  rem  * When true then the executor will try to executes the JavaScript in the
  rem  * BBjHtmlView and returns immediately without waiting for a return value from
  rem  * the client.
  rem  *
  rem  * Enabling this option might boost the performance of the grid.
  rem  *
  rem  * @param BBjNumber enable! true to enable , false to disable
  rem  */
  method public void preferAsyncExecution(BBjNumber enable!)
    #getExecutor().setPreferAsyncExecution(enable!)
  methodend
  rem /**
  rem  * An Event listener executed after the initial load of the HTML View.
  rem  *
  rem  * At this phase the grid will inject all required js files in the client to make the grid functional.
  rem  *
  rem  * @param BBjEvent ev! The onLoad event
  rem  */
  method public void onInit(BBjEvent ev!)
    #HTMLView!.clearCallback(BBjAPI.ON_PAGE_LOADED)
    #HTMLView!.setCallback(BBjAPI.ON_PAGE_LOADED,#this!,"onLoaded")
    isLicensed! = 0

    if (#getForceCommunityBuild() = 0) then
      isLicensed! = #isLicensed()
    FI
    rem /**
    rem  * work out the required js files
    rem  */
    basePath$ = "BBjGridExWidget/client/dist"
    agGridPath$ = iff(isLicensed!, (basePath$ + "/ag-grid-enterprise.min.js") , (basePath$ +"/ag-grid-community.min.js"))
    gxPath$ = basePath$ + "/bbj-grid-widget.min.js"
    rem for debugging we inject the unminified files which contain source maps of the original code
    rem if #getDebug() = 1 then
    rem   agGridPath$ = iff(isLicensed!, (basePath$ + "/ag-grid-enterprise.js") , (basePath$ +"/ag-grid-community.js"))
    rem   gxPath$ = basePath$ + "/bbj-grid-widget.min.js"
    rem FI
    scriptsSet! = new HashSet()
    scriptsSet!.add(agGridPath$)
    scriptsSet!.add(gxPath$)
    bundle$ = ""
    rem /**
    rem  * All JS calls made from the grid's BBj code use the custom `$gw_wnd` and `$gw_doc` variables
    rem  * to reference the injected JS code in the HTMLView.
    rem  *
    rem  * The `$gw_wnd` variable is a reference to the window object of the HTMLView.
    rem  * The `$gw_doc` variable is a reference to the document object of the HTMLView.
    rem  *
    rem  * Why?
    rem  * =====
    rem  *
    rem  * BUI uses GWT and GWT uses $wnd instead of window because compiled code is executed normally in an iframe,
    rem  * and in this context, window will reference the iframe window while $wnd will reference the parent window.
    rem  * The same occurs with $doc which is a reference in the iframe to the parent document.
    rem  * (@see https://www.gwtproject.org/doc/latest/DevGuideCodingBasicsJSNI.html#writing)
    rem  *
    rem  * All JS calls we run from the grid are executed in the iframe context
    rem  * but All scripts are injected in the iframe's parent document so the embedded CSS styles can work.
    rem  *
    rem  * In GUI & DWC there is no iframe which means theres is no $wnd or $doc , because of this all
    rem  * the JS code we execute from the grid will throw an error.
    rem  *
    rem  * Things get more complicated when the grid is running inside an Iframe
    rem  * (Issue: https://github.com/BBj-Plugins/BBjGridExWidget/issues/249).
    rem  *
    rem  * To solve this we use the $gw_wnd and $gw_doc variables which are references to the window and document
    rem  * of the HTMLView according to the context.
    rem  */
    rem /**
    rem  * For BUI, inject the $gw_wnd and $gw_doc variables in the iframe.
    rem  * This will make sure the variables are available for all js code executed in the iframe.
    rem  */
    if (info(3,6)="5")
      bundle$ = bundle$ + "var $gw_wnd = $wnd;"
      bundle$ = bundle$ + "var $gw_doc = $doc;"
      #injectScript(bundle$, 0)
      bundle$ = ""
    fi
    rem /**
    rem  * For all clients inject the $gw_wnd and $gw_doc variables in the top window (iframe's parent if there is one).
    rem  * This will make sure the variables are available for all injected js code.
    rem  */
    bundle$ = bundle$ + "var $gw_wnd = window;"
    bundle$ = bundle$ + "var $gw_doc = document;"
    #injectScript(bundle$, 1)
    rem loop over the require scripts and attach to the bundle
    it! = scriptsSet!.iterator()
    while(it!.hasNext())
      path! = it!.next()
      ch=unt
      open (ch)path!
      read record (ch,siz=5512000)content$
      close (ch)
      bundle$ = bundle$ + ";" + content$
    wend
    rem finally inject the built bundle
    #injectScript(bundle$)
    wait 0
    rem /**
    rem  * Some customers reported that the second ON_PAGE_LOADED event is not fired
    rem  * so we call the onLoaded method manually in case the event is not fired
    rem  *
    rem  * could even directly call the onLoaded Method from here
    rem  * #onLoaded(null())
    rem  */
    BBjAPI().createTimer(str(#this!)+"onLoadFallback",2,#this!,"onLoadedByTimer")
  methodend
  rem /**
  rem  * An Event listener for the fallback by timer
  rem  *
  rem  * Sporadically the ON_PAGE_LOADED event did not fire
  rem  *
  rem  * @param BBjEvent ev! The onLoad event
  rem  */
  method public void onLoadedByTimer(BBjEvent ev!)
    System.out.println("BBjGridExWidget: Loaded by timer fallback. High System Load?")
    #onLoaded(ev!)
  methodend
  rem /**
  rem  * An Event listener executed after the second ON_PAGE_LOADED event
  rem  *
  rem  * At this phase the grid flush all enqueued scripts
  rem  *
  rem  * @param BBjEvent ev! The onLoad event
  rem  */
  method public void onLoaded(BBjEvent ev!)
    #HTMLView!.clearCallback(BBjAPI.ON_PAGE_LOADED)
    BBjAPI().removeTimer(str(#this!)+"onLoadFallback",err=*next)

    if info(3,6)<"5" AND #HTMLView!.executeScript("$gw_wnd") = null() then
      System.out.println("BBjGridExWidget: $gw_wnd not found, repeating injectScript. High System Load?")
      #onInit(ev!)
      methodret
    fi

    #getLicenseManager().register(#this!)
    #IsReady! = BBjAPI.TRUE
    #render()
    #getExecutor().flush()

    if (#newW! <> null() and #newH!<> null()) then
      #super!.setSize(#newW!,#newH!)
      #newW! = null()
      #newH! = null()
    FI
  methodend
  rem /**
  rem  * Focus the grid by selecting the cell in the first cell and first column.
  rem  *
  rem  * Note: If the grid has already a different selected cell , then
  rem  * the event handler will retain the selection
  rem  *
  rem  * @param BBjGainedFocusEvent ev! The focus event
  rem  */
  method public void onGainedFocus(BBjGainedFocusEvent ev!)
    if(ev!.isTemporary())
      methodret
    FI

    #focus()
  methodend
  rem /**
  rem  * On NativeEvent
  rem  *
  rem  * Event Handler for Native JavaScript Event coming from the client
  rem  * Determines and dispatches the actual event
  rem  *
  rem  * @param BBjNativeJavaScriptEvent ev! The Javascript Event
  rem  */
  method public void onNativeEvent(BBjNativeJavaScriptEvent ev!)
    map! = ev!.getEventMap()
    type$ = str(map!.get("type"))
    detail$ = str(map!.get("detail"))
    switch type$
      case "gw.rowSelect"
        #onSelectRowChange(detail$, #ON_GRID_SELECT_ROW())
        break
      case "gw.rowClick"
        #onSelectRowChange(detail$,#ON_GRID_ROW_CLICK())
        break
      case "gw.rowDoubleClick"
        #onSelectRowChange(detail$,#ON_GRID_DOUBLE_CLICK())
        break
      case "gw.cellClicked"
        #onCellEvent(detail$,#ON_GRID_CELL_CLICK())
        break
      case "gw.cellDoubleClicked"
        #onCellEvent(detail$,#ON_GRID_CELL_DOUBLE_CLICK())
        break
      case "gw.rangeSelection"
        #onRangeSelectionChange(detail$)
        break
      case "gw.cellEditingStarted"
        #onCellEvent(detail$,#ON_GRID_CELL_EDITING_STARTED())
        break
      case "gw.cellEditingStopped"
        #onCellEvent(detail$,#ON_GRID_CELL_EDITING_STOPPED())
        break
      case "gw.cellValueChanged"
        #onCellEvent(detail$,#ON_GRID_CELL_VALUE_CHANGED())
        break
      case "gw.rowEditingStarted"
        #onRowEditing(detail$,#ON_GRID_ROW_EDITING_STARTED())
        break
      case "gw.rowEditingStopped"
        #onRowEditing(detail$,#ON_GRID_ROW_EDITING_STOPPED())
        break
      case "gw.rowValueChanged"
        #onRowEditing(detail$,#ON_GRID_ROW_VALUE_CHANGED())
        break
      case "gw.stateChanged"
        #handleStateChangedEvent(detail$,#ON_GRID_STATE_CHANGE())
        break
      case "gw.contextmenu"
        #onContextmenuEvent(detail$)
        break
      case "gw.keypress"
        #onKeypressEvent(detail$)
        break
      case "gw.suggestion"
        #onSuggestionEvent(detail$)
        break
      case "gw.filterChanged"
        #onFilterChangedEvent()
        break
      case "gw.gridReady"
        #onGridReadyEvent()
        break
    swend
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn addColumn(GxColumn definition!)
    methodret #getColumnsManager().addColumn(definition!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn addColumn(BBjString field!,BBjNumber type!)
    methodret #getColumnsManager().addColumn(field! , type!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn addColumn(BBjString field!,BBjString label!)
    methodret #getColumnsManager().addColumn(field! , label!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn addColumn(BBjString field!, BBjString label! , BBjNumber type!)
    methodret #getColumnsManager().addColumn(field! , label! ,type!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn addColumn(BBjString field!)
    methodret #addColumn(field!,field!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn getColumn(BBjString field!)
    methodret #getColumnsManager().getColumn(field!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public BBjNumber hasColumn(BBjString field!)
    methodret #getColumnsManager().hasColumn(field!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumn removeColumn(BBjString field!)
    methodret #getColumnsManager().removeColumn(field!)
  methodend
  rem /**
  rem  * Sets the foreground color for a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column definition
  rem  * @param BBjColor color!  the color for the column
  rem  */
  method public void setColumnForeColor(BBjString field$,BBjColor color!)
    #getColumn(field$).setForeColor(color!)
  methodend
  rem /**
  rem  * Sets the foreground color for a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column definition
  rem  * @param BBjString color$ Valid CSS color
  rem  *
  rem  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
  rem  */
  method public void setColumnForeColor(BBjString field$,BBjString color!)
    #getColumn(field$).setForeColor(color!)
  methodend
  rem /**
  rem  * Sets the background color of a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column definition
  rem  * @param BBjColor color!  The color for the column
  rem  */
  method public void setColumnBackColor(BBjString field$,BBjColor color!)
    #getColumn(field$).setBackColor(color!)
  methodend
  rem /**
  rem  * Sets the background color of a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column definition
  rem  * @param BBjColor color$  Valid CSS color
  rem  *
  rem  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
  rem  */
  method public void setColumnBackColor(BBjString field$,BBjString color!)
    #getColumn(field$).setBackColor(color!)
  methodend
  rem /**
  rem  * Sets the default alignment for a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field! The field name of the column definition
  rem  * @param BBjNumber align! The column alignment
  rem  *
  rem  * valid alignments:
  rem  *
  rem  * @see GRID_ALIGN_LEFT()
  rem  * @see GRID_ALIGN_CENTER()
  rem  * @see GRID_ALIGN_RIGHT()
  rem  *
  rem  * @RequiresRefresh
  rem  */
  method public void setColumnAlignment(BBjString field!, BBjNumber align!)
    #getColumn(field!).setAlignment(align!)
  methodend
  rem /**
  rem  * Sets the default alignment for a column's header
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field! The field name of the column definition
  rem  * @param BBjNumber align! The column's header alignment
  rem  *
  rem  * valid alignments:
  rem  *
  rem  * @see GRID_ALIGN_LEFT()
  rem  * @see GRID_ALIGN_CENTER()
  rem  * @see GRID_ALIGN_RIGHT()
  rem  *
  rem  * @RequiresRefresh
  rem  */
  method public void setColumnHeaderAlignment(BBjString field!, BBjNumber align!)
    #getColumn(field!).setHeaderAlignment(align!)
  methodend
  rem /**
  rem  * Sets the width of a column
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * <br>
  rem  * <b>Note:</b> Unlike setting the width in the column definition, this method will update a column width without
  rem  * a full re-render.
  rem  *
  rem  * @param BBjString field$ The field name of the column definition
  rem  * @param BBjNumber width! The column width
  rem  */
  method public void setColumnWidth(BBjString field$, BBjNumber width!)
    if #hasColumn(field$) then
      #getColumn(field$).setWidth(width!)
      scriptKey! = "$gw_wnd.gw_setColumnWidth_" + field$
      #getExecutor().execute(scriptKey! , "$gw_wnd.gw_setColumnWidth('"+ #getRootId() + "','" + field$ + "'," + str(width!) + ");")
    FI
  methodend
  rem /**
  rem  * Pin a column of the grid to the left or the right margin
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column
  rem  * @param BBjString pin$  The pin direction ("right" or "left")
  rem  *
  rem  * @see GxColumn.PINNED_LEFT()
  rem  * @see GxColumn.PINNED_RIGHT()
  rem  */
  method public void pinColumn(BBjString field$, BBjString pin$)
    pin$=cvs(pin$,8)

    if #hasColumn(field$) then
      #getColumn(field$).setPinned(pin$)
      scriptKey! = "$gw_wnd.gw_pinColumn" + field$
      #getExecutor().execute(scriptKey!,"$gw_wnd.gw_pinColumn('" + #getRootId() + "','" + field$ + "','" + pin$  + "');")
    FI
  methodend
  rem /**
  rem  * Change column position
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString field$ The field name of the column
  rem  * @param BBjNumber toIndex! The new column position/index
  rem  */
  method public void moveColumn(BBjString Field$, BBjNumber toIndex!)
    scriptKey! = "$gw_wnd.gw_moveColumn" + field$
    script$="$gw_wnd.gw_moveColumn('" + #getRootId() + "','" + field$ + "'," + str(toIndex!) + ");"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * Set the mask of a column using value formatter expression.
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  * <br>
  rem  *
  rem  * <b>Note:</b> This method will override the ValueFormatterExpression of the column.The method depends on
  rem  * the column type to determine the correct value formatter (number, date, ...)
  rem  *
  rem  * @param field! - The column's field
  rem  * @param mask! - The BBj date string or numeric mask.
  rem  */
  method public void setColumnMask(BBjString field!, BBjString mask!)
    if(#hasColumn(field!)) then
      #getColumn(field!).setMask(mask!)
    FI
  methodend
  rem /**
  rem  * Set an image list for a given column using GxRendererImageRenderer.
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  * <br>
  rem  *
  rem  * <b>Note:</b> This method will override the CellRenderer of the column.
  rem  * The column has to contain the values "1","2","3" to x to reference the slices in the BBjImage list
  rem  *
  rem  * @param BBjString field! The column's field
  rem  * @param BBjImage imagelist! The image list containing the image sprites
  rem  */
  method public void setColumnImageList(BBjString field!, BBjImage imagelist!)
    if #hasColumn(field!) then
      renderer! = new GxRendererImageRenderer()
      enc! = java.util.Base64.getEncoder()
      for i=1 to int(imageList!.getWidth() / imageList!.getHeight())
        imageSlice!=imageList!.getImageSlice(i-1,imageList!.getHeight())
        bytes$ = imageSlice!.getBytes("png")
        b64$ = enc!.encode(bytes$)
        renderer!.getList().addProperty(str(i-1),"data:image/png;base64, "+b64$)
      next
      rem adding a clear pixel to reflect the -1 for backwards compatibility to legacy BBj grid
      clearpixel$=enc!.encode($89504E470D0A1A0A0000000D4948445200000001000000010804000000B51C0C020000000B49444154789C63FACF0000020701029A1C31710000000049454E44AE426082$)
      renderer!.getList().addProperty("-1","data:image/png;base64, "+clearpixel$)
      #getColumn(field!).setCellRenderer(renderer!)
    FI
  methodend
  rem /**
  rem  * Set an aggregation function for the passed column field
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @param BBjString field! The column's field
  rem  * @param BBjString AggFunc! Name of function to use for aggregation. One of [sum,min,max,first,last].
  rem  */
  method public void setColumnAggFunc(BBjString field! , BBjString AggFunc!)
    if(#hasColumn(field!)) then
      #getColumn(field!).setAggFunc(AggFunc!)
    FI
  methodend
  rem /**
  rem  * Enable row grouping for columns
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void addRowGroupColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_addRowGroupColumn('" + #getRootId() + "','" + columns! + "', 0 );")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    count! = 0
    WHILE (it!.hasNext())
      next! = #getColumn(cvs(it!.next(),128))
      next!.setRowGroup(1)
      next!.setEnableRowGroup(1)
      next!.setRowGroupIndex(count!)
      count! = count! + 1
    WEND
  methodend
  rem /**
  rem  * Disable row grouping for all columns and enable it for the passed columns
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void setRowGroupColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_addRowGroupColumn('" + #getRootId() + "','" + columns! + "' , 1);")
    list! = Arrays.asList(columns!.split(","))
    it! = #getColumnsManager().getColumns().entrySet().iterator()
    count! = 0
    WHILE (it!.hasNext())
      next! = cast(GxColumn , it!.next().getValue())

      if(list!.contains(next!.getField())) then
        next!.setRowGroup(1)
        next!.setEnableRowGroup(1)
        next!.setRowGroupIndex(count!)
        count! = count! + 1
      else
        next!.setRowGroup(0)
        next!.setEnableRowGroup(0)
        next!.setRowGroupIndex(null())
      FI
    WEND
  methodend
  rem /**
  rem  * Disable row grouping for columns.
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void removeRowGroupColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_removeRowGroupColumn('" + #getRootId() + "','" + columns! + "');")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    WHILE (it!.hasNext())
      next! = #getColumn(cvs(it!.next(),128))
      next!.setRowGroup(0)
      next!.setEnableRowGroup(0)
      next!.setRowGroupIndex(null())
    WEND
  methodend
  rem /**
  rem  * Enable pivot for columns
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void addPivotColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_addPivotColumns('" + #getRootId() + "','" + columns! + "', 0 );")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    count! = 0
    WHILE (it!.hasNext())
      next! = #getColumn(cvs(it!.next(),128))
      next!.setEnablePivot(1)
      next!.setPivotIndex(count!)
      count! = count! + 1
    WEND
  methodend
  rem /**
  rem  * Disable pivot for all columns and enable it for the passed columns
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void setPivotColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_addPivotColumns('" + #getRootId() + "','" + columns! + "' , 1);")
    list! = Arrays.asList(columns!.split(","))
    it! = #getColumnsManager().getColumns().entrySet().iterator()
    count! = 0
    WHILE (it!.hasNext())
      next! = cast(GxColumn , it!.next().getValue())

      if(list!.contains(next!.getField())) then
        next!.setEnablePivot(1)
        next!.setPivotIndex(count!)
        count! = count! + 1
      else
        next!.setEnablePivot(0)
        next!.setPivotIndex(null())
      FI
    WEND
  methodend
  rem /**
  rem  * Disable pivot for columns.
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void removePivotColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_removePivotColumns('" + #getRootId() + "','" + columns! + "');")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    WHILE (it!.hasNext())
      next! = #getColumn(cvs(it!.next(),128))
      next!.setEnablePivot(0)
      next!.setPivotIndex(null())
    WEND
  methodend
  rem /**
  rem  * Enable value for columns
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void addValueColumns(BBjString columns!)
    #getExecutor().execute("$gw_wnd.gw_addValueColumns('" + #getRootId() + "','" + columns! + "');")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    WHILE (it!.hasNext())
      next! = cvs(it!.next(),128)
      #getColumn(next!).setEnableValue(1)
    WEND
  methodend
  rem /**
  rem  * Disable value for columns.
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated string of column fields
  rem  */
  method public void removeValueColumns(BBjString columns!)
    #getExecutor().execute("removeValueColumns('" + #getRootId() + "','" + columns! + "');")
    list! = Arrays.asList(columns!.split(","))
    it! = list!.iterator()
    WHILE (it!.hasNext())
      next! = cvs(it!.next(),128)
      #getColumn(next!).setEnableValue(0)
    WEND
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumnGroup addColumnGroup(GxColumnGroup definition!)
    methodret #getColumnsManager().addColumnGroup(definition!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumnGroup addColumnGroup(BBjString id!)
    methodret #getColumnsManager().addColumnGroup(id!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label!)
    methodret #getColumnsManager().addColumnGroup(id!,label!)
  methodend
  rem /**
  rem  * Add column group
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem * @param BBjString id! The group id
  rem * @param BBjString label! The group label/name
  rem * @param BBjVector columns! Vector of columns ids/fields to use
  rem * @param BBjNumber marryChildren! Set to 'true' to keep columns in this group beside each other in the grid.
  rem *                                 Moving the columns outside of the group (and hence breaking the group) is not allowed.
  rem * @param BBjString headerClass!  A CSS class to apply
  rem *
  rem * @return GxColumnGroup The GxColumnGroup instance
  rem */
  method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label! ,  BBjVector columns! , BBjNumber marryChildren! ,BBjString headerClass! )
    declare GxColumnGroup definition!

    definition! = new GxColumnGroup(id! , label!)
    definition!.setMarryChildren(marryChildren!)
    definition!.getHeaderClass().add(headerClass!)
    columnsLength! = columns!.size() - 1
    FOR i = 0 TO columnsLength!
      current$ = columns!.get(i)
      column! = null()

      if(#hasColumn(current$)) then
        column! = #getColumn(current$)
      else
        column! = #addColumn(current$,current$)
      FI

      definition!.addColumn(column!)
      #removeColumn(current$)
    NEXT i

    methodret #addColumnGroup(definition!)
  methodend
  rem /**
  rem  * Group Vector of Columns
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem * @param BBjString id! The group id
  rem * @param BBjString label! The group label/name
  rem * @param BBjVector columns! Vector of columns ids/fields to use
  rem * @param BBjNumber marryChildren! Set to 'true' to keep columns in this group beside each other in the grid.
  rem *                                 Moving the columns outside of the group (and hence breaking the group) is not allowed.
  rem  *
  rem  * @return GxColumnGroup The GxColumnGroup instance
  rem */
  method public GxColumnGroup addColumnGroup(BBjString id!, BBjString label! , BBjVector columns! , BBjNumber marryChildren!)
    methodret #addColumnGroup(id!,label!,columns! , marryChildren! ,  "" )
  methodend
  rem /**
  rem  * Group Vector of Columns
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem * @param BBjString id! The group id
  rem * @param BBjString name! The group label/name
  rem * @param BBjVector columns! Vector of columns ids/fields to use
  rem  *
  rem  * @return GxColumnGroup The GxColumnGroup instance
  rem */
  method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label!, BBjVector columns!)
    methodret #addColumnGroup(id!,label! , columns! , 1  , "" )
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumnGroup getColumnGroup(BBjString id!)
    methodret #getColumnsManager().getColumnGroup(id!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public BBjNumber hasColumnGroup(BBjString id!)
    methodret #getColumnsManager().hasColumnGroup(id!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public GxColumnGroup removeColumnGroup(BBjString id!)
    methodret #getColumnsManager().removeColumnGroup(id!)
  methodend
  rem /**
  rem  * {@inheritDoc}
  rem  */
  method public void resetAllColumns()
    #getColumnsManager().resetAllColumns()
  methodend
  rem /**
  rem  * Alias for <i>resetAllColumns()</i>
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#ColumnsRenderer</small></b>
  rem  *
  rem  * @see resetAllColumns()
  rem  */
  method public void clearColumnDefinitions()
    #resetAllColumns()
  methodend
  rem /**
  rem  * Build the grid json configuration object
  rem  *
  rem  * @return JsonObject The grid options as JsonObject
  rem  */
  method public JsonObject getAsJsonObject()
    REM build the column definition
    iterator! = #getColumnsManager().getColumns().entrySet().iterator()
    cdef! = new JsonArray()
    while iterator!.hasNext()
      next!   = iterator!.next()
      key!   = next!.getKey()
      value! = next!.getValue()
      cdef!.add(value!.getAsJsonObject())
    wend

    options! = #getOptions().getAsJsonObject()
    rem Columns options
    rem ===========================
    options!.        add("columnDefs",cdef!)
    rem Context
    rem ===========================
    context! = options!.get("context").getAsJsonObject()
    context!.addProperty("id",#getRootId())
    context!.        add("interests",iff(#getInterests().size() <> 0 ,#getInterests(), listIsEmpty!) ,err=*next)
    context!.addProperty("getRowNodeId",#RowNodeId$, err=*next)

    if(#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1) then
      context!.add("chartToolbarItems",#getChartToolbarItems(), err=*next)
    FI

    methodret options!
  methodend
  rem /**
  rem  * Render the grid
  rem  *
  rem  * The method will compose the grid config and send it to the client for a full re-render.
  rem  * You can use this method to force the client render after you update a setup configuration (ex: column definitions)
  rem  */
  method public void render()
    isWidgetReady! = #getIsReady()
    rem /**
    rem  * Make sure to delay rendering until the widget is declared ready
    rem  *
    rem  * The widget is declared ready when the HTMLView fires the ON_PAGE_LOADED
    rem  * event and the scripts are injected successfully
    rem  */
    if(!isWidgetReady!)
      methodret
    FI

    isFirstRender! = #getIsFirstRender()
    gson! = new Gson()
    options! = #getAsJsonObject()
    data$ = #getRS().toJson(1 , #getRowNodeId())
    rem /**
    rem  * The script priority is defined based on isFirstRender
    rem  *
    rem  * When the grid is rendering for the first time , we make sure
    rem  * that the init script is the first one in the queue before any
    rem  * other script. if is not the first render , then the init
    rem  * is queued in the normal order.
    rem  */
    priority! = 0

    if(!isFirstRender!)
      priority! = null()
    FI
    rem #getExecutor().execute("console.log($gw_wnd), console.log($gw_doc)" , 1 , priority!)
    #getExecutor().execute("$gw_wnd.gw_init(" + gson!.toJson(options!) + ",'" + #LicenseKey$ + "'," + data$ + ")" , 1 , priority!)
    rem /**
    rem  * Update the IsFirstRender flag once and only once
    rem  */
    if(!isFirstRender!)
      #setIsFirstRender(BBjAPI.FALSE)
    FI
  methodend
  rem /**
  rem  * Re-render the column definitions on the client.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * The method will collect the new changes in columns and column groups and force the client to reflect the
  rem  * change.
  rem  */
  method public void updateColumns()
    definition! = #getAsJsonObject().get("columnDefs").getAsJsonArray()
    scriptKey! = "$gw_wnd.gw_setColumnDefinitions"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setColumnDefinitions('" + #getRootId() + "'," + new Gson().toJson(definition!) + ")")
  methodend
  rem /**
  rem  * Set a result set of pinned rows on top
  rem  *
  rem  * @param ResultSet rs! A ResultSet instance
  rem  */
  method public void setPinnedTopRows(ResultSet rs!)
    #getOptions().setPinnedTopRows(rs!)

    if(#getIsReady())
      #getExecutor().execute("$gw_wnd.gw_setPinnedTopRowData('" + #getRootId() + "'," + #getOptions().getPinnedTopRowsAsJson() + ")")
    fi
  methodend
  rem /**
  rem  * Get the pinned top rows as defined in the grid options
  rem  *
  rem  * @return ResultSet The pinned rows
  rem  */
  method public ResultSet getPinnedTopRows()
    methodret #getOptions().getPinnedTopRows()
  methodend
  rem /**
  rem  * Get the count of pinned rows on top
  rem  *
  rem  * @param BBjNumber rows count
  rem  */
  method public BBjNumber getPinnedTopRowsCount()
    rs! = #getOptions().getPinnedTopRows()
    count! = 0

    if(rs! <> null())
      count! = rs!.count()
    fi

    methodret count!
  methodend
  rem /**
  rem  * Set a result set of pinned rows on bottom
  rem  *
  rem  * @param ResultSet rs! A ResultSet instance
  rem  */
  method public void setPinnedBottomRows(ResultSet rs!)
    #getOptions().setPinnedBottomRows(rs!)

    if(#getIsReady())
      #getExecutor().execute("$gw_wnd.gw_setPinnedBottomRowData('" + #getRootId() + "'," + #getOptions().getPinnedBottomRowsAsJson() + ")")
    fi
  methodend
  rem /**
  rem  * Get the pinned bottom rows as defined in the grid options
  rem  *
  rem  * @return ResultSet The pinned rows
  rem  */
  method public ResultSet getPinnedBottomRows()
    methodret #getOptions().getPinnedBottomRows()
  methodend
  rem /**
  rem  * Get the count of pinned rows on bottom
  rem  *
  rem  * @param BBjNumber rows count
  rem  */
  method public BBjNumber getPinnedBottomRowsCount()
    rs! = #getOptions().getPinnedBottomRows()
    count! = 0

    if(rs! <> null())
      count! = rs!.count()
    fi

    methodret count!
  methodend
  rem /**
  rem  * Build the column definitions from the passed ResultSet
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  *
  rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
  rem  */
  method public void buildColumnsFromResultSet(ResultSet rs! , BBjNumber addAll!)
    if rs! <> NULL() then
      fields!   = rs!.getColumnNames()
      iterator! = fields!.iterator()
      while iterator!.hasNext()
        field$ = iterator!.next()
        meta! = rs!.getColumnMetaData(field$)

        if #hasColumn(field$) = 1 then
          #getColumn(field$).update(meta! , #getOptions().getDefaultColumnDefinition())
        else
          if(addAll! = 1) then
            definition! = new GxColumn(field$)
            definition!.update(meta!, #getOptions().getDefaultColumnDefinition())
            #addColumn(definition!)
          FI
        FI
      wend
    FI
  methodend
  rem /**
  rem  * Feed the grid with data
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
  rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
  rem  * @param BBjString indexdBy$ The field used for creating the unique row index
  rem  *
  rem  * @see render()
  rem  */
  method public void setData(ResultSet rs!,BBjNumber render! , BBjNumber addAll! , BBjString indexdBy$)
    #RowNodeId$ = indexdBy$
    #RS! = rs!

    if rs! <> NULL() then
      #buildColumnsFromResultSet(rs!,addAll!)
      #RS!.createIndex()
    FI

    #render()
  methodend
  rem /**
  rem  * Feed the grid with data
  rem  *
  rem  * The method will sync the result set column definitions with the current column definitions ,
  rem  * update the data and render the grid on the client
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
  rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
  rem  *
  rem  * @see render()
  rem  */
  method public void setData( ResultSet rs! , BBjNumber render!, BBjNumber all!)
    #setData(rs! , render! , all! , #getRowNodeId())
  methodend
  rem /**
  rem  * Feed the grid with data
  rem  *
  rem  * The method will sync the result set column definitions with the current column definitions ,
  rem  * update the data and render the grid on the client
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
  rem  *
  rem  * @see render()
  rem  */
  method public void setData( ResultSet rs! , BBjNumber render!)
    #setData(rs! , render! , 1 , #getRowNodeId())
  methodend
  rem /**
  rem  * Feed the grid with data
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  * @param BBjString indexdBy$ The field used for creating the unique row index
  rem  */
  method public void setData(ResultSet rs!, BBjString indexdBy$)
    #setData(rs! , 1 , 1 , indexdBy$)
  methodend
  rem /**
  rem  * Feed the grid with data
  rem  *
  rem  * The method will sync the result set column definitions with the current column definitions ,
  rem  * update the data and render the grid on the client
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  */
  method public void setData( ResultSet rs!)
    #setData(rs! , 1)
  methodend
  rem /**
  rem  * Feed the grid with a new ResultSet
  rem  *
  rem  * Unlike the <b>setData</b> method, this one will update the grid with a new rows set(ResultSet) without doing a full re-render.
  rem  * The column definition will not be synced from the passed ResultSet in this case.
  rem  *
  rem  * Use this method in case you want to replace the whole data in the grid at once.
  rem  * Please note that All row and range selection will be lost.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  *
  rem  * @see setData()
  rem  */
  method public void updateData(ResultSet rs!)
    #RS! = rs!

    if rs! <> NULL() AND rs!.size() > 0 then
      #RS!.createIndex(err=*next)
      data$=#RS!.toJson(BBjAPI.TRUE,#getRowNodeId())
      scriptKey! = "$gw_wnd.gw_setRowData"
      #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setRowData('" + #getRootId() + "'," + data$+ ")")
    FI
  methodend
  rem /**
  rem  * Feed the grid with a new ResultSet
  rem  *
  rem  * Unlike the <b>setData</b> method, this one will update the grid with a new rows set(ResultSet) without doing a full re-render.
  rem  * The column definition will not be synced from the passed ResultSet in this case.
  rem  *
  rem  * Use this method in case you want to replace the whole data in the grid at once.
  rem  * Please note that All row and range selection will be lost.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param ResultSet rs! ResultSet with the data
  rem  *
  rem  * @see setData()
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setRowsData(ResultSet rs!) is deprecated / renamed. Use BBjGridExWidget.updateData(ResultSet rs!) instead.
  rem  */
  method public void setRowsData(ResultSet rs!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setRowsData(ResultSet rs!) is deprecated / renamed. Use BBjGridExWidget.updateData(ResultSet rs!) instead.")
    #updateData(rs!)
  methodend
  rem /**
  rem  * Execute a bulk update on the grid
  rem  *
  rem  * The transaction method is to pass a transaction object to the grid containing
  rem  * rows to add, remove and update.
  rem  *
  rem  * The grid keeps all active sorting, grouping and filtering, including updating to reflect
  rem  * the changes in the data should the sorting, grouping or filtering be impacted.
  rem  *
  rem  * Updating using transactions is the best way to do large updates to the grid, as the grid treats them
  rem  * as delta changes, so the grid only refreshes what is needed giving a performance boost.
  rem  *
  rem  * All row and range selection will be kept.
  rem  *
  rem  * Note that all update done on the grid will reflected also on the ResultSet instance which is the grid
  rem  * is using.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxClientTransactionModel transaction!
  rem  * @param BBjNumber batchUpdate! when true then execute the update, along with any other updates you subsequently provide
  rem  */
  method public void executeUpdateTransaction(GxClientTransactionModel transaction!,BBjNumber batchUpdate!)
    transaction!.setWidget(#this!)
    json! = transaction!.execute()
    #getExecutor().execute("$gw_wnd.gw_updateRowData('" + #getRootId() + "'," + json!.toString() + "," + str(batchUpdate!.booleanValue()) + ")")
  methodend
  rem /**
  rem  * Execute a bulk update on the grid
  rem  *
  rem  * The transaction method is to pass a transaction object to the grid containing
  rem  * rows to add, remove and update.
  rem  *
  rem  * The grid keeps all active sorting, grouping and filtering, including updating to reflect
  rem  * the changes in the data should the sorting, grouping or filtering be impacted.
  rem  *
  rem  * Updating using transactions is the best way to do large updates to the grid, as the grid treats them
  rem  * as delta changes, so the grid only refreshes what is needed giving a performance boost.
  rem  *
  rem  * All row and range selection will be kept.
  rem  *
  rem  * Note that all update done on the grid will reflected also on the ResultSet instance which is the grid
  rem  * is using.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxClientTransactionModel transaction!
  rem  */
  method public void executeUpdateTransaction(GxClientTransactionModel transaction!)
    #executeUpdateTransaction(transaction! , 0)
  methodend
  rem /**
  rem  * Update row data
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param DataRow row! DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel updateRow(DataRow row!)
    transaction! = new GxClientTransactionModel()
    transaction!.update(row!)
    #executeUpdateTransaction(transaction!)
    methodret transaction!
  methodend
  rem /**
  rem  * Update row data
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The Row index
  rem  * @param DataRow row! DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.updateRow(BBjNumber index!,DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own
  rem  */
  method public GxClientTransactionModel updateRow(BBjNumber index!,DataRow row!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.updateRow(BBjNumber index!,DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own")
    methodret #updateRow(row!)
  methodend
  rem /**
  rem  * Update row data
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The Row index
  rem  * @param DataRow row! DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setRowData(BBjNumber index!,DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own
  rem  */
  method public GxClientTransactionModel setRowData(BBjNumber index!,DataRow row!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setRowData(BBjNumber index!,DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own")
    methodret #updateRow(index!,row!)
  methodend
  rem /**
  rem  * Update row data
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param DataRow row! DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setRowData(DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own
  rem  */
  method public GxClientTransactionModel setRowData(DataRow row!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setRowData(DataRow row!) is deprecated. Use BBjGridExWidget.updateRow(DataRow row!) instead. The grid can work out the row index by its own")
    methodret #updateRow(row!)
  methodend
  rem /**
  rem  * Add new row
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The insert index
  rem  * @param DataRow row! DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel addRow(BBjNumber index!,DataRow row!)
    transaction! = new GxClientTransactionModel()
    transaction!.add(row!)
    transaction!.setAddIndex(index!)
    #executeUpdateTransaction(transaction!)
    methodret transaction!
  methodend
  rem /**
  rem  * Add new row at the beginning of the grid
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param DataRow row! The DataRow object which contains the update
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel addRow(DataRow row!)
    methodret #addRow(0,row!)
  methodend
  rem /**
  rem  * Remove a row from grid by the row reference
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param DataRow row! The data row object to remove
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel removeRow(DataRow row!)
    transaction! = new GxClientTransactionModel()
    transaction!.remove(row!)
    #executeUpdateTransaction(transaction!)
    methodret transaction!
  methodend
  rem /**
  rem  * Remove a row from grid by index
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The row index
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel removeRow(BBjNumber index!)
    methodret #removeRow(#getRS().get(index!))
  methodend
  rem /**
  rem  * Remove a row from grid by key
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! The row key
  rem  *
  rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
  rem  */
  method public GxClientTransactionModel removeRow(BBjString key!)
    methodret #removeRow(#getRS().get(key!))
  methodend
  rem /**
  rem  * Clear row data (Empty the grid )
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void clearData()
    #getRS().clear()

    if(#IsReady!) then
      #getExecutor().execute("$gw_wnd.gw_setRowData('" + #getRootId() + "', [])",0)
    fi
  methodend
  rem /**
  rem  * Clear row data (Empty the grid )
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  *  @deprecated since version 0.101.0, BBjGridExWidget.clearRowsData() is deprecated / renamed. Use BBjGridExWidget.clearData() instead.
  rem  */
  method public void clearRowsData()
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.clearRowsData() is deprecated / renamed. Use BBjGridExWidget.clearData() instead.")
    #clearData()
  methodend
  rem /**
  rem  * Apply the grid's columns , sorbing and filtering state
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxState state! : the state object
  rem  */
  method public void setState(GxState state!)
    scriptKey! = "$gw_wnd.gw_setState"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setState('" + #getRootId() + "'," + state!.toString() +")")
  methodend
  rem /**
  rem  * Apply the grid's columns , sorbing and filtering state
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxState state! : the state object
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setColumnState(GxState state!) is deprecated / renamed. Use BBjGridExWidget.setState(GxState state!) instead.
  rem  */
  method public void setColumnState(GxState state!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setColumnState(GxState state!) is deprecated / renamed. Use BBjGridExWidget.setState(GxState state!) instead.")
    #setState(state!)
  methodend
  rem /**
  rem  * Get the grid's columns , sorting and filtering state
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @returns GxState
  rem  */
  method public GxState getState()
    state! = new GxState()
    json_string$ = str(#getExecutor().execute("$gw_wnd.gw_getState('" + #getRootId() + "')",0))
    state!.setString(json_string$)
    methodret state!
  methodend
  rem /**
  rem  * Get the grid's columns , sorting and filtering state
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @returns GxState
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.getColumnState() is deprecated / renamed. Use BBjGridExWidget.getState() instead.
  rem  */
  method public GxState getColumnState()
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.getColumnState() is deprecated / renamed. Use BBjGridExWidget.getState() instead.")
    methodret #getState()
  methodend
  rem /**
  rem  * Get the grid sidebar instance
  rem  *
  rem  * @return GxSidebar
  rem  */
  method public GxSidebar getSidebar()
    methodret #getOptions().getSidebar()
  methodend
  rem /**
  rem  * Get the language manager instance
  rem  *
  rem  * @returns GxLanguageManager
  rem  */
  method public GxLanguageManager getLanguageManager()
    methodret #getOptions().getLanguageManager()
  methodend
  rem /**
  rem  * Get the grid statusbar instance
  rem  *
  rem  * @return GxStatusBar
  rem  */
  method public GxStatusBar getStatusbar()
    methodret #getOptions().getStatusbar()
  methodend
  rem /**
  rem  * Get the grid default context menu
  rem  *
  rem  * @return GxContextMenu
  rem  */
  method public GxContextMenu getContextMenu()
    methodret #getOptions().getContextMenu()
  methodend
  rem /**
  rem  * Get the grid's client context
  rem  *
  rem  * @return JsonObject
  rem  */
  method public JsonObject getClientContext()
    methodret #getOptions().getClientContext()
  methodend
  rem /**
  rem  * Get instance of GxClientJsonFactory
  rem  *
  rem  * @return GxClientJsonFactory
  rem  */
  method public GxClientJsonFactory getClientJsonFactory()
    methodret #ClientJsonFactory!
  methodend
  rem /**
  rem  * Add Style block
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param selector$ : Css Selector
  rem  * @param rules! : Css Rules object as json object
  rem  */
  method public void addStyle(BBjString selector$ , JsonObject rules! )
    #getExecutor().execute("$gw_wnd.gw_setStyle('" + selector$ + "','" + rules!.toString() + "')")
  methodend
  rem /**
  rem  * Add Style block
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param selector$ : Css Selector
  rem  * @param rules! : Css Rules object as string
  rem  */
  method public void addStyle(BBjString selector$ , BBjString rules! )
    #getExecutor().execute("$gw_wnd.gw_setStyle('" + selector$ + "','" + rules! + "')")
  methodend
  rem /**
  rem  * Remove Style Block
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param selector$ : Css Selector
  rem  */
  method public Boolean removeStyle(BBjString selector$)
    #getExecutor().execute("$gw_wnd.gw_removeStyle('" + selector$ + "')")
    methodret BBjAPI.TRUE
  methodend
  rem /**
  rem  * Set the grid theme
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString theme$
  rem  *
  rem  * @see getThemes()
  rem  * @see GRID_THEME_BALHAM()
  rem  * @see GRID_THEME_BALHAM_DARK()
  rem  * @see GRID_THEME_MATERIAL()
  rem  */
  method public void setTheme(BBjString theme$)
    #getOptions().setTheme(theme$)

    if(#IsReady!) then
      if info(3,6)>"4" then
        s$="$gw_doc.getElementById('" + str(#getRootId()) + "').className='ag-theme-"+theme$+"';"
      else
        s$="document.getElementById('" + str(#getRootId()) + "').className='ag-theme-"+theme$+"';"
      FI

      #getExecutor().execute(s$)
    else
      template! = #getTemplate()
      #HTMLView!.setText(template!)
    FI
  methodend
  rem /**
  rem  * Get the grid supported themes
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @return BBjVector array of theme names
  rem  *
  rem  * @see GRID_THEME_BALHAM()
  rem  * @see GRID_THEME_BALHAM_DARK()
  rem  * @see GRID_THEME_MATERIAL()
  rem  */
  method public BBjVector getThemes()
    v! = new BBjVector()
    v!.addItem(#GRID_THEME_ALPINE())
    v!.addItem(#GRID_THEME_ALPINE_DARK())
    v!.addItem(#GRID_THEME_BALHAM())
    v!.addItem(#GRID_THEME_BALHAM_DARK())
    v!.addItem(#GRID_THEME_MATERIAL())
    methodret v!
  methodend
  rem /**
  rem  * Enable a chart toolbar item
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @see CHART_TOOLBAR_SETTINGS()
  rem  * @see CHART_TOOLBAR_DATA()
  rem  * @see CHART_TOOLBAR_FORMAT()
  rem  * @see CHART_TOOLBAR_DOWNLOAD()
  rem  */
  method public void addChartToolbarItem(BBjString item!)
    #ChartToolbarItems!.add(item!)

    if(#IsReady! and (#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1)) then
      #getClientContext().add("chartToolbarItems",#getChartToolbarItems())
      #updateContext()
    FI
  methodend
  rem /**
  rem  * Disable a chart toolbar item
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @see CHART_TOOLBAR_SETTINGS()
  rem  * @see CHART_TOOLBAR_DATA()
  rem  * @see CHART_TOOLBAR_FORMAT()
  rem  * @see CHART_TOOLBAR_DOWNLOAD()
  rem  */
  method public void removeChartToolbarItem(BBjString item!)
    el! = new JsonPrimitive(item!)

    if #ChartToolbarItems!.contains(el!) then
      #ChartToolbarItems!.remove(el!)
    FI

    if(#IsReady! and (#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1)) then
      #getClientContext().add("chartToolbarItems",#getChartToolbarItems())
      #updateContext()
    FI
  methodend
  rem /**
  rem  * Set the focus on the given row id and the given column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * @param BBjString row! The row id
  rem  * @param BBjString column! The column id
  rem  * @param BBjString floating! The row floating (top , bottom or none)
  rem  *
  rem  * @see BBjGridExWidget.GRID_FLOATING_NONE()
  rem  * @see BBjGridExWidget.GRID_FLOATING_TOP()
  rem  * @see BBjGridExWidget.GRID_FLOATING_BOTTOM()
  rem  */
  method public void focus(BBjString row! , BBjString column! , BBjString floating!)
    rem DO NOT focus the canvas or the we will have an infinite focus calls
    rem #super!.focus()
    REM     if info(3,6)<>"6" then
    if #getCanvas().getParentWindow().getFocusedControlID() <>  #getCanvas().getID() then
      #getHTMLView().clearCallback(BBjAPI.ON_GAINED_FOCUS)
      #HTMLView!.focus()
      #getHTMLView().setCallback(BBjAPI.ON_GAINED_FOCUS,#this!,"onGainedFocus")
    FI
    REM     endif
    rem /**
    rem  * We never debounce the focus calls , this causes a heck of problems
    rem  * when there are several grids rendered
    rem  */
    script$="$gw_wnd.gw_setFocusedCell('" + #getRootId() + "','" + str(row!) + "','" + str(column!) + "','" + str(floating!) +"');"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * Set the focus on the given row id and the given column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * @param BBjString row! The row id
  rem  * @param BBjString column! The column id
  rem  */
  method public void focus(BBjString row! , BBjString column!)
    #focus(row!, column!, #GRID_FLOATING_NONE())
  methodend
  rem /**
  rem  * Set the focus on the given row id and the first column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString row! The row id
  rem  */
  method public void focus(BBjString row!)
    #focus(row!, "")
  methodend
  rem /**
  rem  * Set the focus on the given row id and the given column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber row! The row id
  rem  * @param BBjString column! The column id
  rem  * @param BBjString floating! The row floating
  rem  *
  rem  * @see BBjGridExWidget.GRID_FLOATING_NONE()
  rem  * @see BBjGridExWidget.GRID_FLOATING_TOP()
  rem  * @see BBjGridExWidget.GRID_FLOATING_BOTTOM()
  rem  */
  method public void focus(BBjNumber row!, BBjString column!, BBjString floating!)
    #focus(str(row!), column!, floating!)
  methodend
  rem /**
  rem  * Set the focus on the given row id and the given column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber row! The row id
  rem  * @param BBjString column! The column id
  rem  */
  method public void focus(BBjNumber row!, BBjString column!)
    #focus(row!, column!, #GRID_FLOATING_NONE())
  methodend
  rem /**
  rem  * Set the focus on the given row id and the first column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber row! The row id
  rem  */
  method public void focus(BBjNumber row!)
    #focus(row!, "")
  methodend
  rem /**
  rem  * Will set the focus on the first cell of the first row.
  rem  * In case the grid has already a different selected cell , the the
  rem  * method will retain this information.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void focus()
    #focus(-1)
  methodend
  rem /**
  rem  * Navigates the grid focus to the next cell, as if tabbing.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void tabToNextCell()
    #getExecutor().execute("$gw_wnd.gw_tabToNextCell('" + #getRootId() + "')")
  methodend
  rem /**
  rem  * Navigates the grid focus to the previous cell, as if shift-tabbing.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void tabToPreviousCell()
    #getExecutor().execute("$gw_wnd.gw_tabToPreviousCell('" + #getRootId() + "')")
  methodend
  rem /**
  rem  * select all rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void selectAll()
    scriptKey! = "$gw_wnd.gw_selectAll"
    script$="$gw_wnd.gw_selectAll('" + #getRootId() + "',0);"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * select all rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBJNumber x!: 0 select all, 1 select all filtered
  rem  */
  method public void selectAll(BBjNumber x!)
    #deselectAll()
    scriptKey! = "$gw_wnd.gw_selectAll"
    script$="$gw_wnd.gw_selectAll('" + #getRootId() + "'," + str(x!) + ");"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * deselect all rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void deselectAll()
    scriptKey! = "$gw_wnd.gw_deselectAll"
    script$="$gw_wnd.gw_deselectAll('" + #getRootId() + "',0);"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * deselect all rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBJNumber x!: 0 deselect all, 1 deselect all filtered
  rem  */
  method public void deselectAll(BBjNumber x!)
    scriptKey! = "$gw_wnd.gw_deselectAll"
    script$="$gw_wnd.gw_deselectAll('"+ #getRootId() + "'," + str(x!) + ");"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * Select a row by its index
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber x!: the row index to select
  rem  */
  method public void setSelectedRow(BBjNumber index!)
    #setSelectedRow(str(index!))
  methodend
  rem /**
  rem  * Select a row by its key
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString x!: the row key to select
  rem  */
  method public void setSelectedRow(BBjString key!)
    script$="$gw_wnd.gw_setSelectedRows('" + #getRootId() + "',['" + str(key!) + "']);"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * Get the current selected row
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @return GxClientRowModel The selected row if any, null() otherwise
  rem  */
  method public GxClientRowModel getSelectedRow()
    returnedRow! = #getExecutor().execute("$gw_wnd.gw_getSelectedRow('" + #getRootId() + "')",0)
    if returnedRow!<>null() and len(returnedRow!) > 0 then
      methodret #getClientJsonFactory().getRow(returnedRow!)
    FI

    methodret null()
  methodend
  rem /**
  rem  * Select a vector of rows.
  rem  * The vector can contain a mix of row indices and row keys
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBJNumber x!: vector of row indices and row keys to select
  rem  */
  method public void setSelectedRows(BBjVector x!)
    script$="$gw_wnd.gw_setSelectedRows('" + #getRootId() + "',["
    it! = x!.iterator()
    first=1
    while it!.hasNext()
      if first
        first=0
      else
        script$=script$+","
      FI

      script$ = script$ + "'" + str(it!.next()) + "'"
    wend

    script$=script$+"]);"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * Get Array of selected rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @return BBjVector A vector filled with the selected rows
  rem  */
  method public BBjVector getSelectedRows()
    rows! = new BBjVector()

    if (#getRS() = null()) then
      goto getSelectedRowsErr
    FI

    returnedRows! = #getExecutor().execute("$gw_wnd.gw_getSelectedRows('" + #getRootId() + "')" , 0)
    if returnedRows! = null() then
      goto getSelectedRowsErr
    FI

    parser! = new JsonParser()
    array! = parser!.parse(returnedRows!).getAsJsonArray()
    it! = array!.iterator()
    while (it!.hasNext())
      next! = it!.next().getAsJsonObject(err=getSelectedRowsErr)
      rows!.add(#getClientJsonFactory().getRow(next!))
    wend

    getSelectedRowsErr:
      methodret rows!
  methodend
  rem /**
  rem  * Returns the row with the given key from the grid.
  rem  *
  rem  * <b>Note : </b> if you only need to get the row and
  rem  * you don't care about other meta data like parent(when grouping) , isSelected,... then use the
  rem  * ResultSet API (ex ResultSet.getItem(BBjString key!) )
  rem  *
  rem  * @param BBjString key! the row's key
  rem  *
  rem  * @return GxClientRowModel the grid's row model
  rem  *
  rem  * @see <a href"https://basishub.github.io/components/javadoc/com/basiscomponents/db/ResultSet.html#getItem-int-">ResultSet.getItem</a>
  rem  */
  method public GxClientRowModel getRow(BBjString key!)
    returnedRow! = #getExecutor().execute("$gw_wnd.gw_getRow('" + #getRootId() + "','" + key! + "')" , 0)
    if returnedRow! <> null() and len(returnedRow!) > 0 then
      methodret #getClientJsonFactory().getRow(returnedRow!)
    FI

    methodret null()
  methodend
  rem /**
  rem  * Get the rows from grid in the given phase after applying the given
  rem  * filter expression.
  rem  *
  rem  * <b>Note:</b> if you only need to get the whole rows from the grid and you don't care about
  rem  *              filtering and sorting Then retrieve them from ResultSet as this will be faster
  rem  *              especially in BUI
  rem  *
  rem  * @param BBjString phase! The rows phase
  rem  * @param BBjString filterExpression! A filter expression to execute before returning the rows.
  rem  *                                    The expression must return true or false for the given row
  rem  *
  rem  * @return BBjVector A vector of GxClientRowModel(s)
  rem  *
  rem  * @see #GRID_ROWS_PHASE_ALL()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER_SORT()
  rem  *
  rem  * @see <a href="https://bbj-plugins.github.io/BBjGridExWidget/javadoc/GxExpressions/GxExpression.html">see GxExpression</a>
  rem  */
  method public BBjVector getRows(BBjString phase! , BBjString filterExpression!)
    rows! = new BBjVector()
    returnedRows! = #getExecutor().execute("$gw_wnd.gw_getRows('" + #getRootId() + "','" + phase! + "'," + (new Gson()).toJson(filterExpression!) + ")" , 0)
    if returnedRows! <> null() AND returnedRows! <> "[]" then
      parser! = new JsonParser()
      array! = parser!.parse(returnedRows!).getAsJsonArray()
      it! = array!.iterator()
      while (it!.hasNext())
        next! = it!.next().getAsJsonObject()
        rows!.add(#getClientJsonFactory().getRow(next!))
      wend
    FI

    methodret rows!
  methodend
  rem /**
  rem  * Get the rows from grid in the given phase after applying the given
  rem  * filter expression.
  rem  *
  rem  * <b>Note:</b> if you only need to get the whole rows from the grid and you don't care about
  rem  *              filtering and sorting Then retrieve them from ResultSet as this will be faster
  rem  *              especially in BUI
  rem  *
  rem  * @param BBjString phase! The rows phase
  rem  * @param GxExpressionInterface filterExpression! A filter expression to execute before returning the rows.
  rem  *                                                The expression must return true or false for the given row
  rem  *
  rem  * @return BBjVector A vector of GxClientRowModel(s)
  rem  *
  rem  * @see #GRID_ROWS_PHASE_ALL()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER_SORT()
  rem  *
  rem  * @see <a href="https://bbj-plugins.github.io/BBjGridExWidget/javadoc/GxExpressions/GxExpression.html">see GxExpression</a>
  rem  */
  method public BBjVector getRows(BBjString phase! , GxExpressionInterface filterExpression!)
    methodret #getRows(phase!, filterExpression!.toString())
  methodend
  rem /**
  rem  * Get the rows from grid in the given phase after applying the given
  rem  * filter expression.
  rem  *
  rem  * <b>Note:</b> if you only need to get the whole rows from the grid and you don't care about
  rem  *              filtering and sorting Then retrieve them from ResultSet as this will be faster
  rem  *              especially in BUI
  rem  *
  rem  * @param BBjString phase! The rows phase
  rem  *
  rem  * @return BBjVector A vector of GxClientRowModel(s)
  rem  *
  rem  * @see #GRID_ROWS_PHASE_ALL()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER()
  rem  * @see #GRID_ROWS_PHASE_AFTER_FILTER_SORT()
  rem  */
  method public BBjVector getRows(BBjString phase!)
    methodret #getRows(phase!, "")
  methodend
  rem /**
  rem  * Get the rows from grid after sorting and filtering
  rem  *
  rem  * @return BBjVector A vector of GxClientRowModel(s)
  rem  */
  method public BBjVector getRows()
    methodret #getRows(#GRID_ROWS_PHASE_AFTER_FILTER_SORT())
  methodend
  rem /**
  rem  * Expand all groups
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void expandAll()
    script$="$gw_wnd.gw_expandAll('" + #getRootId() +"');"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * collapse all groups
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void collapseAll()
    script$="$gw_wnd.gw_collapseAll('" + #getRootId() +"');"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * Ensures the row key is visible by vertically scrolling the grid
  rem  *
  rem  * Ensures the row index is visible by vertically scrolling the grid.
  rem  * The valid values for positions are {'top', 'middle', 'bottom'}.
  rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key!: the row key
  rem  * @param BBjString position!: the scrolling position
  rem  *
  rem  * @see GRID_ROWPOS_TOP()
  rem  * @see GRID_ROWPOS_MIDDLE()
  rem  * @see GRID_ROWPOS_BOTTOM()
  rem  */
  method public void ensureIndexVisible(BBjString key! , BBjString position!)
    scriptKey! = "$gw_wnd.gw_ensureIndexVisible"
    script$="$gw_wnd.gw_ensureIndexVisible('" + #getRootId() + "','" + str(key!) + "','" + str(position!) +"');"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * Ensures the row index is visible by vertically scrolling the grid
  rem  *
  rem  * Ensures the row index is visible by vertically scrolling the grid.
  rem  * The valid values for positions are {'top', 'middle', 'bottom'}.
  rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index!: the row index
  rem  * @param BBjString position!: the scrolling position
  rem  *
  rem  * @see GRID_ROWPOS_TOP()
  rem  * @see GRID_ROWPOS_MIDDLE()
  rem  * @see GRID_ROWPOS_BOTTOM()
  rem  */
  method public void ensureIndexVisible(BBjNumber index! , BBjString position!)
    #ensureIndexVisible(str(index!),position!)
  methodend
  rem /**
  rem  * Ensures the row index is visible by vertically scrolling the grid
  rem  *
  rem  * Ensures the row index is visible by vertically scrolling the grid.
  rem  * The valid values for positions are {'top', 'middle', 'bottom'}.
  rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index!: the row index
  rem  * @param BBjString position!: the scrolling position
  rem  *
  rem  * @see GRID_ROWPOS_TOP()
  rem  * @see GRID_ROWPOS_MIDDLE()
  rem  * @see GRID_ROWPOS_BOTTOM()
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setVisibleRow(BBjNumber index! , BBjString position!) is deprecated / renamed. Use BBjGridExWidget.ensureIndexVisible(BBjNumber index! , BBjString position!) instead.
  rem  */
  method public void setVisibleRow(BBjNumber index! , BBjString position!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setVisibleRow(BBjNumber index! , BBjString position!) is deprecated / renamed. Use BBjGridExWidget.ensureIndexVisible(BBjNumber index! , BBjString position!) instead.")
    #ensureIndexVisible(index!,position!)
  methodend
  rem /**
  rem  * Ensures the column is visible, scrolling the table if needed.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBJString columnid!: the column id
  rem  */
  method public void ensureColumnVisible(BBjString columnId!)
    scriptKey! = "$gw_wnd.gw_ensureColumnVisible"
    script$="$gw_wnd.gw_ensureColumnVisible('" + #getRootId() +  "','" + columnId! + "');"
    #getExecutor().execute(scriptKey!,script$)
  methodend
  rem /**
  rem  * Sets the visibility of column(s)
  rem  *
  rem  * @param BBjString columns! A comma separated list of column ids to hide / show
  rem  * @param BBjNumber hidden! True to hide , false to show
  rem  */
  method public void setColumnVisible(BBjString columns! , BBjNumber hidden!)
    ids! = Arrays.asList(columns!.replaceAll(" ","").split(","))
    it! = ids!.iterator()
    while it!.hasNext()
      next! = it!.next()

      if(#hasColumn(next!))
        #getColumn(next!).setHidden(hidden!)
      fi
    wend

    script$="$gw_wnd.gw_setColumnVisible('" + #getRootId() +  "','" + columns! + "'," + str(hidden!.booleanValue()) +");"
    #getExecutor().execute(script$)
  methodend
  rem /**
  rem  * Sets the visibility of a column
  rem  *
  rem  * @param GxColumn column! The column definition
  rem  * @param BBjNumber hidden! True to hide , false to show
  rem  */
  method public void setColumnVisible(GxColumn column! , BBjNumber hidden!)
    #setColumnVisible(column!.getField(), hidden!)
  methodend
  rem /**
  rem  * Ensures the column is visible, scrolling the table if needed.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBJString columnid!: the column id
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.setVisibleColumn(BBjString columnId!) is deprecated / renamed. Use BBjGridExWidget.ensureColumnVisible(BBjString columnId!) instead.
  rem  */
  method public void setVisibleColumn(BBjString columnId!)
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.setVisibleColumn(BBjString columnId!) is deprecated / renamed. Use BBjGridExWidget.ensureColumnVisible(BBjString columnId!) instead.")
    #ensureColumnVisible(columnId!)
  methodend
  rem /**
  rem  * Make the currently visible columns fit the screen.
  rem  *
  rem  * The columns will scale (growing or shrinking) to fit the available width.
  rem  * If you don't want a particular column to be included in the auto resize,
  rem  * then set the column setting SuppressSizeToFit=true.
  rem  * This is helpful if, for example, you want the first column to remain fixed with, but all other columns
  rem  * to fill the width of the table.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void setFitToGrid()
    scriptKey! = "$gw_wnd.gw_sizeColumnsToFit"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_sizeColumnsToFit('" + #getRootId() +"')")
  methodend
  rem /**
  rem  * Gets the grid to size the columns to the specified with
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber width! the width to use to fit all columns in
  rem  */
  method public void setFitToGrid(BBjNumber width!)
    scriptKey! = "$gw_wnd.gw_sizeColumnsToFit"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_sizeColumnsToFit('" + #getRootId() +"','" + str(width!) + "')")
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param HashSet columns! A set of columns to auto size
  rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
  rem  *                               the width of the column.
  rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
  rem  *                               in the grid options.
  rem  */
  method public void autoSizeColumns(HashSet columns!, BBjNumber skipHeader!)
    columnsAsJson! = new Gson().toJson(columns!)
    #getExecutor().execute("$gw_wnd.gw_autoSizeColumns('" + #getRootId() +"'," + str(skipHeader!.booleanValue()) +  "," + str(columnsAsJson!) + ")")
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param HashSet columns! A set of columns to auto size
  rem  */
  method public void autoSizeColumns(HashSet columns!)
    #autoSizeColumns(columns! , 0)
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A common separated list of columns to auto size
  rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
  rem  *                               the width of the column.
  rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
  rem  *                               in the grid options.
  rem  */
  method public void autoSizeColumns(BBjString columns!, BBjNumber skipHeader!)
    columnsSet! = new HashSet()
    columnsSet!.addAll(Arrays.asList(columns!.replaceAll(" ","").split(",")))
    #autoSizeColumns(columnsSet!,skipHeader!)
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! A comma separated list of columns to auto size
  rem  */
  method public void autoSizeColumns(BBjString columns!)
    #autoSizeColumns(columns! , 0)
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
  rem  *                               the width of the column.
  rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
  rem  *                               in the grid options.
  rem  */
  method public void autoSizeColumns(BBjNumber skipHeader!)
    #autoSizeColumns(new HashSet(),skipHeader!)
  methodend
  rem /**
  rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
  rem  * It cannot see the columns that are not rendered due to column virtualisation.
  rem  * Thus it is not possible to autosize a column that is not visible on the screen.
  rem  *
  rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
  rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
  rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
  rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void autoSizeColumns()
    #autoSizeColumns(0)
  methodend
  rem /**
  rem  *Gets the grid to remove a row from the DOM and recreate it again from scratch.
  rem  */
  method public void redrawRows()
    #getExecutor().execute("$gw_wnd.gw_redrawRows('" + #getRootId() +"')")
  methodend
  rem /**
  rem  * Force the context object update
  rem  */
  method public void updateContext()
    if(#IsReady!)
      #getExecutor().execute("$gw_wnd.gw_updateContext('" + #getRootId() +"'," + #getClientContext().toString() + ")")
    FI
  methodend
  rem /**
  rem  * Set and apply filter model for the given column
  rem  *
  rem  * @param BBjString column! the column id
  rem  * @param GxClientFilterModel model! the model filter to use
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  *
  rem  * @return GxClientFilterModel the passed model
  rem  */
  method public GxClientFilterModel setFilterModel(BBjString column!, GxClientFilterModel model!)
    model!.setWidget(#this!)
    model!.setColumn(column!)
    model!.update()
    methodret model!
  methodend
  rem /**
  rem  * Set and apply a filter transaction
  rem  *
  rem  * The transaction is a `LinkedHashMap` of columns and their models.
  rem  * This the fastest way to apply several filters on several columns.
  rem  * When using this method The grid will delay executing the filters on the data
  rem  * until all models are set and ready.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  *
  rem  * @param  LinkedHashMap transaction! a map of columns and their model
  rem  */
  method public void executeFilterTransaction(LinkedHashMap transaction!)
    applyCode! = new HashSet()
    executeCode! = new HashSet()
    it! = transaction!.entrySet().iterator()
    while(it!.hasNext())
      next! = it!.next()
      column! = next!.getKey()
      model! = next!.getValue()
      model!.setWidget(#this!)
      model!.setColumn(column!)
      applyCode!.add(model!.apply(0))
      executeCode!.add(model!.execute(0))
    wend

    #getExecutor().execute(String.join("",applyCode!) + String.join("",executeCode!))
  methodend
  rem /**
  rem  * Get The filter model for the given column
  rem  *
  rem  * This method will return a `GxClientFilterModel` for the given column
  rem  * If column has already some filter values set through the UI , then the model will contain
  rem  * these changes too.
  rem  *
  rem  * In case the grid is not ready (not renderer yet) then the method will just return
  rem  * any empty filter model for the column.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  *
  rem  * @param BBjString column! the column id to use for the constructed model
  rem  *
  rem  * @throws 256 in case the column has no filter component attached
  rem  */
  method public GxClientFilterModel getFilterModel(BBjString column!)
    jsonModel! = null()
    rem we try to get the model from the UI first
    if(#getIsReady() = BBjAPI.TRUE)
      code! = String.format("JSON.stringify($gw_wnd.gw_getGrid('%s').options.api.getFilterInstance('%s').getModel());" , #getRootId(), column!)
      jsonModel! = #getExecutor().execute(code! , 0)
    FI

    if(jsonModel! <> null() AND jsonModel! <> "null")
      methodret #getClientJsonFactory().getFilter(jsonModel!,column!)
    else
      model! = null()
      rem we try to detect the filter type and create its model
      if (#getColumn(column!).getFilter() <> null())
        filterName! = #getColumn(column!).getFilter().getFilterName()
        SWITCH (filterName!)
          CASE GxFilterNumber.getFilterName()
            model! = new GxClientFilterNumberModel()
            break
          CASE GxFilterBasicTimestamp.getFilterName()
            model! = new GxClientFilterDateTimeModel()
            break
          CASE GxFilterBasicBoolean.getFilterName()
            model! = new GxClientFilterBooleanModel()
            break
          CASE GxFilterText.getFilterName()
            model! = new GxClientFilterTextModel()
            break
          CASE GxFilterSetFilter.getFilterName()
            model! = new GxClientFilterSetFilterModel()
            break
        SWEND
      FI

      if(model! = null())
        throw "Failed to create column filter's model. The column has no filter component attached" , 256
      FI

      model!.setWidget(#this!)
      model!.setColumn(column!)
      methodret model!
    FI
  methodend
  rem /**
  rem  * Get The combined filter model for the given column
  rem  *
  rem  * This method will return a `GxClientFilterCombinedModel` for the given column
  rem  * If the column has already some filter values set through the UI , then the model will contain
  rem  * these changes too.
  rem  *
  rem  * In case the grid is not ready (not renderer yet) then the method will just return
  rem  * any empty combined filter model for the column.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  *
  rem  * @param BBjString column! the column id to use for the constructed model
  rem  *
  rem  * @throws 256 in case the column filter does not support the combined model
  rem  */
  method public GxClientFilterCombinedModel getFilterAsCombinedModel(BBjString column!)
    model! = #getFilterModel(column!)
    rem first check if the model is already a combined model
    isAlreadyCombined! = 0
    model! = cast(GxClientFilterCombinedModel,model!,err=*next); isAlreadyCombined! = 1

    if(isAlreadyCombined! = 0 AND model!.supportsCombinedModel() = 0)
      throw "The column's filter component does not support combined models" , 256
    FI

    combinedModel! = iff(isAlreadyCombined!,model! ,new GxClientFilterCombinedModel() )
    combinedModel!.setWidget(#this!)
    combinedModel!.setColumn(column!)

    if(!isAlreadyCombined!)
      combinedModel!.setFirstCondition(model!)
    FI

    methodret combinedModel!
  methodend
  rem /**
  rem  * Clear all active filters on columns
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void clearFilters()
    code! = String.format(";var api = $gw_wnd.gw_getGrid('%s').options.api;" , #getRootId())
    code! = code! + "api.setFilterModel(null);api.onFilterChanged(null);"
    wrap! = ";(function(){" + code! + "})();"
    #getExecutor().execute(wrap! , 0)
  methodend
  rem /**
  rem  * setSize - set the size of the control
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber w! - width
  rem  * @param BBjNumber h! - height
  rem  */
  method public void setSize(BBjNumber w!, BBjNumber h!)
    rem if setSize is called before the page is ready, delay its execution
    if #IsReady! then
      #super!.setSize(w!,h!)
    else
      rem cheat with the superclass so getWidth / getHeight already return the later size
      #super!.setW(w!)
      #super!.setH(h!)
      #newW! = w!
      #newH! = h!
    FI
  methodend
  rem /**
  rem  * Set all rows height
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber height! - the new row height
  rem  */
  method public void setRowHeight(BBjNumber height!)
    #getOptions().setRowHeight(height!)
    scriptKey! = "$gw_wnd.gw_setRowsHeight"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setRowsHeight('" + #getRootId() + "'," + str(height!) + ")")
  methodend
  rem /**
  rem  * Set the given row height
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! - the row key
  rem  * @param BBjNumber height! - the new row height
  rem  */
  method public void setRowHeight(BBjString key!, BBjNumber height!)
    scriptKey! = "$gw_wnd.gw_setRowsHeight" + key!
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setRowHeight('" + #getRootId() + "','" + str(key!) + "'," + str(height!) + ")")
  methodend
  rem /**
  rem  * Set the given row height
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! - the row index
  rem  * @param BBjNumber height! - the new row height
  rem  */
  method public void setRowHeight(BBjNumber index!, BBjNumber height!)
    #setRowHeight(str(index!) , height!)
  methodend
  rem /**
  rem  * Reset The row heights.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * The rows height is calculated once when the data is first given to the grid.
  rem  * If the data changes, or the width of a column changes, then you may require the grid to calculate
  rem  * the height again by calling this method
  rem  */
  method public void resetRowHeights()
    #getExecutor().execute("$gw_wnd.gw_resetRowHeights('" + #getRootId() + "')",0)
  methodend
  rem /**
  rem  * Set a sorting for one or more columns
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxClientSortModel model! the sorting model
  rem  */
  method public void setSortModel(GxClientSortModel model!)
    #getExecutor().execute("$gw_wnd.gw_setSortModel('" + #getRootId() + "','" + str(model!.getAsJsonArray()) + "')")
  methodend
  rem /**
  rem  * Sort the given column with the given direction
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString column! The column id
  rem  * @param BBjString direction! The sort direction
  rem  *
  rem  * @see setSortModel
  rem  */
  method public void sortColumn(BBjString column! , BBjString direction!)
    model! = new GxClientSortModel()
    model!.add(column! , direction!)
    #setSortModel(model!)
  methodend
  rem /**
  rem  * Enable / disable pivot mode
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber mode! when true, the pivot mode will be enabled, disabled otherwise
  rem  */
  method public void setPivotMode(BBjNumber mode!)
    #getOptions().setPivotMode(mode!)

    if(#IsReady!) then
      scriptKey! = "$gw_wnd.gw_setPivotMode"
      #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setPivotMode('" + #getRootId() + "'," + str(mode!) + ")")
    FI
  methodend
  rem /**
  rem  * Check if pivot mode is enabled or disabled
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @return BBjNumber 1 when pivot mode is enabled, 0 otherwise
  rem  */
  method public BBjNumber getPivotMode()
    if(#IsReady!) then
      mode! = #getExecutor().execute("$gw_wnd.gw_getPivotMode('" + #getRootId() + "'," + str(mode!) + ")" , 0)
      #getOptions().setPivotMode(num(mode!))
    FI

    methodret #getOptions().getPivotMode()
  methodend
  rem /**
  rem  * Perform throw columns search
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber filter filter as number
  rem  */
  method public void setQuickFilter(BBjString filter!)
    scriptKey! = "$gw_wnd.gw_setQuickFilter"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setQuickFilter('" + #getRootId() + "','" + filter! +"')")
  methodend
  rem /**
  rem  * Perform throw columns search
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber filter! filter as a number
  rem  */
  method public void setQuickFilter(BBjNumber filter!)
    #setQuickFilter(str(filter!))
  methodend
  rem /**
  rem  * Start Next Cell Editing
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void moveToNextCell()
    #getExecutor().execute("$gw_wnd.gw_editNextCell('"+ #getRootId() + "')")
  methodend
  rem /**
  rem  * Move to previous cell
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void moveToPreviousCell()
    #getExecutor().execute("$gw_wnd.gw_editPreviousCell('" + #getRootId() + "')")
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! The row key
  rem  * @param BBjString column! The column ID
  rem  * @param BBjNumber keyPress! The key code to pass to the editor when the editor supports it
  rem  * @param BBjString charPress! The key char to pass to the editor when the editor supports it
  rem  * @param BBjString floating! The row floating (top , bottom or none)
  rem  *
  rem  * @see BBjGridExWidget.GRID_FLOATING_NONE()
  rem  * @see BBjGridExWidget.GRID_FLOATING_TOP()
  rem  * @see BBjGridExWidget.GRID_FLOATING_BOTTOM()
  rem  */
  method public void setStartCellEditing(BBjString key!, BBjString column!, BBjNumber keyPress!, BBjString charPress!, BBjString floating!)
    params! = String.format("'%s','%s','%s',%s,'%s','%s'",#getRootId(), key!, column!, str(keyPress!), charPress!, floating!)
    #getExecutor().execute("$gw_wnd.gw_startEditingCell(" + params! + ")")
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The row index
  rem  * @param BBjString column! The column ID
  rem  * @param BBjNumber keyPress! The key code to pass to the editor when the editor supports it
  rem  * @param BBjString charPress! The key char to pass to the editor when the editor supports it
  rem  * @param BBjString floating! The row floating (top , bottom or none)
  rem  *
  rem  * @see BBjGridExWidget.GRID_FLOATING_NONE()
  rem  * @see BBjGridExWidget.GRID_FLOATING_TOP()
  rem  * @see BBjGridExWidget.GRID_FLOATING_BOTTOM()
  rem  */
  method public void setStartCellEditing(BBjNumber index!, BBjString column!, BBjNumber keyPress!, BBjString charPress!, BBjString floating!)
    #setStartCellEditing(str(index!), column!, keyPress!, charPress!, floating!)
  methodend
  rem ===========================
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! The row key
  rem  * @param BBjString column! The column ID
  rem  */
  method public void setStartCellEditing(BBjString key!, BBjString column!)
    #setStartCellEditing(key!, column!, -100, "", #GRID_FLOATING_NONE())
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The row index
  rem  * @param BBjString column! The column ID
  rem  */
  method public void setStartCellEditing(BBjNumber index!, BBjString column!)
    #setStartCellEditing(str(index!), column!)
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! The row key
  rem  * @param BBjString column! The column ID
  rem  * @param BBjString charPress! The key char to pass to the editor when the editor supports it
  rem  */
  method public void setStartCellEditing(BBjString key!, BBjString column!, BBjString charPress!)
    #setStartCellEditing(key!, column!, -100, charPress!, #GRID_FLOATING_NONE())
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The row index
  rem  * @param BBjString column! The column ID
  rem  * @param BBjString charPress! The key char to pass to the editor when the editor supports it
  rem  */
  method public void setStartCellEditing(BBjNumber index!, BBjString column!, BBjString charPress!)
    #setStartCellEditing(str(index!), column!, charPress!)
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString key! The row key
  rem  * @param BBjString column! The column ID
  rem  * @param BBjNumber keyPress! The key code to pass to the editor when the editor supports it
  rem  */
  method public void setStartCellEditing(BBjString key!, BBjString column!, BBjNumber keyPress!)
    #setStartCellEditing(key!, column!, keyPress!, "", #GRID_FLOATING_NONE())
  methodend
  rem /**
  rem  * Start Cell Editing at the given row and column
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber index! The row index
  rem  * @param BBjString column! The column ID
  rem  * @param BBjNumber keyPress! The key code to pass to the editor when the editor supports it
  rem  */
  method public void setStartCellEditing(BBjNumber index!, BBjString column!, BBjNumber keyPress!)
    #setStartCellEditing(str(index!), column!, keyPress!)
  methodend
  rem /**
  rem  * Navigates the grid focus to the next cell, as if tabbing.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.startNextCellEditing() is deprecated / renamed. Use BBjGridExWidget.tabToNextCell() instead.
  rem  */
  method public void startNextCellEditing()
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.startNextCellEditing() is deprecated / renamed. Use BBjGridExWidget.tabToNextCell() instead.")
    #tabToNextCell()
  methodend
  rem /**
  rem  * Navigates the grid focus to the previous cell, as if shift-tabbing.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @deprecated since version 0.101.0, BBjGridExWidget.startPreviousCellEditing() is deprecated / renamed. Use BBjGridExWidget.tabToPreviousCell() instead.
  rem  */
  method public void startPreviousCellEditing()
    GxLogger.warn("since version 0.101.0, BBjGridExWidget.startPreviousCellEditing() is deprecated / renamed. Use BBjGridExWidget.tabToPreviousCell() instead.")
    #tabToPreviousCell()
  methodend
  rem /**
  rem  * Stop editing and accepts changes
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void stopEditing()
    #getExecutor().execute("$gw_wnd.gw_stopEditing('" + #getRootId() + "',0)")
  methodend
  rem /**
  rem  * Stop Editing
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber cancel!: 1 = discard changes, 0 = accept changes
  rem  */
  method public void stopEditing(BBjNumber cancel!)
    #getExecutor().execute("$gw_wnd.gw_stopEditing('"+ #getRootId() + "'," + STR(cancel!)+ ")")
  methodend
  rem /**
  rem  * If true, then row group, pivot and value aggregation will be read only from the Ui.
  rem  * The grid will display what values are used for each, but will not allow the use to change the selection
  rem  *
  rem  * <br><b><small>#Enterprise</small></b>
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjNumber readonly! when true disable, enable otherwise
  rem  */
  method public void setFunctionsReadOnly(BBjNumber readonly!)
    #getOptions().setFunctionsReadOnly(readonly!)
    scriptKey! = "$gw_wnd.gw_setFunctionsReadOnly"
    #getExecutor().execute(scriptKey!,"$gw_wnd.gw_setFunctionsReadOnly('" + #getRootId() + "'," + str(readonly!) +")")
  methodend
  rem /**
  rem  * Sync the client row data every time a new GxClientRowModel
  rem  * is composed by the grid.
  rem  *
  rem  * Use this method if the row's data in the client is different that the row's data in
  rem  * the ResultSet
  rem  *
  rem  * @param BBjNumber include! when true the ClientRow field will always be filled in GxClientRowModel
  rem  *                           otherwise it will always be null().
  rem  *
  rem  * <br><b><small>#Configuration</small></b>
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void includeClientRowDataInRowModels(BBjNumber include!)
    #getClientContext().addProperty("includeClientRowData",include!.booleanValue())
    #updateContext()
  methodend
  rem /**
  rem  * The method will return a vector of the selected ranges including columns and rows
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @return BBjVector
  rem  */
  method public BBjVector getRangeSelections()
    rem an array to save the parsed range selections
    rangeSelectionVector! = new BBjVector()
    rem get the range selections from the client
    rem the client will return an array of objects where each object is a range
    rangeSelections! = #getExecutor().execute("$gw_wnd.gw_getRangeSelections('" + #getRootId() + "')",0)

    if (rangeSelections! = "[]") then
      goto getSelectionRangeErr
    FI
    rem iterate throw the ranges array and parse the range objects
    parser! = new JsonParser()
    ranges! = parser!.parse(rangeSelections!).getAsJsonArray()
    rangesIterator! = ranges!.iterator()
    while (rangesIterator!.hasNext())
      model! = #getClientJsonFactory().getRangeSelection(rangesIterator!.next().getAsJsonObject())
      rangeSelectionVector!.addItem(model!)
    wend

    getSelectionRangeErr:
      methodret rangeSelectionVector!
  methodend
  rem /**
  rem  * Add new range selection
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxClientAddRangeSelectionModel model! the add selection model
  rem  *
  rem  * @return GxClientAddRangeSelectionModel
  rem  */
  method public GxClientAddRangeSelectionModel addRangeSelection(GxClientAddRangeSelectionModel model!)
    #getExecutor().execute("$gw_wnd.gw_addCellRange('" + #getRootId() + "'," + model!.getAsJsonObject().toString() + ")")
    methodret model!
  methodend
  rem /**
  rem  * Add new range selection
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
  rem  * @param BBjString start! start row id or index
  rem  * @param BBjString end! end row id or index
  rem  *
  rem  * @return GxClientAddRangeSelectionModel
  rem  */
  method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns! , BBjString start! , BBjString end!)
    model! = new GxClientAddRangeSelectionModel()
    model!.setColumns(columns!)
    model!.setStart(start!)
    model!.setEnd(end!)
    methodret #addRangeSelection(model!)
  methodend
  rem /**
  rem  * Add new range selection
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
  rem  * @param BBjNumber start! start row id or index
  rem  * @param BBjNumber end! end row id or index
  rem  *
  rem  * @return GxClientAddRangeSelectionModel
  rem  */
  method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns! , BBjNumber start! , BBjNumber end!)
    methodret #addRangeSelection(columns! , str(start!),str(end!))
  methodend
  rem /**
  rem  * Add new range selection
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
  rem  *
  rem  * @return GxClientAddRangeSelectionModel
  rem  */
  method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns!)
    methodret #addRangeSelection(columns!,null() , null())
  methodend
  rem /**
  rem  * Clears the selected range.
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void clearRangeSelection()
    #getExecutor().execute("$gw_wnd.gw_clearRangeSelection('" + #getRootId() + "')",0)
  methodend
  rem /**
  rem  * Clear already created charts.
  rem  * <b>Note</b> that this method does not clear user created charts
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  *
  rem  * @param GxClientAddRangeChartModel model! the add range model
  rem  * @return BBjString A unique id for the created chart
  rem  */
  method public BBjString addRangeChart(GxClientAddRangeChartModel model!)
    uuid! = #getExecutor().execute("$gw_wnd.gw_addChartRange('" + #getRootId() + "'," + model!.getAsJsonObject().toString() + ")" , 0)
    methodret str(uuid!)
  methodend
  rem /**
  rem  * Clear already created chart by its id
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  * Note that this method does not clear user created charts
  rem  *
  rem  * @param BBjString id! the chart's id to destroy
  rem  */
  method public void clearChart(BBjString id!)
    rem /**
    rem  * Even Though the `gw_destroyChart` function does not return any value
    rem  * we don't debounce the call because the developer might call
    rem  * `addRangeChart` before calling this method. and `addRangeChart` is not debounced call
    rem  * which will lead the chart to be created and then destroy directly
    rem  */
    #getExecutor().execute("$gw_wnd.gw_destroyChart('" + #getRootId() + "','" + str(id!) + "')",0)
  methodend
  rem /**
  rem  * Clear already created charts.
  rem  * <b>Note</b> that this method does not clear user created charts
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void clearChart()
    rem /**
    rem  * Even Though the `gw_destroyChart` function does not return any value
    rem  * we don't debounce the call because the developer might call
    rem  * `addRangeChart` before calling this method. and `addRangeChart` is not debounced call
    rem  * which will lead the chart to be created and then destroy directly
    rem  */
    #getExecutor().execute("$gw_wnd.gw_destroyChart('" + #getRootId() + "')",0)
  methodend
  rem /**
  rem  * Show loading overlay
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void showLoadingOverlay()
    #getExecutor().execute("$gw_wnd.gw_showLoadingOverlay('" + #getRootId() + "')", 0)
  methodend
  rem /**
  rem  * Show 'no rows' overlay
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void showNoRowsOverlay()
    #getExecutor().execute("$gw_wnd.gw_showNoRowsOverlay('" + #getRootId() + "')", 0)
  methodend
  rem /**
  rem  * Clear all overlays
  rem  *
  rem  * <br><b><small>#API</small></b>
  rem  */
  method public void hideOverlay()
    #getExecutor().execute("$gw_wnd.gw_hideOverlay('" + #getRootId() + "')", 0)
  methodend
  rem /**
  rem  * Destroy the grid
  rem  */
  method public void destroy()
    #super!.destroy()
    #IsReady! = BBjAPI.FALSE
  methodend
  rem /**
  rem  * Align the current grid with the passed one
  rem  *
  rem  * Aligning two or more grids means columns will be kept aligned in all grids.
  rem  * In other words, column changes to one grid (column width, column order, column visibility etc)
  rem  * are reflected in the other grid. This is useful if you have two grids, one above the other such
  rem  * that their columns are vertically aligned, and you want to keep the columns aligned.
  rem  *
  rem  * @param BBjGridExWidget widget!
  rem  */
  method public void addAlignedGrid(BBjGridExWidget widget!)
    #getExecutor().execute("$gw_wnd.gw_addAlignedGrid('" + #getRootId() + "','" + widget!.getRootId() + "')", 0)
  methodend
  rem /**
  rem  * Disable the current grid alignment with the passed one
  rem  *
  rem  * @param BBjGridExWidget widget!
  rem  */
  method public void removeAlignedGrid(BBjGridExWidget widget!)
    #getExecutor().execute("$gw_wnd.gw_removeAlignedGrid('" + #getRootId() + "','" + widget!.getRootId() + "')", 0)
  methodend
  rem /**
  rem  * Fires an event
  rem  *
  rem  * @param Int type! The event's type
  rem  * @param Object payload! The event's payload
  rem  *
  rem  * @Override
  rem  */
  method protected void fireEvent(int type!, Object payload!)
    el! = new JsonPrimitive(type!)

    if(#getInterests().contains(el!)) then
      #super!.fireEvent(type!,payload!)
    FI
  methodend
  rem /**
  rem  * Send the current interests to the client
  rem  */
  method protected void updateClientWithInterests()
    #getClientContext().add("interests",#getInterests())
    #updateContext()
  methodend
  rem /**
  rem  * The method will add the default chart toolbar items
  rem  */
  method protected void fillChartToolbarItems()
    #getChartToolbarItems().add(#CHART_TOOLBAR_SETTINGS())
    #getChartToolbarItems().add(#CHART_TOOLBAR_DATA())
    #getChartToolbarItems().add(#CHART_TOOLBAR_FORMAT())
    #getChartToolbarItems().add(#CHART_TOOLBAR_DOWNLOAD())
  methodend
  rem /**
  rem  * Get the grid template
  rem  *
  rem  * @return BBjString parsed html template
  rem  */
  method protected BBjString getTemplate()
    html$ = #Template$

    if(len(html$) = 0) then
      ch=unt
      open (ch)"BBjGridExWidget/client/index.html"
      read record (ch,siz=5512000)html$
      close (ch)
    FI

    html! = html$
    html! = html!.replaceAll("__id__" , #getRootId())
    html! = html!.replaceAll("__lang__", #getLanguageManager().getLanguage())
    html! = html!.replaceAll("__THEME__", "ag-theme-" + #getOptions().getTheme())
    style$ = ""

    if(info(3,6) = "6")
      ch=unt
      open (ch) BBjAPI().getFileSystem().resolvePath("BBjGridExWidget/client/dist/dwc.css")
      read record (ch,siz=5512000)style$
      close (ch)
    fi

    html! = html!.replaceAll("__DWC__", style$)
    methodret html!
  methodend

  method protected void handleStateChangedEvent(BBjString detail$, BBjNumber type!)
    event! = #getState()
    #fireEvent(type!, event!)
  methodend
  rem /**
  rem  * Handle Range Selections Event
  rem  *
  rem  * @see GxClientEventsRangeSelection
  rem  */
  method private void onRangeSelectionChange(BBjString detail$)
    event! = new GxClientEventsRangeSelection()
    #fireEvent(#ON_GRID_RANGE_SELECTION_CHANGED(),event!)
  methodend
  rem /**
  rem  * On rows selections event
  rem  *
  rem  * Parse the json details coming from the client and fires new GxSelectRowEvent
  rem  *
  rem  * @param BBjString detail$ The event detail as Json
  rem  * @param BBjNumber type! The event type
  rem  *
  rem  * @see GxSelectRowEvent
  rem  */
  method protected void onSelectRowChange(BBjString detail$, BBjNumber type!)
    declare GxClientEventsRowSelection event!
    declare JsonParser parser!

    event! = new GxClientEventsRowSelection()
    event!.setSelectedRows(#getSelectedRows())
    rem report keypress for click events only
    if(type! = #ON_GRID_ROW_CLICK() OR type! = #ON_GRID_DOUBLE_CLICK())
      parser! = new JsonParser()
      detailsAsJson!  = parser!.parse(detail$).getAsJsonObject()
      keypress! =  null()

      if(detailsAsJson!.has("k") AND detailsAsJson!.get("k").isJsonNull() = BBjAPI.FALSE) then
        keypress! = #getClientJsonFactory().getKeypress(detailsAsJson!.get("k").getAsJsonObject())
      fi

      event!.setKey(keypress!)
    fi

    #fireEvent(type!,event!)
  methodend
  rem /**
  rem  * On context menu event
  rem  *
  rem  * @param BBjString detail$ The event response
  rem  */
  method protected void onContextmenuEvent(BBjString detail$)
    declare JsonParser parser!

    parser! = new JsonParser()
    parsedCell!  = parser!.parse(detail$).getAsJsonObject()
    cell! = #getClientJsonFactory().getCell(parsedCell!)
    event! = new GxClientEventsContextMenu()
    event!.setCell(cell!)
    #fireEvent(parsedCell!.get("i").getAsInt(),event!)
  methodend
  rem /**
  rem  * On cell Event. handles cell clicking and editing events
  rem  *
  rem  * @param BBjString detail$ The event detail as Json
  rem  * @param BBjNumber type! The event type
  rem  *
  rem  * @see ON_GRID_CELL_VALUE_CHANGED()
  rem  * @see ON_GRID_CELL_DOUBLE_CLICK()
  rem  * @see ON_GRID_CELL_CLICK()
  rem  */
  method protected void onCellEvent(BBjString detail$ , BBjNumber type!)
    declare JsonParser parser!

    parser! = new JsonParser()
    parsedCell!  = parser!.parse(detail$).getAsJsonObject()
    cell! = #getClientJsonFactory().getCell(parsedCell!)
    event! = new GxClientEventsCell()
    event!.setCell(cell!)
    event!.setOldValue(parsedCell!.get("o").getAsString(), err=*next)

    if(type! = #ON_GRID_CELL_CLICK() OR type! = #ON_GRID_CELL_DOUBLE_CLICK())
      if(parsedCell!.has("k") AND parsedCell!.get("k").isJsonNull() = BBjAPI.FALSE) then
        keypress! = #getClientJsonFactory().getKeypress(parsedCell!.get("k").getAsJsonObject())
        event!.setKey(keypress!)
      fi
    fi

    #fireEvent(type!, event!)
  methodend
  rem /**
  rem  * Fire an row editing event when row editing starts or stops
  rem  *
  rem  * @param BBjString detail$ The event detail as json
  rem  * @param BBjNumber type! The event type
  rem  *
  rem  * @see ON_GRID_ROW_EDITING_STARTED()
  rem  * @see ON_GRID_ROW_EDITING_STOPPED()
  rem  */
  method protected void onRowEditing(BBjString detail$ , BBjNumber type!)
    event! = new GxClientEventsRowEditing()
    event!.setRow(#getClientJsonFactory().getRow(detail$))
    #fireEvent(type!, event!)
  methodend
  rem /**
  rem  * Fire an keypress event when keypress is passed from the client
  rem  *
  rem  * @param BBjString detail$ The event detail as json
  rem  *
  rem  * @see ON_GRID_KEYPRESS()
  rem  */
  method protected void onKeypressEvent(BBjString detail$)
    declare JsonParser parser!

    parser! = new JsonParser()
    parsedKeypress!  = parser!.parse(detail$).getAsJsonObject()
    keypress! = #getClientJsonFactory().getKeypress(parsedKeypress!)
    event! = new GxClientEventsKeypress()
    event!.setKey(keypress!)
    #fireEvent(#ON_GRID_KEYPRESS(), event!)
  methodend
  rem /**
  rem  * Call the cell editor resolver on the passed column
  rem  *
  rem  * @param BBjString detail$ The event detail as json
  rem  */
  method protected void onSuggestionEvent(BBjString detail$)
    declare JsonParser parser!

    parser! = new JsonParser()
    parsedDetail!  = parser!.parse(detail$).getAsJsonObject()
    columnName! = parsedDetail!.get("column").getAsString()

    if(#hasColumn(columnName!)) then
      cellEditor! = #getColumn(columnName!).getCellEditor()
      resolver! = cellEditor!.getResolver()
      id! = parsedDetail!.get("id").getAsString()
      text! = parsedDetail!.get("text").getAsString()
      row!  = parsedDetail!.get("row").getAsJsonObject()
      columnModel! = #getClientJsonFactory().getColumn(columnName!)
      rowModel! = #getClientJsonFactory().getRow(row!)
      data! = resolver!.resolve(text!, columnModel!, rowModel!)
      script! = String.format("$gw_doc.dispatchEvent(new CustomEvent('%s', { detail: %s }))", id!, data!.toString())
      #getExecutor().execute(script!)
    fi
  methodend
  rem /**
  rem  * Fire a filter changed event
  rem  *
  rem  * @see ON_GRID_FILTER_CHANGED()
  rem  */
  method protected void onFilterChangedEvent()
    #fireEvent(#ON_GRID_FILTER_CHANGED(),null())
  methodend
  rem /**
  rem  * Fire a ready event
  rem  *
  rem  * @see ON_GRID_READY()
  rem  */
  method protected void onGridReadyEvent()
    #fireEvent(#ON_GRID_READY(),#this!)
  methodend

classend
