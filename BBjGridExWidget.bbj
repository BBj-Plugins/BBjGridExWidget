use com.basiscomponents.db.ResultSet
use com.basiscomponents.db.DataRow
use java.sql.Types
use com.google.gson.Gson
use com.google.gson.JsonParser
use com.google.gson.JsonObject
use com.google.gson.JsonPrimitive
use com.google.gson.JsonArray
use java.lang.Integer
use java.util.ArrayList
use java.util.HashMap
use ::BBjWidget/BBjWidget.bbj::BBjWidget
use ::BBjGridExWidget/AbstractBBjGridExWidgetStatusBarComponent.bbj::AbstractBBjGridExWidgetStatusBarComponent
use ::BBjGridExWidget/BBjGridContextMenu.bbj::BBjGridContextMenu
use ::BBjGridExWidget/BBjGridContextMenuItem.bbj::BBjGridContextMenuItem
use ::BBjGridExWidget/BBjGridDefaultContextMenu.bbj::BBjGridDefaultContextMenu
use ::BBjGridExWidget/BBjGridExWidgetColumnsToolpanel.bbj::BBjGridExWidgetColumnsToolpanel
use ::BBjGridExWidget/BBjGridExWidgetDefaultSidebar.bbj::BBjGridExWidgetDefaultSidebar
use ::BBjGridExWidget/BBjGridExWidgetFiltersToolpanel.bbj::BBjGridExWidgetFiltersToolpanel
use ::BBjGridExWidget/BBjGridExWidgetRow.bbj::BBjGridExWidgetRow
use ::BBjGridExWidget/BBjGridExWidgetSelectRowEvent.bbj::BBjGridExWidgetSelectRowEvent
use ::BBjGridExWidget/BBjGridExWidgetSidebar.bbj::BBjGridExWidgetSidebar
use ::BBjGridExWidget/BBjGridExWidgetState.bbj::BBjGridExWidgetState
use ::BBjGridExWidget/BBjGridExWidgetStatusBar.bbj::BBjGridExWidgetStatusBar
use ::BBjGridExWidget/BBjGridExWidgetStatusBarComponentInterface.bbj::BBjGridExWidgetStatusBarComponentInterface
use ::BBjGridExWidget/BBjGridExWidgetStatusBarFilteredRowCountComponent.bbj::BBjGridExWidgetStatusBarFilteredRowCountComponent
use ::BBjGridExWidget/BBjGridExWidgetStatusBarSelectedRowCountComponent.bbj::BBjGridExWidgetStatusBarSelectedRowCountComponent
use ::BBjGridExWidget/BBjGridExWidgetStatusBarTotalAndFilteredRowCountComponent.bbj::BBjGridExWidgetStatusBarTotalAndFilteredRowCountComponent
use ::BBjGridExWidget/BBjGridExWidgetStatusBarTotalRowCountComponent.bbj::BBjGridExWidgetStatusBarTotalRowCountComponent
use ::BBjGridExWidget/BBjGridExWidgetToolpanel.bbj::BBjGridExWidgetToolpanel
use ::BBjGridExWidget/BBjGridWidgetCellEditingEvent.bbj::BBjGridWidgetCellEditingEvent
use ::BBjGridExWidget/BBjGridWidgetContextMenuEvent.bbj::BBjGridWidgetContextMenuEvent
use ::BBjGridExWidget/BBjGridWidgetRowEditingEvent.bbj::BBjGridWidgetRowEditingEvent
use ::BBjGridExWidget/BBjGridExWidgetLanguageManager.bbj::BBjGridExWidgetLanguageManager
rem /**
rem  * A Grid Widget Plugin for BBj
rem  */
class public BBjGridExWidget extends BBjWidget
    rem /**
    rem  * Unique auto generate id for the grid instance
    rem  * 
    rem  * This id is used in the client to distinguish instances  
    rem  */
    field public BBjString GRIDID$ = java.util.UUID.randomUUID().toString()
    rem /**
    rem  * Ag Grid enterprise key
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public static BBjString LicenseKey$
    rem /**
    rem  * Allow selection of multiple cells or rows
    rem  * multiple: 1 to enable multiple selection, 0 to disabled
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber MultipleSelection! = 0
    rem /**
    rem  * Set to true to all multiple rows to be selected with a single click.
    rem  * E.g. if you click select one row, then click select another row, 
    rem  * the first row will keep it's selection. 
    rem  * Clicking a selected row in this mode will deselect the row. 
    rem  * This is useful for touch devices where ctrl and shift clicking is 
    rem  * not an option.
    rem  *
    rem  * <b>Note:</b> Despite the setting name , it works when MultipleSelection is enabled or disabled 
    rem  * 
    rem  * @RequiresRefresh
    rem  */    
    field public BBjNumber RowMultiSelectWithClick! = 0
    rem /**
    rem  * Set to true or false. If true, then rows will be deselected if you 
    rem  * hold down ctrl + click the row. Normal behaviour with the grid disallows 
    rem  * deselection of nodes (ie once a node is selected, it remains selected until 
    rem  * another row is selected in its place).
    rem  *
    rem  * @RequiresRefresh
    rem  */        
    field public BBjNumber RowDeselection! = 0
    rem /**
    rem  * If true, rows won't be selected when clicked. Use, for example, 
    rem  * when you want checkbox selection, and don't want to also select when the row
    rem  * is clicked.
    rem  *
    rem  * @RequiresRefresh
    rem  */        
    field public BBjNumber SuppressRowClickSelection! = 0
    rem /**
    rem  * When true, selection box will be show on the first column
    rem  * When false, no checkbox will be displayed
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber ShowSelectionCheckbox! = 0
    rem /**
    rem  * When true, selection box will be show on the first column header
    rem  * When false, no checkbox will be displayed
    rem  *
    rem  * <b>Note:</b> This option will enable multi row selection by default
    rem  * 
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber ShowHeaderSelectionCheckbox! = 0
    rem /**
    rem  * When true, selection box will be show on group column
    rem  * When false, no checkbox will be displayed
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber ShowGroupSelectionCheckbox! = 0
    rem /**
    rem  * When true, selecting a group will have the impact of selecting all its children
    rem  * When false, then the group is selectable independently of the child nodes
    rem  *
    rem  * <b>Note:</b> this settings has no effect if  MultipleSelection is disabled
    rem  * 
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber GroupSelectsChildren! = 0
    rem /**
    rem  * Enable / Disable Range Selection
    rem  * 
    rem  * @RequiresRefresh
    rem  */    
    field public BBjNumber RangeSelection! = 0
    rem /**
    rem  * Navigation Behavior
    rem  * 
    rem  * Defines how users can move between rows using arrow keys
    rem  *
    rem  * @see BBjGridExWidget.GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW
    rem  * @see BBjGridExWidget.GRID_NAVIGATION_BEHAVIOUR_NEXT_CELL
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString NavigationBehavior$ = #GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW()    
    rem /**
    rem  * Enable / Disable cell editing for the whole grid
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * This option can be overridden from the column attributes directly
    rem  *
    rem  * ex:
    rem  *
    rem  * <code>
    rem  *  dr! = new DataRow()
    rem  *  dr!.setFieldAttribute("DOUBLE","EDITABLE","1")
    rem  * </code>
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber Editable! = 0
    rem /**
    rem  * Enable / Disable cell editing for the whole grid
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber SingleClickEdit! = 0
    rem /**
    rem  * Define the edit type
    rem  *
    rem  * Set the default cell editor type
    rem  * default to GRID_TYPE_BASIC_STRING
    rem  *
    rem  * This option is used only in case the grid failed to detect the field's type
    rem  *
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_STRING
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_TEXT
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_NUMBER
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_BOOLEAN
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_DATE
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_TIMESTAMP
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_IMAGE
    rem  * @see BBjGridExWidget.GRID_TYPE_BASIC_IMAGE_FILTERABLE
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString DefaultType$ = #GRID_TYPE_BASIC_STRING()
    rem /**
    rem  * Define the edit behavior
    rem  *
    rem  * @see BBjGridExWidget.GRID_EDITTYPE_ROW
    rem  * @see BBjGridExWidget.GRID_EDITTYPE_CELL
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString EditType$ = #GRID_EDITTYPE_CELL()
    rem /**
    rem  * Set to true to enable Group Editing, otherwise by default, row groups cannot be edited.
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber GroupEdit! = 0
    rem /**
    rem  * Enter Key Behavior
    rem  *
    rem  * @see BBjGridExWidget.GRID_ENTER_NEXT_CELL
    rem  * @see BBjGridExWidget.GRID_ENTER_STOP_EDITING
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString EnterKeyBehavior$ = #GRID_ENTER_STOP_EDITING()
    rem /**
    rem  * Allow filters in the grid
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber EnableFilter! = 0
    rem /**
    rem  * Allow floating filters in the grid
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber EnableFloatingFilter! = 0
    rem /**
    rem  * set the label for the group column
    rem  * defaults to "Group"
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString GroupColumnLabel$ = "Group"
    rem /**
    rem  * Set the default grouping footer getter expression
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjString GroupColumnFooterGetter$ = "'Total' +  x "
    rem /**
    rem  * Enable/disable Suppress the number of items in a group
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber ShowGroupChildCount! = 0
    rem /**
    rem  * Enable/disable aggregate by column via the GUI.
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * This option can be overridden from the column attributes directly
    rem  *
    rem  * ex:
    rem  *
    rem  * <code>
    rem  *  dr! = new DataRow()
    rem  *  dr!.setFieldAttribute("DOUBLE","ENABLE_VALUE","1")
    rem  * </code>
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber EnableValue! = 1
    rem /**
    rem  * Enable/disable row group by column via the GUI
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * This option can be overridden from the column attributes directly
    rem  *
    rem  * ex:
    rem  *
    rem  * <code>
    rem  *  dr! = new DataRow()
    rem  *  dr!.setFieldAttribute("DOUBLE","ENABLE_ROW_GROUP","1")
    rem  * </code>
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber EnableRowGroup! = 1
    rem /**
    rem  * Enable/disable pivot by column via the GUI.
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * This option can be overridden from the column attributes directly
    rem  *
    rem  * ex:
    rem  *
    rem  * <code>
    rem  *  dr! = new DataRow()
    rem  *  dr!.setFieldAttribute("DOUBLE","ENABLE_PIVOT","1")
    rem  * </code>
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber EnablePivot! = 0
    rem /**
    rem  * Enable/disable changes to group, pivot or values through the GUI
    rem  * This is useful if you want to show the user the group, pivot and values panel, so they can see what columns are used,
    rem  * but prevent them from making changes to the selection.
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @Enterprise
    rem  */
    field public BBjNumber FunctionsReadOnly! = 0
    rem /**
    rem  * Set group panel visiblity
    rem  *
    rem  * @see BBjGridExWidget.GRID_GROUPPANEL_SHOW_HIDDEN
    rem  * @see BBjGridExWidget.GRID_GROUPPANEL_SHOW_VISIBLE
    rem  * @see BBjGridExWidget.GRID_GROUPPANEL_SHOW_ONGROUPING
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjString RowGroupPanelShow$ = #GRID_GROUPPANEL_SHOW_ONGROUPING()
    rem /**
    rem  * If using auto column, set to true to have each group in its own column separate column.
    rem  * eg if group by Country then Year, two auto columns will be created, one for country and
    rem  * one for year
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber GroupMultiAutoColumn! = 0
    rem /**
    rem  * If grouping, set to true or false (default is false). If true, a group row will span all columns
    rem  * across the entire width of the table. If false, the cells will be rendered as normal and you will
    rem  * have the opportunity to include a grouping column (normally the first on the left) to show the
    rem  * group.
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber GroupUseEntireRow! = 0
    rem /**
    rem  * If true then includes a 'grand' total across all groups
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber GroupIncludeFooter! = 0
    rem /**
    rem  * If true then includes group totals within each group level
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjNumber GroupIncludeTotalFooter! = 0
    rem /**
    rem  * The grid context menu
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field public BBjGridContextMenu ContextMenu! = new BBjGridDefaultContextMenu()
    rem /**
    rem  * The grid default row height
    rem  *
    rem  * @RequiresRefresh
    rem  */
    field public BBjNumber RowHeight! = 30
    rem /**
    rem  * The grid sidebar
    rem  *
    rem  * Set the default grid sidebar
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field protected BBjGridExWidgetSidebar Sidebar! = new BBjGridExWidgetDefaultSidebar(#this!)
    field protected BBjGridExWidgetLanguageManager LanguageManager! = new BBjGridExWidgetLanguageManager()
    rem /**
    rem  * The grid statusbar
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    field protected BBjGridExWidgetStatusBar Statusbar! = new BBjGridExWidgetStatusBar(#this!)
    field private BBjHtmlView HTMLView!
    field private Boolean IsReady! = BBjAPI.FALSE
    field private BBjVector backlog! = new BBjVector()
    field private ResultSet RS!
    field private BBjString URL$
    field private BBjString RowNodeId$ = "__ROW_INDEX"
    field private BBjString ParentNodeId$
    field private DataRow ColumnDefinition!
    field public  DataRow AttributesRecord!
    field private DataRow AdditionalAttributes! = new DataRow()
    field private BBjNumber Editing! = 0
    field private HashMap ColumnGroups! = new HashMap()
    field public static BBjNumber Debug=0
    field private BBjString DataFingerprint$
    field private BBjNumber newW!
    field private BBjNumber newH!
    field private BBjString DoubleClickRowsHistory$
    rem /**
    rem  * disabled default constructor
    rem  */
    method private BBjGridExWidget()
    methodend
    rem /**
    rem  * The constructor that creates the widget on wnd!
    rem * @param BBjWindow wnd!: parent window
    rem * @param BBjInt id: the control ID
    rem * @param BBjInt x: x-location
    rem * @param BBjInt y: y-location
    rem * @param BBjInt w: width
    rem * @param BBjInt h: height
    rem */
    method public BBjGridExWidget(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
        #super!.create(wnd!,id!,x!,y!,w!,h!)
    methodend
    rem /**
    rem  * The constructor that creates the widget in the ChildWindow
    rem * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
    rem */
    method public BBjGridExWidget(BBjChildWindow wnd!)
        #super!.create(wnd!)
    methodend
    REM /**
    REM  *
    REM  * returns the unique control type
    REM  * @returns int controlType = 65001
    REM  *
    REM  */
    method public int getControlType()
        methodret 65001
    methodend
    rem /**
    rem  * @Override
    rem  * This method is called whenever the widget needs to be rendered
    rem  * @param Boolean f_init!: if TRUE trem /**
    rem  *
    rem  * control is rendered for the first time so this method has to perform initial rendering
    rem  */
    method public void redraw(Boolean f_init!)
        declare BBjHtmlView htmlview!

        if (f_init!) then
            lic!=System.getProperty("bbjgridexwidget.license")

            if lic! <> null() and str(lic!) <> "" then
                #setLicenseKey(str(lic!))
            FI

            html$ = ""
            ch=unt
            open (ch)"BBjGridExWidget/client/index.html"
            read record (ch,siz=5512000)html$
            close (ch)
            html! = html$
            html! = html!.replaceAll("__id__",#GRIDID$)
            html! = html!.replaceAll("__lang__",#getLanguageManager().getLanguage())
            html$ = str(html!)

            if (info(3,6)<>"5" and #Debug>0) then
                call "BBjGridExWidget/util/EnableDebugger.bbj"
            FI

            htmlview! = #getCanvas().addHtmlView(101,0,0,#getCanvas().getWidth(),#getCanvas().getHeight(),"",$0010$)
            htmlview!.setNoEdge(1)

            if (info(3,6)<>"5" and #Debug>0) then
                url$ = htmlview!.getAttribute("remoteDebuggingURL")

                if url$>"" then
                    BBjAPI().getThinClient().browse(url$)
                FI
            FI
            REM             if (htmlview!.getClientType() <> "Chromium" AND INFO(3,6)<>"5")
            REM                 htmlview!.setText("<html><center>Error: Need the Chromium Engine in BBj 18.10 or later. Please check your BBj SAM coverage!</center></html>")
            REM             else
            htmlview!.setCallback(BBjAPI.ON_PAGE_LOADED,#this!,"onLoad")
            htmlview!.setCallback(BBjAPI.ON_NATIVE_JAVASCRIPT,#this!,"onNativeEvent")
            htmlview!.setOpaque(0)
            htmlview!.setText(html$)
            REM             fi
            #HTMLView!=htmlview!
            #HTMLView!.setVisible(1)
        else
            #HTMLView!.setSize(#getCanvas().getWidth(),#getCanvas().getHeight())
        FI
    methodend

    method protected void injectScript(BBjString script$)
        bui = INFO(3,6)="5"

        if bui then
            #HTMLView!.injectScript(script$)
        ELSE
            #HTMLView!.injectScript(script$ , 1)
        FI
    methodend
    rem /**
    rem  * callback method after initial load
    rem  * does last initialization work
    rem  *
    rem  * @param BBjEvent ev!: the onLoad event
    rem  */
    method public void onLoad(BBjEvent ev!)
        rem ' only do this once
        #HTMLView!.clearCallback(#HTMLView!.ON_PAGE_LOADED)
        ch=unt
        distBase$ = "BBjGridExWidget/client/dist"
        rem include the grid
        if #getDebug() = 1 then
            gridPath$ = iff(LEN(#LicenseKey$) > 0,distBase$ + "/ag-grid-enterprise.noStyle.js",distBase$ +"/ag-grid-community.noStyle.js")
        else
            gridPath$ = iff(LEN(#LicenseKey$) > 0,distBase$ + "/ag-grid-enterprise.min.noStyle.js",distBase$ +"/ag-grid-community.min.noStyle.js")
        FI

        open (ch)gridPath$
        read record (ch,siz=5512000)script$
        close (ch)
        #injectScript(script$)
        rem include locale files
        locale! = #getLanguageManager().getLanguage()
        locale$ = str(locale!.replaceAll("_","-").replaceAll("_","-"))
        dateJsLocalePath$ = distBase$ + "/../vendor/Datejs/build/date-" + locale$ + ".js"
        isLocale = 0
        ch=unt
        open (ch,err=*next)dateJsLocalePath$;isLocale=1

        if isLocale = 0 then
            close (ch)
            dateJsLocalePath$ = distBase$ + "/i18n/Datejs/" + locale$ + ".js"
            open (ch,err=*next)dateJsLocalePath$
        FI

        read record (ch,siz=5512000)script$
        close (ch)
        #injectScript(script$)
        ch=unt

        if #getDebug() = 1 then
            open (ch) distBase$ + "/bbj-grid-widget.js"
        else
            open (ch) distBase$ + "/bbj-grid-widget.min.js"
        FI

        read record (ch,siz=5512000)script$
        close (ch)
        #injectScript(script$)
        #IsReady! = BBjAPI.TRUE

        if #RS! <> null() or #URL$>"" then
            #performGridDataUpdate()
        FI

        it! = #backlog!.iterator()
        while it!.hasNext()=BBjAPI.TRUE
            s$=str(it!.next())
            #HTMLView!.executeScript(s$)
        wend

        #backlog! = null()
        if #newW! <> null() and #newH!<> null() then
        #super!.setSize(#newW!,#newH!)
        #newW! = null()
        #newH! = null()
    FI
    methodend
    rem /**
    rem  * Event Handler for Native JavaScript Event (from the Grid)
    rem  * Determines and dispatches the actual event
    rem  *
    rem  * @param BBjNativeJavaScriptEvent ev!: the js event
    rem  */
    method public void onNativeEvent ( BBjNativeJavaScriptEvent ev!)
        map! = ev!.getEventMap()
        type$ = str(map!.get("type"))
        detail$ = str(map!.get("detail"))
        switch type$
            case "gw.rowSelect"
                #onSelecteRowChange(detail$, "single")
                break
            case "gw.rowDoubleClick"
                #onSelecteRowChange(detail$,"double")
                break
            case "gw.cellClicked"
                #handleGridCellEditingEvent(detail$,#ON_GRID_CELL_CLICK())
                break
            case "gw.cellDoubleClicked"
                #handleGridCellEditingEvent(detail$,#ON_GRID_CELL_DOUBLE_CLICK())
                break
            case "gw.stateChanged"
                #handleStateChangedEvent(detail$,#ON_GRID_COLUMN_STATE_CHANGE())
                break
            case "cellEditingStarted"
                #Editing! = 1
                #handleGridCellEditingEvent(detail$,#ON_GRID_CELL_EDITING_STARTED())
                break
            case "cellEditingStopped"
                #Editing! = 0
                #handleGridCellEditingEvent(detail$,#ON_GRID_CELL_EDITING_STOPPED())
                break
            case "rowEditingStarted"
                #Editing! = 1
                #handleGridROWEditingEvent(detail$,#ON_GRID_ROW_EDITING_STARTED())
                break
            case "rowEditingStopped"
                #Editing! = 0
                #handleGridROWEditingEvent(detail$,#ON_GRID_ROW_EDITING_STOPPED())
                break
            case "contextmenu"
                #handleGridContextmenuEvent(detail$)
                break
        swend
    methodend
    rem /**
    rem  * set the data into the grid
    rem  * @param ResultSet: the com.basiscomponents.db.ResultSet with the data
    rem  */
    method public void setData( ResultSet rs!)
        #RS! = rs!

        if #AttributesRecord! <> NULL() AND rs! <> NULL() AND rs!.size() >0 then
            rem TODO: use the new method of components as soon as implemented
            rem https://github.com/BasisHub/components/issues/87
            r1! = rs!.getItem(0)
            ar! = #AttributesRecord!
            it! = r1!.getFieldNames().iterator()
            while it!.hasNext()
                f$ = it!.next()

                if ar!.contains(f$) then
                    r1!.setFieldAttributes(f$,ar!.getFieldAttributes(f$))
                FI
            wend
        FI

        if #ColumnDefinition! <> NULL() AND rs! <> NULL() AND rs!.size() >0 then
            r1! = rs!.getItem(0)
            ar! = #ColumnDefinition!
            it! = r1!.getFieldNames().iterator()
            while it!.hasNext()
                f$ = it!.next()

                if ar!.contains(f$) then
                    r1!.setFieldAttributes(f$,ar!.getFieldAttributes(f$))
                FI
            wend
        FI

        if rs! <> NULL() AND rs!.size()>0 then
            it! = #AdditionalAttributes!.getFieldNames().iterator()
            r1! = rs!.getItem(0)
            while it!.hasNext()
                f$=it!.next()

                if r1!.contains(f$) then
                    r1!.setFieldAttributes(f$,#AdditionalAttributes!.getFieldAttributes(f$))
                FI
            wend
        FI
        rem if the data fed to the grid is the same as before, it's an update.
        rem In this case we want to retain the setting of the columns
        rem and the order and sizes
        if (rs!.size() >0) then
            r1! = rs!.getItem(0)
            datafingerprint$ = r1!.getFieldNames().toString()
            keep=0

            if (datafingerprint$ = #DataFingerprint$) then
                tmpstate!=#getColumnState()
            FI
        FI

        #RS!.createIndex()
        #URL$=""
        #performGridDataUpdate()

        if (rs!.size() >0) then
            if tmpstate!<>null() then
                #setColumnState(tmpstate!)
            FI

            #DataFingerprint$ = datafingerprint$
        FI

        #DataFingerprint$ = datafingerprint$
    methodend
    rem /**
    rem  * set the data into the grid
    rem  * @param ResultSet: the com.basiscomponents.db.ResultSet with the data
    rem  * @param BBjString: field used to generate id
    rem  */
    method public void setData( ResultSet rs! ,BBjString RowNodeId$)
        #RowNodeId$ = RowNodeId$
        #setData(rs!)
    methodend
    rem /**
    rem  * Set new rows into the grid
    rem  *
    rem  * @param ResultSet: the com.basiscomponents.db.ResultSet with the data
    rem  */
    method public void setRowsData(ResultSet rs!)
        #RS! = rs!

        if #AttributesRecord! <> NULL() AND rs! <> NULL() AND rs!.size() >0 then
            rem TODO: use the new method of components as soon as implemented
            rem https://github.com/BasisHub/components/issues/87
            r1! = rs!.getItem(0)
            ar! = #AttributesRecord!
            it! = r1!.getFieldNames().iterator()
            while it!.hasNext()
                f$ = it!.next()

                if ar!.contains(f$) then
                    r1!.setFieldAttributes(f$,ar!.getFieldAttributes(f$))
                FI
            wend
        FI

        if #ColumnDefinition! <> NULL() AND rs! <> NULL() AND rs!.size() >0 then
            r1! = rs!.getItem(0)
            ar! = #ColumnDefinition!
            it! = r1!.getFieldNames().iterator()
            while it!.hasNext()
                f$ = it!.next()

                if ar!.contains(f$) then
                    r1!.setFieldAttributes(f$,ar!.getFieldAttributes(f$))
                FI
            wend
        FI

        #RS!.createIndex()
        #URL$=""
        data$=#RS!.toJson(BBjAPI.TRUE,"__ROW_INDEX")
        #executeScript("gw_setRowsData('" + #GRIDID$ + "'," + data$+ ")")
    methodend
    rem /**
    rem  * Update row data
    rem  *
    rem  * @param BBjNumber: row index
    rem  * @param DataRow: DataRow object which contains the update
    rem  */
    method public void setRowData(BBjNumber index!,DataRow row!)
        if #RS!.count() <> 0 then
            #RS!.set(index!,row!)
            REM toJsonObject is available in basiscomponents.jar >= BBj 19.00
            REM FIXME as soon as we release a version that has >=19.00 as a dependency, clean this up
            if com.basiscomponents.VersionInfo.getBBjBuildID()>="1555708604" then
                #executeScript("gw_setRowData('"+ #GRIDID$ + "'," + row!.toJsonObject(1,"__ROW_INDEX",0) +")")
            else
                parser! = new JsonParser()
                #executeScript("gw_setRowData('"+ #GRIDID$ + "'," + parser!.parse(row!.toJson("__ROW_INDEX")).getAsJsonArray().get(0).toString()  +")")
            FI
        FI
    methodend
    rem /**
    rem  * Add new row
    rem  *
    rem  * @param BBjNumber: index insert index
    rem  * @param DataRow: DataRow object which contains the update
    rem  */
    method public void addRow(BBjNumber index!,DataRow row!)
        #RS!.add(index! , row!)
        REM toJsonObject is available in basiscomponents.jar >= BBj 19.00
        REM FIXME as soon as we release a version that has >=19.00 as a dependency, clean this up
        if com.basiscomponents.VersionInfo.getBBjBuildID()>="1555708604" then
            #executeScript("gw_setRowData('"+ #GRIDID$ + "'," + row!.toJsonObject(1,"__ROW_INDEX",0) +")")
        else
            parser! = new JsonParser()
            #executeScript("gw_addRows('" + #GRIDID$ + "'," + str(index!) +",[" + parser!.parse(row!.toJson("__ROW_INDEX")).getAsJsonArray().get(0).toString() +"])")
        FI
    methodend
    rem /**
    rem  * Add new row
    rem  *
    rem  * @param DataRow: DataRow object which contains the update
    rem  */
    method public void addRow(DataRow row!)
        #RS!.add(row!)
        REM toJsonObject is available in basiscomponents.jar >= BBj 19.00
        REM FIXME as soon as we release a version that has >=19.00 as a dependency, clean this up
        if com.basiscomponents.VersionInfo.getBBjBuildID()>="1555708604" then
            #executeScript("gw_setRowData('"+ #GRIDID$ + "'," + row!.toJsonObject(1,"__ROW_INDEX",0) +")")
        else
            parser! = new JsonParser()
            #executeScript("gw_addRows('" + #GRIDID$ +"',null,[" + parser!.parse(row!.toJson("__ROW_INDEX")).getAsJsonArray().get(0).toString() +"])")
        FI
    methodend
    rem /**
    rem  * Remove row from grid by index
    rem  *
    rem  * @param BBjNumber: row index
    rem  */
    method public void removeRow(BBjNumber index!)
        if #RS!.count() <> 0 then
            if #RowNodeId$ <> "__ROW_INDEX" then
                value! = #RS!.getItem(index!).getFieldAsString(#RowNodeId$)
            else
                value! = #RS!.getItem(index!).getRowKey()
            FI

            #RS!.remove(index!)
            #executeScript("gw_removeRows('" + #GRIDID$ + "',['" + str(value!)  +"'])")
            rem print #RS!.getItem(index!)
            rem escape
        FI
    methodend
    rem /**
    rem  * Clear row data (Empty the grid )
    rem  */
    method public void clearRowsData()
        #RS! = new ResultSet()
        #RS!.createIndex()
        #URL$=""
        #executeScript("gw_setRowsData('" + #GRIDID$ + "', [])")
    methodend
    rem /**
    rem  * add a column to the grid
    rem  * @param BBjString field$: the field name that matches the ResultSet
    rem  * @param BBjString label$: the column header
    rem  * @param BBjNumber Type!: the column Type (java.sql.Types)
    rem  * @param BBjNumber Editable!: 1 = column is editable
    rem  * @see https://docs.oracle.com/javase/8/docs/api/java/sql/Types.html
    rem  *
    rem  */
    method public void addColumn(BBjString Field$, BBjString Label$, BBjNumber Type!, BBjNumber Editable!)
        if #ColumnDefinition! = null() then
            #ColumnDefinition! = new DataRow()
        FI

        #ColumnDefinition!.setFieldValue(Field$,Type!,null())
        #ColumnDefinition!.setFieldAttribute(Field$,"LABEL",Label$)
        #ColumnDefinition!.setFieldAttribute(Field$,"EDITABLE",STR(Editable!))
    methodend
    rem /**
    rem  * add a column to the grid
    rem  * @param BBjString field$: the field name that matches the ResultSet
    rem  */
    method public void addColumn(BBjString Field$)
        #addColumn(Field$,Field$,12,0)
    methodend
    rem /**
    rem  * add a column to the grid
    rem  * @param BBjString field$: the field name that matches the ResultSet
    rem  * @param BBjString label$: the column header
    rem  */
    method public void addColumn(BBjString Field$, BBjString Label$)
        #addColumn(Field$,Label$, 12, 0)
    methodend
    rem /**
    rem  * add a column to the grid
    rem  * @param BBjString field$: the field name that matches the ResultSet
    rem  * @param BBjString label$: the column header
    rem  * @param BBjNumber Type!: the column Type (java.sql.Types)
    rem  * @see https://docs.oracle.com/javase/8/docs/api/java/sql/Types.html
    rem  *
    rem  */
    method public void addColumn(BBjString Field$, BBjString Label$, BBjNumber Type!)
        #addColumn(Field$,Label$, Type!, 0)
    methodend
    rem /**
    rem  * clear all columns
    rem  */
    method public void clearColumnDefinitions()
        #ColumnDefinition! = null()
    methodend
    rem /**
    rem  * set the font color of a column
    rem  *
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjColor color!: the color for the column
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnForeColor(BBjString Field$,BBjColor color!)
        #ColumnDefinition!.setFieldAttribute(Field$,"FGCOLOR","#"+hta(chr(color!.getRed()))+hta(chr(color!.getGreen()))+hta(chr(color!.getBlue())),err=*next)
    methodend
    rem /**
    rem  * set the background color of a column
    rem  *
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjColor color!: the color for the column
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnBackColor(BBjString Field$,BBjColor color!)
        #ColumnDefinition!.setFieldAttribute(Field$,"BGCOLOR","#"+hta(chr(color!.getRed()))+hta(chr(color!.getGreen()))+hta(chr(color!.getBlue())),err=*next)
    methodend
    rem /**
    rem  * set the mask of a column
    rem  *
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjString mask$: the (date or numeric) mask, BBj style, for display and editing
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnMask(BBjString Field$, BBjString mask$)
        #ColumnDefinition!.setFieldAttribute(Field$,"MASK",mask$)
    methodend
    rem /**
    rem  * set the alignment of a column
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjNumber align: the column alignment
    rem  *
    rem  * valid alignments:
    rem  *
    rem  * @see GRID_ALIGN_LEFT()
    rem  * @see GRID_ALIGN_CENTER()
    rem  * @see GRID_ALIGN_RIGHT()
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnAlignment(BBjString Field$, BBjNumber align)
        switch align
            case BBjGrid.GRID_ALIGN_LEFT
                #ColumnDefinition!.setFieldAttribute(Field$,"ALIGN","left",err=*next)
                break
            case BBjGrid.GRID_ALIGN_CENTER
                #ColumnDefinition!.setFieldAttribute(Field$,"ALIGN","center",err=*next)
                break
            case BBjGrid.GRID_ALIGN_RIGHT
                #ColumnDefinition!.setFieldAttribute(Field$,"ALIGN","right",err=*next)
                break
        swend
    methodend
    rem /**
    rem  * Apply columns state
    rem  *
    rem  * @param BBjGridExWidgetState state! : the state object
    rem  */
    method public void setColumnState(BBjGridExWidgetState state!)
        #executeScript("gw_setState('" + #GRIDID$ + "'," + state!.toString() +")")
    methodend
    rem /**
    rem  * Get Column state
    rem  *
    rem  * @returns BBjGridExWidgetState
    rem  */
    method public BBjGridExWidgetState getColumnState()
        state! = new BBjGridExWidgetState()
        json_string$ = str(#HTMLView!.executeScript("gw_getState('" + #GRIDID$ + "')"))
        state!.setString(json_string$)
        methodret state!
    methodend
    rem /**
    rem  * Get the grid sidebar instance
    rem  *
    rem  * @return BBjGridExWidgetSidebar
    rem  */
    method public BBjGridExWidgetSidebar getSidebar()
        methodret #Sidebar!
    methodend
    rem /**
    rem  * Get the language manager instance
    rem  *
    rem  * @returns BBjGridExWidgetLanguageManager
    rem  */
    method public BBjGridExWidgetLanguageManager getLanguageManager()
        methodret #LanguageManager!
    methodend
    rem /**
    rem  * Get the grid statusbar instance
    rem  *
    rem  * @return BBjGridExWidgetStatusBar
    rem  */
    method public BBjGridExWidgetSidebar getStatusbar()
        methodret #Statusbar!
    methodend      
    rem /**
    rem  * Add Style block
    rem  *
    rem  * @param selector$ : Css Selector
    rem  * @param rules! : Css Rules object as json object
    rem  */
    method public void addStyle(BBjString selector$ , JsonObject rules! )
        #executeScript("gw_setStyle('" + selector$ + "','" + rules!.toString() + "')")
    methodend
    rem /**
    rem  * Add Style block
    rem  *
    rem  * @param selector$ : Css Selector
    rem  * @param rules! : Css Rules object as string
    rem  */
    method public void addStyle(BBjString selector$ , BBjString rules! )
        #executeScript("gw_setStyle('" + selector$ + "','" + rules! + "')")
    methodend
    rem /**
    rem  * Remove Style Block
    rem  *
    rem  * @param selector$ : Css Selector
    rem  */
    method public void removeStyle(BBjString selector$)
        #executeScript("gw_removeStyle('" + selector$ + "')")
    methodend
    rem /**
    rem  * Set the grid theme
    rem  *
    rem  * @param BBjString theme$
    rem  *
    rem  * @see BBjGridExWidget.getThemes()
    rem  */
    method public void setTheme(BBjString theme$)
        if pos(theme$="dark#fresh#blue#bootstrap#material#balham#balham-dark")>0 then
            if info(3,6)="5" then
                s$="$doc.getElementById('" + str(#GRIDID$) + "').className='ag-theme-"+theme$+"';"
            else
                s$="document.getElementById('" + str(#GRIDID$) + "').className='ag-theme-"+theme$+"';"
            FI

            #executeScript(s$)
        FI
    methodend
    rem /**
    rem  * Get themes
    rem  *
    rem  * Get the grid supported themes
    rem  */
    method public BBjVector getThemes()
        v! = new BBjVector()
        v!.addItem("balham")
        v!.addItem("balham-dark")
        v!.addItem("dark")
        v!.addItem("fresh")
        v!.addItem("blue")
        v!.addItem("bootstrap")
        v!.addItem("material")
        methodret v!
    methodend
    rem /**
    rem  * select all rows
    rem  */
    method public void selectAll()
        script$="gw_selectAll('" + #GRIDID$ + "',0);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * select all rows
    rem  *
    rem  * @param BBJNumber x!: 0 select all , 1 select all filtered
    rem  */
    method public void selectAll(BBjNumber x!)
        #deselectAll()
        script$="gw_selectAll('" + #GRIDID$ + "'," + str(x!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * deselect all rows
    rem  */
    method public void deselectAll()
        script$="gw_deselectAll('" + #GRIDID$ + "',0);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * deselect all rows
    rem  *
    rem  * @param BBJNumber x!: 0 deselect all , 1 deselect all filtered
    rem  */
    method public void deselectAll(BBjNumber x!)
        script$="gw_deselectAll('"+ #GRIDID$ + "'," + str(x!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Select a row
    rem  *
    rem  * @param BBJNumber x!: the row index to select
    rem  */
    method public void setSelectedRow(BBjNumber x!)
        #deselectAll()
        script$="gw_setSelectedRows('" + #GRIDID$ + "',[" + str(x!) + "]);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Select verctor of rows
    rem  *
    rem  * @param BBJNumber x!: vector of row indices to select
    rem  */
    method public void setSelectedRows(BBjVector x!)
        #deselectAll()
        script$="gw_setSelectedRows('" + #GRIDID$ + "',["
        it! = x!.iterator()
        first=1
        while it!.hasNext()
            if first
                first=0
            else
                script$=script$+","
            FI

            script$=script$+str(it!.next())
        wend

        script$=script$+"]);"
        #executeScript(script$)
    methodend
    rem /**
    rem  *  Expand all groups.
    rem  */
    method public void expandAll()
        script$="gw_expandAll('" + #GRIDID$ +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  *  collapse all groups.
    rem  */
    method public void collapseAll()
        script$="gw_collapseAll('" + #GRIDID$ +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Set visible row
    rem  *
    rem  * Ensures the row index is visible by vertically scrolling the grid.
    rem  * The valid values for positions are {'top', 'middle', 'bottom'}.
    rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
    rem  *
    rem  * @param BBjNumber index!: the row index
    rem  * @param BBjString position!: the scrolling poistion
    rem  *
    rem  * @see GRID_ROWPOS_TOP()
    rem  * @see GRID_ROWPOS_MIDDLE()
    rem  * @see GRID_ROWPOS_BOTTOM()
    rem  */
    method public void setVisibleRow(BBjNumber index! , BBjString position!)
        script$="gw_setVisibleRow('" + #GRIDID$ + "'," + str(index!) + ",'" + str(position!) +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Set visible column
    rem  *
    rem  * Ensures the column is visible, scrolling the table if needed.
    rem  *
    rem  * @param BBJString columnid!: the column id
    rem  */
    method public void setVisibleColumn(BBjString columnId!)
        script$="gw_setVisibleColumn('" + #GRIDID$ +  "','" + columnId! + "');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * pin a column of the grid to the left or the right margin
    rem  *
    rem  * @param BBjString field$: the field name of the column
    rem  * @param BBjString pin$: "right" or "left"
    rem  */
    method public void pinColumn(BBjString Field$, BBjString pin$)
        pin$=cvs(pin$,8)

        if pin$="left" or pin$="right" then
            #ColumnDefinition!.setFieldAttribute(Field$,"PINNED",pin$,err=*next)
        else
            #ColumnDefinition!.removeFieldAttribute(Field$,"PINNED",err=*next)
        FI

        script$="gw_pinColumn('" + #GRIDID$ + "','" + Field$ + "','" + pin$  + "');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * set the grid to scroll horizontally or fit into the client area
    rem  */
    method public void setFitToGrid()
        ret! = #executeScript("gw_sizeColumnsToFit('" + #GRIDID$ +"')")
    methodend
    rem /**
    rem  * setSize - set the size of the control
    rem  * @param BBjNumber w! - width
    rem  * @param BBjNumber h! - height
    rem  */
    method public void setSize(BBjNumber w!, BBjNumber h!)
        rem if setSize is called before the page is ready, delay its execution
        if #IsReady! then
            #super!.setSize(w!,h!)
        else
            rem cheat with the superclass so getWidth / getHeight already return the later size
            #super!.setW(w!)
            #super!.setH(h!)
            #newW! = w!
            #newH! = h!
        FI
    methodend
    rem /**
    rem  * Set all rows height
    rem  *
    rem  * @param BBjNumber height! - the new row height
    rem  */
    method public void setRowHeight(BBjNumber height!)
        #RowHeight! = height!
        #executeScript("gw_setRowsHeight('" + #GRIDID$ + "'," + str(height!) + ")")
    methodend
    rem /**
    rem  * Set the given row height
    rem  *
    rem  * @param BBjNumber index! - the row index
    rem  * @param BBjNumber height! - the new row height
    rem  */
    method public void setRowHeight(BBjNumber index!, BBjNumber height!)
        #executeScript("gw_setRowHeight('" + #GRIDID$ + "'," + str(index!) + "," + str(height!) + ")")
    methodend
    rem /**
    rem  * set the width of a column
    rem  *
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjNumber width!: the column width
    rem  */
    method public void setColumnWidth(BBjString Field$, BBjNumber w!)
        #ColumnDefinition!.setFieldAttribute(Field$,"WIDTH",num(w!),err=*next)
        script$="gw_setColumnWidth('"+ #GRIDID$ + "','" + Field$ + "'," + str(w!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Change column position
    rem  *
    rem  * @param BBjString Field$: the field name of the column
    rem  * @param BBjNumber toIndex!: the new column position/index
    rem  */
    method public void moveColumn(BBjString Field$, BBjNumber toIndex!)
        script$="gw_moveColumn('" + #GRIDID$ + "','" + Field$ + "'," + str(toIndex!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Perform throw columns search
    rem  *
    rem  * @param BBjNumber filter : filter as a string
    rem  */
    method public void setQuickFilter(BBjNumber filter)
        #executeScript("gw_setQuickFilter('" + #GRIDID$ + "'," + str(filter) +")")
    methodend
    rem /**
    rem  * Perform throw columns search
    rem  *
    rem  * @param BBjNumber filter : filter as number
    rem  */
    method public void setQuickFilter(BBjString filter!)
        #executeScript("gw_setQuickFilter('" + #GRIDID$ + "','" + filter! +"')")
    methodend
    rem /**
    rem  * Start Next Cell Editing
    rem  */
    method public void moveToNextCell()
        #executeScript("gw_editNextCell('"+ #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Move to previous cell
    rem  */
    method public void moveToPreviousCell()
        #executeScript("gw_editPreviousCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Start Cell Editing
    rem  *
    rem  * @param BBjNumber row!: The row number
    rem  * @param BBjString colId!: The column ID
    rem  */
    method public void setStartCellEditing(BBjNumber row! , BBjString colId$)
        #executeScript("gw_startEditingCell('" + #GRIDID$ + "',"+ STR(row!)+ ",'" + colId$ + "')")
    methodend
    rem /**
    rem  * Start Cell Editing
    rem  *
    rem  * @param BBjNumber row!: The row number
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber char$: key chars to press on editors when editors support it
    rem  */
    method public void setStartCellEditing(BBjNumber row! , BBjString colId$, BBjString char$)
        #executeScript("gw_startEditingCell('" + #GRIDID$ + "',"+ STR(row!)+ ",'" + colId$ + "','','" + char$ +"')")
    methodend
    rem /**
    rem  * Start Cell Editing
    rem  *
    rem  * @param BBjNumber row!: The row number
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber key!: key codes to press on editors when editors support it
    rem  */
    method public void setStartCellEditing(BBjNumber row! , BBjString colId$,BBjNumber key!)
        #executeScript("gw_startEditingCell('" + #GRIDID$ + "',"+ STR(row!)+ ",'" + colId$ + "','" + STR(key!)+ "')")
    methodend
    rem /**
    rem  * Start next Cell Editing
    rem  */
    method public void startNextCellEditing()
        #executeScript("gw_editNextCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Start previous Cell Editing
    rem  */
    method public void startPreviousCellEditing()
        #executeScript("gw_editPreviousCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Stop Editing and accept any changes
    rem  */
    rem /**
    rem  * Stop editing and discard changes
    rem  */
    method public void stopEditing()
        #executeScript("gw_stopEditing('" + #GRIDID$ + "',0)")
    methodend
    rem /**
    rem  * Stop Editing
    rem  *
    rem  * @param BBjNumber cancel!: 1 = discard changes , 0 = accept changes
    rem  */
    method public void stopEditing(BBjNumber cancel!)
        #executeScript("gw_stopEditing('"+ #GRIDID$ + "'," + STR(cancel!)+ ")")
    methodend
    rem /**
    rem  * Enable/disable changes to group, pivot or values through the GUI
    rem  * This is useful if you want to show the user the group, pivot and values panel, so they can see what columns are used,
    rem  * but prevent them from making changes to the selection.
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @Enterprise
    rem  */
    method public void setFunctionsReadOnly(BBjNumber readonly!)
        #assertIsEnterprise("FunctionsReadOnly")
        #FunctionsReadOnly! = readonly!
        #executeScript("gw_setFunctionsReadOnly('" + #GRIDID$ + "'," + str(readonly!) +")")
    methodend
    rem /**
    rem  * Enable/disable aggregate by column via the GUI.
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    method public void setEnableValue(BBjNumber bool!)
        #assertIsEnterprise("EnableValue")
        #EnableValue! = bool!
    methodend
    rem /**
    rem  * Enable/disable pivot by column via the GUI.
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    method public void setEnablePivot(BBjNumber bool!)
        #assertIsEnterprise("EnablePivot")
        #EnablePivot! = bool!
    methodend
    rem /**
    rem  * Enable/disable row group by column via the GUI
    rem  *
    rem  * 1 = enable editing
    rem  * 0 = disable edition
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    method public void setEnableRowGroup(BBjNumber bool!)
        #assertIsEnterprise("EnableRowGroup")
        #EnableRowGroup! = bool!
    methodend
    rem /**
    rem  * If using auto column, set to true to have each group in its own column separate column.
    rem  * eg if group by Country then Year, two auto columns will be created, one for country and
    rem  * one for year
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    method public void setGroupMultiAutoColumn(BBjNumber bool!)
        #assertIsEnterprise("GroupMultiAutoColumn")
        #GroupMultiAutoColumn!  = bool!
    methodend
    rem /**
    rem  * If grouping, set to true or false (default is false). If true, a group row will span all columns
    rem  * across the entire width of the table. If false, the cells will be rendered as normal and you will
    rem  * have the opportunity to include a grouping column (normally the first on the left) to show the
    rem  * group.
    rem  *
    rem  * 1 = enable
    rem  * 0 = disable
    rem  *
    rem  * @RequiresRefresh
    rem  * @Enterprise
    rem  */
    method public void setGroupUseEntireRow(BBjNumber bool!)
        #assertIsEnterprise("GroupUseEntireRow")
        #GroupUseEntireRow!  = bool!
    methodend
    rem /**
    rem  * @return one if ag grid is in the editing mode , 0 otherwise
    rem  */
    method public BBjNumber isEditing()
        return #Editing
    methodend
    rem /**
    rem  * @return the selected row
    rem  */
    method public BBjGridExWidgetRow getSelectedRow()
        returnedRow! = #executeScript("gw_getSelectedRow('" + #GRIDID$ + "')")
        if len(returnedRow!) > 0 then
            parser! = new JsonParser()
            parsedRow! = parser!.parse(returnedRow!).getAsJsonObject()
            row! = new BBjGridExWidgetRow(#RS!)
            row!.setId(parsedRow!.get("id").getAsString())
            row!.setChildIndex(parsedRow!.get("childIndex").getAsInt())
            row!.setIndex(parsedRow!.get("index").getAsString())
            row!.setParentKey(parsedRow!.get("parentKey").getAsString())
            row!.setIsSelected(iff(parsedRow!.get("selected").getAsString() = "true" ,  1 , 0))
            methodret row!
        FI

        methodret null()
    methodend
    rem /**
    rem  * @return BBjVector with the selected rows
    rem  */
    method public BBjVector getSelectedRows()
        rows! = new BBjVector()

        if (#RS! = null()) then
            goto getSelectedRowsErr
        FI

        returnedRows! = #executeScript("gw_getSelectedRows('" + #GRIDID$ + "')")
        if returnedRows!=null() then
            goto getSelectedRowsErr
        FI

        parser! = new JsonParser()
        array! = parser!.parse(returnedRows!).getAsJsonArray()
        it! = array!.iterator()
        while (it!.hasNext())
            next! = it!.next().getAsJsonObject(err=getSelectedRowsErr)
            row! = new BBjGridExWidgetRow(#RS!)
            row!.setId(next!.get("id").getAsString())
            row!.setChildIndex(next!.get("childIndex").getAsInt())
            row!.setIndex(next!.get("index").getAsString())
            row!.setParentKey(next!.get("parentKey").getAsString())
            row!.setIsSelected(iff(next!.get("selected").getAsString() = "true" ,  1 , 0))
            rows!.add( row!)
        wend

        getSelectedRowsErr:
            methodret rows!
    methodend
    rem /**
    rem  * Group Vector of Columns
    rem * @param BBjString id$: the group id
    rem * @param BBjString name$: the group label/name
    rem * @param BBjVector columns!: Vector of columns ids
    rem * @param BBjInt MarryChildren!: Set to 'true' to keep columns in this group beside each other in the grid.
    rem *                               Moving the columns outside of the group (and hence breaking the group) is not allowed.
    rem * @param BBjInt HeaderClass$:  Css class to apply
    rem */
    method public void addColumnGroup(BBjString id$ , BBjString name$ ,  BBjVector columns! , Boolean MarryChildren! ,BBjString HeaderClass$ )
        json! = new JsonObject()
        size! = columns!.size()

        if size! > 0 then
            columnsStr! = ""
            for n = 0 to size! - 1 step 1
                columnsStr! = columnsStr! +str(columns!.getItem(n)) + ","
            next n

            columnsStr! = columnsStr!.substring(0,columnsStr!.length() - 1)
            json!.addProperty("children",columnsStr!)
        FI

        json!.addProperty("groupId",id$)
        json!.addProperty("headerName",name$)
        json!.addProperty("marryChildren",MarryChildren!)
        json!.addProperty("headerClass",HeaderClass$)
        #ColumnGroups!.put(id$,str(json!))
    methodend
    rem /**
    rem  * Group Vector of Columns
    rem * @param BBjString id$: the group id
    rem * @param BBjString name$: the group label/name
    rem * @param BBjVector columns!: Vector of columns ids
    rem * @param BBjInt MarryChildren!: Set to 'true' to keep columns in this group beside each other in the grid.
    rem *                               Moving the columns outside of the group (and hence breaking the group) is not allowed.
    rem */
    method public void addColumnGroup(BBjString id$, BBjString name$ , BBjVector columns! , Boolean MarryChildren!)
        #addColumnGroup(id$,name$,columns! , MarryChildren! ,  "" )
    methodend
    rem /**
    rem  * Group Vector of Columns
    rem * @param BBjString id$: the group id
    rem * @param BBjString name$: the group label/name
    rem * @param BBjVector columns!: Vector of columns ids
    rem */
    method public void addColumnGroup(BBjString id$ , BBjString name$, BBjVector columns!)
        #addColumnGroup(id$,name$ , columns! , 1  , "" )
    methodend
    rem /**
    rem  * Set an image list for a given column
    rem  * The column has to contain the values "1","2","3" to x to reference
    rem  * the slices in the BBjImage list
    rem  * @param BBjString colname$: the column name
    rem  * @param BBjImage imagelist!: the image list containing the image sprites
    rem  */
    method public void setColumnImageList(BBjString colname$, BBjImage imagelist!)
        enc! = java.util.Base64.getEncoder()
        list! = new JsonObject()
        for i=1 to int(imageList!.getWidth() / imageList!.getHeight())
            imageSlice!=imageList!.getImageSlice(i-1,imageList!.getHeight())
            bytes$ = imageSlice!.getBytes("png")
            b64$ = enc!.encode(bytes$)
            list!.addProperty(str(i-1),"data:image/png;base64, "+b64$)
        next
        rem adding a clear pixel to reflext the -1 for backwards compatibility to legacy BBj grid
        clearpixel$=enc!.encode($89504E470D0A1A0A0000000D4948445200000001000000010804000000B51C0C020000000B49444154789C63FACF0000020701029A1C31710000000049454E44AE426082$)
        list!.addProperty("-1","data:image/png;base64, "+clearpixel$)
        #AdditionalAttributes!.setFieldValue(colname$,"")
        #AdditionalAttributes!.setFieldAttribute(colname$,"TYPE",#GRID_TYPE_BASIC_IMAGE())
        #AdditionalAttributes!.setFieldAttribute(colname$,"IMAGES_LIST",list!.toString())
    methodend
    rem /**
    rem  * experimental function that shows the developer console
    rem  * (only in GUI, for BUI it's a NOOP)
    rem  */
    method public void showDeveloperConsole()
        if (info(3,6)<>"5") then
            #executeScript("if (!document.getElementById('FirebugLite')){E = document['createElement' + 'NS'] && document.documentElement.namespaceURI;E = E ? document['createElement' + 'NS'](E, 'script') : document['createElement']('script');E['setAttribute']('id', 'FirebugLite');E['setAttribute']('src', 'https://getfirebug.com/' + 'firebug-lite.js' + '#startOpened');E['setAttribute']('FirebugLite', '4');(document['getElementsByTagName']('head')[0] || document['getElementsByTagName']('body')[0]).appendChild(E);E = new Image;E['setAttribute']('src', 'https://getfirebug.com/' + '#startOpened');}")
        FI
    methodend
    rem /**
    rem  * @return constant value to define left aligned column
    rem  */
    method public static BBjNumber GRID_ALIGN_LEFT()
        methodret BBjGrid.GRID_ALIGN_LEFT
    methodend
    rem /**
    rem  * @return constant value to define right aligned column
    rem  */
    method public static BBjNumber GRID_ALIGN_RIGHT()
        methodret BBjGrid.GRID_ALIGN_RIGHT
    methodend
    rem /**
    rem  * @return constant value to define centered column
    rem  */
    method public static BBjNumber GRID_ALIGN_CENTER()
        methodret BBjGrid.GRID_ALIGN_CENTER
    methodend

    method public static BBjNumber GRID_SELECT_ROW()
        methodret BBjGrid.GRID_SELECT_ROW
    methodend
    rem /**
    rem  * @return constant value to define cell selection mode
    rem  */
    method public static BBjNumber GRID_SELECT_CELL()
        methodret BBjGrid.GRID_SELECT_CELL
    methodend
    rem /**
    rem  * @return constant value to define row selection event
    rem  */
    method public static BBjNumber ON_GRID_SELECT_ROW()
        methodret BBjAPI.ON_GRID_SELECT_ROW
    methodend
    rem /**
    rem  * @return constant value to define row double click event
    rem  */
    method public static BBjNumber ON_GRID_DOUBLE_CLICK()
        methodret BBjAPI.ON_GRID_DOUBLE_CLICK
    methodend
    rem /**
    rem  * @return constant value to define cell editing start event
    rem  */
    method public static BBjNumber ON_GRID_CELL_EDITING_STARTED()
        methodret 5000
    methodend
    rem /**
    rem  * @return constant value to define cell editing stop event
    rem  */
    method public static BBjNumber ON_GRID_CELL_EDITING_STOPPED()
        methodret 5002
    methodend
    rem /**
    rem  * @return constant value to define row editing start event
    rem  */
    method public static BBjNumber ON_GRID_ROW_EDITING_STARTED()
        methodret 5003
    methodend
    rem /**
    rem  * @return constant value to define row editing stop event
    rem  */
    method public static BBjNumber ON_GRID_ROW_EDITING_STOPPED()
        methodret 5005
    methodend
    rem /**
    rem  * @return constant value to define cell click event
    rem  */
    method public static BBjNumber ON_GRID_CELL_CLICK()
        methodret 5006
    methodend
    rem /**
    rem  * @return constant value to define cell double click event
    rem  */
    method public static BBjNumber ON_GRID_CELL_DOUBLE_CLICK()
        methodret 5007
    methodend
    rem /**
    rem  * @return constant value to define grid state changes
    rem  */
    method public static BBjNumber ON_GRID_COLUMN_STATE_CHANGE()
        methodret 5008
    methodend
    rem /**
    rem  * @return constant value to define row position
    rem  */
    method public static BBjString GRID_ROWPOS_TOP()
        methodret "top"
    methodend
    rem /**
    rem  * @return constant value to define row position
    rem  */
    method public static BBjString GRID_ROWPOS_MIDDLE()
        methodret "middle"
    methodend
    rem /**
    rem  * @return constant value to define row position
    rem  */
    method public static BBjString GRID_ROWPOS_BOTTOM()
        methodret "bottom"
    methodend
    rem /**
    rem  * @return constant value to define editing mode "row"
    rem  */
    method public static BBjString GRID_EDITTYPE_ROW()
        methodret "fullRow"
    methodend
    rem /**
    rem  * @return constant value to define editing mode "cell"
    rem  */
    method public static BBjString GRID_EDITTYPE_CELL()
        methodret ""
    methodend
    rem /**
    rem  * @return constant value to define string column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_STRING()
        methodret "basic-string"
    methodend
    rem /**
    rem  * @return constant value to define text column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_TEXT()
        methodret "basic-text"
    methodend
    rem /**
    rem  * @return constant value to define number column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_NUMBER()
        methodret "basic-number"
    methodend
    rem /**
    rem  * @return constant value to define boolean column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_BOOLEAN()
        methodret "basic-boolean"
    methodend
    rem /**
    rem  * @return constant value to define date column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_DATE()
        methodret "basic-date"
    methodend
    rem /**
    rem  * @return constant value to define timestamp column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_TIMESTAMP()
        methodret "basic-timestamp"
    methodend
    rem /**
    rem  * @return constant value to define image column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_IMAGE()
        methodret "basic-image"
    methodend
    rem /**
    rem  * @return constant value to define filterable image column types
    rem  */
    method public static BBjString GRID_TYPE_BASIC_IMAGE_FILTERABLE()
        methodret "basic-image-filterable"
    methodend
    rem /**
    rem  * @return constant value to define enter key behavior (Move to next cell)
    rem  */
    method public static BBjString GRID_ENTER_NEXT_CELL()
        methodret "next"
    methodend
    rem /**
    rem  * @return constant value to define navigation behavior (Move to next cell)
    rem  */
    method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_CELL()
        methodret "navigate_next_cell"
    methodend    
    rem /**
    rem  * @return constant value to define navigation behavior (Move to next row)
    rem  */
    method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW()
        methodret "navigate_next_row"
    methodend      
    rem /**
    rem  * @return constant value to define enter key behavior (Stop editing)
    rem  */
    method public static BBjString GRID_ENTER_STOP_EDITING()
        methodret "stop"
    methodend
    rem /**
    rem  * @return constant value which defines that group panel must always be shown
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_VISIBLE()
        methodret "always"
    methodend
    rem /**
    rem  * @return constant value which defines that group panel must be shown only when grouping
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_ONGROUPING()
        methodret "onlyWhenGrouping"
    methodend
    rem /**
    rem  * @return constant value which defines that group panel must always be hidden
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_HIDDEN()
        methodret "never"
    methodend

    method private Object executeScript(BBjString s$)
        if #IsReady! then
            methodret #HTMLView!.executeScript(s$)
        else
            #backlog!.addItem(s$)
        FI

        methodret null()
    methodend

    method private void assertIsEnterprise(BBjString feature$)
        if LEN(#LicenseKey$) <= 0 then
            throw "(" + feature$ + ") is an ag-grid enterprise feature , please set a licence key to use this feature.", 256
        FI
    methodend

    method private void handleStateChangedEvent(BBjString detail$, BBjNumber type!)
        event! = #getColumnState()
        #fireEvent(type!, event!)
    methodend
    rem /**
    rem  * Handle Rows Selections Event
    rem  *
    rem  * Parse the json details coming from the client and fires new BBjGridExWidgetSelectRowEvent
    rem  *
    rem  * @see BBjGridExWidgetSelectRowEvent
    rem  */
    method private void onSelecteRowChange(BBjString detail$, BBjString type$)
        event! = new BBjGridExWidgetSelectRowEvent()
        event!.setSelectedRows(#getSelectedRows())

        if type$ = "single" then
            #fireEvent(#ON_GRID_SELECT_ROW(),event!)
        else
            rem double-click four times on the same row will copy the JSON result set data to the clipboard, in GUI
            if info(3,6)<>"5" and #RS!<> null() then
            r$ = str(#getSelectedRows())

            if #DoubleClickRowsHistory$="" or #DoubleClickRowsHistory$=r$ or #DoubleClickRowsHistory$=r$+r$ then
                #DoubleClickRowsHistory$=#DoubleClickRowsHistory$+r$
            else
                if #DoubleClickRowsHistory$=r$+r$+r$ then
                    clipfromstr 1,#RS!.toJson()
                    a=msgbox("JSON-Data has been copied to the Clipboard",0,"Grid Data")
                    #DoubleClickRowsHistory$=""
                else
                    #DoubleClickRowsHistory$=""
                FI
            FI
        FI

        #fireEvent(#ON_GRID_DOUBLE_CLICK(), event!)
    FI
    methodend

    method private void handleGridCellEditingEvent(BBjString detail$ , BBjNumber type!)
        parser! = new JsonParser()
        array! = parser!.parse(detail$).getAsJsonObject().get("0")
        next! = array!.iterator().next().getAsJsonObject()
        rowAsJson! = next!.get("row").getAsJsonObject()
        row! = new BBjGridExWidgetRow(#RS!)
        row!.setId(rowAsJson!.get("id").getAsString())
        row!.setChildIndex(rowAsJson!.get("childIndex").getAsInt())
        row!.setIndex(rowAsJson!.get("index").getAsString())
        row!.setParentKey(rowAsJson!.get("parentKey").getAsString())
        row!.setIsSelected(iff(rowAsJson!.get("selected").getAsString() = "true" ,  1 , 0))
        event! = new BBjGridWidgetCellEditingEvent()
        event!.setRow(row!)
        event!.setValue(next!.get("value").getAsString())
        event!.setColumn(next!.get("column").getAsString())
        #fireEvent(type!, event!)
    methodend

    method private void handleGridROWEditingEvent(BBjString detail$ , BBjNumber type!)
        parser! = new JsonParser()
        array! = parser!.parse(detail$).getAsJsonObject().get("0")
        next! = array!.iterator().next().getAsJsonObject()
        row! = new BBjGridExWidgetRow(#RS!)
        row!.setId(next!.get("id").getAsString())
        row!.setChildIndex(next!.get("childIndex").getAsInt())
        row!.setIndex(next!.get("index").getAsString())
        row!.setParentKey(next!.get("parentKey").getAsString())
        row!.setIsSelected(iff(next!.get("selected").getAsString() = "true" ,  1 , 0))
        event! = new BBjGridExWidgetDoubleClickRowEvent()
        event!.setRow(row!)
        #fireEvent(type!, event!)
    methodend

    method private void handleGridContextmenuEvent(BBjString detail$)
        parser! = new JsonParser()
        array! = parser!.parse(detail$).getAsJsonObject().get("0")
        next! = array!.iterator().next().getAsJsonObject()
        rowAsJson! = next!.get("row").getAsJsonObject()
        row! = new BBjGridExWidgetRow(#RS!)
        row!.setId(rowAsJson!.get("id").getAsString())
        row!.setChildIndex(rowAsJson!.get("childIndex").getAsInt())
        row!.setIndex(rowAsJson!.get("index").getAsString())
        row!.setParentKey(rowAsJson!.get("parentKey").getAsString())
        row!.setIsSelected(iff(rowAsJson!.get("selected").getAsString() = "true" ,  1 , 0))
        event! = new BBjGridWidgetContextMenuEvent()
        event!.setRow(row!)
        event!.setValue(next!.get("value").getAsString())
        event!.setColumn(next!.get("column").getAsString())
        #fireEvent(next!.get("id").getAsInt(),event!)
    methodend

    method private void performGridDataUpdate()
        if (! #IsReady!)
            methodret
        FI

        gson! = new Gson()
        data$=#RS!.toJson(BBjAPI.TRUE,"__ROW_INDEX")
        cdef!= #getAgGridColumnDefinition()
        comma$=","
        dot$="."
        a$=opts
        if AND ( a$(3,1), $02$ ) = $02$ then
        comma$=a$(5,1)
        dot$=a$(6,1)
    FI

    options! = new JsonObject()
    options!.addProperty("animateRows",Boolean.valueOf(1))
    options!.addProperty("allowContextMenuWithControlKey",Boolean.valueOf(0))
    options!.addProperty("enableFilter",#EnableFilter!)
    options!.addProperty("floatingFilter",#EnableFloatingFilter!)
    options!.addProperty("editType",#EditType$)
    options!.addProperty("singleClickEdit",#SingleClickEdit!)
    options!.addProperty("enableGroupEdit",#GroupEdit!)
    options!.addProperty("rowSelection",iff(#MultipleSelection! = 1 , "multiple" ,"single"))
    options!.addProperty("rowMultiSelectWithClick",#RowMultiSelectWithClick!)
    options!.addProperty("rowDeselection",#RowDeselection!)
    options!.addProperty("suppressRowClickSelection",#SuppressRowClickSelection!)
    options!.addProperty("groupSelectsChildren",#GroupSelectsChildren!)
    options!.addProperty("enableRangeSelection",#RangeSelection!)
    options!.addProperty("functionsReadOnly",#FunctionsReadOnly!)
    options!.addProperty("rowGroupPanelShow",#RowGroupPanelShow$)
    options!.addProperty("rowGroupPanelShow",#RowGroupPanelShow$)
    options!.addProperty("groupMultiAutoColumn",#GroupMultiAutoColumn!)
    options!.addProperty("groupUseEntireRow",#GroupUseEntireRow!)
    options!.addProperty("groupIncludeFooter",#GroupIncludeFooter!)
    options!.addProperty("groupIncludeTotalFooter",#GroupIncludeTotalFooter!)
    options!.addProperty("rowHeight",#RowHeight!.longValue())
    options!.addProperty("sideBar",#Sidebar!.toString())
    options!.addProperty("statusBar",#Statusbar!.toString())
    options!.addProperty("localeText" , #getLanguageManager().getLanguageKeys())
    autoGroupColumnDef! = new JsonObject()

    if #GroupMultiAutoColumn! = 0 then
        autoGroupColumnDef!.addProperty("headerName",#GroupColumnLabel$)
    FI

    autoGroupColumnDefCellRendererParams! = new JsonObject()
    autoGroupColumnDefCellRendererParams!.addProperty("suppressCount", 1 - #ShowGroupChildCount!)
    autoGroupColumnDefCellRendererParams!.addProperty("checkbox", #ShowGroupSelectionCheckbox!)
    autoGroupColumnDefCellRendererParams!.addProperty("footerValueGetter", #GroupColumnFooterGetter$)
    autoGroupColumnDef!.add("cellRendererParams",autoGroupColumnDefCellRendererParams!)
    options!.add("autoGroupColumnDef",autoGroupColumnDef!)
    options!.add("columnDefs",cdef!)
    context! = new JsonObject()
    context!.addProperty("id",#GRIDID$)
    context!.addProperty("getRowNodeId",#RowNodeId$)
    context!.addProperty("getParentNodeId",#ParentNodeId$)
    context!.addProperty("enterKeyBehavior",#EnterKeyBehavior$)
    context!.addProperty("columnsGroup", new Gson().toJson(#ColumnGroups!))
    context!.addProperty("numberGroupSep",comma$)
    context!.addProperty("numberDecimalSep",dot$)
    context!.addProperty("locale",#getLanguageManager().getLanguage())
    context!.addProperty("contextMenu",#ContextMenu!.toString())
    context!.addProperty("NUMBERS_RENDERER_GROUP_SEPARATOR",comma$)
    context!.addProperty("NUMBERS_RENDERER_DECIMAL_SEPARATOR",dot$)
    context!.addProperty("showSelectionCheckbox",#ShowSelectionCheckbox!)
    context!.addProperty("showHeaderSelectionCheckbox",#ShowHeaderSelectionCheckbox!)
    context!.addProperty("contextMenu",#ContextMenu!.toString())
    context!.addProperty("navigateToNextCell",Iff(#NavigationBehavior$ = #GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW() , 1 , 0))

    options!.add("context",context!)
    #HTMLView!.executeScript("gw_setData(" + data$ + "," + gson!.toJson(options!) + ",'" + #LicenseKey$ + "')")
    methodend

    method private JsonArray getAgGridColumnDefinition()
        declare DataRow cd!

        cd! = #ColumnDefinition!

        if #AttributesRecord! <> NULL() and cd! <> NULL() then
            if REV>"REV 18.11" then
                cd!.copyAttributes(ar!)
            else
                ar! = #AttributesRecord!
                it! = cd!.getFieldNames().iterator()
                while it!.hasNext()
                    f$ = it!.next()

                    if cd!.contains(f$) then
                        cd!.setFieldAttributes(f$,ar!.getFieldAttributes(f$))
                    FI
                wend
            FI
        FI

        if cd! = null() and #AttributesRecord!<> null() then
        cd! = #AttributesRecord!
    FI

    if cd! = null() or cd!.getFieldNames().size()=0  then
        if #RS! <> null() and #RS!.size()>0 then
            cd! = #RS!.get(0)
        FI
    FI

    cdef! = new JsonArray()
    first=1

    if cd! = null() or cd!.getFieldNames().size()=0  then
        methodret cdef!
    FI

    f! = cd!.getFieldNames()
    it! = f!.iterator()
    while it!.hasNext()=BBjAPI.TRUE
        f$=str(it!.next())
        label$=""
        label$=cd!.getFieldAttribute(f$,"LABEL",err=*next)

        if label$="" then
            label$=f$
        FI

        node! = new JsonObject()
        node!.addProperty("headerName",label$)
        node!.addProperty("field",f$)

        pin$=""
        pin$=cd!.getFieldAttribute(f$,"PINNED",err=*next)

        if pin$>"" then
            node!.addProperty("pinned",pin$)
        FI

        width$=""
        width$=cd!.getFieldAttribute(f$,"WIDTH",err=*next)

        if width$>"" then
            node!.addProperty("width",num(width$))
        FI

        editable! = 0
        editable!= num(cd!.getFieldAttribute(f$,"EDITABLE",err=*next))

        if editable! > 0 and #Editable! > 0 then
            node!.addProperty("editable",1)
        else
            node!.addProperty("editable",0)
        FI

        aggFunc$ = cd!.getFieldAttribute(f$,"AGG_FUNC",err=*next)

        if len(aggFunc$) > 0 then
            node!.addProperty("aggFunc",aggFunc$)
        FI

        allowedAggFuncs$ = cd!.getFieldAttribute(f$,"ALLOWED_AGG_FUNCS",err=*next)

        if len(aggFunc$) > 0 then
            node!.addProperty("ALLOWED_AGG_FUNCS",allowedAggFuncs$)
        FI

        footerValueGetter$ = cd!.getFieldAttribute(f$,"FOOTER_VALUE_GETTER",err=*next)

        if len(footerValueGetter$) > 0 then
            node!.addProperty("FOOTER_VALUE_GETTER",footerValueGetters$)
        FI

        enableValue!= num(cd!.getFieldAttribute(f$,"ENABLE_VALUE",err=*next))

        if enableValue! > 0 then
            node!.addProperty("enableValue",1)
        else
            node!.addProperty("enableValue",#EnableValue!)
        FI

        enableRowGroup!= num(cd!.getFieldAttribute(f$,"ENABLE_ROW_GROUP",err=*next))

        if enableRowGroup! > 0 then
            node!.addProperty("enableRowGroup",1)
        else
            node!.addProperty("enableRowGroup",#EnableRowGroup!)
        FI

        enablePivot!= num(cd!.getFieldAttribute(f$,"ENABLE_PIVOT",err=*next))

        if enablePivot! > 0 then
            node!.addProperty("enablePivot",1)
        else
            node!.addProperty("enablePivot",#EnablePivot!)
        FI

        cellClass$=""
        cellClass$=cd!.getFieldAttribute(f$,"CELL_CLASS")

        if cellClass$>"" then
            node!.addProperty("cellClass",cellClass$)
        FI

        type! = ""
        type!= cd!.getFieldAttribute(f$,"TYPE",err=*next)

        if type! <> "" then
            node!.addProperty("type",type!)
        else
            switch cd!.getFieldType(f$)
                case Types.INTEGER
                case Types.DECIMAL
                case Types.DOUBLE
                case Types.NUMERIC
                    node!.addProperty("type",#GRID_TYPE_BASIC_NUMBER())
                    break
                case Types.DATE
                    node!.addProperty("type",#GRID_TYPE_BASIC_DATE())
                    break
                case Types.TIMESTAMP
                    node!.addProperty("type",#GRID_TYPE_BASIC_TIMESTAMP())
                    break
                case Types.BOOLEAN
                    node!.addProperty("type",#GRID_TYPE_BASIC_BOOLEAN())
                    break
                case default
                    node!.addProperty("type",#DefaultType$)
                    break
            swend
        FI

        bgc$=""
        bgc$=cd!.getFieldAttribute(f$,"BGCOLOR",err=*next)
        fgc$=""
        fgc$=cd!.getFieldAttribute(f$,"FGCOLOR",err=*next)
        align$=""
        align$=cd!.getFieldAttribute(f$,"ALIGN",err=*next)
        f=0

        if (bgc$>"" OR fgc$>"" or align$>"") then
            cellStyleDefaults! = new JsonObject()

            if (fgc$>"") then
                cellStyleDefaults!.addProperty("FGCOLOR",fgc$)
                f=1
            FI

            if bgc$>"" then
                cellStyleDefaults!.addProperty("BGCOLOR",bgc$)
                f=1
            FI

            if align$>"" then
                cellStyleDefaults!.addProperty("ALIGN",align$)
                f=1
            FI

            node!.add("cellStyleDefaults",cellStyleDefaults!)
        FI

        first = 0
        cdef!.add(node!)
    wend

    methodret cdef!
    methodend
    rem /**
    rem  * A public access to the excute method
    rem  *
    rem  * NOTE : even though the method is declared as public , it is not meant for public usage.
    rem  *        this method is used by external classes integrated with the widget
    rem  *        like BBjGridExWidgetSidebar.
    rem  *
    rem  * @param BBjString script$
    rem  */
    method public void __executeScript__(BBjString script!)
        #executeScript(script!)
    methodend

    method public static BBjString getImageData(BBjString filename$)
        imageSlice!=BBjAPI().getSysGui().getImageManager().loadImageFromFile(filename$)
        bytes$ = str(imageSlice!.getBytes("png"))
        b64$ = java.util.Base64.getEncoder().encode(bytes$)
        methodret "data:image/png;base64, "+b64$
    methodend

classend
