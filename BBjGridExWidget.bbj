rem package BBjGridExWidget
rem /**
rem  * This file is part of the BBjGridExWidget plugin.
rem  * (c) Basis Europe <eu@basis.com>
rem  *
rem  * For the full copyright and license information, please view the LICENSE
rem  * file that was distributed with this source code.
rem  */
use java.util.Arrays
use java.util.ArrayList
use java.util.HashSet
use java.util.LinkedHashMap
use java.lang.StringBuilder
use java.sql.Types
use com.google.gson.Gson
use com.google.gson.JsonParser
use com.google.gson.JsonObject
use com.google.gson.JsonArray
use com.google.gson.JsonPrimitive
rem Basis Components
rem ==========================
use com.basiscomponents.db.ResultSet
use com.basiscomponents.db.DataRow
rem BBjWidget
rem ==========================
use ::BBjWidget/BBjWidget.bbj::BBjWidget
rem BBjGridExWidget Package
rem ==========================
use ::BBjGridExWidget/GxOptions.bbj::GxOptions
use ::BBjGridExWidget/util/LicenseManager.bbj::LicenseManager
use ::BBjGridExWidget/GxState.bbj::GxState
use ::BBjGridExWidget/GxLanguageManager.bbj::GxLanguageManager
use ::BBjGridExWidget/GxClientJsonFactory.bbj::GxClientJsonFactory
rem Client Events
rem ==========================
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRowSelection
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsContextMenu
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsCell
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRowEditing
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsRangeSelection
use ::BBjGridExWidget/GxClientEvents.bbj::GxClientEventsKeypress
rem Sidebars
rem ==========================
use ::BBjGridExWidget/GxSidebar.bbj::GxSidebar
use ::BBjGridExWidget/GxSidebar.bbj::GxDefaultSidebar
use ::BBjGridExWidget/GxSidebar.bbj::GxFiltersToolpanel
rem Statusbar
rem ==========================
use ::BBjGridExWidget/GxStatusBar.bbj::GxStatusBar
rem Context Menu
rem ==========================
use ::BBjGridExWidget/GxContextMenu.bbj::BBjGridContextMenu
use ::BBjGridExWidget/GxContextMenu.bbj::BBjGridDefaultContextMenu
rem Expressions
rem ==========================
use ::BBjGridExWidget/GxExpressions.bbj::GxExpressionInterface
use ::BBjGridExWidget/GxExpressions.bbj::GxExpression
rem Columns
rem ==========================
use ::BBjGridExWidget/GxColumns.bbj::GxDefaultColumnDefinition
use ::BBjGridExWidget/GxColumns.bbj::GxAutoGroupColumn
use ::BBjGridExWidget/GxColumns.bbj::GxColumn
use ::BBjGridExWidget/GxColumns.bbj::GxDefaultColumnGroup
use ::BBjGridExWidget/GxColumns.bbj::GxColumnGroup
use ::BBjGridExWidget/GxColumns.bbj::GxColumnsManagerInterface
use ::BBjGridExWidget/GxColumns.bbj::GxColumnsManager
rem Renderers
rem ==========================
use ::BBjGridExWidget/GxRenderers.bbj::GxRendererImageRenderer
rem Client Models
rem ==========================
use ::BBjGridExWidget/GxClientModels.bbj::GxClientRowModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientAddRangeSelectionModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientAddRangeChartModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientSortModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientTransactionModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterNumberModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterTextModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterDateTimeModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterBooleanModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterCombinedModel
use ::BBjGridExWidget/GxClientModels.bbj::GxClientFilterSetFilterModel
rem Filter Components
rem ==========================
use ::BBjGridExWidget/GxFilters.bbj::GxFilterText
use ::BBjGridExWidget/GxFilters.bbj::GxFilterNumber
use ::BBjGridExWidget/GxFilters.bbj::GxFilterBasicBoolean
use ::BBjGridExWidget/GxFilters.bbj::GxFilterBasicTimestamp
use ::BBjGridExWidget/GxFilters.bbj::GxFilterSetFilter
rem /**
rem  * The Grid Core Class.This class works as a columns manager and api provider.
rem  * It contains a big number of methods and properties to configure the column from A..Z.
rem  * Every property and method has one or more tag attached.
rem  *
rem  * The following is the meaning for each tag :<br><br>
rem  *
rem  *
rem  * <table border="1" cellpadding="10">
rem  *  <tbody>
rem  *      <tr>
rem  *          <td><strong>&nbsp;Enterprise</strong></td>
rem  *          <td>The property/method is used only with the enterprise version&#183; using it without having a valid license will<br />be ignored&#183;</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td>&nbsp;<strong>Configuration</strong></td>
rem  *          <td>Properties and methods which are tagged with&nbsp;this tag are used to configure the grid before it is rendered on the client&#183;<br />Changing these properties or calling these methods won't affect&nbsp;the grid which is displayed on the client&#183;<br />In order to reflect your changes on the client, you need to re-render the whole grid <br />or re-render the column definition once again&#183;</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td>&nbsp;<strong>API</strong></td>
rem  *          <td>Methods/properties tagged with this tag can be called before or after the grid is rendered on the client and they don't require a refresh&#183;</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td><strong>&nbsp;ColumnsRenderer</strong></td>
rem  *          <td>Changing this property or calling this method after the first render require columns re-render using <i>updateColumns()</i> method</td>
rem  *      </tr>
rem  *      <tr>
rem  *          <td><strong>&nbsp;GridRenderer</strong></td>
rem  *          <td>Changing this property or calling this method after the first render require full re-render using <i>render()</i> method</td>
rem  *      </tr>
rem  *  </tbody>
rem  * </table>
rem  *
rem  * @author Stephan Wald
rem  * @author Hyyan Abo Fakher
rem  */
class public BBjGridExWidget extends BBjWidget implements GxColumnsManagerInterface
    rem /**
    rem  * The Grid enterprise key
    rem  */
    field public static BBjString LicenseKey$
    rem /**
    rem  * When true, the grid will force using the community version of the grid whether there
    rem  * is a license key or not.
    rem  */
    field public static BBjNumber ForceCommunityBuild! = 0
    rem /**
    rem  * When true the grid will use the unmingled version of the Javascript code then open the debugger
    rem  * in the browser when the CHROMIUM_HTMLVIEW is in use&#183;<br>
    rem  * <b>Note :</b> in BBj 19.10 and higher the grid will open the debugger only when the debugging port is set
    rem  * <pre><code>
    rem  *      chromiumSwitches$ = stbl("!CHROMIUM_SWITCHES","--remote-debugging-port=9222")
    rem  * </code></pre>
    rem  */
    field public static BBjNumber Debug = 0
    rem /**
    rem  * Unique auto generate id for the grid instance&#183; This id is used in the client to distinguish instances
    rem  */
    field public BBjString GRIDID$ = java.util.UUID.randomUUID().toString()
    rem /**
    rem  * The unique string to use as row inedx&#183; default is __ROW_INDEX
    rem  */
    field public BBjString RowNodeId$ = "__ROW_INDEX"
    rem /**
    rem  * The ResultSet instance
    rem  */
    field public ResultSet RS! = new ResultSet()
    rem /**
    rem  * Columns Manager instance
    rem  */
    field public GxColumnsManager ColumnsManager! = new GxColumnsManager()
    rem /**
    rem  * Instance of the grid options class
    rem  */
    field public GxOptions Options! = new GxOptions(#this!)
    rem /**
    rem  * Instance of GxClientJsonFactory to convert client JSON strings to Client Models
    rem  */
    field protected GxClientJsonFactory ClientJsonFactory! = new GxClientJsonFactory(#this!)
    rem /**
    rem  * The vector holds the registered events
    rem  */
    field protected JsonArray Interests! = new JsonArray()
    rem /**
    rem  * An array which contains the supported toolbar items
    rem  */
    field protected JsonArray ChartToolbarItems! = new JsonArray()
    rem /**
    rem  * The client's HTML template to use in order to build the grid&#183;
    rem  */
    field protected BBjString Template$ = ""
    rem /**
    rem  * Instance of the grid's license manager
    rem  */
    field protected static LicenseManager LicenseManager! = new LicenseManager()
    rem /**
    rem  * Instance of the created HTMLView
    rem  */
    field public BBjHtmlView HTMLView!
    rem /**
    rem  * A flag which defines when the grid is ready and the process events started
    rem  */
    field public Boolean IsReady! = BBjAPI.FALSE
    field protected BBjVector backlog! = new BBjVector()
    field protected BBjString URL$
    field protected BBjNumber newW!
    field protected BBjNumber newH!
    rem /**
    rem  * Constant value to define row click events
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_CLICK()
        methodret 5011
    methodend
    rem /**
    rem  * A Constant value to define row selection (selected/deselected) change events
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_SELECT_ROW()
        methodret BBjAPI.ON_GRID_SELECT_ROW
    methodend
    rem /**
    rem  * Alias for ON_GRID_SELECT_ROW
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_SELECT()
        methodret #ON_GRID_SELECT_ROW()
    methodend
    rem /**
    rem  * Constant value to define row double-click event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_DOUBLE_CLICK()
        methodret BBjAPI.ON_GRID_DOUBLE_CLICK
    methodend
    rem /**
    rem  * Alias to <i>ON_GRID_ROW_DOUBLE_CLICK()</i>
    rem  *
    rem  * @see ON_GRID_ROW_DOUBLE_CLICK()
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_DOUBLE_CLICK()
        methodret #ON_GRID_ROW_DOUBLE_CLICK()
    methodend
    rem /**
    rem  * Constant value to define cell click event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_CELL_CLICK()
        methodret 5001
    methodend
    rem /**
    rem  * Constant value to define cell double-click event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_CELL_DOUBLE_CLICK()
        methodret 5002
    methodend
    rem /**
    rem  * Constant value to define cell editing start event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_CELL_EDITING_STARTED()
        methodret 5003
    methodend
    rem /**
    rem  * Constant value to define cell editing stop event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_CELL_EDITING_STOPPED()
        methodret 5004
    methodend
    rem /**
    rem  * Constant value to define cell value changed event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_CELL_VALUE_CHANGED()
        methodret 5005
    methodend
    rem /**
    rem  * Constant value to define row editing start event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_EDITING_STARTED()
        methodret 5006
    methodend
    rem /**
    rem  * Constant value to define A row has changed. 
    rem  * This event corresponds to Full Row Editing only.
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_VALUE_CHANGED()
        methodret 5012
    methodend    
    rem /**
    rem  * Constant value to define row editing stop event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_ROW_EDITING_STOPPED()
        methodret 5007
    methodend
    rem /**
    rem  * Constant value to define grid state changes
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_STATE_CHANGE()
        methodret 5008
    methodend
    rem /**
    rem  * Constant value to define range selection event
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_RANGE_SELECTION_CHANGED()
        methodret 5009
    methodend
    rem /**
    rem  * Constant value to define keyboard keypress
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_KEYPRESS()
        methodret 5010
    methodend
    rem /**
    rem  * Alias for <i>ON_GRID_STATE_CHANGE()</i>
    rem  *
    rem  * @see ON_GRID_STATE_CHANGE()
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber ON_GRID_COLUMN_STATE_CHANGE()
        methodret #ON_GRID_STATE_CHANGE()
    methodend
    rem /**
    rem  * Constant value to define left aligned column
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber GRID_ALIGN_LEFT()
        methodret BBjGrid.GRID_ALIGN_LEFT
    methodend
    rem /**
    rem  * Constant value to define right aligned column
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber GRID_ALIGN_RIGHT()
        methodret BBjGrid.GRID_ALIGN_RIGHT
    methodend
    rem /**
    rem  * Constant value to define centered column
    rem  *
    rem  * @return BBjNumber
    rem  */
    method public static BBjNumber GRID_ALIGN_CENTER()
        methodret BBjGrid.GRID_ALIGN_CENTER
    methodend
    rem /**
    rem  * Constant value to define row position
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_ROWPOS_TOP()
        methodret "top"
    methodend
    rem /**
    rem  * Constant value to define row position
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_ROWPOS_MIDDLE()
        methodret "middle"
    methodend
    rem /**
    rem  * Constant value to define row position
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_ROWPOS_BOTTOM()
        methodret "bottom"
    methodend
    rem /**
    rem  * Constant value to define editing mode "row"
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_EDITTYPE_ROW()
        methodret "fullRow"
    methodend
    rem /**
    rem  * Constant value to define editing mode "cell"
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_EDITTYPE_CELL()
        methodret ""
    methodend
    rem /**
    rem  * Constant value to define enter key behavior (Move to next cell)
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_ENTER_NEXT_CELL()
        methodret "next"
    methodend
    rem /**
    rem  * Constant value to define navigation behavior (Move to next cell)
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_CELL()
        methodret "navigate_next_cell"
    methodend
    rem /**
    rem  * Constant value to define navigation behavior (Move to next row)
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_NAVIGATION_BEHAVIOUR_NEXT_ROW()
        methodret "navigate_next_row"
    methodend
    rem /**
    rem  * Constant value to define enter key behavior (Stop editing)
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_ENTER_STOP_EDITING()
        methodret "stop"
    methodend
    rem /**
    rem  * Constant value which defines that group panel must always be shown
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_VISIBLE()
        methodret "always"
    methodend
    rem /**
    rem  * Constant value which defines that group panel must be shown only when grouping
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_ONGROUPING()
        methodret "onlyWhenGrouping"
    methodend
    rem /**
    rem  * Constant value which defines that group panel must always be hidden
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_GROUPPANEL_SHOW_HIDDEN()
        methodret "never"
    methodend
    rem /**
    rem  * Constant value which defines that chart toolbar settings item
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString CHART_TOOLBAR_SETTINGS()
        methodret "chartSettings"
    methodend
    rem /**
    rem  * Constant value which defines that chart toolbar data item
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString CHART_TOOLBAR_DATA()
        methodret "chartData"
    methodend
    rem /**
    rem  * Constant value which defines that chart toolbar format item
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString CHART_TOOLBAR_FORMAT()
        methodret "chartFormat"
    methodend
    rem /**
    rem  * Constant value which defines that chart toolbar download item
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString CHART_TOOLBAR_DOWNLOAD()
        methodret "chartDownload"
    methodend
    rem /**
    rem  * Constant value which defines that balham theme
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_THEME_BALHAM()
        methodret "balham"
    methodend
    rem /**
    rem  * Constant value which defines that balham dark theme
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_THEME_BALHAM_DARK()
        methodret "balham-dark"
    methodend
    rem /**
    rem  * Constant value which defines the material theme
    rem  *
    rem  * @return BBjString
    rem  */
    method public static BBjString GRID_THEME_MATERIAL()
        methodret "material"
    methodend
    rem /**
    rem  * Make Hex Color
    rem  *
    rem  * Convert the given BBjColor to a hex color string
    rem  *
    rem  * @param BBjColor color! BBj color
    rem  *
    rem  * @return BBjString hex color
    rem  */
    method public static BBjString makeHexColor(BBjColor color!)
        methodret "#"+hta(chr(color!.getRed()))+hta(chr(color!.getGreen()))+hta(chr(color!.getBlue()))
    methodend
    rem /**
    rem  * Convert the image at the given path to base64 string
    rem  *
    rem  * @param BBjString filename! The image's path
    rem  *
    rem  * @return BBjString Image as base64 string
    rem  */
    method public static BBjString imageToBase64(BBjString filename!)
        imageSlice!=BBjAPI().getSysGui().getImageManager().loadImageFromFile(filename!)
        bytes$ = str(imageSlice!.getBytes("png"))
        b64$ = java.util.Base64.getEncoder().encode(bytes$)
        methodret "data:image/png;base64, "+b64$
    methodend
    rem /**
    rem  * Alais for <i>imageToBase64()</i>
    rem  *
    rem  * @see imageToBase64()
    rem  */
    method public static BBjString getImageData(BBjString filename!)
        methodret BBjGridExWidget.imageToBase64(filename!)
    methodend
    rem /**
    rem  * The method will check whether the grid has license key or not.
    rem  *
    rem  * @return BBjNumber true when a license key is found, false otherwise
    rem  */
    method public static BBjNumber isLicensed()
        #getLicenseManager().setLicenseKey(#getLicenseKey())
        methodret #getLicenseManager().isLicensed()
    methodend
    rem /**
    rem  * disabled default constructor
    rem  */
    method public BBjGridExWidget()
    methodend
    rem /**
    rem  * The constructor that creates the widget on wnd!
    rem  *
    rem * @param BBjWindow wnd!! parent window
    rem * @param BBjNumber id! the control ID
    rem * @param BBjNumber x! x-location
    rem * @param BBjNumber y! y-location
    rem * @param BBjNumber w! width
    rem * @param BBjNumber h! height
    rem */
    method public BBjGridExWidget(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
        #create(wnd!,id!,x!,y!,w!,h!,"")
    methodend
    rem /**
    rem  * The constructor that creates the widget on wnd!
    rem  *
    rem * @param BBjWindow wnd!! parent window
    rem * @param BBjNumber id! the control ID
    rem * @param BBjNumber x! x-location
    rem * @param BBjNumber y! y-location
    rem * @param BBjNumber w! width
    rem * @param BBjNumber h! height
    rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
    rem  *                           By default you will never need  to change the default Template.
    rem  *                           Unless you want to do something really unusual
    rem */
    method public BBjGridExWidget(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h! , BBjString template$)
        #create(wnd!,id!,x!,y!,w!,h!,template$)
    methodend
    rem /**
    rem  * The constructor that creates the widget in the ChildWindow
    rem  *
    rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
    rem  */
    method public BBjGridExWidget(BBjChildWindow wnd!)
        #create(wnd!,"")
    methodend
    rem /**
    rem  * The constructor that creates the widget in the ChildWindow
    rem  *
    rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
    rem  * @param BBjString template$ The client's HTML template to use in order to build the grid.
    rem  *                           By default you will never need  to change the default Template.
    rem  *                           Unless you want to do something really unusual
    rem  */
    method public BBjGridExWidget(BBjChildWindow wnd!,BBjString template$)
        #create(wnd!,template$)
    methodend
    rem /**
    rem  * Create the widget
    rem  *
    rem * @param BBjWindow wnd!! parent window
    rem * @param BBjNumber id! the control ID
    rem * @param BBjNumber x! x-location
    rem * @param BBjNumber y! y-location
    rem * @param BBjNumber w! width
    rem * @param BBjNumber h! height
    rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
    rem  *                           By default you will never need  to change the default Template.
    rem  *                           Unless you want to do something really unusual
    rem  *
    rem  * @Override
    rem  */
    method protected void create(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!, BBjString template$)
        #super!.setCanvas(wnd!.addChildWindow(id!,x!,y!,w!,h!,"",$00000800$,BBjAPI().getSysGui().getAvailableContext()))
        #super!.setX(x!)
        #super!.setY(y!)
        #super!.setW(w!)
        #super!.setH(h!)
        #RS!.createIndex()
        #fillChartToolbarItems()
        #setTemplate(template$)
        #redraw(BBjAPI.TRUE)
    methodend
    rem /**
    rem  * Create the widget
    rem  *
    rem * @param BBjWindow wnd!! parent window
    rem * @param BBjNumber id! the control ID
    rem * @param BBjNumber x! x-location
    rem * @param BBjNumber y! y-location
    rem * @param BBjNumber w! width
    rem * @param BBjNumber h! height
    rem  *
    rem  * @Override
    rem  */
    method protected void create(BBjWindow wnd!, BBjNumber id!, BBjNumber x!, BBjNumber y!, BBjNumber w!, BBjNumber h!)
        #create(wnd!,id!,x!,y!,w!,h!,"")
    methodend
    rem /**
    rem  * Create the widget
    rem  *
    rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
    rem * @param BBjString template$ The client's HTML template to use in order to build the grid.
    rem  *                           By default you will never need  to change the default Template.
    rem  *                           Unless you want to do something really unusual
    rem  *
    rem  * @Override
    rem  */
    method protected void create(BBjChildWindow wnd!,BBjString template$)
        #super!.setCanvas(wnd!)
        #super!.setX(wnd!.getX())
        #super!.setY(wnd!.getY())
        #super!.setW(wnd!.getWidth())
        #super!.setH(wnd!.getHeight())
        #RS!.createIndex()
        #fillChartToolbarItems()
        #setTemplate(template$)
        #redraw(BBjAPI.TRUE)
    methodend
    rem /**
    rem  * Create the widget
    rem  *
    rem  * @param BBjChildWindow wnd!: the child window in which to create the BBjGridExWidget
    rem  * @param BBjString template$ the html template to use for the grid initialization
    rem  *
    rem  * @Override
    rem  */
    method protected void create(BBjChildWindow wnd!)
        #create(wnd!,"")
    methodend
    REM /**
    REM  * Get the unique control type
    REM  *
    REM  * @returns int controlType = 65001
    REM  */
    method public int getControlType()
        methodret 65001
    methodend
    rem /**
    rem  * Register an event handler
    rem  *
    rem  * @param Int type! The event's type
    rem  * @param String callback! The event's callback
    rem  *
    rem  * @Override
    rem  */
    method public void setCallback(int type!, String callback!)
        #super!.setCallback(type!,callback!)
        #getInterests().add(type!)
        #updateClientWithInterests()
    methodend
    rem /**
    rem  * Register an event handler
    rem  *
    rem  * @param Int type! The event's type
    rem  * @param CustomObject instance! class instance
    rem  * @param String method! method name
    rem  *
    rem  * @Override
    rem  */
    method public void setCallback(int type!, CustomObject instance!, String method!)
        #super!.setCallback(type!, instance!, method!)
        #getInterests().add(type!)
        #updateClientWithInterests()
    methodend
    rem /**
    rem  * Remove callback
    rem  *
    rem  * @param Int type! The event's type
    rem  *
    rem  * @Override
    rem  */
    method public void clearCallback(int type!)
        #super!.clearCallback(type!)
        interests! = #getInterests()
        el! = new JsonPrimitive(type!)

        if(interests!.contains(el!)) then
            interests!.remove(el!)
            #updateClientWithInterests()
        FI
    methodend
    rem /**
    rem  * @Override
    rem  *
    rem  * This method is called whenever the widget needs to be rendered
    rem  *
    rem  * @param Boolean f_init! if TRUE then the control is rendered for the first time so this method
    rem  *                         has to perform initial rendering
    rem  */
    method public void redraw(Boolean f_init!)
        declare BBjHtmlView htmlview!

        if (f_init!) then
            html$ = #getTemplate()

            if (info(3,6)<>"5" and #Debug>0) then
                if (REV < "REV 19.10")
                    call "BBjGridExWidget/util/EnableDebugger.bbj"
                FI
            FI

            if (REV < "REV 19.10")
                htmlview! = #getCanvas().addHtmlView(101,0,0,#getCanvas().getWidth(),#getCanvas().getHeight(),"",$0000$)
            else
                switches$ = stbl("!CHROMIUM_SWITCHES",err=*next)
                htmlview! = #getCanvas().addHtmlView(101,0,0,#getCanvas().getWidth(),#getCanvas().getHeight(),"",$0000$,switches$)
            FI

            htmlview!.setOpaque(0)
            htmlview!.setNoEdge(1)
            htmlview!.setTabTraversable(1)
            htmlview!.setFocusable(1)

            if (info(3,6)<>"5" and #Debug>0) then
                url$ = htmlview!.getAttribute("remoteDebuggingURL")

                if url$>"" then
                    BBjAPI().getThinClient().browse(url$)
                FI
            FI

            htmlview!.setCallback(BBjAPI.ON_PAGE_LOADED,#this!,"onInit")
            htmlview!.setCallback(BBjAPI.ON_NATIVE_JAVASCRIPT,#this!,"onNativeEvent")
            htmlview!.setCallback(BBjAPI.ON_GAINED_FOCUS,#this!,"onGainedFocus")
            htmlview!.setText(html$)
            #HTMLView!=htmlview!
        else
            #HTMLView!.setSize(#getCanvas().getWidth(),#getCanvas().getHeight())
        FI
    methodend
    rem /**
    rem  * Inject a js Script at the top window.
    rem  *
    rem  * If for some reason you want to inject a script in the iframe , then use the injectScript method
    rem  * from the created internal HTML View.
    rem  *
    rem  * @see <a href="https://documentation.basis.com/BASISHelp/WebHelp/index.htm">BBjHtmlView::injectScript</a>
    rem  *
    rem  * @param BBjString script$ the path for the javascript file
    rem  */
    method public void injectScript(BBjString script$)
        #HTMLView!.injectScript(script$ , 1)
    methodend
    rem /**
    rem  * Execute a javascript code on the client.
    rem  *
    rem  * Note that if the grid is not ready yet , then script will queued until the grid is ready then send
    rem  * to the client.
    rem  * If some reason you do not want this behavior , then use the executeScript method from the created internal
    rem  * HTML View
    rem  *
    rem  * @see <a href="https://documentation.basis.com/BASISHelp/WebHelp/index.htm">BBjHtmlView::executeScript</a>
    rem  *
    rem  * @param BBjString script$ The javascript code
    rem  *
    rem  * @return Object returned value, if any
    rem  */
    method public Object executeScript(BBjString script$)
        if #IsReady! then
            methodret #HTMLView!.executeScript(script$)
        else
            #backlog!.addItem(script$)
        FI

        methodret null()
    methodend
    rem /**
    rem  * An Event listener executed after the initial load of the HTML View.
    rem  *
    rem  * At this phase the grid will inject all required js files in the client to make the grid functional.
    rem  *
    rem  * @param BBjEvent ev! The onLoad event
    rem  */
    method public void onInit(BBjEvent ev!)
        #HTMLView!.clearCallback(BBjAPI.ON_PAGE_LOADED)
        isLicensed! = 0
        if (#getForceCommunityBuild() = 0) then isLicensed! = #isLicensed() FI
        rem /**
        rem  * work out the required js files
        rem  */
        basePath$ = "BBjGridExWidget/client/dist"
        agGridPath$ = iff(isLicensed!, (basePath$ + "/ag-grid-enterprise.min.noStyle.js") , (basePath$ +"/ag-grid-community.min.noStyle.js"))
        gxPath$ = basePath$ + "/bbj-grid-widget.min.js"
        rem for debugging we inject the unminified files which contain source maps of the original code
        if #getDebug() = 1 then
            agGridPath$ = iff(isLicensed!, (basePath$ + "/ag-grid-enterprise.noStyle.js") , (basePath$ +"/ag-grid-community.noStyle.js"))
            gxPath$ = basePath$ + "/bbj-grid-widget.js"
        FI
        rem /**
        rem  * Bundle the content of all required scripts
        rem  */
        scriptsSet! = new HashSet()
        scriptsSet!.add(agGridPath$)
        scriptsSet!.add(gxPath$)
        rem /**
        rem  * This is the most important piece , without it the grid won't work in GUI
        rem  *
        rem  * Why?
        rem  *
        rem  * in BUI we use GWT ad GWT uses $wnd instead of window because compiled code is executed normally in an iframe,
        rem  * and in this context, window will reference the iframe window while $wnd will reference the parent window.
        rem  * The same occurs with $doc which is a reference in the iframe to the parent document.
        rem  *
        rem  * All JS calls we run from the grid are executed in the $wnd context because all scripts
        rem  * are inject in the top level window
        rem  *
        rem  * In GUI there is no iframe which means theres is no $wnd or $doc , because of this all
        rem  * the JS code we execute from the grid will throw an error , we polyfill these two vars
        rem  * for GUI to get around the problem
        rem  */
        bundle$ = "var $wnd = (typeof $wnd !== 'undefined' ? $wnd : window);"
        bundle$ = bundle$ + "var $doc = (typeof $doc !== 'doc' ? $doc : document);"
        rem loop over the require scripts and attach to the bundle
        it! = scriptsSet!.iterator()
        while(it!.hasNext())
            path! = it!.next()
            ch=unt
            open (ch)path!
            read record (ch,siz=5512000)content$
            close (ch)
            bundle$ = bundle$ + content$
        wend
        rem finally inject the built bundle
        #injectScript(bundle$)
        rem /**
        rem  * Some customers reported that the second ON_PAGE_LOADED event is not fired
        rem  * so we call the onLoaded method manually in case the event is not fired
        rem  *
        rem  * could even directly call the onLoaded Method from here
        rem  * #onLoaded(null())
        rem  */
        BBjAPI().createTimer(str(#this!)+"onLoadFallback",.2,#this!,"onLoaded")
    methodend
    rem /**
    rem  * An Event listener executed after the second ON_PAGE_LOADED event
    rem  *
    rem  * At this phase the grid flush all enqueued scripts
    rem  *
    rem  * @param BBjEvent ev! The onLoad event
    rem  */
    method public void onLoaded(BBjEvent ev!)
        #HTMLView!.clearCallback(BBjAPI.ON_PAGE_LOADED)
        BBjAPI().removeTimer(str(#this!)+"onLoadFallback",err=*next)
        #getLicenseManager().register(#this!)
        #IsReady! = BBjAPI.TRUE
        REM         if #RS! <> null() or #URL$>"" then
        REM             #render()
        REM         FI
        if(#getOptions().getBlockRenderToReady() = 1) then
            #render()
        FI

        firstScripts$  = ""
        secondScripts$ = ""
        it! = #backlog!.iterator()
        while (it!.hasNext())
            next! = str(it!.next())

            if(next!.contains("$wnd.gw_init"))
                firstScripts$ = firstScripts$ + str(next!) + ";"
            else
                secondScripts$ = secondScripts$ + str(next!) + ";"
            fi
        wend

        #backlog! = null()
        scripts$ =  firstScripts$ + secondScripts$

        if(scripts$ > "") then
            #HTMLView!.executeScript(scripts$)
        FI

        if (#newW! <> null() and #newH!<> null()) then
            #super!.setSize(#newW!,#newH!)
            #newW! = null()
            #newH! = null()
        FI
    methodend
    rem /**
    rem  * Focus the grid by selecting the cell in the first cell and first column.
    rem  *
    rem  * Note: If the grid has already a different selected cell , then
    rem  * the event handler will retain the selection
    rem  *
    rem  * @param BBjGainedFocusEvent ev! The focus event
    rem  */
    method public void onGainedFocus(BBjGainedFocusEvent ev!)
        if(ev!.isTemporary()) methodret
        #focus()
    methodend
    rem /**
    rem  * On NativeEvent
    rem  *
    rem  * Event Handler for Native JavaScript Event coming from the client
    rem  * Determines and dispatches the actual event
    rem  *
    rem  * @param BBjNativeJavaScriptEvent ev! The Javascript Event
    rem  */
    method public void onNativeEvent(BBjNativeJavaScriptEvent ev!)
        map! = ev!.getEventMap()
        type$ = str(map!.get("type"))
        detail$ = str(map!.get("detail"))
        switch type$
            case "gw.rowSelect"
                #onSelectRowChange(detail$, "select")
                break
            case "gw.rowClick"
                #onSelectRowChange(detail$,"single")
                break
            case "gw.rowDoubleClick"
                #onSelectRowChange(detail$,"double")
                break
            case "gw.cellClicked"
                #onCellEvent(detail$,#ON_GRID_CELL_CLICK())
                break
            case "gw.cellDoubleClicked"
                #onCellEvent(detail$,#ON_GRID_CELL_DOUBLE_CLICK())
                break
            case "gw.rangeSelection"
                #onRangeSelectionChange(detail$)
                break
            case "gw.cellEditingStarted"
                #onCellEvent(detail$,#ON_GRID_CELL_EDITING_STARTED())
                break
            case "gw.cellEditingStopped"
                #onCellEvent(detail$,#ON_GRID_CELL_EDITING_STOPPED())
                break
            case "gw.cellValueChanged"
                #onCellEvent(detail$,#ON_GRID_CELL_VALUE_CHANGED())
                break
            case "gw.rowEditingStarted"
                #onRowEditing(detail$,#ON_GRID_ROW_EDITING_STARTED())
                break
            case "gw.rowEditingStopped"
                #onRowEditing(detail$,#ON_GRID_ROW_EDITING_STOPPED())
                break
            case "gw.rowValueChanged"
                #onRowEditing(detail$,#ON_GRID_ROW_VALUE_CHANGED())
                break                
            case "gw.stateChanged"
                #handleStateChangedEvent(detail$,#ON_GRID_STATE_CHANGE())
                break
            case "gw.contextmenu"
                #onContextmenuEvent(detail$)
                break
            case "gw.keypress"
                #onKeypressEvent(detail$)
                break
        swend
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn addColumn(GxColumn definition!)
        methodret #getColumnsManager().addColumn(definition!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn addColumn(BBjString field!,BBjNumber type!)
        methodret #getColumnsManager().addColumn(field! , type!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn addColumn(BBjString field!,BBjString label!)
        methodret #getColumnsManager().addColumn(field! , label!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn addColumn(BBjString field!, BBjString label! , BBjNumber type!)
        methodret #getColumnsManager().addColumn(field! , label! ,type!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn addColumn(BBjString field!)
        methodret #addColumn(field!,field!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn getColumn(BBjString field!)
        methodret #getColumnsManager().getColumn(field!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public BBjNumber hasColumn(BBjString field!)
        methodret #getColumnsManager().hasColumn(field!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumn removeColumn(BBjString field!)
        methodret #getColumnsManager().removeColumn(field!)
    methodend
    rem /**
    rem  * Sets the foreground color for a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column definition
    rem  * @param BBjColor color!  the color for the column
    rem  */
    method public void setColumnForeColor(BBjString field$,BBjColor color!)
        #getColumn(field$).setForeColor(color!)
    methodend
    rem /**
    rem  * Sets the foreground color for a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column definition
    rem  * @param BBjString color$ Valid CSS color
    rem  *
    rem  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
    rem  */
    method public void setColumnForeColor(BBjString field$,BBjString color!)
        #getColumn(field$).setForeColor(color!)
    methodend
    rem /**
    rem  * Sets the background color of a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column definition
    rem  * @param BBjColor color!  The color for the column
    rem  */
    method public void setColumnBackColor(BBjString field$,BBjColor color!)
        #getColumn(field$).setBackColor(color!)
    methodend
    rem /**
    rem  * Sets the background color of a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column definition
    rem  * @param BBjColor color$  Valid CSS color
    rem  *
    rem  * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
    rem  */
    method public void setColumnBackColor(BBjString field$,BBjString color!)
        #getColumn(field$).setBackColor(color!)
    methodend
    rem /**
    rem  * Sets the default alignment for a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field! The field name of the column definition
    rem  * @param BBjNumber align! The column alignment
    rem  *
    rem  * valid alignments:
    rem  *
    rem  * @see GRID_ALIGN_LEFT()
    rem  * @see GRID_ALIGN_CENTER()
    rem  * @see GRID_ALIGN_RIGHT()
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnAlignment(BBjString field!, BBjNumber align!)
        #getColumn(field!).setAlignment(align!)
    methodend
    rem /**
    rem  * Sets the default alignment for a column's header
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field! The field name of the column definition
    rem  * @param BBjNumber align! The column's header alignment
    rem  *
    rem  * valid alignments:
    rem  *
    rem  * @see GRID_ALIGN_LEFT()
    rem  * @see GRID_ALIGN_CENTER()
    rem  * @see GRID_ALIGN_RIGHT()
    rem  *
    rem  * @RequiresRefresh
    rem  */
    method public void setColumnHeaderAlignment(BBjString field!, BBjNumber align!)
        #getColumn(field!).setHeaderAlignment(align!)
    methodend
    rem /**
    rem  * Sets the width of a column
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * <br>
    rem  * <b>Note:</b> Unlike setting the width in the column definition, this method will update a column width without
    rem  * a full re-render.
    rem  *
    rem  * @param BBjString field$ The field name of the column definition
    rem  * @param BBjNumber width! The column width
    rem  */
    method public void setColumnWidth(BBjString field$, BBjNumber width!)
        if #hasColumn(field$) then
            #getColumn(field$).setWidth(width!)
            #executeScript("$wnd.gw_setColumnWidth('"+ #GRIDID$ + "','" + field$ + "'," + str(width!) + ");")
        FI
    methodend
    rem /**
    rem  * Pin a column of the grid to the left or the right margin
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column
    rem  * @param BBjString pin$  The pin direction ("right" or "left")
    rem  *
    rem  * @see GxColumn.PINNED_LEFT()
    rem  * @see GxColumn.PINNED_RIGHT()
    rem  */
    method public void pinColumn(BBjString field$, BBjString pin$)
        pin$=cvs(pin$,8)

        if #hasColumn(field$) then
            #getColumn(field$).setPinned(pin$)
            #executeScript("$wnd.gw_pinColumn('" + #GRIDID$ + "','" + field$ + "','" + pin$  + "');")
        FI
    methodend
    rem /**
    rem  * Change column position
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString field$ The field name of the column
    rem  * @param BBjNumber toIndex! The new column position/index
    rem  */
    method public void moveColumn(BBjString Field$, BBjNumber toIndex!)
        script$="$wnd.gw_moveColumn('" + #GRIDID$ + "','" + field$ + "'," + str(toIndex!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Set the mask of a column using value formatter expression&#183;
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  * <br>
    rem  *
    rem  * <b>Note:</b> This method will override the ValueFormatterExpression of the column.The method depends on
    rem  * the column type to determine the correct value formatter (number, date, ...)
    rem  *
    rem ng field! The column's field
    rem  * @param BBjString mask!: The (date or numeric) mask, BBj style
    rem  */
    method public void setColumnMask(BBjString field!, BBjString mask!)
        if(#hasColumn(field!)) then
            #getColumn(field!).setColumnMask(mask!)
        FI
    methodend
    rem /**
    rem  * Set an image list for a given column using GxRendererImageRenderer&#183;
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  * <br>
    rem  *
    rem  * <b>Note:</b> This method will override the CellRenderer of the column&#183;
    rem  * The column has to contain the values "1","2","3" to x to reference the slices in the BBjImage list
    rem  *
    rem  * @param BBjString field! The column's field
    rem  * @param BBjImage imagelist! The image list containing the image sprites
    rem  */
    method public void setColumnImageList(BBjString field!, BBjImage imagelist!)
        if #hasColumn(field!) then
            renderer! = new GxRendererImageRenderer()
            enc! = java.util.Base64.getEncoder()
            for i=1 to int(imageList!.getWidth() / imageList!.getHeight())
                imageSlice!=imageList!.getImageSlice(i-1,imageList!.getHeight())
                bytes$ = imageSlice!.getBytes("png")
                b64$ = enc!.encode(bytes$)
                renderer!.getList().addProperty(str(i-1),"data:image/png;base64, "+b64$)
            next
            rem adding a clear pixel to reflect the -1 for backwards compatibility to legacy BBj grid
            clearpixel$=enc!.encode($89504E470D0A1A0A0000000D4948445200000001000000010804000000B51C0C020000000B49444154789C63FACF0000020701029A1C31710000000049454E44AE426082$)
            renderer!.getList().addProperty("-1","data:image/png;base64, "+clearpixel$)
            #getColumn(field!).setCellRenderer(renderer!)
        FI
    methodend
    rem /**
    rem  * Set an aggregation function for the passed column field
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @param BBjString field! The column's field
    rem  * @param BBjString AggFunc! Name of function to use for aggregation. One of [sum,min,max,first,last].
    rem  */
    method public void setColumnAggFunc(BBjString field! , BBjString AggFunc!)
        if(#hasColumn(field!)) then
            #getColumn(field!).setAggFunc(AggFunc!)
        FI
    methodend
    rem /**
    rem  * Enable row grouping for columns
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void addRowGroupColumns(BBjString columns!)
        #executeScript("$wnd.gw_addRowGroupColumn('" + #GRIDID$ + "','" + columns! + "', 0 );")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        count! = 0
        WHILE (it!.hasNext())
            next! = #getColumn(cvs(it!.next(),128))
            next!.setRowGroup(1)
            next!.setEnableRowGroup(1)
            next!.setRowGroupIndex(count!)
            count! = count! + 1
        WEND
    methodend
    rem /**
    rem  * Disable row grouping for all columns and enable it for the passed columns
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void setRowGroupColumns(BBjString columns!)
        #executeScript("$wnd.gw_addRowGroupColumn('" + #GRIDID$ + "','" + columns! + "' , 1);")
        list! = Arrays.asList(columns!.split(","))
        it! = #getColumnsManager().getColumns().entrySet().iterator()
        count! = 0
        WHILE (it!.hasNext())
            next! = cast(GxColumn , it!.next().getValue())

            if(list!.contains(next!.getField())) then
                next!.setRowGroup(1)
                next!.setEnableRowGroup(1)
                next!.setRowGroupIndex(count!)
                count! = count! + 1
            else
                next!.setRowGroup(0)
                next!.setEnableRowGroup(0)
                next!.setRowGroupIndex(null())
            FI
        WEND
    methodend
    rem /**
    rem  * Disable row grouping for columns.
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void removeRowGroupColumns(BBjString columns!)
        #executeScript("$wnd.gw_removeRowGroupColumn('" + #GRIDID$ + "','" + columns! + "');")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        WHILE (it!.hasNext())
            next! = #getColumn(cvs(it!.next(),128))
            next!.setRowGroup(0)
            next!.setEnableRowGroup(0)
            next!.setRowGroupIndex(null())
        WEND
    methodend
    rem /**
    rem  * Enable pivot for columns
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void addPivotColumns(BBjString columns!)
        #executeScript("$wnd.gw_addPivotColumns('" + #GRIDID$ + "','" + columns! + "', 0 );")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        count! = 0
        WHILE (it!.hasNext())
            next! = #getColumn(cvs(it!.next(),128))
            next!.setEnablePivot(1)
            next!.setPivotIndex(count!)
            count! = count! + 1
        WEND
    methodend
    rem /**
    rem  * Disable pivot for all columns and enable it for the passed columns
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void setPivotColumns(BBjString columns!)
        #executeScript("$wnd.gw_addPivotColumns('" + #GRIDID$ + "','" + columns! + "' , 1);")
        list! = Arrays.asList(columns!.split(","))
        it! = #getColumnsManager().getColumns().entrySet().iterator()
        count! = 0
        WHILE (it!.hasNext())
            next! = cast(GxColumn , it!.next().getValue())

            if(list!.contains(next!.getField())) then
                next!.setEnablePivot(1)
                next!.setPivotIndex(count!)
                count! = count! + 1
            else
                next!.setEnablePivot(0)
                next!.setPivotIndex(null())
            FI
        WEND
    methodend
    rem /**
    rem  * Disable pivot for columns.
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void removePivotColumns(BBjString columns!)
        #executeScript("$wnd.gw_removePivotColumns('" + #GRIDID$ + "','" + columns! + "');")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        WHILE (it!.hasNext())
            next! = #getColumn(cvs(it!.next(),128))
            next!.setEnablePivot(0)
            next!.setPivotIndex(null())
        WEND
    methodend
    rem /**
    rem  * Enable value for columns
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void addValueColumns(BBjString columns!)
        #executeScript("$wnd.gw_addValueColumns('" + #GRIDID$ + "','" + columns! + "');")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        WHILE (it!.hasNext())
            next! = cvs(it!.next(),128)
            #getColumn(next!).setEnableValue(1)
        WEND
    methodend
    rem /**
    rem  * Disable value for columns.
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated string of column fields
    rem  */
    method public void removeValueColumns(BBjString columns!)
        #executeScript("removeValueColumns('" + #GRIDID$ + "','" + columns! + "');")
        list! = Arrays.asList(columns!.split(","))
        it! = list!.iterator()
        WHILE (it!.hasNext())
            next! = cvs(it!.next(),128)
            #getColumn(next!).setEnableValue(0)
        WEND
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumnGroup addColumnGroup(GxColumnGroup definition!)
        methodret #getColumnsManager().addColumnGroup(definition!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumnGroup addColumnGroup(BBjString id!)
        methodret #getColumnsManager().addColumnGroup(id!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label!)
        methodret #getColumnsManager().addColumnGroup(id!,label!)
    methodend
    rem /**
    rem  * Add column group
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem * @param BBjString id! The group id
    rem * @param BBjString label! The group label/name
    rem * @param BBjVector columns! Vector of columns ids/fields to use
    rem * @param BBjNumber marryChildren! Set to 'true' to keep columns in this group beside each other in the grid.
    rem *                                 Moving the columns outside of the group (and hence breaking the group) is not allowed.
    rem * @param BBjString headerClass!  A CSS class to apply
    rem *
    rem * @return GxColumnGroup The GxColumnGroup instance
    rem */
    method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label! ,  BBjVector columns! , BBjNumber marryChildren! ,BBjString headerClass! )
        declare GxColumnGroup definition!

        definition! = new GxColumnGroup(id! , label!)
        definition!.setMarryChildren(marryChildren!)
        definition!.getHeaderClass().add(headerClass!)
        columnsLength! = columns!.size() - 1
        FOR i = 0 TO columnsLength!
            current$ = columns!.get(i)
            column! = null()

            if(#hasColumn(current$)) then
                column! = #getColumn(current$)
            else
                column! = #addColumn(current$,current$)
            FI

            definition!.addColumn(column!)
            #removeColumn(current$)
        NEXT i

        methodret #addColumnGroup(definition!)
    methodend
    rem /**
    rem  * Group Vector of Columns
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem * @param BBjString id! The group id
    rem * @param BBjString label! The group label/name
    rem * @param BBjVector columns! Vector of columns ids/fields to use
    rem * @param BBjNumber marryChildren! Set to 'true' to keep columns in this group beside each other in the grid.
    rem *                                 Moving the columns outside of the group (and hence breaking the group) is not allowed.
    rem  *
    rem  * @return GxColumnGroup The GxColumnGroup instance
    rem */
    method public GxColumnGroup addColumnGroup(BBjString id!, BBjString label! , BBjVector columns! , BBjNumber marryChildren!)
        methodret #addColumnGroup(id!,label!,columns! , marryChildren! ,  "" )
    methodend
    rem /**
    rem  * Group Vector of Columns
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem * @param BBjString id! The group id
    rem * @param BBjString name! The group label/name
    rem * @param BBjVector columns! Vector of columns ids/fields to use
    rem  *
    rem  * @return GxColumnGroup The GxColumnGroup instance
    rem */
    method public GxColumnGroup addColumnGroup(BBjString id! , BBjString label!, BBjVector columns!)
        methodret #addColumnGroup(id!,label! , columns! , 1  , "" )
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumnGroup getColumnGroup(BBjString id!)
        methodret #getColumnsManager().getColumnGroup(id!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public BBjNumber hasColumnGroup(BBjString id!)
        methodret #getColumnsManager().hasColumnGroup(id!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public GxColumnGroup removeColumnGroup(BBjString id!)
        methodret #getColumnsManager().removeColumnGroup(id!)
    methodend
    rem /**
    rem  * {@inheritDoc}
    rem  */
    method public void resetAllColumns()
        #getColumnsManager().resetAllColumns()
    methodend
    rem /**
    rem  * Alias for <i>resetAllColumns()</i>
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#ColumnsRenderer</small></b>
    rem  *
    rem  * @see resetAllColumns()
    rem  */
    method public void clearColumnDefinitions()
        #resetAllColumns()
    methodend
    rem /**
    rem  * Build the grid json configuration object
    rem  *
    rem  * @return JsonObject The grid options as JsonObject
    rem  */
    method public JsonObject getAsJsonObject()
        REM build the column definition
        iterator! = #getColumnsManager().getColumns().entrySet().iterator()
        cdef! = new JsonArray()
        while iterator!.hasNext()
            next!   = iterator!.next()
            key!   = next!.getKey()
            value! = next!.getValue()
            cdef!.add(value!.getAsJsonObject())
        wend

        options! = #getOptions().getAsJsonObject()
        rem Columns options
        rem ===========================
        options!.        add("columnDefs",cdef!)
        rem Context
        rem ===========================
        context! = options!.get("context").getAsJsonObject()
        context!.addProperty("id",#GRIDID$)
        context!.        add("interests",iff(#getInterests().size() <> 0 ,#getInterests(), listIsEmpty!) ,err=*next)
        context!.addProperty("getRowNodeId",#RowNodeId$, err=*next)

        if(#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1) then
            context!.add("chartToolbarItems",#getChartToolbarItems(), err=*next)
        FI

        methodret options!
    methodend
    rem /**
    rem  * Render the grid
    rem  *
    rem  * The method will compose the grid config and send it to the client for a full re-render.
    rem  * You can use this method to force the client render after you update a setup configuration (ex: column definitions)
    rem  */
    method public void render()
        if(#getOptions().getBlockRenderToReady() = 1) then
            if(!#IsReady!) then
                methodret
            FI
        FI

        gson! = new Gson()
        options! = #getAsJsonObject()
        data$ = #getRS().toJson(1 , #getRowNodeId())
        #executeScript("$wnd.gw_init(" + gson!.toJson(options!) + ",'" + #LicenseKey$ + "'," + data$ + ")")
    methodend
    rem /**
    rem  * Re-render the column definitions on the client.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * The method will collect the new changes in columns and column groups and force the client to reflect the
    rem  * change.
    rem  */
    method public void updateColumns()
        definition! = #getAsJsonObject().get("columnDefs").getAsJsonArray()
        #executeScript("$wnd.gw_setColumnDefinitions('" + #GRIDID$ + "'," + new Gson().toJson(definition!) + ")")
    methodend
    rem /**
    rem  * Build the column definitions from the passed ResultSet
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  *
    rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
    rem  */
    method public void buildColumnsFromResultSet(ResultSet rs! , BBjNumber addAll!)
        if rs! <> NULL() then
            fields!   = rs!.getColumnNames()
            iterator! = fields!.iterator()
            while iterator!.hasNext()
                field$ = iterator!.next()
                meta! = rs!.getColumnMetaData(field$)

                if #hasColumn(field$) = 1 then
                    #getColumn(field$).update(meta! , #getOptions().getDefaultColumnDefinition())
                else
                    if(addAll! = 1) then
                        definition! = new GxColumn(field$)
                        definition!.update(meta!, #getOptions().getDefaultColumnDefinition())
                        #addColumn(definition!)
                    FI
                FI
            wend
        FI
    methodend
    rem /**
    rem  * Feed the grid with data
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
    rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
    rem  * @param BBjString indexdBy$ The field used for creating the unique row index
    rem  *
    rem  * @see render()
    rem  */
    method public void setData(ResultSet rs!,BBjNumber render! , BBjNumber addAll! , BBjString indexdBy$)
        #RowNodeId$ = indexdBy$
        #RS! = rs!

        if rs! <> NULL() then
            #buildColumnsFromResultSet(rs!,addAll!)
            #RS!.createIndex()
        FI

        if(render! = 1) then
            #render()
        FI
    methodend
    rem /**
    rem  * Feed the grid with data
    rem  *
    rem  * The method will sync the result set column definitions with the current column definitions ,
    rem  * update the data and render the grid on the client
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
    rem  * @param BBjNumber addAll! When true, We will create a column definition for every column in the ResultSet, otherwise update the existing ones only
    rem  *
    rem  * @see render()
    rem  */
    method public void setData( ResultSet rs! , BBjNumber render!, BBjNumber all!)
        #setData(rs! , render! , all! , #getRowNodeId())
    methodend
    rem /**
    rem  * Feed the grid with data
    rem  *
    rem  * The method will sync the result set column definitions with the current column definitions ,
    rem  * update the data and render the grid on the client
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  * @param BBjNumber render! When true the grid will render directly on the client, otherwise you need to call <b>render()</b> directly
    rem  *
    rem  * @see render()
    rem  */
    method public void setData( ResultSet rs! , BBjNumber render!)
        #setData(rs! , render! , 1 , #getRowNodeId())
    methodend
    rem /**
    rem  * Feed the grid with data
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  * @param BBjString indexdBy$ The field used for creating the unique row index
    rem  */
    method public void setData(ResultSet rs!, BBjString indexdBy$)
        #setData(rs! , 1 , 1 , indexdBy$)
    methodend
    rem /**
    rem  * Feed the grid with data
    rem  *
    rem  * The method will sync the result set column definitions with the current column definitions ,
    rem  * update the data and render the grid on the client
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  */
    method public void setData( ResultSet rs!)
        #setData(rs! , 1)
    methodend
    rem /**
    rem  * Feed the grid with a new ResultSet
    rem  *
    rem  * Unlike the <b>setData</b> method, this one will update the grid with a new rows set(ResultSet) without doing a full re-render&#183;
    rem  * The column definition will not be synced from the passed ResultSet in this case&#183;
    rem  *
    rem  * Use this method in case you want to replace the whole data in the grid at once&#183;
    rem  * Please note that All row and range selection will be lost.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param ResultSet rs! ResultSet with the data
    rem  *
    rem  * @see setData()
    rem  */
    method public void updateData(ResultSet rs!)
        #RS! = rs!

        if rs! <> NULL() AND rs!.size() > 0 then
            #RS!.createIndex(err=*next)
            data$=#RS!.toJson(BBjAPI.TRUE,#getRowNodeId())
            #executeScript("$wnd.gw_setRowData('" + #GRIDID$ + "'," + data$+ ")")
        FI
    methodend
    rem /**
    rem  * @deprecated Use updateData(ResultSet rs!) instead
    rem  */
    method public void setRowsData(ResultSet rs!)
        #updateData(rs!)
    methodend
    rem /**
    rem  * Execute a bulk update on the grid
    rem  *
    rem  * The transaction method is to pass a transaction object to the grid containing
    rem  * rows to add, remove and update.
    rem  *
    rem  * The grid keeps all active sorting, grouping and filtering, including updating to reflect
    rem  * the changes in the data should the sorting, grouping or filtering be impacted.
    rem  *
    rem  * Updating using transactions is the best way to do large updates to the grid, as the grid treats them
    rem  * as delta changes, so the grid only refreshes what is needed giving a performance boost.
    rem  *
    rem  * All row and range selection will be kept.
    rem  *
    rem  * Note that all update done on the grid will reflected also on the ResultSet instance which is the grid
    rem  * is using.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxClientTransactionModel transaction!
    rem  * @param BBjNumber batchUpdate! when true then execute the update, along with any other updates you subsequently provide
    rem  */
    method public void executeUpdateTransaction(GxClientTransactionModel transaction!,BBjNumber batchUpdate!)
        transaction!.setWidget(#this!)
        json! = transaction!.execute()
        #executeScript("$wnd.gw_updateRowData('" + #GRIDID$ + "'," + json!.toString() + "," + str(batchUpdate!.booleanValue()) + ")")
    methodend
    rem /**
    rem  * Execute a bulk update on the grid
    rem  *
    rem  * The transaction method is to pass a transaction object to the grid containing
    rem  * rows to add, remove and update.
    rem  *
    rem  * The grid keeps all active sorting, grouping and filtering, including updating to reflect
    rem  * the changes in the data should the sorting, grouping or filtering be impacted.
    rem  *
    rem  * Updating using transactions is the best way to do large updates to the grid, as the grid treats them
    rem  * as delta changes, so the grid only refreshes what is needed giving a performance boost.
    rem  *
    rem  * All row and range selection will be kept.
    rem  *
    rem  * Note that all update done on the grid will reflected also on the ResultSet instance which is the grid
    rem  * is using.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxClientTransactionModel transaction!
    rem  */
    method public void executeUpdateTransaction(GxClientTransactionModel transaction!)
        #executeUpdateTransaction(transaction! , 0)
    methodend
    rem /**
    rem  * Update row data
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param DataRow row! DataRow object which contains the update
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel updateRow(DataRow row!)
        transaction! = new GxClientTransactionModel()
        transaction!.update(row!)
        #executeUpdateTransaction(transaction!)
        methodret transaction!
    methodend
    rem /**
    rem  * Update row data
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index! The Row index
    rem  * @param DataRow row! DataRow object which contains the update
    rem  *
    rem  * @deprecated use `updateRow(DataRow row!)`. The grid can work out the row index by its own
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel updateRow(BBjNumber index!,DataRow row!)
        methodret #updateRow(row!)
    methodend
    rem /**
    rem  * @deprecated use `updateRow(DataRow row!)`. The grid can work out the row index by its own
    rem  */
    method public GxClientTransactionModel setRowData(BBjNumber index!,DataRow row!)
        methodret #updateRow(index!,row!)
    methodend
    rem /**
    rem  * @deprecated use `updateRow(DataRow row!)`. The grid can work out the row index by its own
    rem  */
    method public GxClientTransactionModel setRowData(DataRow row!)
        methodret #updateRow(row!)
    methodend
    rem /**
    rem  * Add new row
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index! The insert index
    rem  * @param DataRow row! DataRow object which contains the update
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel addRow(BBjNumber index!,DataRow row!)
        transaction! = new GxClientTransactionModel()
        transaction!.add(row!)
        transaction!.setAddIndex(index!)
        #executeUpdateTransaction(transaction!)
        methodret transaction!
    methodend
    rem /**
    rem  * Add new row at the beginning of the grid
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param DataRow row! The DataRow object which contains the update
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel addRow(DataRow row!)
        methodret #addRow(0,row!)
    methodend
    rem /**
    rem  * Remove a row from grid by the row refernce
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param DataRow row! The data row object to remove
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel removeRow(DataRow row!)
        transaction! = new GxClientTransactionModel()
        transaction!.remove(row!)
        #executeUpdateTransaction(transaction!)
        methodret transaction!
    methodend
    rem /**
    rem  * Remove a row from grid by index
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index! The row index
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel removeRow(BBjNumber index!)
        methodret #removeRow(#getRS().get(index!))
    methodend
    rem /**
    rem  * Remove a row from grid by key
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString key! The row key
    rem  *
    rem  * @return GxClientTransactionModel the transaction object which used to achieve the update
    rem  */
    method public GxClientTransactionModel removeRow(BBjString key!)
        methodret #removeRow(#getRS().get(key!))
    methodend
    rem /**
    rem  * Clear row data (Empty the grid )
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void clearData()
        #RS! = new ResultSet()
        #RS!.createIndex(err=*next)
        #executeScript("$wnd.gw_setRowData('" + #GRIDID$ + "', [])")
    methodend
    rem /**
    rem  * @deprecated use clearData() instead
    rem  */
    method public void clearRowsData()
        #clearData()
    methodend
    rem /**
    rem  * Apply the grid's columns , soring and filtering state
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxState state! : the state object
    rem  */
    method public void setState(GxState state!)
        #executeScript("$wnd.gw_setState('" + #GRIDID$ + "'," + state!.toString() +")")
    methodend
    rem /**
    rem  * @deprecated use #setState instead
    rem  */
    method public void setColumnState(GxState state!)
        #executeScript("$wnd.gw_setState('" + #GRIDID$ + "'," + state!.toString() +")")
    methodend
    rem /**
    rem  * Get the grid's columns , sorting and filtering state
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @returns GxState
    rem  */
    method public GxState getState()
        state! = new GxState()
        json_string$ = str(#HTMLView!.executeScript("$wnd.gw_getState('" + #GRIDID$ + "')"))
        state!.setString(json_string$)
        methodret state!
    methodend
    rem /**
    rem  * @deprecated Use #getState() instead
    rem  */
    method public GxState getColumnState()
        methodret #getState()
    methodend
    rem /**
    rem  * Get the grid sidebar instance
    rem  *
    rem  * @return GxSidebar
    rem  */
    method public GxSidebar getSidebar()
        methodret #getOptions().getSidebar()
    methodend
    rem /**
    rem  * Get the language manager instance
    rem  *
    rem  * @returns GxLanguageManager
    rem  */
    method public GxLanguageManager getLanguageManager()
        methodret #getOptions().getLanguageManager()
    methodend
    rem /**
    rem  * Get the grid statusbar instance
    rem  *
    rem  * @return GxStatusBar
    rem  */
    method public GxStatusBar getStatusbar()
        methodret #getOptions().getStatusbar()
    methodend
    rem /**
    rem  * Get the grid default context menu
    rem  *
    rem  * @return BBjGridContextMenu
    rem  */
    method public BBjGridContextMenu getContextMenu()
        methodret #getOptions().getContextMenu()
    methodend
    rem /**
    rem  * Get the grid's client context
    rem  *
    rem  * @return JsonObject
    rem  */
    method public JsonObject getClientContext()
        methodret #getOptions().getClientContext()
    methodend
    rem /**
    rem  * Get instance of GxClientJsonFactory
    rem  *
    rem  * @return GxClientJsonFactory
    rem  */
    method public GxClientJsonFactory getClientJsonFactory()
        methodret #ClientJsonFactory!
    methodend
    rem /**
    rem  * Add Style block
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param selector$ : Css Selector
    rem  * @param rules! : Css Rules object as json object
    rem  */
    method public void addStyle(BBjString selector$ , JsonObject rules! )
        #executeScript("$wnd.gw_setStyle('" + selector$ + "','" + rules!.toString() + "')")
    methodend
    rem /**
    rem  * Add Style block
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param selector$ : Css Selector
    rem  * @param rules! : Css Rules object as string
    rem  */
    method public void addStyle(BBjString selector$ , BBjString rules! )
        #executeScript("$wnd.gw_setStyle('" + selector$ + "','" + rules! + "')")
    methodend
    rem /**
    rem  * Remove Style Block
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param selector$ : Css Selector
    rem  */
    method public void removeStyle(BBjString selector$)
        #executeScript("$wnd.gw_removeStyle('" + selector$ + "')")
    methodend
    rem /**
    rem  * Set the grid theme
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString theme$
    rem  *
    rem  * @see getThemes()
    rem  * @see GRID_THEME_BALHAM()
    rem  * @see GRID_THEME_BALHAM_DARK()
    rem  * @see GRID_THEME_MATERIAL()
    rem  */
    method public void setTheme(BBjString theme$)
        #getOptions().setTheme(theme$)

        if(#IsReady!) then
            if info(3,6)="5" then
                s$="$doc.getElementById('" + str(#GRIDID$) + "').className='ag-theme-"+theme$+"';"
            else
                s$="document.getElementById('" + str(#GRIDID$) + "').className='ag-theme-"+theme$+"';"
            FI

            #executeScript(s$)
        else
            template! = #getTemplate()
            #HTMLView!.setText(template!)
        FI
    methodend
    rem /**
    rem  * Get the grid supported themes
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @return BBjVector array of theme names
    rem  *
    rem  * @see GRID_THEME_BALHAM()
    rem  * @see GRID_THEME_BALHAM_DARK()
    rem  * @see GRID_THEME_MATERIAL()
    rem  */
    method public BBjVector getThemes()
        v! = new BBjVector()
        v!.addItem(#GRID_THEME_BALHAM())
        v!.addItem(#GRID_THEME_BALHAM_DARK())
        v!.addItem(#GRID_THEME_MATERIAL())
        methodret v!
    methodend
    rem /**
    rem  * Enable a chart toolbar item
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @see CHART_TOOLBAR_SETTINGS()
    rem  * @see CHART_TOOLBAR_DATA()
    rem  * @see CHART_TOOLBAR_FORMAT()
    rem  * @see CHART_TOOLBAR_DOWNLOAD()
    rem  */
    method public void addChartToolbarItem(BBjString item!)
        #ChartToolbarItems!.add(item!)

        if(#IsReady! and (#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1)) then
            #getClientContext().add("chartToolbarItems",#getChartToolbarItems())
            #updateContext()
        FI
    methodend
    rem /**
    rem  * Disable a chart toolbar item
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @see CHART_TOOLBAR_SETTINGS()
    rem  * @see CHART_TOOLBAR_DATA()
    rem  * @see CHART_TOOLBAR_FORMAT()
    rem  * @see CHART_TOOLBAR_DOWNLOAD()
    rem  */
    method public void removeChartToolbarItem(BBjString item!)
        el! = new JsonPrimitive(item!)

        if #ChartToolbarItems!.contains(el!) then
            #ChartToolbarItems!.remove(el!)
        FI

        if(#IsReady! and (#getOptions().getEnableCharts() <> null() and #getOptions().getEnableCharts() = 1)) then
            #getClientContext().add("chartToolbarItems",#getChartToolbarItems())
            #updateContext()
        FI
    methodend
    rem /**
    rem  * Set the focus on the given row id and the given column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * @param BBjString row! The row id
    rem  * @param BBjStrinf column! The column id
    rem  */
    method public void focus(BBjString row! , BBjString column!)
        rem DO NOT focus the canvas or the we will have an infinite focus calls
        rem #super!.focus()
        if #HTMLView!.getParentWindow().getFocusedControlID() <>  #HTMLView!.getID() then
            #HTMLView!.focus()
        fi

        script$="$wnd.gw_setFocusedCell('" + #GRIDID$ + "','" + str(row!) + "','" + str(column!) + "');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Set the focus on the given row id and the given column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber row! The row id
    rem  * @param BBjString column! The column id
    rem  */
    method public void focus(BBjNumber row! , BBjString column!)
        #focus(str(row!) , column!)
    methodend
    rem /**
    rem  * Set the focus on the given row id and the first column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString row! The row id
    rem  */
    method public void focus(BBjString row!)
        #focus(str(row!) , "")
    methodend
    rem /**
    rem  * Set the focus on the given row id and the first column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber row! The row id
    rem  */
    method public void focus(BBjNumber row!)
        #focus(str(row!))
    methodend
    rem /**
    rem  * Will set the focus on the first cell of the first row.
    rem  * In case the grid has already a different selected cell , the the
    rem  * method will retain this information.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void focus()
        #focus(-1)
    methodend
    rem /**
    rem  * Navigates the grid focus to the next cell, as if tabbing.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void tabToNextCell()
        #executeScript("$wnd.gw_tabToNextCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Navigates the grid focus to the previous cell, as if shift-tabbing.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void tabToPreviousCell()
        #executeScript("$wnd.gw_tabToPreviousCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * select all rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void selectAll()
        script$="$wnd.gw_selectAll('" + #GRIDID$ + "',0);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * select all rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBJNumber x!: 0 select all, 1 select all filtered
    rem  */
    method public void selectAll(BBjNumber x!)
        #deselectAll()
        script$="$wnd.gw_selectAll('" + #GRIDID$ + "'," + str(x!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * deselect all rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void deselectAll()
        script$="$wnd.gw_deselectAll('" + #GRIDID$ + "',0);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * deselect all rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBJNumber x!: 0 deselect all, 1 deselect all filtered
    rem  */
    method public void deselectAll(BBjNumber x!)
        script$="$wnd.gw_deselectAll('"+ #GRIDID$ + "'," + str(x!) + ");"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Select a row by its key
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString x!: the row key to select
    rem  */
    method public void setSelectedRow(BBjString key!)
        script$="$wnd.gw_setSelectedRows('" + #GRIDID$ + "',['" + str(key!) + "']);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Select a row by its index
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber x!: the row index to select
    rem  */
    method public void setSelectedRow(BBjNumber index!)
        #setSelectedRow(str(index!))
    methodend
    rem /**
    rem  * Select a vector of rows.
    rem  * The vector can contain a mix of row indices and row keys
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBJNumber x!: vector of row indices and row keys to select
    rem  */
    method public void setSelectedRows(BBjVector x!)
        script$="$wnd.gw_setSelectedRows('" + #GRIDID$ + "',["
        it! = x!.iterator()
        first=1
        while it!.hasNext()
            if first
                first=0
            else
                script$=script$+","
            FI

            script$ = script$ + "'" + str(it!.next()) + "'"
        wend

        script$=script$+"]);"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Expand all groups
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void expandAll()
        script$="$wnd.gw_expandAll('" + #GRIDID$ +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * collapse all groups
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void collapseAll()
        script$="$wnd.gw_collapseAll('" + #GRIDID$ +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Ensures the row key is visible by vertically scrolling the grid
    rem  *
    rem  * Ensures the row index is visible by vertically scrolling the grid&#183;
    rem  * The valid values for positions are {'top', 'middle', 'bottom'}&#183;
    rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString key!: the row key
    rem  * @param BBjString position!: the scrolling position
    rem  *
    rem  * @see GRID_ROWPOS_TOP()
    rem  * @see GRID_ROWPOS_MIDDLE()
    rem  * @see GRID_ROWPOS_BOTTOM()
    rem  */
    method public void ensureIndexVisible(BBjString key! , BBjString position!)
        script$="$wnd.gw_ensureIndexVisible('" + #GRIDID$ + "','" + str(key!) + "','" + str(position!) +"');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * Ensures the row index is visible by vertically scrolling the grid
    rem  *
    rem  * Ensures the row index is visible by vertically scrolling the grid&#183;
    rem  * The valid values for positions are {'top', 'middle', 'bottom'}&#183;
    rem  * If top, middle or bottom, the grid will scroll the row to place the row at top, middle or bottom
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index!: the row index
    rem  * @param BBjString position!: the scrolling position
    rem  *
    rem  * @see GRID_ROWPOS_TOP()
    rem  * @see GRID_ROWPOS_MIDDLE()
    rem  * @see GRID_ROWPOS_BOTTOM()
    rem  */
    method public void ensureIndexVisible(BBjNumber index! , BBjString position!)
        #ensureIndexVisible(str(index!),position!)
    methodend
    rem /**
    rem  * @deprecated use ensureIndexVisible instead
    rem  */
    method public void setVisibleRow(BBjNumber index! , BBjString position!)
        #ensureIndexVisible(index!,position!)
    methodend
    rem /**
    rem  * Ensures the column is visible, scrolling the table if needed.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBJString columnid!: the column id
    rem  */
    method public void ensureColumnVisible(BBjString columnId!)
        script$="$wnd.gw_ensureColumnVisible('" + #GRIDID$ +  "','" + columnId! + "');"
        #executeScript(script$)
    methodend
    rem /**
    rem  * @deprecated use ensureColumnVisible instead
    rem  */
    method public void setVisibleColumn(BBjString columnId!)
        #ensureColumnVisible(columnId!)
    methodend
    rem /**
    rem  * Make the currently visible columns fit the screen.
    rem  *
    rem  * The columns will scale (growing or shrinking) to fit the available width.
    rem  * If you don't want a particular column to be included in the auto resize,
    rem  * then set the column setting SuppressSizeToFit=true.
    rem  * This is helpful if, for example, you want the first column to remain fixed with, but all other columns
    rem  * to fill the width of the table.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void setFitToGrid()
        #executeScript("$wnd.gw_sizeColumnsToFit('" + #GRIDID$ +"')")
    methodend
    rem /**
    rem  * Gets the grid to size the columns to the specified with
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber width! the width to use to fit all columns in
    rem  */
    method public void setFitToGrid(BBjNumber width!)
        #executeScript("$wnd.gw_sizeColumnsToFit('" + #GRIDID$ +"','" + str(width!) + "')")
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param HashSet columns! A set of columns to auto size
    rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
    rem  *                               the width of the column.
    rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
    rem  *                               in the grid options.
    rem  */
    method public void autoSizeColumns(HashSet columns!, BBjNumber skipHeader!)
        columnsAsJson! = new Gson().toJson(columns!)
        #executeScript("$wnd.gw_autoSizeColumns('" + #GRIDID$ +"'," + str(skipHeader!.booleanValue()) +  "," + str(columnsAsJson!) + ")")
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param HashSet columns! A set of columns to auto size
    rem  */
    method public void autoSizeColumns(HashSet columns!)
        #autoSizeColumns(columns! , 0)
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A common separated list of columns to auto size
    rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
    rem  *                               the width of the column.
    rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
    rem  *                               in the grid options.
    rem  */
    method public void autoSizeColumns(BBjString columns!, BBjNumber skipHeader!)
        columnsSet! = new HashSet()
        columnsSet!.addAll(Arrays.asList(columns!.replaceAll(" ","").split(",")))
        #autoSizeColumns(columnsSet!,skipHeader!)
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! A comma separated list of columns to auto size
    rem  */
    method public void autoSizeColumns(BBjString columns!)
        #autoSizeColumns(columns! , 0)
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber skipHeader! indicate that the header content (headerName) should not be considered when calculating
    rem  *                               the width of the column.
    rem  *                               You can also set this behavior to be the default by setting SkipHeaderOnAutoSize: true
    rem  *                               in the grid options.
    rem  */
    method public void autoSizeColumns(BBjNumber skipHeader!)
        #autoSizeColumns(new HashSet(),skipHeader!)
    methodend
    rem /**
    rem  * looks at the rendered cells on the screen, and works out the width based on what it sees.
    rem  * It cannot see the columns that are not rendered due to column virtualisation.
    rem  * Thus it is not possible to autosize a column that is not visible on the screen.
    rem  *
    rem  * Column Virtualisation is the technique the grid uses to render large amounts of columns with
    rem  * degrading performance by only rendering columns that are visible due to the horizontal scroll positions.
    rem  * Eg the grid can have 1000 columns with only 10 rendered if the horizontal scroll is only showing 10 columns.
    rem  * To get around this, you can turn off column virtualisation by setting grid options SuppressColumnVirtualisation=true.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void autoSizeColumns()
        #autoSizeColumns(0)
    methodend
    rem /**
    rem  *Gets the grid to remove a row from the DOM and recreate it again from scratch.
    rem  */
    method public void redrawRows()
        #executeScript("$wnd.gw_redrawRows('" + #GRIDID$ +"')")
    methodend
    rem /**
    rem  * Force the context object update
    rem  */
    method public void updateContext()
        if(#IsReady!)
            #executeScript("$wnd.gw_updateContext('" + #GRIDID$ +"'," + #getClientContext().toString() + ")")
        fi
    methodend
    rem /**
    rem  * Set and apply filter model for the given column
    rem  *
    rem  * @param BBjString column! the column id
    rem  * @param GxClientFilterModel model! the model filter to use
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  *
    rem  * @return GxClientFilterModel the passed model
    rem  */
    method public GxClientFilterModel setFilterModel(BBjString column!, GxClientFilterModel model!)
        model!.setWidget(#this!)
        model!.setColumn(column!)
        model!.update()
        methodret model!
    methodend
    rem /**
    rem  * Set and apply a filter transaction
    rem  *
    rem  * The transaction is a `LinkedHashMap` of columns and their models.
    rem  * This the fastest way to apply several filters on several columns.
    rem  * When using this method The grid will delay executing the filters on the data
    rem  * until all models are set and ready.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  *
    rem  * @param  LinkedHashMap transaction! a map of columns and their model
    rem  */
    method public void executeFilterTransaction(LinkedHashMap transaction!)
        applyCode! = new HashSet()
        executeCode! = new HashSet()
        it! = transaction!.entrySet().iterator()
        while(it!.hasNext())
            next! = it!.next()
            column! = next!.getKey()
            model! = next!.getValue()
            model!.setWidget(#this!)
            model!.setColumn(column!)
            applyCode!.add(model!.apply(0))
            executeCode!.add(model!.execute(0))
        wend

        #executeScript(String.join("",applyCode!) + String.join("",executeCode!))
    methodend
    rem /**
    rem  * Get The filter model for the given column
    rem  *
    rem  * This method will return a `GxClientFilterModel` for the given column
    rem  * If column has already some filter values set through the UI , then the model will contain
    rem  * these changes too.
    rem  *
    rem  * In case the grid is not ready (not renderer yet) then the method will just return
    rem  * any empty filter model for the column.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  *
    rem  * @param BBjString column! the column id to use for the constructed model
    rem  *
    rem  * @throws 256 in case the column has no filter component attached
    rem  */
    method public GxClientFilterModel getFilterModel(BBjString column!)
        jsonModel! = null()
        rem we try to get the model from the UI first
        if(#getIsReady() = BBjAPI.TRUE)
            code! = String.format("JSON.stringify($wnd.gw_getGrid('%s').options.api.getFilterInstance('%s').getModel());" , #getGRIDID(), column!)
            jsonModel! = #executeScript(code!)
        fi

        if(jsonModel! <> null() AND jsonModel! <> "null")
            methodret #getClientJsonFactory().getFilter(jsonModel!,column!)
        else
            model! = null()
            rem we try to detect the filter type and create its model
            if (#getColumn(column!).getFilter() <> null())
                filterName! = #getColumn(column!).getFilter().getFilterName()
                SWITCH (filterName!)
                    CASE GxFilterNumber.getFilterName()
                        model! = new GxClientFilterNumberModel()
                        break
                    CASE GxFilterBasicTimestamp.getFilterName()
                        model! = new GxClientFilterDateTimeModel()
                        break
                    CASE GxFilterBasicBoolean.getFilterName()
                        model! = new GxClientFilterBooleanModel()
                        break
                    CASE GxFilterText.getFilterName()
                        model! = new GxClientFilterTextModel()
                        break
                    CASE GxFilterSetFilter.getFilterName()
                        model! = new GxClientFilterSetFilterModel()
                        break
                SWEND
            fi

            if(model! = null())
                throw "Failed to create column filter's model. The column has no filter component attached" , 256
            fi

            model!.setWidget(#this!)
            model!.setColumn(column!)
            methodret model!
        fi
    methodend
    rem /**
    rem  * Get The combined filter model for the given column
    rem  *
    rem  * This method will return a `GxClientFilterCombinedModel` for the given column
    rem  * If the column has already some filter values set through the UI , then the model will contain
    rem  * these changes too.
    rem  *
    rem  * In case the grid is not ready (not renderer yet) then the method will just return
    rem  * any empty combined filter model for the column.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  *
    rem  * @param BBjString column! the column id to use for the constructed model
    rem  *
    rem  * @throws 256 in case the column filter does not support the combined model
    rem  */
    method public GxClientFilterCombinedModel getFilterAsCombinedModel(BBjString column!)
        model! = #getFilterModel(column!)
        rem first check if the model is already a combined model
        isAlreadyCombined! = 0
        model! = cast(GxClientFilterCombinedModel,model!,err=*next); isAlreadyCombined! = 1

        if(isAlreadyCombined! = 0 AND model!.supportsCombinedModel() = 0)
            throw "The column's filter component does not support combined models" , 256
        fi

        combinedModel! = iff(isAlreadyCombined!,model! ,new GxClientFilterCombinedModel() )
        combinedModel!.setWidget(#this!)
        combinedModel!.setColumn(column!)
        if(!isAlreadyCombined!) combinedModel!.setFirstCondition(model!)
        methodret combinedModel!
    methodend
    rem /**
    rem  * Clear all active filters on columns
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void clearFilters()
        code! = String.format(";var api = $wnd.gw_getGrid('%s').options.api;" , #getGRIDID())
        code! = code! + "api.setFilterModel(null);api.onFilterChanged(null);"
        wrap! = ";(function(){" + code! + "})();"
        #executeScript(wrap!)
    methodend
    rem /**
    rem  * setSize - set the size of the control
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber w! - width
    rem  * @param BBjNumber h! - height
    rem  */
    method public void setSize(BBjNumber w!, BBjNumber h!)
        rem if setSize is called before the page is ready, delay its execution
        if #IsReady! then
            #super!.setSize(w!,h!)
        else
            rem cheat with the superclass so getWidth / getHeight already return the later size
            #super!.setW(w!)
            #super!.setH(h!)
            #newW! = w!
            #newH! = h!
        FI
    methodend
    rem /**
    rem  * Set all rows height
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber height! - the new row height
    rem  */
    method public void setRowHeight(BBjNumber height!)
        #getOptions().setRowHeight(height!)
        #executeScript("$wnd.gw_setRowsHeight('" + #GRIDID$ + "'," + str(height!) + ")")
    methodend
    rem /**
    rem  * Set the given row height
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString key! - the row key
    rem  * @param BBjNumber height! - the new row height
    rem  */
    method public void setRowHeight(BBjString key!, BBjNumber height!)
        #executeScript("$wnd.gw_setRowHeight('" + #GRIDID$ + "','" + str(key!) + "'," + str(height!) + ")")
    methodend
    rem /**
    rem  * Set the given row height
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index! - the row index
    rem  * @param BBjNumber height! - the new row height
    rem  */
    method public void setRowHeight(BBjNumber index!, BBjNumber height!)
        #setRowHeight(str(index!) , height!)
    methodend
    rem /**
    rem  * Reset The row heights.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * The rows height is calculated once when the data is first given to the grid.
    rem  * If the data changes, or the width of a column changes, then you may require the grid to calculate
    rem  * the height again by calling this method
    rem  */
    method public void resetRowHeights()
        #executeScript("$wnd.gw_resetRowHeights('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Set a sorting for one or more columns
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxClientSortModel model! the sorting model
    rem  */
    method public void setSortModel(GxClientSortModel model!)
        #executeScript("$wnd.gw_setSortModel('" + #GRIDID$ + "','" + str(model!.getAsJsonArray()) + "')")
    methodend
    rem /**
    rem  * Sort the given column with the given direction
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString column! The column id
    rem  * @param BBjString direction! The sort direction
    rem  *
    rem  * @see setSortModel
    rem  */
    method public void sortColumn(BBjString column! , BBjString direction!)
        model! = new GxClientSortModel()
        model!.add(column! , direction!)
        #setSortModel(model!)
    methodend
    rem /**
    rem  * Enable / disable pivot mode
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber mode! when true, the pivot mode will be enabled, disabled otherwise
    rem  */
    method public void setPivotMode(BBjNumber mode!)
        #getOptions().setPivotMode(mode!)

        if(#IsReady!) then
            #executeScript("$wnd.gw_setPivotMode('" + #GRIDID$ + "'," + str(mode!) + ")")
        FI
    methodend
    rem /**
    rem  * Check if pivot mode is enabled or disabled
    rem  *
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @return BBjNumber 1 when pivot mode is enabled, 0 otherwise
    rem  */
    method public BBjNumber getPivotMode()
        if(#IsReady!) then
            mode! = #executeScript("$wnd.gw_getPivotMode('" + #GRIDID$ + "'," + str(mode!) + ")")
            #getOptions().setPivotMode(num(mode!))
        FI

        methodret #getOptions().getPivotMode()
    methodend
    rem /**
    rem  * Perform throw columns search
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber filter : filter as a string
    rem  */
    method public void setQuickFilter(BBjNumber filter)
        #executeScript("$wnd.gw_setQuickFilter('" + #GRIDID$ + "'," + str(filter) +")")
    methodend
    rem /**
    rem  * Perform throw columns search
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber filter : filter as number
    rem  */
    method public void setQuickFilter(BBjString filter!)
        #executeScript("$wnd.gw_setQuickFilter('" + #GRIDID$ + "','" + filter! +"')")
    methodend
    rem /**
    rem  * Start Next Cell Editing
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void moveToNextCell()
        #executeScript("$wnd.gw_editNextCell('"+ #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Move to previous cell
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void moveToPreviousCell()
        #executeScript("$wnd.gw_editPreviousCell('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber key!: The row key
    rem  * @param BBjString colId!: The column ID
    rem  */
    method public void setStartCellEditing(BBjString key! , BBjString colId$)
        #executeScript("$wnd.gw_startEditingCell('" + #GRIDID$ + "','"+ STR(key!)+ "','" + colId$ + "')")
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index!: The row index
    rem  * @param BBjString colId!: The column ID
    rem  */
    method public void setStartCellEditing(BBjNumber index! , BBjString colId$)
        #setStartCellEditing(str(index!), colId$)
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber key!: The row key
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber char$: key chars to press on editor when editor supports it
    rem  */
    method public void setStartCellEditing(BBjString key!, BBjString colId$, BBjString char$)
        #executeScript("$wnd.gw_startEditingCell('" + #GRIDID$ + "','"+ STR(key!)+ "','" + colId$ + "','','" + char$ +"')")
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index!: The row index
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber char$: key chars to press on editor when editor supports it
    rem  */
    method public void setStartCellEditing(BBjNumber index!, BBjString colId$, BBjString char$)
        #setStartCellEditing(str(index!),colId$,char$)
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber key!: The row key
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber keyPress!: key codes to press on the editor when the editor supports it
    rem  */
    method public void setStartCellEditing(BBjString key!, BBjString colId$, BBjNumber keyPress!)
        #executeScript("$wnd.gw_startEditingCell('" + #GRIDID$ + "','"+ STR(key!)+ "','" + colId$ + "','" + STR(keyPress!)+ "')")
    methodend
    rem /**
    rem  * Start Cell Editing at the given row and column
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber index!: The row index
    rem  * @param BBjString colId$: The column ID
    rem  * @param BBjNumber keyPress!: key codes to press on the editor when the editor supports it
    rem  */
    method public void setStartCellEditing(BBjNumber index!, BBjString colId$, BBjNumber keyPress!)
        #setStartCellEditing(str(index!),colId$,keyPress!)
    methodend
    rem /**
    rem  * @deprecated Use tabToNextCell() instead
    rem  */
    method public void startNextCellEditing()
        #tabToNextCell()
    methodend
    rem /**
    rem  * @deprecated Use tabToPreviousCell() instead
    rem  */
    method public void startPreviousCellEditing()
        #tabToPreviousCell()
    methodend
    rem /**
    rem  * Stop editing and accepts changes
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void stopEditing()
        #executeScript("$wnd.gw_stopEditing('" + #GRIDID$ + "',0)")
    methodend
    rem /**
    rem  * Stop Editing
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber cancel!: 1 = discard changes, 0 = accept changes
    rem  */
    method public void stopEditing(BBjNumber cancel!)
        #executeScript("$wnd.gw_stopEditing('"+ #GRIDID$ + "'," + STR(cancel!)+ ")")
    methodend
    rem /**
    rem  * If true, then row group, pivot and value aggregation will be read only from the Ui&#183;
    rem  * The grid will display what values are used for each, but will not allow the use to change the selection
    rem  *
    rem  * <br><b><small>#Enterprise</small></b>
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjNumber readonly! when true disable, enable otherwise
    rem  */
    method public void setFunctionsReadOnly(BBjNumber readonly!)
        #getOptions().setFunctionsReadOnly(readonly!)
        #executeScript("$wnd.gw_setFunctionsReadOnly('" + #GRIDID$ + "'," + str(readonly!) +")")
    methodend
    rem /**
    rem  * Sync the client row data every time a new GxClientRowModel
    rem  * is composed by the grid.
    rem  * 
    rem  * Use this method if the row's data in the client is different that the row's data in 
    rem  * the ResultSet 
    rem  * 
    rem  * @param BBjNumber include! when true the ClientRow field will always be filled in GxClientRowModel
    rem  *                           otherwise it will always be null().
    rem  * 
    rem  * <br><b><small>#Configuration</small></b>
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void includeClientRowDataInRowModels(BBjNumber include!)
        #getClientContext().addProperty("includeClientRowData",include!.booleanValue())
        #updateContext()
    methodend    
    rem /**
    rem  * Get the current selected row
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @return GxClientRowModel The selected row if any, null() otherwise
    rem  */
    method public GxClientRowModel getSelectedRow()
        returnedRow! = #executeScript("$wnd.gw_getSelectedRow('" + #GRIDID$ + "')")
        if returnedRow!<>null() and len(returnedRow!) > 0 then
            methodret #getClientJsonFactory().getRow(returnedRow!)
        FI

        methodret null()
    methodend
    rem /**
    rem  * Get Array of selected rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @return BBjVector A vector filled with the selected rows
    rem  */
    method public BBjVector getSelectedRows()
        rows! = new BBjVector()

        if (#getRS() = null()) then
            goto getSelectedRowsErr
        FI

        returnedRows! = #executeScript("$wnd.gw_getSelectedRows('" + #GRIDID$ + "')")
        if returnedRows! = null() then
            goto getSelectedRowsErr
        FI

        parser! = new JsonParser()
        array! = parser!.parse(returnedRows!).getAsJsonArray()
        it! = array!.iterator()
        while (it!.hasNext())
            next! = it!.next().getAsJsonObject(err=getSelectedRowsErr)
            rows!.add(#getClientJsonFactory().getRow(next!))
        wend

        getSelectedRowsErr:
            methodret rows!
    methodend
    rem /**
    rem  * The method will return a vector of the selected ranges including columns and rows
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @return BBjVector
    rem  */
    method public BBjVector getRangeSelections()
        rem an array to save the parsed range selections
        rangeSelectionVector! = new BBjVector()
        rem get the range selections from the client
        rem the client will return an array of objects where each object is a range
        rangeSelections! = #executeScript("$wnd.gw_getRangeSelections('" + #GRIDID$ + "')")

        if (rangeSelections! = "[]") then
            goto getSelectionRangeErr
        FI
        rem iterate throw the ranges array and parse the range objects
        parser! = new JsonParser()
        ranges! = parser!.parse(rangeSelections!).getAsJsonArray()
        rangesIterator! = ranges!.iterator()
        while (rangesIterator!.hasNext())
            model! = #getClientJsonFactory().getRangeSelection(rangesIterator!.next().getAsJsonObject())
            rangeSelectionVector!.addItem(model!)
        wend

        getSelectionRangeErr:
            methodret rangeSelectionVector!
    methodend
    rem /**
    rem  * Add new range selection
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxClientAddRangeSelectionModel model! the add selection model
    rem  *
    rem  * @return GxClientAddRangeSelectionModel
    rem  */
    method public GxClientAddRangeSelectionModel addRangeSelection(GxClientAddRangeSelectionModel model!)
        #executeScript("$wnd.gw_addCellRange('" + #GRIDID$ + "'," + model!.getAsJsonObject().toString() + ")")
        methodret model!
    methodend
    rem /**
    rem  * Add new range selection
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
    rem  * @param BBjString start! start row id or index
    rem  * @param BBjString end! end row id or index
    rem  *
    rem  * @return GxClientAddRangeSelectionModel
    rem  */
    method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns! , BBjString start! , BBjString end!)
        model! = new GxClientAddRangeSelectionModel()
        model!.setColumns(columns!)
        model!.setStart(start!)
        model!.setEnd(end!)
        methodret #addRangeSelection(model!)
    methodend
    rem /**
    rem  * Add new range selection
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
    rem  * @param BBjNumber start! start row id or index
    rem  * @param BBjNumber end! end row id or index
    rem  *
    rem  * @return GxClientAddRangeSelectionModel
    rem  */
    method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns! , BBjNumber start! , BBjNumber end!)
        methodret #addRangeSelection(columns! , str(start!),str(end!))
    methodend
    rem /**
    rem  * Add new range selection
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param BBjString columns! columns as comma separated string (ex: CDNUMBER, COST)
    rem  *
    rem  * @return GxClientAddRangeSelectionModel
    rem  */
    method public GxClientAddRangeSelectionModel addRangeSelection(BBjString columns!)
        methodret #addRangeSelection(columns!,null() , null())
    methodend
    rem /**
    rem  * Clears the selected range.
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void clearRangeSelection()
        #executeScript("$wnd.gw_clearRangeSelection('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Clear already created charts&#183;
    rem  * <b>Note</b> that this method does not clear user created charts
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  *
    rem  * @param GxClientAddRangeChartModel model! the add range model
    rem  * @return BBjString A unique id for the created chart
    rem  */
    method public BBjString addRangeChart(GxClientAddRangeChartModel model!)
        uuid! = #executeScript("$wnd.gw_addChartRange('" + #GRIDID$ + "'," + model!.getAsJsonObject().toString() + ")")
        methodret str(uuid!)
    methodend
    rem /**
    rem  * Clear already created chart by its id
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  * Note that this method does not clear user created charts
    rem  *
    rem  * @param BBjString id! the chart's id to destroy
    rem  */
    method public void clearChart(BBjString id!)
        #executeScript("$wnd.gw_destroyChart('" + #GRIDID$ + "','" + str(id!) + "')")
    methodend
    rem /**
    rem  * Clear already created charts&#183;
    rem  * <b>Note</b> that this method does not clear user created charts
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void clearChart()
        #executeScript("$wnd.gw_destroyChart('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Show loading overlay
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void showLoadingOverlay()
        #executeScript("$wnd.gw_showLoadingOverlay('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Show 'no rows' overlay
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void showNoRowsOverlay()
        #executeScript("$wnd.gw_showNoRowsOverlay('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Clear all overlays
    rem  *
    rem  * <br><b><small>#API</small></b>
    rem  */
    method public void hideOverlay()
        #executeScript("$wnd.gw_hideOverlay('" + #GRIDID$ + "')")
    methodend
    rem /**
    rem  * Destroy the grid
    rem  */
    method public void destroy()
        #super!.destroy()
        #IsReady! = BBjAPI.FALSE
        #backlog! = new BBjVector()
    methodend
    rem /**
    rem  * Fires an event
    rem  *
    rem  * @param Int type! The event's type
    rem  * @param Object payload! The event's payload
    rem  *
    rem  * @Override
    rem  */
    method protected void fireEvent(int type!, Object payload!)
        el! = new JsonPrimitive(type!)

        if(#getInterests().contains(el!)) then
            #super!.fireEvent(type!,payload!)
        FI
    methodend
    rem /**
    rem  * Send the current interests to the client
    rem  */
    method protected void updateClientWithInterests()
        #getClientContext().add("interests",#getInterests())
        #updateContext()
    methodend
    rem /**
    rem  * The method will add the default chart toolbar items
    rem  */
    method protected void fillChartToolbarItems()
        #getChartToolbarItems().add(#CHART_TOOLBAR_SETTINGS())
        #getChartToolbarItems().add(#CHART_TOOLBAR_DATA())
        #getChartToolbarItems().add(#CHART_TOOLBAR_FORMAT())
        #getChartToolbarItems().add(#CHART_TOOLBAR_DOWNLOAD())
    methodend
    rem /**
    rem  * Get the grid template
    rem  *
    rem  * @return BBjString parsed html template
    rem  */
    method protected BBjString getTemplate()
        html$ = #Template$

        if(len(html$) = 0) then
            ch=unt
            open (ch)"BBjGridExWidget/client/index.html"
            read record (ch,siz=5512000)html$
            close (ch)
        FI

        html! = html$
        html! = html!.replaceAll("__id__" , #GRIDID$)
        html! = html!.replaceAll("__lang__", #getLanguageManager().getLanguage())
        html! = html!.replaceAll("__THEME__", "ag-theme-" + #getOptions().getTheme())
        methodret html!
    methodend

    method protected void handleStateChangedEvent(BBjString detail$, BBjNumber type!)
        event! = #getColumnState()
        #fireEvent(type!, event!)
    methodend
    rem /**
    rem  * Handle Range Selections Event
    rem  *
    rem  * @see GxClientEventsRangeSelection
    rem  */
    method private void onRangeSelectionChange(BBjString detail$)
        event! = new GxClientEventsRangeSelection()
        #fireEvent(#ON_GRID_RANGE_SELECTION_CHANGED(),event!)
    methodend
    rem /**
    rem  * On rows selections event
    rem  *
    rem  * Parse the json details coming from the client and fires new GxSelectRowEvent
    rem  *
    rem  * @see GxSelectRowEvent
    rem  */
    method protected void onSelectRowChange(BBjString detail$, BBjString type$)
        declare GxClientEventsRowSelection event!

        event! = new GxClientEventsRowSelection()
        event!.setSelectedRows(#getSelectedRows())
        SWITCH (type$)
            CASE "single"
                #fireEvent(#ON_GRID_ROW_CLICK(),event!)
                break
            CASE "double"
                #fireEvent(#ON_GRID_DOUBLE_CLICK(), event!)
                break
            case "select"
                #fireEvent(#ON_GRID_SELECT_ROW(),event!)
                break
            case default
                break
        SWEND
    methodend
    rem /**
    rem  * On context menu event
    rem  *
    rem  * @param BBjString detail$ The event response
    rem  */
    method protected void onContextmenuEvent(BBjString detail$)
        declare JsonParser parser!

        parser! = new JsonParser()
        parsedCell!  = parser!.parse(detail$).getAsJsonObject()
        cell! = #getClientJsonFactory().getCell(parsedCell!)
        event! = new GxClientEventsContextMenu()
        event!.setCell(cell!)
        #fireEvent(parsedCell!.get("i").getAsInt(),event!)
    methodend
    rem /**
    rem  * On cell Event. handles cell clicking and editing events
    rem  *
    rem  * @param BBjString detail$ The event detail as Json
    rem  * @param BBjNumber type! The event type
    rem  *
    rem  * @see ON_GRID_CELL_VALUE_CHANGED()
    rem  * @see ON_GRID_CELL_DOUBLE_CLICK()
    rem  * @see ON_GRID_CELL_CLICK()
    rem  */
    method protected void onCellEvent(BBjString detail$ , BBjNumber type!)
        declare JsonParser parser!

        parser! = new JsonParser()
        parsedCell!  = parser!.parse(detail$).getAsJsonObject()
        cell! = #getClientJsonFactory().getCell(parsedCell!)
        event! = new GxClientEventsCell()
        event!.setCell(cell!)
        event!.setOldValue(parsedCell!.get("o").getAsString())
        #fireEvent(type!, event!)
    methodend
    rem /**
    rem  * Fire an row editing event when row editing starts or stops
    rem  *
    rem  * @param BBjString detail$ The event detail as json
    rem  * @param BBjNumber type! The event type
    rem  *
    rem  * @see ON_GRID_ROW_EDITING_STARTED()
    rem  * @see ON_GRID_ROW_EDITING_STOPPED()
    rem  */
    method protected void onRowEditing(BBjString detail$ , BBjNumber type!)
        event! = new GxClientEventsRowEditing()
        event!.setRow(#getClientJsonFactory().getRow(detail$))
        #fireEvent(type!, event!)
    methodend
    rem /**
    rem  * Fire an keypress event when keypress is passed from the client
    rem  *
    rem  * @param BBjString detail$ The event detail as json
    rem  *
    rem  * @see ON_GRID_KEYPRESS()
    rem  */
    method protected void onKeypressEvent(BBjString detail$)
        declare JsonParser parser!

        parser! = new JsonParser()
        parsedKeypress!  = parser!.parse(detail$).getAsJsonObject()
        keypress! = #getClientJsonFactory().getKeypress(parsedKeypress!)
        event! = new GxClientEventsKeypress()
        event!.setKey(keypress!)
        #fireEvent(#ON_GRID_KEYPRESS(), event!)
    methodend

classend